---
title: day93-组合继承
tags: 
- 前端
categories: 
- 技术
date:  2019-4-15
grammar_cjkRuby: true
---
### 前言
原型链虽然很强大，但是实现继承还是存在一些问题的。比如引用类型值问题。当然这个问题的解决也有一些，如用apply()，call()，或是借用构造函数。

![](https://ws1.sinaimg.cn/large/b15ca614gy1g23q72mg6dj20dw0aft8y.jpg)
<!--more-->
### apply() call()
> 解决原型中包含引用类型值所带来问题的过程中。可以借用构造函数。
```javascript
// --即在子类型构造函数的内部调用超类型构造函数。
// --也可以用apply()和call()方法在新创建的对象上执行构造函数。
function SuperType() {
  this.colors = ['red', 'blue', 'green'] 
}
function SubType() {
  // 继承了SuperType,解决饮用类型值问题
  SuperType.call(this)
}
// 直接继承的写法，会导致引用类型值问题
// SubType.prototype = new SuperType()
let instance1 = new SubType()
instance1.colors.push('black')
console.log(instance1.colors)
let instance2 = new SubType()
console.log(instance2.colors)
```
### 借用构造函数
> 组合继承
```javascript
function SuperType(name) {
  this.name = name
  this.colors = ['red', 'blue', 'black']
}
SubType.prototype.sayName = function () {
  console.log(this.name)
}
function SubType(name, age) {
  SuperType.call(this, name)
  this.age = age
}
// 继承方法
SubType.prototype = new SuperType()
SubType.prototype.constructor = SubType()
SubType.prototype.sayAge = function () {
  console.log(this.age)
}
let instance11 = new SubType('zhangsan', 12)
// 继承了SuperType()
instance11.colors.push('black')
console.log(instance11.colors) // 'red, blue, black'
instance11.sayName() // 'zhangsan'
instance11.sayAge() // 12
```

