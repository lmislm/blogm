---
title: day131-vuejs源码-数据绑定-3
tags: 
- 前端
categories: 
- 技术
date:  2019-5-23
grammar_cjkRuby: true
---
### 前言
在Observer中，有一个`walk`方法：
在其构造器中，如果`observer`实例是对象则`walk`进行绑定
`walk`方法会遍历对象的每一个属性进行`defineReactive`绑定
`defineReactive`的作用则是通过`Object.defineProperty`为
数据定义上`getter\setter`方法，进行依赖收集后
闭包中的`Deps`会存放`Watcher`对象。触发`setter`改变数据时
会通知`Deps`订阅者通知所有的`Watcher`观察者对象进行视图的更新。

<!--more-->

### 代码
```javascript
/**
 * Define a reactive property on an Object.
 */
export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  // 闭包Dep
  const dep = new Dep()

  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property && property.configurable === false) {
    return
  }
  // 如果之前定义过了就取出来
  // cater（注：迎合） for pre-defined getter/setters
  const getter = property && property.get
  const setter = property && property.set
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key]
  }

  let childOb = !shallow && observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val
      if (Dep.target) {
        /* 依赖收集 */
        dep.depend()
        if (childOb) {
          /* 子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend -- 引 */
          childOb.dep.depend()
          /* 判断是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。 */
          if (Array.isArray(value)) {
            dependArray(value)
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      /* 如果原本对象拥有getter方法则执行 */
      const value = getter ? getter.call(obj) : val
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter()
      }
      // #7981: for accessor properties without setter
      if (getter && !setter) return
      /* 判断原本对象拥有setter方法，有的话直接执行setter */
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      /* 新值需要重新进行observe，保证数据响应式 */
      childOb = !shallow && observe(newVal)
      /* 通知观察者 */
      dep.notify()
    }
  })
}
```
