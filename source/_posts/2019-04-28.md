---
title: day106-promise-then方法
tags: 
- 前端
categories: 
- 技术
date:  2019-4-28
grammar_cjkRuby: true
---
### 前言
本文主要是then方法的实现，以及thenable的实现，then链式调用。

![](https://ws1.sinaimg.cn/large/b15ca614gy1g2is8ppmm5j20gs09gq3z.jpg)
<!--more-->
### 实现
```javascript
// promise then方法实现-笔记
// Promise/A标准要求返回一个新对象，Promise/A+没有要求。
// 注意：then方法里需要onResolved或者onRejected,必须符合标准thenable
MyPromise.prototype.then= function (resolve, reject) {
  const _self = this
  const myPromise
  // then方法需要是function
  onResolved = typeof onResolved === 'function' ? onResolved : function () {}
  onReject = typeof onReject === 'function' ? onReject : function () {}

  if (_self.status === 'resolved') {
    return myPromise = new Promise(function (resolve, reject) {
      try {
        // 取onResolved结果
        let x = onResolved(_self.data)
        // myPromise的onResolved的返回值是一个promise对象？
        if (x instanceof Promise) {
          x.then(resolve, reject)
        }
        resolve(x)
      } catch (error) {
        reject(error)
      }
    })
  }
  if (_self.status === 'rejected') {
    return myPromise = new Promise(function (resolve, reject) {
      try {
        let x = onReject(_self.data)
        if (x instanceof Promise) {
          x.then(resolve, reject)
        }
        // 当然是没有reject
      } catch (error) {
        reject(error)
      }
    })
  }
  if (_self.status === 'pending') {
    // 放入数组中
    return myPromise = new Promise(function (resolve, reject) {
      _self.onResolvedCallback.push(function (value) {
        try {
          let x = onResolved(_self.data)
          if (x instanceof Promise) {
            x.then(resolve, reject)
          }
        } catch (error) {
          reject(error)
        }
      })
      _self.onRejectedCallback.push(function (reason) {
        // try...catch, 同上
      })
    })
  }
}
// 根据值来决定myPromise的状态
/**
 * Promise/A+标准规范 https://promisesaplus.com/#point-47
 * @param {*} myPromise 
 * @param {*} value onFulfilled or onRejected的结果
 * @param {*} resolve 
 * @param {*} reject 
 */
function resolvePromise(myPromise, value, resolve, reject) {
  let then
  // 接到结果之后往后抛，then链式调用？
  let thenCalledOrThrow = false
  if (myPromise === value) {// 如果myPromise和value引用同一个对象，抛TypeError错,规范：2.3.1
    return reject(new TypeError('value和myPromise引用的同一个对象'))
  }
  if(value instanceof Promise) {// 如果value是一个promise就用其声明， 2.3.2
    if (value.status === 'pending') {
      // value的最终状态并没有确定，就必须要等确定fulfilled或rejected， 2.3.2.1
      value.then(function (value) {
        resolvePromise(myPromise, value, resolve, reject)
      }, reject)
    } else {
      // 确定了直接取值fulfilled或rejected 2.3.2.2 \ 2.3.2.3
      value.then(resolve, reject)
    }
    return
  }
  // 实现的不是很详细，和标准规范可能有点出入。
  if ((value !== null) && ((typeof value === 'object') || (typeof value === 'function'))) {
    try {
      then = value.then
      // 如果检查到value.then的结果有错，则抛错
      if (typeof then === 'function') {
        then.call(value, function reject(err) {
          if (thenCalledOrThrow) return
          // ???
          thenCalledOrThrow = true
          return reject(err)
        })
      } else {
        resolve(value)
      }
    } catch (error) {
      // if (thenCalledOrThrow) return 
      thenCalledOrThrow = true
      return reject(e)
    }
  } else {
    resolve(x)
  }
}
```
### 参考

[剖析Promise内部结构][1]


  [1]: https://github.com/xieranmaya/blog/issues/3