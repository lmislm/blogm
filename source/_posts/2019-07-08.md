---
title: day176-数组-嵌套数组-nested Array
tags: 
- 前端
categories: 
- 技术
date:  2019-7-8
grammar_cjkRuby: true
---
## 要点

给出特定结构的数据，转换成特定的数据结构。
1. `deepMerge`, `groupBy`
2. `flattenDeep`, nested Array(嵌套数组)
<!--more-->

## 源数组->目标数组

> 源数据
```js
let data = [
  {
    '文风': {
      '过译': [
        { 'errorLevel': '一般般', 'count': 5 }
        // ...
      ],
      '漏译': [
        { 'errorLevel': '非常严重', 'count': 2 },
        { 'errorLevel': '一般般', 'count': 10 }
      ],
      '增译': [
        { 'errorLevel': '非常严重', 'count': 22 },
        { 'errorLevel': '一般般', 'count': 10 }
      ]
      // ...
    }
    // ...
  }
  // ...
]
```
> 目标数组
```js
let res = [
  { name: '一般般', count: 27, '过译': 10, '漏译': 20, '增译': 22 },
  { name: '非常严重', count: 24, '漏译': 4, '增译': 44 },
  { name: '重大错误', count: 10, '过译': 10 }
  // ...
]
```

## 两步

1. 先降维处理成一维数组
2. 根据一维数组相关属性`groupBy`

### 降维处理
+ 注意不需要第一层的`keys`。
+ `_.`是loadshjs的方法。

```js
function flatData (data) {
  // 去掉了术语、文风等
  let res = (data || []).map(item => {
    let mergedData = _.mergeWith({}, ...Object.values(item), (obj, src) => {
      return (obj || []).concat(src)
    })
    return Object.entries(mergedData).map(([key, value]) => {
      // 转为多层嵌套数组
      return [...value.map(item => ({...item, type: key}))]
    })
  })
  return _.flattenDeep(res)
}
```

### 数组分类
由`嵌套数组`得出的结果进行数组归类。
```js
function nest (seq, keys) {
  if (!keys.length) return seq
  let first = keys[0]
  let rest = keys.slice(1)
  return mapValues(groupBy(seq, first), (value) => {
    // return { ...nest(value, rest) }
    if (Array.isArray(nest(value, rest))) {
      // reduce by prop count
      return (nest(value, rest) || []).reduce((acc, obj) => (acc + obj['count']), 0)
      // return { ...item, item: '122'}
    } else {
      return nest(value, rest)
    }
  })
}
```
