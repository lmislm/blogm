---
title: day92-promise单一值传递（局限性）
tags: 
- 前端
categories: 
- 技术
date:  2019-4-13
grammar_cjkRuby: true
---
### 前言
promise只能是一个完成值和一个拒绝理由。但是这造成了现状只能是构造一个值封装来保存多个信息。

![](https://ws1.sinaimg.cn/large/b15ca614gy1g21g6gy76bj20dw0983ym.jpg)
Photo by Min Wu on Unsplash
<!--more-->
### Promise的分裂值
异步产生的两个值，封装到一个数组值中通过promise传输
```javascript
function getY(x) {
  return new Promise(function (resolve, reject) {
    setTimeout(function () {
      resolve((3*x) - 1)
    }, 100)
  })
}
function foo(bar, baz) {
  let x = bar * baz
  return getY(x)
  .then(function(y) {
    // 把两个值封装在容器中
    return [x, y]
  })
}
foo (10, 20)
.then(function (msg) {
  let x = msgs[0]
  let y = msgs[1]
  console.log(x, y) // 200 599
})

```
### 展开/传递参数
利用apply.bind的技巧。
```javascript
function spread (fn) {
  return Function.apply.bind(fn, null)
}
Promise.all(foo(10, 20))
.then(spread(function (x, y) {
  console.log(x, y) // 200 599
}))
```

### 数组解构赋值ES6
这个比上面的都更加的灵活。
```javascript
Promise.all(foo(10, 20))
.then(function (msgs) {
  let [x,y] = msgs
  console.log(x, y) // 200 599
})
```
更好的。
```javascript
Promise.all(foo(10, 20))
.then(function ([x,y]) {
  console.log(x,y) // 200 599
})
```
