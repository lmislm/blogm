---
title: day94-寄生组合式继承
tags: 
- 前端
categories: 
- 技术
date:  2019-4-16
grammar_cjkRuby: true
---
### 前言
组合式继承存在一定的局限性，即为了得到一个副本，去指定子类型的原型而调用超类型的构造函数。可以通过借用构造函数来继承属性，通过原型链混成形式来继承方法。不用为了指定子类型的原型而调用超类型的构造函数,再将结果指定给子类型的原型。**本质上**就是用寄生式组合继承来继承超类型的原型，然后将结果指定给子类型的原型。

![](https://ws1.sinaimg.cn/large/b15ca614gy1g24wgmkmxdj20dw0b4wfi.jpg)
Photo by Jenny Caywood on Unsplash
<!--more-->
### 简单形式

简单的寄生式组合继承组合形式。
```javascript
function inheritPrototype (subType, superType) {
  // 创建对象，创建超类型副本
  let prototype = object(superType.prototype)
  // 增强对象，添加属性constructor,弥补因重写类型失去默认的constructor属性
  prototype.constructor = subType
  // 指定对象，将新创建的对象赋值给子类型的原型
  subType.prototype = prototype
}
```

### 应用
替换为子类型原型赋值的语句（例子详情参考组合继承）
```javascript
function SuperType (name) {
  this.name = name
  this.colors = ['red', 'blue', 'green']
}
SuperType.prototype.sayName = function () {
  console.log(this.name)
}
function SubType(name, age) {
  SuperType.call(this, name)
  this.age = age
}
// SubType.prototype = new SuperType()
// SubType.prototype.constructor = SubType
// SubType.prototype.sayAge = function () {
//   console.log(this.age)
// }
// 替换
inheritPrototype(SubType, SuperType)
SubType.prototype.sayAge = function () {
  console.log(this.age)
}
```
