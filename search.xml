<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[day214-HTTP三次握手]]></title>
    <url>%2F2019%2F08%2F14%2F2019-08-14%2F</url>
    <content type="text"><![CDATA[要点 目的 名词 过程 疑问 目的客户端连接服务端，建立TCP连接，交换窗口大小信息 名词ISN(Initial Sequence Number)：操作系统动态随机选取一个32位长的序列号，即初始序列号ISN。 SYN(SYNchronization)：同步信号SYN，占用一个字节的编号。 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。 对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。 ACKnum：确认序号。Inform the sending host that the transmitted data was received successfully. 过程第一次握手（SYN=1, seq=x)（注意：SYN又可以写FIN） 客户端发送，TCP的SYN标志位初始值为1的包，表明客户端向服务端发起连接。同时seq（ sequence numbers 序列号）包含ISN序列号x，保存在发送包序列号字段里。 发送完毕后，客户端进入SYN_SEND状态。 第二次握手（SYN=1, seq=y, ACK=1, ACKnum=x+1）（注意ACKnum又写作ack） 服务器返回，SYN标志位和ACK标志位为1。服务端将ISN序列号放入Seq域，同时将ACKnum（Acknowledgement Number：确认序号）设置为客户端ISN序列号加1，即x+1。发送完毕后，服务端进入SYN_RCVD状态。 第三次握手（ACK=1，seq=x + 1，ACKnum=y+1） 客户端发送，SYN标志位为0，ACK标志位为1，将服务端的seq序号值加1，放入确认序号中，发送给服务端。发送完毕后，客户端进入ESTABLISHED状态，服务端接收后，也进入ESTABLISHED状态。TCP三次握手结束 疑问 为什么是三次握手不是两次握手？ TCP 需要 seq 序列号来做可靠重传或接收，而避免连接复用时无法分辨出 seq 是延迟或者是旧链接的 seq。 谢希仁版《计算机网络》：“已失效的连接请求报文段” 的产生在这样一种情况下：client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。” TCP 怎么样识别之前旧链接重发的包？ ISN（初始序列号）机制。 参考TCP 为什么是三次握手，而不是两次或四次？ 三次握手 Understanding TCP Sequence and Acknowledgment Numbers]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day213-DNS解析]]></title>
    <url>%2F2019%2F08%2F13%2F2019-08-13%2F</url>
    <content type="text"><![CDATA[要点 DNS解析过程 DNS优化 DNS解析过程DNS解析查IP过程：（以www.xxx.com为例）过程：. -&gt; .com -&gt; xxx.com. -&gt; www.xxx.com. 读取DNS缓存（缓存分为：浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存） 查找LDNS（本地区域名服务器，如果你在学校接入互联网，则 LDNS 服务器就在学校）。LDNS查询自己的DNS缓存，失败则进行DNS解析请求。 LDNS查找根域名服务器（www.xxx.com.，注意com后的“.”对应根域名服务器，默认都有，通常省略，但浏览器请求DNS时会自动加上) LDNS查找顶级域名服务器（COM域名服务器） LDNS查找主域名服务器（xxx.com域名服务器），得到IP地址 LDNS将得到的IP地址，返回给操作系统，自己也存一份。 DNS优化 缓存主要有：浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存浏览器缓存查看（Chrome版本75.0.3770.100为例）：chrome://net-internals/#dns。注：可以从chrome://chrome-urls/进去系统缓存查看：（/etc/hosts，Linux系统）（hosts，Windows系统） 负载均衡根据每台被请求的机器（含有请求资源）的负载量，该机器离用户地理位置的距离等等，来决定哪个机器处理，即负载均衡，又叫DNS重定向。 参考前端经典面试题: 从输入URL到页面加载发生了什么？ 从输入页面地址到展示页面信息都发生了些什么？]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day212-localStorage、sessionStorage、Cookie]]></title>
    <url>%2F2019%2F08%2F12%2F2019-08-12%2F</url>
    <content type="text"><![CDATA[要点 三者异同 三者的基本概念 三者异同 特性 Cookie localStorage sessionStorage 生命周期 可由服务器生成，可设置过期时间。如果在浏览器端生成Cookie，默认是关闭浏览器后清除 除非被清除，否则永久保存 仅在当前会话下有效，关闭页面或浏览器后被清除 可存放数据大小 4K左右 5MB左右 5MB左右 与服务器端通信 携带在HTTP头中 不与服务器端通信，仅仅在浏览器中保存 不与服务器端通信，仅仅在浏览器中保存 易用性 接口不友好 相对较容易封装 相对较容易封装 三者的基本概念localStorage HTML5新特性，支持IE8+、 IE6+的polyfill可以用userData。localStorage在浏览器的隐私模式下面是不可读取的。 sessionStorage 仅在当前会话下有效，关闭页面或浏览器后被清除。作用域 如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的。 Cookie生命周期在设置的cookie过期时间之前一直有效。长度和数量的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB。属于旧方法。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day211-Content-Type]]></title>
    <url>%2F2019%2F08%2F11%2F2019-08-11%2F</url>
    <content type="text"><![CDATA[要点 是什么？ 句法 指令，及其注释 是什么Content-Type 实体头部用于指示资源的MIME类型 media type 。 句法就是经常在header中看到的东西，如，Content-Type: text/html; charset=utf-8 指令 media-type 资源或数据的 MIME type（媒体类型—通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型 ，是一种标准，用来表示文档、文件或字节流的性质和格式，如：text/html、text/plain）。 常见的：multipart/form-data，用以支持向服务器发送二进制数据 application/x-www-urlencoded，消息内容会经过 URL 格式编码，可用get方法和post方法，但不写enctype，无法实现文件上传 参考HTTP content-type 对照表 理解HTTP之Content-Type 上传文件multipart/form-data深入解析 深入解析 multipart/form-data]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day210-repaint和reflow扫盲]]></title>
    <url>%2F2019%2F08%2F10%2F2019-08-10%2F</url>
    <content type="text"><![CDATA[要点 介绍 引起XX的常见操作 优化 介绍浏览器重新渲染，就需要重新生成布局和重新绘制。前者叫做”回流”（reflow，又叫重排，英文也叫Layout），后者叫做”重绘”（repaint）。 元素样式的改变不影响布局， UI 层面的重新像素绘制，重绘对元素进行更新 —— 重绘(repaint)重新渲染页面 —— 回流(reflow) 常见原因常见的reflow操作： 页面初次渲染，浏览器窗口大小改变 元素尺寸/位置/内容发生改变 css伪类 offsetTop/offsetLeft/offsetWidth/offsetHeight/offsetParent clientTop/clientLeft/clientWidth/clientHeight scrollTop/scrollLeft/scrollWidth/scrollHeight getComputedStyle()/getClientRects()/getBoundingClientRect() 常见的repaint操作： css属性的改变。 具体见CSS Triggers https://csstriggers.com/ 这里列出了哪些属性会引起reflow(即Layout)或repaint。 优化 rAF等使用 window.requestAnimationFrame()、window.requestIdleCallback() 这两个方法调节重新渲染 FASTDOM (Eliminates layout thrashing by batching DOM measurement and mutation tasks) 自动完成读写操作的批处理 参考如何不择手段提升scroll事件的性能—知乎 网页性能管理详解—阮一峰]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day208-requestAnimationFrame-了解]]></title>
    <url>%2F2019%2F08%2F09%2F2019-08-09%2F</url>
    <content type="text"><![CDATA[要点 作用 应用 实例 作用 要求浏览器在下次重绘之前调用指定的回调函数更新动画[1] 应用 减少重绘或回流。 替代通过时间管理队列的高频发事件，通过requestAnimationFrame来管理队列，保证 requestAnimationFrame的队列里，同样的回调函数只有一个。因为通常显示器16.7ms（16.7 = 1000 / 60, 即每秒60帧）的刷新间隔中，如果发生了其他绘制请求(setTimeout)，可能导致帧丢失。这里帧丢失通常就包含有，滚动、触摸这类高触发频率事件的回调可能会在同一帧内触发多次所导致，requestAnimationFrame就是跟着浏览器的绘制走，绘制间隔时间内绘制完毕。 实例-进度条&lt;div id="myDiv" style="background-color: lightblue;width: 0;height: 20px;line-height: 20px;"&gt;0%&lt;/div&gt;&lt;button id="btn"&gt;run&lt;/button&gt;&lt;script&gt; var timer; btn.onclick = function()&#123; myDiv.style.width = '0'; cancelAnimationFrame(timer); timer = requestAnimationFrame(function fn()&#123; if(parseInt(myDiv.style.width) &lt; 500)&#123; myDiv.style.width = parseInt(myDiv.style.width) + 5 + 'px'; myDiv.innerHTML = parseInt(myDiv.style.width)/5 + '%'; timer = requestAnimationFrame(fn); &#125;else&#123; cancelAnimationFrame(timer); &#125; &#125;);&#125; &lt;/script&gt; 进度条例子来自：W3Plus-被誉为神器的requestAnimationFrame 参考[1]. window.requestAnimationFrame-MDN CSS3动画那么强，requestAnimationFrame还有毛线用？ requestAnimationFrame 方法你真的用对了吗？]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day207-Vue-nextTick()]]></title>
    <url>%2F2019%2F08%2F08%2F2019-08-08%2F</url>
    <content type="text"><![CDATA[要点 nextTick用法 nextTick源码相关 事件循环 源码中的降级策略 nextTick作用 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。来源 源码// 850555d on 20 Dec 2018if (!isIE &amp;&amp; typeof MutationObserver !== 'undefined' &amp;&amp; ( isNative(MutationObserver) || // PhantomJS and iOS 7.x MutationObserver.toString() === '[object MutationObserverConstructor]')) &#123; // Use MutationObserver where native Promise is not available, // e.g. PhantomJS, iOS7, Android 4.4 // (#6466 MutationObserver is unreliable in IE11) let counter = 1 const observer = new MutationObserver(flushCallbacks) const textNode = document.createTextNode(String(counter)) // 创建一个文本 observer.observe(textNode, &#123; characterData: true // 初始化监听文本节点 &#125;) timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) // 文本节点变化监听 &#125;&#125; 以上主要作用就是：监听文本变动是否完毕。 事件循环 常见的microtask有：Promise、MutationObserver、Object.observe(废弃)，以及nodejs中的process.nextTick 常见的macrotask 有setTimeout、MessageChannel、postMessage、setImmediate 降级策略在vue2.x版本的源码文件next-tick.js中，你还可以看到有其他的一些兼容性方法。 参考Vue源码详解之nextTick：MutationObserver只是浮云，microtask才是核心！ 全面解析Vue.nextTick实现原理]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day206-初识MutationObserver]]></title>
    <url>%2F2019%2F08%2F07%2F2019-08-07%2F</url>
    <content type="text"><![CDATA[要点 MutationObserver 使用方法 MutationObserver 的方法observe()(具体)和takeRecords()以及disconnect() MutationRecord 使用方法var mObserver = new MutationObserver(callback) // 新建实例var word = document.querySelector('words');var options = &#123; 'childList': true, 'arrtibutes': true, 'characterData': true, // 节点内容或节点文本的变动 'subtree': true, // 所有子节点，不能单独观察，必须同时指定以上三个为`true` 'attributeOldValue': true, 'characterDataOldValue': true, 'attributesFilter': ['class', 'str'] // 值为数组，表示观察的特定属性&#125;mObserver.observer(word, options) disconnect、takeRecord disconnect 表示停止观察，无参数，用法：mObserver.disconnect() takeRecord 用来清除变动记录，无参数，用法：mObserver.takeRecords() MutationRecord 每个 MutationRecord 代表一个独立的 DOM 变化，其作为参数传递给 MutationObserver 的回调函数。 参数的含义 type: 观察的变动类型（attribute、characterData或者childList） target: 发生变动的DOM对象 addedNodes: 新增的DOM对象 removeNodes: 删除的DOM对象 previousSibling: 前一个同级的DOM对象，无则返回null nextSibling: 下个同级的DOM对象，无则返回null attributeName: 发生变动的属性，如果设置了attributeFilter，则只返回预先指定的属性 oldValue：变动前的值。只对attribute和characterData变动有效 详细的属性表，点击这里 参考MDN-MutationObserver MDN-MutationRecord]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day205-instanceOf]]></title>
    <url>%2F2019%2F08%2F06%2F2019-08-06%2F</url>
    <content type="text"><![CDATA[要点instanceOf 简单实现 原理：检查是否在left（左边的值）的原型链上 代码function myInstanceOf (left, right) &#123; let rightProto = right.prototype left = left.__proto__ while (true) &#123; if (!left) &#123; return false &#125; if (left === rightProto) &#123; return true // 继续找下去 &#125; left = left.__proto__ // 继续遍历 &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day204-es6-笔记-Class-this]]></title>
    <url>%2F2019%2F08%2F05%2F2019-08-05%2F</url>
    <content type="text"><![CDATA[要点 class 构造函数constructor中this的指向类的方法内部如果含有this,默认指向类的实例。单独使用方法时，可能报错。 解决方法： 构造方法中绑定`this 使用箭头函数 使用Proxy，获取方法的时候，自动绑定this 具体解决方法-3rd function selfish (target) &#123; const cache = new WeakMap() // 弱引用 const handler = &#123; get (target, key) &#123; const value = Reflect.get(target, key) if (typeof value !== 'function') &#123; return value &#125; if (!cache.has(value)) &#123; cache.set(value, value.bind(target)) // 还是用到了bind &#125; return cache.get(value) &#125; &#125; const proxy = new Proxy(target, handler) return proxy&#125;/** 示例 */const logger = selfish(new logger())]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day203-reduce题目]]></title>
    <url>%2F2019%2F08%2F04%2F2019-08-04%2F</url>
    <content type="text"><![CDATA[题目 求[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ] 代码第一个[3,2,1].reduce(Math.pow)结果是：Math.pow(3, 2) =&gt; 9; Math.pow(9, 1) =&gt;9。第二个[].reduce(Math.pow)结果是TypeError: Reduce of empty array with no initial value,即：没有初始值。 输出error]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day202-简单实现Promise(4)]]></title>
    <url>%2F2019%2F08%2F03%2F2019-08-03%2F</url>
    <content type="text"><![CDATA[要点 resolved,rejected和pending三种情况的相应处理 代码/** promise */MyPromise.prototype.then = function(onFulfilled, onRejected) &#123; var self = this // 根据标准，如果then的参数不是function，则我们需要忽略它 onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : function(v) &#123; return v&#125; onRejected = typeof onRejected === 'function' ? onRejected : function(r) &#123; return r &#125; if (self.status === 'resolved') &#123; // 这里promise的状态已经确定是resolved，所以调用onResolved return new MyPromise(function(resolve, reject) &#123; try &#123; // ret是onFulfilled的返回值 var ret = onFulfilled(self.data) if (ret instanceof MyPromise) &#123; // 如果ret是一个promise，则取其值作为新的promise的结果 ret.then(resolve, reject) &#125; else &#123; // 否则，以它的返回值作为新的promise的结果 resolve(ret) &#125; &#125; catch (e) &#123; // 如果出错，以捕获到的错误作为promise2的结果 reject(e) &#125; &#125;) &#125; // 这里的逻辑跟前面一样，不再赘述 if (self.status === 'rejected') &#123; return new MyPromise(function(resolve, reject) &#123; try &#123; var ret = onRejected(self.data) if (ret instanceof MyPromise) &#123; ret.then(resolve, reject) &#125; else &#123; reject(ret) &#125; &#125; catch (e) &#123; reject(e) &#125; &#125;) &#125; if (self.status === 'pending') &#123; // 如果当前的Promise还处于pending状态，则不能确定调用 // onResolved还是onRejecte，只能等到Promise状态确定后， // 才能确定如何处理 return new MyPromise(function(resolve, reject) &#123; self.onFulfilledCallback.push(function(value) &#123; try &#123; var ret = onFulfilled(self.data) if (ret instanceof MyPromise) &#123; ret.then(resolve, reject) &#125; else &#123; resolve(ret) &#125; &#125; catch (e) &#123; reject(e) &#125; &#125;) self.onRejectedCallback.push(function(value) &#123; try &#123; var ret = onRejected(self.data) if (ret instanceof MyPromise) &#123; ret.then(resolve, reject) &#125; else &#123; reject(ret) &#125; &#125; catch (e) &#123; reject(e) &#125; &#125;) &#125;) &#125;&#125;// 顺便实现一下catch方法MyPromise.prototype.catch = function(onRejected) &#123; return this.then(null, onRejected);&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day201-简单实现Promise(3)]]></title>
    <url>%2F2019%2F08%2F02%2F2019-08-02%2F</url>
    <content type="text"><![CDATA[要点 promise的then方法框架 代码/** promise-then方法 */MyPromise.prototype.then = function (onFulfilled, onRejected) &#123; var self = this // 标准2.2.1.1. If onFulfilled is not a function, it must be ignored. onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : function(v) &#123; return v &#125; onRejected = typeof onRejected === 'function' ? onRejected : function(r) &#123; return r &#125; // Promise对象存在以下三种状态，对三种状态采用不同处理 if (self.status === 'resolved') &#123; return new MyPromise(function(resolve, reject) &#123; // todo &#125;) &#125; if (self.status === 'rejected') &#123; return new MyPromise(function(resolve, reject) &#123; // todo &#125;) &#125; if (self.status === 'pending') &#123; return new MyPromise(function(resolve, reject) &#123; // todo &#125;) &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day200-简单实现Promise(2)]]></title>
    <url>%2F2019%2F08%2F01%2F2019-08-01%2F</url>
    <content type="text"><![CDATA[要点 修改promise状态 代码/** 构造函数 - 雏形 */function Promise (fn) &#123; let self = this self.status = 'pending' self.data = undefined self.onFulfilledCallback = [] // resolve 回调函数集合 self.onRejectedCallback = [] // reject 回调函数集合 function resolve (value) &#123; if (self.status === 'pending') &#123; self.status = 'resolved' self.data = value for (var i = 0; i &lt; self.onFulfilledCallback.length; i++) &#123; self.onFulfilledCallback[i](value) &#125; &#125; &#125; function reject (reason) &#123; if (self.status === 'pending') &#123; self.status = 'rejected' self.data = reason for (var i = 0; i &lt; self.onRejectedCallback.length; i++) &#123; self.onRejectedCallback[i](reason) &#125; &#125; &#125; try &#123; fn (resolve, reject) // 执行传入的函数，传入 &#125; catch (error) &#123; reject(error) &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day199-简单实现Promise(1)]]></title>
    <url>%2F2019%2F07%2F31%2F2019-07-31%2F</url>
    <content type="text"><![CDATA[要点 构造函数 回调函数集合 代码/** 构造函数 - 雏形 */function Promise (fn) &#123; let self = this self.status = 'pending' self.data = undefined self.onFulfilledCallback = [] // resolve 回调函数集合 self.onRejectedCallback = [] // reject 回调函数集合 fn(resolve, reject) // 执行传入函数&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day198-字符串连续出现最多的字符]]></title>
    <url>%2F2019%2F07%2F30%2F2019-07-30%2F</url>
    <content type="text"><![CDATA[要点 统计出现次数。 连续出现次数。 时间复杂度尽量最小。 'abcaakjbb' =&gt; &#123;'a':2,'b':2&#125;'abbkejsbcccwqaa' =&gt; &#123;'c':3&#125; 代码let str = 'abcaakjbb'// 过程let result = &#123;&#125;let flag = 0let strArr = str.split('')let letterTimes = strArr.reduce((acc, cur, index) =&gt; &#123; if (!acc[cur]) &#123; acc[cur] = 1 // 不存在，就创建键值对，初始值1 &#125; if (strArr[index + 1] === cur) &#123; acc[cur] += 1 &#125; // 比较次数大小 if (acc[cur] &gt; flag) &#123; flag = acc[cur] &#125; acc[] return acc&#125;, &#123;&#125;)console.log(letterTimes)console.log(result)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day197-DOM Range操作]]></title>
    <url>%2F2019%2F07%2F29%2F2019-07-29%2F</url>
    <content type="text"><![CDATA[要点 Range是？ createRange？ Range是？Range是一种fragment（HTML片断），包含了节点或文本节点的一部分，通过document.createRange()或selection象的getRangeAt()方法获得。 IE没有。需要检查兼容性。 createRange？ Document.createRange()常用来设置光标定位。 let el = document.getElementById('editable')let range = document.createRange()let sel = window.getSelection()range.setStart(el.childNodes[2], 5) // childNodes来源于NodeListrange.collapse(true) // collapse(toStart) 折叠该范围，使它的“起点”和“结束点”重合。sel.removeAllRanges()sel.addRange(range) 参考Javascript标准DOM Range操作 Document.createRange() How to set caret(cursor) position in contenteditable element (div)?]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day196-事件循环的常见问题和错误观点]]></title>
    <url>%2F2019%2F07%2F28%2F2019-07-28%2F</url>
    <content type="text"><![CDATA[要点 Node.js 是完全单线程？ 其他线程？ 事件循环是种栈结构？ Node.js 是完全单线程?Node 单线程运行，但是Nodejs中一些标准库函数为了保证程序速度和性能并不是运行在同一个线程上（例如：fs函数）。 其他线程运行在什么地方？既然NOdejs不是单线程，那么其他线程运行在什么地方呢？Nodejs使用名为libuv的特殊库模块来执行异步操作。此库还和Node的后台逻辑一起使用，用来管理被称为libuv线程池的特殊线程池。 该特殊线程池由四个线程组成，用于委派对于事件循环来说太重（长时间运行，过于昂贵）的操作。 事件循环是种栈结构在线程中可能涉及一些类似栈的结构，但其实是事件循环由一系列的阶段所组成，每个阶段都有自己的特定任务，所有阶段都以循环重复的方式去处理。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day195-Vue-style Hooks]]></title>
    <url>%2F2019%2F07%2F27%2F2019-07-27%2F</url>
    <content type="text"><![CDATA[要点在vue3中，将更多的采用hook。个人觉得，如果能保留之前的东西再加上hook，将会更加的灵活。 API that maps Vue’s existing API. Usage in Normal Vue Components API that maps Vue’s existing API.import &#123; withHooks, useData, useComputed, useWatch, useMounted, useUpdated, useDestroyed&#125; from "vue-hooks"const Foo = withHooks(h =&gt; &#123; const data = useData(&#123; count: 0 &#125;) const double = useComputed(() =&gt; data.count * 2) useWatch(() =&gt; data.count, (val, prevVal) =&gt; &#123; console.log(`count is: $&#123;val&#125;`) &#125;) useMounted(() =&gt; &#123; console.log('mounted!') &#125;) useUpdated(() =&gt; &#123; console.log('updated!') &#125;) useDestroyed(() =&gt; &#123; console.log('destroyed!') &#125;) return h('div', [ h('div', `count is $&#123;data.count&#125;`), h('div', `double count is $&#123;double&#125;`), h('button', &#123; on: &#123; click: () =&gt; &#123; // still got that direct mutation! data.count++ &#125;&#125;&#125;, 'count++') ])&#125;) Usage in Normal Vue Componentsimport &#123; hooks, useData, useComputed &#125; from 'vue-hooks'Vue.use(hooks)new Vue(&#123; template: ` &lt;div @click="data.count++"&gt; &#123;&#123; data.count &#125;&#125; &#123;&#123; double &#125;&#125; &lt;/div&gt; `, hooks() &#123; const data = useData(&#123; count: 0 &#125;) const double = useComputed(() =&gt; data.count * 2) return &#123; data, double &#125; &#125;&#125;)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day194-控制contenteditable的光标]]></title>
    <url>%2F2019%2F07%2F26%2F2019-07-26%2F</url>
    <content type="text"><![CDATA[要点元素为contenteditable时控制光标在尾部，方法适用于粘贴纯文本时，光标的定位。 代码function placeCaretAtEnd(el) &#123; el.focus(); if (typeof window.getSelection != "undefined" &amp;&amp; typeof document.createRange != "undefined") &#123; var range = document.createRange(); range.selectNodeContents(el); range.collapse(false); var sel = window.getSelection(); sel.removeAllRanges(); sel.addRange(range); &#125; else if (typeof document.body.createTextRange != "undefined") &#123; var textRange = document.body.createTextRange(); textRange.moveToElementText(el); textRange.collapse(false); textRange.select(); &#125;&#125;placeCaretAtEnd( document.querySelector('p') ); 来源stackoverflow—contenteditable, set caret at the end of the text (cross-browser)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day193-模拟new]]></title>
    <url>%2F2019%2F07%2F25%2F2019-07-25%2F</url>
    <content type="text"><![CDATA[要点 模拟new直接上代码,之前有写过两次，但是一个过于毛糙，一个过于复杂不便于理解。这里根据记忆，再手写一遍。 代码/** * 模拟new */function newFactory () &#123; Constructor = [].shift.call(arguments) // __proto__不建议使用了，建议用Object.create()代替 // var newObj = Object.create(null) // newObj.__proto__ = Constructor.prototype var newObj = Object.create(Constructor.prototype) var r = Constructor.apply(newObj, arguments) return typeof newObj === 'object' ? r || newObj : newObj&#125;function newTes (name) &#123; this.name = name&#125;console.log(newFactory(newTes, 'ceshi'))]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day192-event loop-处理过程]]></title>
    <url>%2F2019%2F07%2F24%2F2019-07-24%2F</url>
    <content type="text"><![CDATA[要点 event loop的处理过程（Processing model） 规范 event-loop-processing-model 只要event loop存在，就会不断执行下面的步骤： 让task queue成为事件循环的任务队列之一，以用户代理定义的方式选择，约束条件是所选任务队列必须至少包含一个可运行的任务。如果没有这样的任务队列，那么跳到下一个微任务步骤。 让oldesttask成为taskqueue中的第一个可运行任务，并将其从taskqueue中删除。 通过执行以下步骤报告用户代理不执行此循环的持续时间： …. 将事件循环当前正在运行的任务设置为OldestTask。 执行旧任务的步骤。 从其任务队列中删除OldestTask。 Microtasks: 执行microtasks任务检查点（microtasks队列里的任务）。 … 更新渲染 … 如果这是一个worker event loop，但是没有任务在task队列中，并且WorkerGlobalScope对象的closing标识为true，则销毁event loop，中止这些步骤，然后进行定义在Web workers章节的run a worker。 返回到第一步。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day191-MyVue-完成]]></title>
    <url>%2F2019%2F07%2F23%2F2019-07-23%2F</url>
    <content type="text"><![CDATA[要点 完善Compilerjs 运行 Complier import Watcher from "./Watcher";const REG = /\&#123;\&#123;(.*)\&#125;\&#125;/class Complier &#123; constructor(el, vm) &#123; this.el = document.querySelector(el) // 高效的原生DOM选择器，用着方便（比getElementsBy系列） this.vm = vm this.frag = this._createFragment() this.el.appendChild(this.frag) // 整个element添加到这里，最后会清空 &#125; _createFragment () &#123; var frag = document.createDocumentFragment() // 文档碎片节点，比createElement多次添加到document.body效率高 var child while(child = this.el.firstChild) &#123; this._compile(child) // 接收每个node的子节点 frag.appendChild(child) // 编译完之后，添加到碎片;appendChild做移动步骤； &#125; return frag &#125; _compile(node) &#123; console.log(node) if (node.nodeType === 1) &#123; // 元素 // 最后，完成双向绑定 var attr = node.attributes if (attr.hasOwnProperty('v-model')) &#123; var propValue = attr['v-model'].nodeValue var self = this node.addEventListener('input', function (e) &#123; self.vm[propValue] = e.target.value // 用了set，每次调用，添加了Watcher了的地方会做相应处理 &#125;) node.value = this.vm[propValue] &#125; &#125; if (node.nodeType === 3) &#123; // 文本节点 // 通过Observer中notify()，通知get。watcher中会update() if (REG.test(node.nodeValue)) &#123; var name = RegExp.$1 // 拿到第一个大括号里的 name = name.trim() // 得到属性名字 new Watcher(node, name, this.vm) // 观察得到的值 &#125; &#125; &#125;&#125;export default Complier 运行安装webpack 全局 npm i -g webpack webpack-cli 局部 npm i -D webpack webpack-cli 打包webpack main.js –output bundle.js 热编译webpack main.js –output bundle.js –watch]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day190-MyVue-完善Complier、Watcher]]></title>
    <url>%2F2019%2F07%2F22%2F2019-07-22%2F</url>
    <content type="text"><![CDATA[要点 提取模板中的变量 完善Watcher和Observer之间的桥梁，Dep中添加target Complierimport Watcher from "./Watcher";const REG = /\&#123;\&#123;(.*)\&#125;\&#125;/ // 取胡须括号中的内容class Complier &#123; constructor(el, vm) &#123; this.el = document.querySelector(el) // 高效的原生DOM选择器，用着方便（比getElementsBy系列） this.vm = vm this.frag = this._createFragment() this.el.appendChild(this.frag) // 整个element添加到这里，最后会清空 &#125; _createFragment () &#123; var frag = document.createDocumentFragment() // 文档碎片节点，比createElement多次添加到document.body效率高 var child while(child = this.el.firstChild) &#123; this._compile(child) // 接收每个node的子节点 frag.appendChild(child) // 编译完之后，添加到碎片;appendChild做移动步骤； &#125; return frag &#125; _compile(node) &#123; if (node.nodeType === 1) &#123; // 元素 &#125; if (node.nodeType === 3) &#123; // 文本节点 if (REG.test(node.nodeValue)) &#123; var name = RegExp.$1 // 拿到第一个大括号里的 name = name.trim() // 得到属性名字 new Watcher(node, name, this.vm) // 观察得到的值 &#125; &#125; &#125;&#125;export default Complier Watcherimport Dep from "./Dep";/** * 订阅的人附到Dep */class Watcher &#123; constructor (node, name, vm) &#123; this.node = node this.name = name this.vm = vm Dep.target = this // 注入，给Observer提供this，否则Observer不会主动注入listen(Dep.target) this.update() Dep.target = null &#125; update () &#123; this.node.nodeValue = this.vm[this.name] &#125;&#125;export default Watcher Dep添加target /** * 发布订阅事件 */class Dep &#123; // static target = null // 可能不被识别 constructor () &#123; this.listenerList = [] &#125; /** * subs 传入Watcher,知道谁在监听 * @param &#123;*&#125; subs */ sub (subs) &#123; this.listenerList.push(subs) &#125; notify () &#123; for (var i = 0; i &lt; this.listenerList.length; i++) &#123; this.listenerList[i].update() &#125; &#125;&#125;Dep.prototype.target = null // 兼容性export default Dep]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day189-MyVue-完善Observer]]></title>
    <url>%2F2019%2F07%2F21%2F2019-07-21%2F</url>
    <content type="text"><![CDATA[要点 从Vue.js中入手，先完善new Obersver(this._data) Obersver/** * 观察者，需要观察到的实例属性,通过set、get把数据发布者订阅者绑定在一起 */import Dep from './Dep'class Observer &#123; constructor (data) &#123; this.data = data Object.keys(this.data).forEach(key =&gt; &#123; this._bind(data, key, data[key]) &#125;) &#125; _bind(data, key, val) &#123; var myDep = new Dep() // 逐个改掉 Object.defineProperty(data, key, &#123; get () &#123; if (Dep.target) myDep.listen(Dep.target) return val &#125;, set (newVal) &#123; if (val === newVal) return val = newVal myDep.notify() &#125; &#125;) &#125; &#125;export default Observer]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day188-MyVue-搭建基本架构]]></title>
    <url>%2F2019%2F07%2F20%2F2019-07-20%2F</url>
    <content type="text"><![CDATA[要点 发布订阅模式 Vue基本架构，文件目录 架构细化，Dep.js、index.html、main.js、Watcher.js、Observer.js vue.js-获取data等，构建入口文件 发布订阅模式class SimpleEvent &#123; constructor () &#123; this.listenerList = [] &#125; listen (listener) &#123; // 订阅 this.listenerList.push(listener) &#125; trigger () &#123; // 发布 for (var i = 0; i &lt; this.listenerList.length; i++) &#123; // this.listenerList[i].call(this) this.listenerList[i].update() &#125; &#125;&#125;var myEvent = new SimpleEvent()// myEvent.listen(function () &#123;// console.log('谁订阅了我')// &#125;)// myEvent.trigger()let eventObj = &#123; update () &#123; console.log('订阅之后更新了') &#125;&#125;myEvent.listen(eventObj)myEvent.trigger()// 订阅之后更新了 Vue基本架构MyVue|├─index.html # 页面├─main.js # new Vue 实例化vue├─vue.js # vue 入口文件├─Dep.js # 发布订阅├─Watcher.js # 订阅的事件，即Dep中listen(subs)的subs├─Comlier.js # 模板编译，处理html文件相关数据└─Observer.js # 观察者，set、get方法，绑定数据 架构细化Dep.js 展开代码class Dep &#123; constructor () &#123; this.listenerList = [] &#125; /** * subs 传入Watcher,知道谁在监听 * @param &#123;*&#125; subs */ sub (subs) &#123; this.listenerList.push(subs) &#125; notify () &#123; for (var i = 0; i &lt; this.listenerList.length; i++) &#123; this.listenerList[i].update() &#125; &#125;&#125;export default Dep index.html 展开代码&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" v-model="message"&gt; &lt;br/&gt; &#123;&#123;message&#125;&#125; &lt;script src="bundle.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; main.js 展开代码import MyVue from "./Vue";new MyVue(&#123; el: '#app', data: &#123; message: 'my binding vue' &#125;&#125;) Watcher.js 展开代码/** * 订阅的人附到Dep */class Watcher &#123; constructor () &#123;&#125;&#125;export default Watchers Observer.js 展开代码/** * 观察者，需要观察到的实例属性,通过set、get把数据发布者订阅者绑定在一起 */class Observer &#123; constructor () &#123;&#125;&#125;export default Observer Vue.js获取data等Vue.js 展开代码import Observer from './Observer'import Complier from './Complier'class Vue &#123; constructor (options) &#123; // 拿到内部 this.$options = options this.$el = this.$options.el this._data = this.$options.data // 绑定数据 new Observer(this._data) // 编译，挂载 new Complier(this.$el, this) // data上每个属性都做转换 Object.keys(this._data.forEach(key =&gt; &#123; this._proxy(key) &#125;)) &#125; // 函数解决调繁琐调用Vue.$options.data.message _proxy (key) &#123; var self = this Object.defineProperty(this, key, &#123; get () &#123; return self.data[key] &#125;, set (value) &#123; self.data[key] = value &#125; &#125;) &#125;&#125;export default Vue]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day187-diff-updateChildren示例]]></title>
    <url>%2F2019%2F07%2F19%2F2019-07-19%2F</url>
    <content type="text"><![CDATA[要点 updateChildren()如何进行比较最终全部替换掉的。 例子： 原有的oldCh的顺序是 A、B、C、D、E、F、G 更新后成ch的顺序是 F、D、A、H、E、C、B、G diff流程示例开始：patchVnode (oldVnode, newVnode))round1:(找到相同的)对比顺序：A-F -&gt; G-G，匹配成功，然后：/** A-F（头头比较：不等） -&gt; G-G（尾尾比较：相等尾部指针往前移动，不满足while条件，开始第二次循环比较） */对G进行patchVnode的操作，更新oldEndVnodeG和newEndVnodeG的elm指针移动，两个尾部指针向左移动，即oldEndIdx-- newEndIdx--round2:对比顺序：A-F -&gt; F-B -&gt; A-B -&gt; F-F，匹配成功，然后：/** （头头比较：不等） -&gt; （尾尾比较：不等）-&gt;（头尾比较：不等）-&gt;（尾头比较：相等） */对F进行patchVnode的操作，更新oldEndVnodeF和newEndVnodeF的elm指针移动，移动指针，即oldEndIdx-- newStartIdx++找到oldStartVnode在dom中所在的位置A，然后在其前面插入更新过的F的elmround3:对比顺序：A-D -&gt; E-B -&gt; A-B -&gt; E-D，仍未成功，取D的key，在oldKeyToIdx中查找，找到对应的D，查找成功，然后：将D取出赋值到 vnodeToMove对D进行patchVnode的操作，更新vnodeToMoveD和newStartVnodeD的elm指针移动，移动指针，即newStartIdx++将oldCh中对应D的vnode置undefined在dom中找到oldStartVnodeA的elm对应的节点，然后在其前面插入更新过的D的elmround4:对比顺序：A-A，对比成功，然后：对A进行patchVnode的操作，更新oldStartVnodeA和newStartVnodeA的elm指针移动，两个尾部指针向左移动，即oldStartIdx++ newStartIdx++round5:对比顺序：B-H -&gt; E-B -&gt; B-B ,对比成功，然后：对B进行patchVnode的操作，更新oldStartVnodeB和newStartVnodeB的elm指针移动，即oldStartIdx++ newEndIdx--在dom中找到oldEndVnodeE的elm的nextSibling节点（即G的elm），然后在其前面插入更新过的B的elmround6:对比顺序：C-H -&gt; E-C -&gt; C-C ,对比成功，然后(同round5)：对C进行patchVnode的操作，更新oldStartVnodeC和newStartVnodeC的elm指针移动，即oldStartIdx++ newEndIdx--在dom中找到oldEndVnodeE的elm的nextSibling节点（即刚刚插入的B的elm），然后在其前面插入更新过的C的elmround7:获取oldStartVnode失败（因为round3的步骤4）,然后：指针移动，即oldStartIdx++round8:对比顺序：E-H、E-E,匹配成功，然后（同round1）：对E进行patchVnode的操作，更新oldEndVnodeE和newEndVnodeE的elm指针移动，两个尾部指针向左移动，即oldEndIdx-- newEndIdx--lastround8之后oldCh提前发生了‘交叉’，退出循环。 参考VUE源码解析DIFF过程一探究竟]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day186-具体的diff分析过程（vuejs）-笔记]]></title>
    <url>%2F2019%2F07%2F18%2F2019-07-18%2F</url>
    <content type="text"><![CDATA[要点 updateChildren()代码 代码相对较多，较繁琐，这里了解代码和key起的作用就可。 代码 + 内部注释patch过程中父节点相同，父节点文本内容相同，子节点不同updateChildren()的比较。 基本思路就是两个树进行新旧节点的比较。 updateChildren (parentElm, oldCh, newCh) &#123; let oldStartIdx = 0, newStartIdx = 0 let oldStartVnode = oldCh[0] let oldEndIdx = oldCh.length - 1 let oldEndVnode = oldCh[oldEndIdx] let newStartVnode = newCh[0] let newEndIdx = newCh.length - 1 let newEndVnode = newCh[newEndIdx] let oldKeyToIdx let idxInOld let elmToMove let before // 判断遍历是否结束 while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; // 1，不设置key if (oldStartVnode === null) &#123; // 2,都是两头指针相互向中间靠 oldStartVnode = oldCh[++oldStartIdx] &#125; else if (oldEndVnode === null) &#123; oldEndVnode = oldCh[--oldEndIdx] &#125; else if (newStartVnode === null) &#123; newStartVnode = newCh[++newStartIdx] &#125; else if (newEndVnode === null) &#123; newEndVnode = newCh[--newEndIdx] // 3,递归调用，需要看清楚具体比较的东西是什么 &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newEndVnode) // 如果碰到一样的节点，就深度遍历比较，走递归 oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // ？？？？ patchVnode(oldEndVnode, newEndVnode) // 需要对dom进行移动 api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; patchVnode(oldEndVnode, newStartVnode) // 需要对dom进行移动 api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] &#125; else &#123; // 设置key，除头尾两端比较外，加了一个oldKeyToIdx对象表，从中查找匹配的节点 if (oldKeyToIdx === undefined) &#123; // 有key时生成index表 oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) &#125; idxInOld = oldKeyToIdx[newStartVnode.key] if (!idxInOld) &#123; api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) newStartVnode = newCh[++newStartIdx] &#125; else &#123; elmToMove = oldCh[idxInOld] if (elmToMove.sel !== newStartVnode.sel) &#123; api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) &#125; else &#123; patchVnode(elmToMove, newStartVnode) oldCh[idxInOld] = null api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el) &#125; newStartVnode = newCh[++newStartIdx] &#125; &#125; &#125; if (oldStartIdx &gt; oldEndIdx) &#123; before = newCh[newEndIdx + 1] === null ? null : newCh[newEndIdx + 1].el addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx) &#125; else if (newStartIdx &gt; newEndIdx) &#123; removeVnodess(parentElm, oldCh, oldStartIdx, oldEndIdx) &#125;&#125; 参考原文点此]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day185-Diff过程（vuejs）-笔记]]></title>
    <url>%2F2019%2F07%2F17%2F2019-07-17%2F</url>
    <content type="text"><![CDATA[要点 patch 函数概览。() patchVnode 函数概览。主要分为两个部分。每个函数中都会有代码并附上代码的行行解释。 patch() 函数概览 代码 + 解析 代码/** * vuejs diff过程 * @param &#123;String&#125; oldVnode * @param &#123;String&#125; newVnode */function patch(oldVnode, newVnode) &#123; // 1 if (sameVnode(oldVnode, newVnode)) &#123; // 2 patchVnode(oldVnode, newVnode) &#125; else &#123; // 3 const oEl = oldVnode.el // 4 let parentEle = api.parentNode(oEl) // 5 createEle(newVnode) if (parentEle !== null) &#123; // 6 api.insertBefore(parentEle, newVnode.el, api.nextSibling(oEl)) api.removeChild(parentEle, oldVnode.el) oldVnode = null &#125; &#125; // 7 return newVnode&#125; 解析 看这两个节点是否值得比较（比比是不是子节点有不一样的地方），比较两者key和sel是否完全相等。（sel：节点的选择器）vuejs中virtual dom用的是snabbdom，snabbom定义的(Virtual Node属性)[https://github.com/snabbdom/snabbdom#sel--string]有sel、data、children、text、elm、key。这点和React用的库不一样。 两个节点相互比较比较的过程要分好几种情况，后面再记笔记啊。 进入了不需要比较两个节点的处理流程oEl表示节点的父节点。（取父节点做？？） parentEle是父节点的真是dom 给newVnode创建真实的节点。 插入新的节点，移除旧节点。（为啥还要特地移除Child，直接把二叉树的顶部根节点移除不就行了？） 返回newVnode对应的真实dom patchVnode() 函数概览代码 + 解析 代码/** * 比较不同的节点patchVnode() * @param &#123;String&#125; oldVnode * @param &#123;String&#125; newVnode */function patchVnode (oldVnode, newVnode) &#123; const el = newVnode.el = oldVnode.el let i, oldCh = oldVnode.children, newCh = newVnode.children // 这里这个相等应该是深比较吧，完全相等就返回`false`？ // 2.1 if (oldVnode === newVnode) return // 比较Virtual node中text是否相等？ // 2.2 if (oldVnode.text !== null &amp;&amp; newVnode.text !== null &amp;&amp; oldVnode.text !== newVnode.text) &#123; // 如果只是文本内容相等直接替换旧文本内容就行？ api.setTextContent(el, newVnode.text) &#125; else &#123; // 2.3 updateEle(el, newVnode, oldVnode) if (oldCh &amp;&amp; newCh &amp;&amp; oldCh !== newCh) &#123; // 2.4 updateChildren(el, oldCh, newCh) &#125; else if (newCh) &#123; // 2.5 createEle(newVnode) &#125; else if (oldCh) &#123; // 2.6 api.removeChildren(el) &#125; &#125;&#125; 解析 序号2中，什么是值得比较的节点（我理解的是，子节点是不是完全一样？）比较相同节点sameVnode(oldVnode, newVnode) 2.1 比较引用是否一致，一致则认为没有变化。（引用？） 2.2 文本节点的比较，需要修改则调用Node.textContent = newVnode.text。 2.3 判断新旧节点是否存在子节点，新旧节点子节点是不是相等。 2.4 updateChildren函数，是diff核心。 2.5 只有新节点有子节点就调用createEle(newVnode)。在老dom节点上添加子节点。 2.6 只有旧节点有子节点，新节点为空。可以直接遵循新节点。直接删除老节点。 参考原文点此]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day184-Diff Algorithm（译）]]></title>
    <url>%2F2019%2F07%2F16%2F2019-07-16%2F</url>
    <content type="text"><![CDATA[要点本文为一篇经典的Diff算法文章的译文，原文写的是React的Diff算法。这里只是摘取了后半部分的内容，并没有翻译开篇部分。 原文点此 level by level找出两个任意二叉树的最小变化是一个O(n^3)问题。但是React用简单且强大的启发式来找一个O(n)的最优解。 React尝试逐层地去求解二叉树。这种方式大幅地减少了树的复杂度且在web应用中组件移动到不同层级时产生极少的（性能）损耗。通常这种移动都是横向的子节点间移动。 List假设有在一个组件中某次迭代渲染5个组件之后要在List的中间位置插入一个新的组件。这里很难去根据这个信息去知道如何映射在两个list组件之间。（This would be really hard with just this information to know how to do the mapping between the two lists of components.） 默认情况下，React会将前一个list中的第一个组件和下一个list中的第一个组件相关联,等等。你可以加一个key属性来帮助React找出映射。在实践中，这样做通常能很容易找到唯一的key就存在子节点之间。 Components一个React应用通常是由很多用户定义的组件组成并最终转换成一棵主要由div组成的树。其他的信息会被diff算法考虑在内，因为React只匹配具有相同类的组件。例如，如果一个&lt;Header&gt;被一个&lt;ExampleBlock&gt;替代，React会移除header创建一个example block。不需要我们花宝贵的时间去尝试匹配两个组件而且是不太可能有任何的相似之处。 Event Delegation（事件委托）添加事件监听到DOM节点上非常的慢而且还费内存。相反的是，React采用一种非常流行的技术叫“event delegation”。React则更进一步重新实现符合W3C标准的事件系统。这个意味着Internet Explorer 8事件处理的问题已经成为过去，事件名称在所有的浏览器中都是一致的。 让我解释下它是怎么实现的。一个单独的事件监听被添加到document的root中。当该事件被触发时，浏览器给我们提供目标DOM节点。为了通过DOM层级分发事件（propagate the even），React不会再virtual DOM层级上进行迭代。 相反，我们用的每个React组件实际上都有唯一的id来编码层级（encodes the hierarchy）。我们可以用简单的字符操作来获取所有父组件（原文为：parents）的id。通过将事件监听存储在hash map中，我们发现性能要优于添加到virtual DOM。这里有个例子来解释当一个事件通过virtual DOM被调度（dispatched）会发生什么。// dispatchEven('click', 'a.b.c', event)clickCaptureListeners['a'](event);clickCaptureListeners['a.b'](event);clickCaptureListeners['a.b.c'](event);clickBubbleListeners['a.b.c'](event);clickBubbleListeners['a.b'](event);clickBubbleListeners['a'](event); 浏览器创建一个新的事件对象给每个事件和每个监听者（listener）。这个性质的好处在于你可以保留事件对象的引用甚至可以修改它。然而，这意味着要进行大量的内存分配。React在启动时会分配这些对象一个池。需要事件对象时，它会从池子里去取。这极大地减少了垃圾收集。 RenderingBatching（批量）当你调用在组件内的setState时，React会标记它为脏值。在事件循环的末尾，React会查看组件所有的脏值并重新渲染它们。批量表示在一次事件循环期间，DOM只有一次的更新。这个性质是建立高性能应用的关键，但用常规的JavaScript非常难写这个。在React应用中，默认有这个性质。 Sub-tree Rendering当setState被调用时，组件给其子节点重新建立virtual DOM。如果你在根元素调用setState，整个React应用就会重新渲染。所有的组件，即使它们没有改变，都会被他们的render方法调用。这可能听起来很可怕且在实际情况中低效，这很好用，因为我们没有接触到真实DOM。 首先，我们谈谈关于用户界面的展示。因为屏幕空间的限制，你可能通常一次性地展示成百上千的节点。JavaScript在整个可管理的界面上的业务逻辑已经够快了（JavaScript has gotten fast enough business logic for the whole interface is manageable.）另一个重要的点是写React代码时，你通常不会在根节点每次变化时都调用setState。你会在收到变动的事件或上层几个组件时在组件上调用。很少会直接到顶部。这表明改动会落实到用户的交互。 Selective Sub-tree Rendering最后你有可能阻止一些子树重新渲染。如果你在组件上用下列方法：boolean shouldComponentUpdate(object nextProps object nextState) 建立在前后（previous and next）的props/state组件上，你可以告诉React这个组件不要改动且没必要再重新渲染它。用的得当时，这个可以让性能极大地提升。为了能够用它，必须能够比较JavaScript对象。如果比较的浅或深会有很多的问题产生；如果深的话我们是否要用不可变数据结构或者做深拷贝。而你想要记住，这个功能会一直被调用，因此你想确认它计算所需的时间是否少于启发式少于渲染组件的花费，及时不是严格需要重新渲染。 Conclusion这技术让React变得更快这并不新鲜。我们很早就知道，接触DOM的开销很大，应该批量的读写操作，事件委托更快… 人们依旧在讨论这些东西，因为在实践中，它们很难用于常规的JavaScript代码。让React脱颖而出的是所有这些优化都是默认。这让你很难搬起石头砸自己的脚，让你的应用变慢。这些React的性能开销模型也非常容易理解：每个setState重新渲染整个子树。如果你想挤出性能，尽可能的少调用setState同时用shouldComponentUpdate来阻止一颗大子树的重新渲染。(全文完)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day183-Tree Shaking in Webpack-了解]]></title>
    <url>%2F2019%2F07%2F15%2F2019-07-15%2F</url>
    <content type="text"><![CDATA[要点 概念 机制 使用方法 概念 DCE Dead Code Elimination 去除无用的没有执行的代码（如：不可能进入的分支）。 导致dead variable的代码（写入变量之后不再读取的代码）。 tree shaking是DCE的一种方式，可以在webpack打包时，忽略没有用的代码。 机制 找出使用的代码基于 ES6 的静态引用，tree shaking 扫描所有export，找出有用的和无用的内容添加到代码中，最后压缩时分类处理。 使用方法源码必须遵循 ES6 的模块规范 (import &amp; export)，CommonJs规范（require）没法用。 webpack2需要修改配置文件，webpack3+可以正常tree shaking]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day182-对象-键值对]]></title>
    <url>%2F2019%2F07%2F14%2F2019-07-14%2F</url>
    <content type="text"><![CDATA[要点对象的指定位置插入键值对let data = &#123; key1: 'value1', key3: 'value3' &#125; 代码function insertKey(key, value, obj, pos) &#123; return Object.keys(obj).reduce((ac, a, i) =&gt; &#123; if (i === pos) ac[key] = value ac[a] = obj[a] return ac &#125;, &#123;&#125;)&#125;// 运行console.log(insertKey('key2', 'value2', data, 1))]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day181-Reduce求对象中多个属性的和]]></title>
    <url>%2F2019%2F07%2F13%2F2019-07-13%2F</url>
    <content type="text"><![CDATA[要点求对象中多个属性的和let data = [ &#123; tqaModifyCount: 9, tqaMarkCount: 19 &#125;, &#123; tqaModifyCount: 3, tqaMarkCount: 3 &#125;]let tgt = &#123; tqaModifyCounts: 12 tqaMarkCounts: 22&#125; 代码function sum (dataArr) &#123; return dataArr.reduce((acc, obj) =&gt; &#123; return &#123; tqaModifyCounts: acc.tqaModifyCount + obj.tqaModifyCount, tqaMarkCounts: acc.tqaMarkCount + obj.tqaMarkCount &#125; &#125;)&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day180-Virtual DOM-再探]]></title>
    <url>%2F2019%2F07%2F12%2F2019-07-12%2F</url>
    <content type="text"><![CDATA[要点 Virtual DOM的是三个重要步骤； Virtual DOM的具体步骤； Virtual DOM的是三个重要步骤 生成Virtual DOM树 对比两棵树的差异（diff） 更新试图（patch） Virtual DOM的具体步骤生成Virtual DOM树例子： 真实DOM&lt;ul id="list"&gt; &lt;li class="item"&gt;Item 1&lt;/li&gt; &lt;li class="item"&gt;Item 2&lt;/li&gt;&lt;/ul&gt; DOM树let element = &#123; tagName: 'ul', props: &#123; id: 'list' &#125;, children: [ &#123; tagName: 'li', props: &#123; class: 'item' &#125;, children: ['Item 1'] &#125;, &#123; tagName: 'li', props: &#123; class: 'item' &#125;, children: ['Item 2'] &#125; ]&#125; 对比两棵树的差异对树进行遍历：深度优先遍历、广度优先遍历 diff算法中采用深度优先遍历。对新旧两棵树进行一次深度优先的遍历，这样每个节点都会有一个唯一的标记。 遍历时，每遍历到一个节点就把该节点和新的树的同一个位置的节点进行对比，如果有差异的话就记录到一个对象（差异对象）里面。 差异对象（常见的差异）替换节点增加/删除子节点修改节点属性改变文本内容 更新视图根据差异的不同类型，对DOM进行针对性的更新。更新视图（针对相应差异的更新方法）replaceChild()appendChild() / removeChild()setAttribute() / removeAttribute()textContent]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day179-HTTPS协议-SSL和TLS的区别]]></title>
    <url>%2F2019%2F07%2F11%2F2019-07-11%2F</url>
    <content type="text"><![CDATA[要点 关系（并列关系）； SSL(Secure Socket Layer，安全套接字层)； HTTP/2的多路复用解决要点2的问题； 不适用于HTTP/2的优化； SSL和TLS之间的详细关系； 关系SSL是专门保护Web通讯的。TLS是制定的一种新协议，建立在SSL3.0协议规范上，TLS1.0和SSL3.0两者差别极小。 SSL(Secure Socket Layer，安全套接字层)简介作用：SSL利用数据加密技术，确保web浏览器与服务器之间的身份认证和数据加密传输安全。通用的规格为40bit安全标准。 层级：SSL协议位于TCP/IP协议与各种应用层之间，为数据通讯提供安全支持。 分类：SSL协议主要分两层，SSL记录协议（SSL Record Protocol）和SSL握手协议（SSL Handshake Protocol）。 SSL记录协议：它建立在可靠的传输协议（如TCP）上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL握手协议：它建立在SSL记录协议之上，用于数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。 SSL协议提供的服务1) 认证用户和服务端（服务器），确保数据发送到正确的客户端和服务端。2) 维护数据的完整性，确保数据在传输过程中不被改变。3) 加密数据以防数据中途被窃取。 SSL协议的工作流程 服务端认证阶段：1) 客户端向服务端发送一个开始信息’Hello’以便开始一个新的会话连接；2) 服务端根据客户的信息确定是否需要生成新的主密钥（什么信息申请新的主密钥？），如果需要则服务端在响应客户的’Hello’信息时将包含生成主密钥所需的信息。3) 客户端根据收到的服务端响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务端。4) 服务端恢复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务端。 用户端认证阶段：在此之前，服务端已通过客户端认证，这一阶段主要是完成对客户端的认证。经认证的服务端发送一个提问给客户端，客户端则返回（数字）签名后的提问和其公开的密钥，从而向服务端提供认证。 SSL协议的总结SSL协议的运行基础是商家（即：服务端）对消费者（即：客户端）信息保密的承诺，有利于商家而不利于消费者。 在电子商务初级阶段，由于运作电子商务的企业大多是信誉较高的大公司，因此这问题还没有充分暴露出来。 随着电子商务的发展，各中小型公司也参与进来，这样在电子支付过程中的单一认证问题就越来越突出。 虽然在SSL3.0中通过数字签名和数字证书可实现浏览器和Web服务端双方的身份验证，但SSL协议仍存在一些问题，比如，只能提供交易中客户端与服务端间的双方认证，在设计多方的电子交易中，SSL协议并不能协调各方间的安全传输和信任关系。 在这种情况下，Visa和MasterCard两大信用卡组织制定了SET协议，为网上信用卡支付提供了全球性的标准。 TLS(Transport Layer Security Protocol, 安全传输层协议)简介作用：TLS（安全传输层协议）用于在两个通信应用程序之间提供保密性和数据完整性。分类：TLS协议主要分两层，TLS记录协议（TLS Record）和TLS握手协议（TLS Handshake）。 较低的层为TLS记录协议（注：同SSL记录协议），位于某个可靠的传输协议（如TCP）上面。 TLS记录协议：它提供的连接安全性具有两个基本特性，私有、可靠。 私有——对称加密用数据加密（DES、RC4等）。对称加密产生的密钥对每个连接都是唯一的，且此密钥基于另一个协议（如握手协议）协商。 记录协议也可以不加密使用。 可靠——信息传输包括使用密钥的MAC进行信息完整性检查。安全哈希功能（SHA、MD5等）用于MAC计算。 记录协议在没有MAC的情况下也能操作，但一般只能用于这种模式，即有另一个协议正在使用记录协议传输协商安全参数。 TLS握手协议： 简介 TLS记录协议用于封装各种高层协议。 作为这种封装协议之一的握手协议允许服务器于客户端在应用程序协议传输和接收其第一个数据字节前彼此之间相互认证，协商加密算法和加密密钥。 TLS握手协议提供的连接安全具有三个基本属性： 1）可以使用非对称的，或公共密钥的密码来认证对方的身份。该认证是可选的，但至少需要一个结点方。 2）共享加密密钥的协商是安全的。对偷窃者来说协商加密是难以获得的。以此经过认证的连接不能获得加密，及时是进入连接中间的攻击者也不能。 3）协商是可靠的。没有经过通信方成员的检测，任何攻击者都不能修改通信协商。 TLS的最大优势就在于：TLS是独立于应用协议。高层协议可以透明地分布在TLS协议上面。 然而，TLS标准并没有规定应用程序如何在TLS上增加安全性， 它把如何启动TLS握手协议以及如何解释交换的认证证书的决定权留给协议的设计者和实施者来判断。 TLS协议的协议结构TLS协议包括两个协议组（即：TLS记录协议和TLS握手协议），每组具有很多不同格式的信息。 在此文件中我们只列出协议摘要并不做具体解析。具体内容可参照相关文档。 TLS记录协议是一种分层协议。每一层中的信息可能包含长度、描述和内容等字段。记录协议支持信息传输、将数据分段到可处理块、压缩数据、应用MAC、加密以及传输结果等。对接收到的数据进行解密、校验、解压缩、重组等，然后将他们传送到高层客户机。 TLS连接状态指的是TLS记录协议的操作环境。它规定了压缩算法、加密算法和MAC算法。 TLS记录层从高层接收任意大小无空块的连续数据。密钥计算：记录协议通过算法从握手协议提供的安全参数中产生密钥、IV和MAC密钥。 TLS握手协议由三个子协议组构成，允许对等双方在记录层的安全参数上达成一致、自我认证、例示协商安全参数、互相报告出错条件。 SSL和TLS之间的详细关系TLS（Transport Layer Security，传输层安全协议）是IETF制定的一种新的协议，它建立在SSL3.0协议规范之上，是SSL3.0的后续版本。在TLS与SSL3.0之间存在着显著的差别，主要是所支持的加密算法不同,所以TLS与SSL3.0不能互操作。 差异 版本号：TLS记录格式与SSL记录格式相同，但版本号的值不同，TLS的版本1.0使用的版本号为SSLv3.1。 报文鉴别码：SSLv3.0和TLS的MAC算法及MAC计算的范围不同。TLS使用了RFC-2104定义的HMAC算法（消息认证代码的密钥散列法）。 SSLv3.0使用了相似的算法，两者差别在于SSLv3.0中，填充的字节与密钥之间采用的是连接运算，而HMAC算法采用的是异或运算。但是两者的安全程度是相同的。 伪随机函数：TLS使用了称为PRF的伪随机函数将密钥扩展成数据块，是更安全的方式。 报警代码：TLS支持几乎所有的SSLv3.0报警代码，而且TLS还补充定义了很多的报警代码，如：解密失败（decryption_failed）、记录溢出（record_overflow）、未知CA（unknown_ca）、拒绝访问（access_denied）等。 密文族和客户证书：SSLv3.0和TLS存在少量差别，即TLS不支持Fortezza密钥交换、加密算法和客户证书。 certificate_verify和finished消息：SSLv3.0和TLS在用certificate_verify和finished消息计算MD5和SHA-1散列码时，计算的输入有少许差别，但安全性相当。 加密计算：TLS和SSLv3.0在计算主密值（master sercret）时采用的方式不同。 填充：用户数据加密之前需要增加的填充字节。在SSL中，填充后的数据长度要达到密文块长度的最小整数倍。 而在TLS中，填充后的数据长度可以是密文块长度的任意整数倍（但填充的最大长度为255字节），这种方式可以防止基于对报文长度进行分析的攻击。 TLS的主要增强内容（对比SSL)TLS的主要目标是使SSL更安全，并使协议的规范更精确和完善。TLS在SSLv3.0的基础上，提供了一下增强内容： 1) 更安全的MAC算法。 2) 更严密的警报。 3) ‘灰色区域’规范的更明确定义。 TLS对于安全性的改进 1) 对于消息认证使用密钥散列法：TLS使用“消息认证代码的密钥散列法”（HMAC），当记录在开放网络（如：英特网）上传送时，该代码确保记录不会被变更。SSLv3.0还提供键控消息认证，但HMAC比SSLv3.0使用的（消息认证代码）MAC功能更安全。 2) 增强的伪随机功能（PRF）：PRF生成密钥数据。在TLS中，HMAC定义PRF。PRF使用两种散列算法保证其安全性。如果任一算法暴露了，只要第二种算法未暴露，则数据仍然是安全的。 3) 改进的已完成消息验证：TLS和SSLv3.0都对两个端点提供已完成的消息，该消息认证交换的消息没有被变更。然而，TLS将此已完成消息基于PRF和HMAC值之上，这也比SSLv3.0更安全。 4) 一致证书处理：与SSLv3.0不同，TLS试图制定必须在TLS之间实现交换的证书类型。 5) 特定警报消息：TLS提供更多的特定和附加警报，以指示任一会话端点检测到的问题。TLS还对合适应该发送某些警报进行记录。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day178-HTTP协议-多路复用]]></title>
    <url>%2F2019%2F07%2F10%2F2019-07-10%2F</url>
    <content type="text"><![CDATA[要点 Keep-Alive。 HTTP1.1存在的问题。 HTTP/2的多路复用解决要点2的问题。 不适用于HTTP/2的优化。 Keep-Alive起源每次请求都会建立一次HTTP连接,即3次握手和四次挥手。一个长连接时就会有多次不间断请求数据和建立连接的过程。 如果第一次建立连接，就一直占用通道，就省去多次请求过程，即：Keep-Alive。 详细（Keep-Alive解决的核心问题）规定的时间内，同一个域名多次请求数据，只建立一次HTTP请求，其他请求可复用每次建立的连接通道，以达到提高请求效率的问题。 HTTP1.1的其他问题 Keep-Alive解决多次连接问题 文件传输是串行进行。在HTTP1.1协议中，传输的request和response都是基于文本的，所有的数据必须按顺序串行传输，这样接收端才能知道原本的顺序。 连接数过多。最大并发数有限为50(Apache)。 HTTP/2的多路复用 解决以上的HTTP1.1中两个问题 解决文件串行传输。HTTP/2引入二进制数据帧和流的概念。帧对数据进行顺序标识,这样才能并行传输，接收端才能按照序列（即：顺序标识）对数据进行合并。流（服务器并行传输数据）。 解决连接数过多。HTTP/2对同一域名下所有请求都是基于流,不管访问多少个文件，都只建立一路连接。最大并发提升到了300(Apache)。 不适用于HTTP/2的优化 JS文件合并。上线时把所有多个模块代码压缩合并成一个文件，减少HTTP的请求数。但是其中某个模块改了之后，所有的文件都需要重新下载，不能被缓存。HTTP/2里，模块可以单独压缩上线不影响其他没有修改的模块。 多域名的下载速度当css文件和js文件放到两个域名下面时，可以避免浏览器的6个通道限制(对于同一个协议、域名、端口，浏览器允许同时打开个 TCP 连接，一般上限为 6 个)。 缺点 HTTP/2解决了这些缺点 DNS解析时间变长。 增加服务器压力。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day177-TypeScript基础小记-构造函数]]></title>
    <url>%2F2019%2F07%2F09%2F2019-07-09%2F</url>
    <content type="text"><![CDATA[要点 构造函数。 编译成JavaScript后。 把类当做接口使用。 构造函数 简单的构造函数 class Greeter &#123; greeting: string constructor(message: string) &#123; this.greeting = message &#125; greet() &#123; return 'Hello,' + this.greeting &#125;&#125;let greeter: Greeter // Greeter类的实例的类型是Greetergreeter = new Greeter('TypeScript')console.log(greeter.greet()) 编译成JavaScript let Greeter被赋值为构造函数。 let Greeter = (function () &#123; function Greeter(message) &#123; this.greeting = message &#125; Greeter.prototype.greet = function () &#123; return 'Hello,' + this.greeting &#125; return Greeter&#125;)()let greetergreeter = new Greeter('world')console.log(greeter.greet()) 例子改写 class Greeter &#123; static standardGreeting = 'hello, there' greeting: string greet () &#123; if (this.greeting) &#123; return 'hello,' + this.greeting &#125; else &#123; return Greeter.standardGreeting &#125; &#125;&#125;let greeter1: Greetergreeter1 = new Greeter()console.log(greeter1)// typeof Greeter意思取Greeter类的类型，而不是实例类型。let greeterMaker: typeof Greeter = GreetergreeterMaker.standardGreeting = 'Hey there!'let greeter2: Greeter = new greeterMaker()console.log(greeter2.greet()) 类当做接口使用 类定义会创建两个东西：类的实例累心和一个构造函数（因为类可以创建出类型，所以你能够在允许使用接口的地方使用类）class Point &#123; x: number y: number&#125;interface Point3d extends Point &#123; z: number&#125;let point3d: Point3d = &#123; x: 1, y: 2, z: 3 &#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day176-数组-嵌套数组-nested Array]]></title>
    <url>%2F2019%2F07%2F08%2F2019-07-08%2F</url>
    <content type="text"><![CDATA[要点给出特定结构的数据，转换成特定的数据结构。 deepMerge, groupBy flattenDeep, nested Array(嵌套数组) 源数组-&gt;目标数组 源数据let data = [ &#123; '文风': &#123; '过译': [ &#123; 'errorLevel': '一般般', 'count': 5 &#125; // ... ], '漏译': [ &#123; 'errorLevel': '非常严重', 'count': 2 &#125;, &#123; 'errorLevel': '一般般', 'count': 10 &#125; ], '增译': [ &#123; 'errorLevel': '非常严重', 'count': 22 &#125;, &#123; 'errorLevel': '一般般', 'count': 10 &#125; ] // ... &#125; // ... &#125; // ...] 目标数组let res = [ &#123; name: '一般般', count: 27, '过译': 10, '漏译': 20, '增译': 22 &#125;, &#123; name: '非常严重', count: 24, '漏译': 4, '增译': 44 &#125;, &#123; name: '重大错误', count: 10, '过译': 10 &#125; // ...] 两步 先降维处理成一维数组 根据一维数组相关属性groupBy 降维处理 注意不需要第一层的keys。 _.是loadshjs的方法。 function flatData (data) &#123; // 去掉了术语、文风等 let res = (data || []).map(item =&gt; &#123; let mergedData = _.mergeWith(&#123;&#125;, ...Object.values(item), (obj, src) =&gt; &#123; return (obj || []).concat(src) &#125;) return Object.entries(mergedData).map(([key, value]) =&gt; &#123; // 转为多层嵌套数组 return [...value.map(item =&gt; (&#123;...item, type: key&#125;))] &#125;) &#125;) return _.flattenDeep(res)&#125; 数组分类由嵌套数组得出的结果进行数组归类。function nest (seq, keys) &#123; if (!keys.length) return seq let first = keys[0] let rest = keys.slice(1) return mapValues(groupBy(seq, first), (value) =&gt; &#123; // return &#123; ...nest(value, rest) &#125; if (Array.isArray(nest(value, rest))) &#123; // reduce by prop count return (nest(value, rest) || []).reduce((acc, obj) =&gt; (acc + obj['count']), 0) // return &#123; ...item, item: '122'&#125; &#125; else &#123; return nest(value, rest) &#125; &#125;)&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day175-contenteditable（2）]]></title>
    <url>%2F2019%2F07%2F07%2F2019-07-07%2F</url>
    <content type="text"><![CDATA[要点contenteditable这里是contentedtable的第二种写法。 应用VEdit组件 VEdit vue2 实现 div contenteditable=”true” 类似于 v-model 的效果 参考https://segmentfault.com/a/1190000008261449#articleHeader1&lt;template&gt; &lt;div ref="diveditable" v-html="innerText" :contenteditable="canEdit" @input="changeText" @focus="isLocked = true" @blur="isLocked = false" class="v-edit" &gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'VEdit', props: &#123; value: &#123; type: String, default: '' &#125;, canEdit: &#123; type: Boolean, default: true &#125; &#125;, data () &#123; return &#123; innerText: this.value, isLocked: false &#125; &#125;, watch: &#123; 'value' () &#123; if (!this.isLocked || !this.innerText) &#123; this.innerText = this.value &#125; &#125; &#125;, methods: &#123; changeText () &#123; this.$emit('input', this.$el.innerHTML) &#125; &#125;, created () &#123;&#125;&#125;&lt;/script&gt;&lt;style lang='less' scoped&gt;.v-edit &#123; width: 100%; height: 100%; overflow: auto; word-break: break-all; outline: none; user-select: text; white-space: pre-wrap; text-align: left; &amp;[contenteditable=true]&#123; user-modify: read-write-plaintext-only; &amp;:empty:before &#123; content: attr(placeholder); display: block; color: #ccc; &#125; &#125;&#125;&lt;/style&gt;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day174-contenteditable]]></title>
    <url>%2F2019%2F07%2F06%2F2019-07-06%2F</url>
    <content type="text"><![CDATA[要点contenteditable利用contenteditable来做行内编辑。与利用input的区别是，能够保留内容的样式，而input内输入的是纯文本。这里依靠Vue2做了一个小组件。 应用EditDiv组件 &lt;!-- EditDiv Vue 2 contentEditable with v-model --&gt;&lt;template&gt; &lt;div ref="diveditable" contenteditable v-on="listeners" class="edit-div" &gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'EditDiv', props: &#123; value: &#123; type: String, default: '' &#125; &#125;, data () &#123; return &#123;&#125; &#125;, computed: &#123; listeners () &#123; return &#123; ...this.$listeners, input: this.onInput &#125; &#125; &#125;, mounted () &#123; this.$refs.diveditable.innerText = this.value &#125;, methods: &#123; onInput (e) &#123; this.$emit('input', e.target.innerText) &#125; &#125;, created () &#123;&#125;&#125;&lt;/script&gt;&lt;style lang='less' scoped&gt;.edit-div &#123; width: 100%; height: 100%; overflow: auto; word-break: break-all; outline: none; user-select: text; white-space: pre-wrap; text-align: left; &amp;[contenteditable=true]&#123; user-modify: read-write-plaintext-only; &amp;:empty:before &#123; content: attr(placeholder); display: block; color: #ccc; &#125; &#125;&#125;&lt;/style&gt;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day173-数组-结构转换]]></title>
    <url>%2F2019%2F07%2F05%2F2019-07-05%2F</url>
    <content type="text"><![CDATA[要点给出特定结构的数据，转换成特定的数据结构。 循环 递归 源数组-&gt;目标数组 源数组let data = [ &#123; '文风': &#123; '过译': [ &#123; 'errorLevel': '一般般', 'count': 5 &#125; // ... ], '漏译': [ &#123; 'errorLevel': '非常严重', 'count': 2 &#125;, &#123; 'errorLevel': '一般般', 'count': 10 &#125; ] // ... &#125; // ... &#125;] 目标数组let res = [ &#123; name: '文风', '过译': 5, '漏译': 12, '增译': 3 &#125;, &#123; name: '准确性', '过译': 21, '漏译': 20, '增译': 10 &#125;, &#123; name: '流畅性', '过译': 9, '漏译': 12, '增译': 2 &#125;, &#123; name: '术语', '过译': 34, '漏译': 24, '增译': 34 &#125; // ...] 循环let obj = Object.entries(...data).map(([key, value]) =&gt; &#123; let newVal = Object.entries(value).map(([objkey, objVal]) =&gt; &#123; let objVals = [...objVal].reduce((acc, obj) =&gt; &#123; for (let k in obj) &#123; if (obj.hasOwnProperty(k)) &#123; acc[k] = (acc[k] || 0) + obj[k] &#125; &#125; return acc &#125;, &#123;&#125;)['count'] return &#123;[objkey]: objVals&#125; &#125;) return &#123; name: key, ...Object.assign(...newVal), total: sum &#125;&#125;)// return [].concat(obj)console.log(obj) 递归function flatData(object) &#123; for(let i in object) &#123; if(typeof object[i] == typeof &#123;&#125;)&#123; flatData(object[i]) &#125; console.log(object[i]) if (Array.isArray(object[i])) &#123; let tmp = object[i] object[i] = tmp.reduce((acc, obj) =&gt; &#123; for (let k in obj) &#123; if (obj.hasOwnProperty(k)) &#123; acc[k] = (acc[k] || 0) + obj[k] &#125; &#125; return acc &#125;, &#123;&#125;)['count'] &#125; &#125; // return object&#125;flatData(data)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day172-TypeScript基础小记-抽象类]]></title>
    <url>%2F2019%2F07%2F04%2F2019-07-04%2F</url>
    <content type="text"><![CDATA[要点 abstract关键字。 抽象方法。 abstract关键字 抽象类做其他派生类的基类使用。抽象类一般不会直接被实例化。 抽象类可以包含成员的实现细节。abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法。abstract class Animal &#123; abstract makeSound(): void move(): void &#123; console.log('到处走') &#125;&#125; 抽象方法 抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。然而，抽象方法必须包含abstract关键字并且可以包含访问修饰符。 abstract class Department &#123; constructor(public name: string) &#123;&#125; printName(): void &#123; console.log('Department name:' + this.name) &#125; abstract printMeeting(): void // 必须在派生类中实现&#125;class AccountingDepartment extends Department &#123; constructor() &#123; super('银行') &#125; printMeeting(): void &#123; console.log('银行每周一早上10点开门') &#125; generateReports(): void &#123; console.log('生成银行报告') &#125;&#125;let department: Department // 允许创建一个对抽象类型的引用// department = new Department() // 无法创建抽象类的实例。ts(2511)department = new AccountingDepartment() // 允许对一个抽象子类进行实例化和赋值department.printMeeting()department.printName()department.generateReports() // 类型“Department”上不存在属性“generateReports”。ts(2339)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day171-获取图片原始长宽]]></title>
    <url>%2F2019%2F07%2F03%2F2019-07-03%2F</url>
    <content type="text"><![CDATA[要点 base64图片的长宽。 图片长宽。 “src图片”的长宽。 base64图片function getPngDimensions (base64) &#123; const header = atob(base64.slice(0, 50)).slice(16, 24) const uint8 = Uint8Array.from(header, c =&gt; c.charCodeAt(0)) const dataView = new DataView(uint8.buffer) return &#123; width: dataView.getInt32(0), height: dataView.getInt32(4) &#125;&#125; 图片长宽imageElement.naturalHeightimageElement.naturalWidth “src图片”let img = new Image()img.src = 'http://www.google.com/intl/en_ALL/images/logo.gif'img.onload = function() &#123; console.log(this.width + 'x' + this.height)&#125; 参考https://stackoverflow.com/questions/623172/how-to-get-image-size-height-width-using-javascript]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day170-TypeScript基础小记-参数属性]]></title>
    <url>%2F2019%2F07%2F02%2F2019-07-02%2F</url>
    <content type="text"><![CDATA[要点 存取器。 静态属性。 存取器例子1 把简单的类改写成使用get和set。注意：只带get不带有set的存取器自动被推断为readonly // 随意修改全名class Employee &#123; fullName: string&#125;let employee = new Employee()employee.fullName = '二柱子'if (employee.fullName) &#123; console.log(employee.fullName)&#125;// 加密，不让随意修改全名let passcode = 'secret passcode'class Employee &#123; private _fullName: string get fullName (): string &#123; return this._fullName &#125; set fullName (newName: string) &#123; if (passcode &amp;&amp; passcode == 'secret passcode') &#123; this._fullName = newName &#125; else &#123; console.log('Error: 认证错误！又想把人名字改成二柱子！') &#125; &#125;&#125;let employee = new Employee()employee.fullName = "铁蛋"if (employee.fullName) &#123; console.log(employee.fullName)&#125; 静态属性 这些属性存在类本身上而不是类的实例上。 例子1 使用static定义origin，因为origin是所有网格都会用到的属性。每个实例访问该属性时，都要在origin前面加上类名。如同在实例属性上使用this.前缀来访问属性，本例子用Grid.来访问静态属性。 class Grid &#123; static origin = &#123; x: 0, y: 0 &#125; constructor (public scale: number) &#123;&#125; calculateDistanceFromOrigin (point: &#123; x: number, y: number &#125;) &#123; let xDis = (point.x - Grid.origin.x) let yDis = (point.y - Grid.origin.y) return Math.sqrt(xDis * xDis + yDis * yDis) / this.scale &#125;&#125;let grid1 = new Grid(1.0)let grid2 = new Grid(2.0)console.log(grid1.calculateDistanceFromOrigin(&#123;x: 1, y: 1&#125;))console.log(grid2.calculateDistanceFromOrigin(&#123;x: 2, y: 2&#125;))]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day169-手写debounce]]></title>
    <url>%2F2019%2F07%2F01%2F2019-07-01%2F</url>
    <content type="text"><![CDATA[题目手写防抖函数debounce。防抖和节流的区别：防抖：一定时间内只执行最后一次（非立即执行），如：window触发resize，search搜索联想。节流：一定时间内只执行一次，如：多次连续点击按钮，防抖只执行一次；rAF。 debouncefunction debounce(func, wait, immediate) &#123; let timeout, args, ctx, timestamp, result const later = function () &#123; // 距离上一次触发时间间隔 const last = +new Date() - timestamp // wait: 当前时间间隔；lat：上次被包装函数调用的时间间隔 if (wait &gt; last &amp;&amp; last &gt; 0) &#123; // 继续等待一定时间执行 timeout = setTimeout(later, wait - last) &#125; else &#123; // 超过约定的时间 timeout = null // 前提是没有设置立即执行 if (!immediate) &#123; // 可以立即执行 result = func.apply(ctx, args) // 第一次执行完毕，重置各种条件 if (!timeout) ctx = args = null &#125; &#125; &#125; return function (...args) &#123; ctx = this timestamp = +new Date() const callImmediate = immediate &amp;&amp; !timeout // 非立即执行 if (!timeout) &#123; timeout = setTimeout(later, wait) &#125; // 立即执行 if (callImmediate) &#123; result = func.apply(ctx, args) ctx = args = null &#125; return result &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day168-TypeScript基础小记-private与protected]]></title>
    <url>%2F2019%2F06%2F30%2F2019-06-30%2F</url>
    <content type="text"><![CDATA[要点 private、protected类型的比较。 private、protected修饰符。 protected与类。 类型比较 比较不同的类型时，如果所有成员类型都是兼容的，就认为类型是兼容的。 比较private或protected成员的类型时，只有来自同一处声明时，才认为两个类型是兼容的。 例子1Employee赋值给Animal时，类型不兼容，因为Employee里也有一个私有成员name，但并不是Animal里面定义的那个。class Animal &#123; private name: string constructor(theName: string) &#123; this.name = theName &#125;&#125;class Rhino extends Animal &#123; constructor() &#123; super('犀牛哥已提前就位') &#125;&#125;class Employee &#123; private name: string constructor(theName: string) &#123; this.name = theName &#125;&#125;let animal = new Animal('羊总')let rhino = new Rhino()let employee = new Employee('护林员')animal = rhino// 不能将类型“Employee”分配给类型“Animal”。类型具有私有属性“name”的单独声明。ts(2322)// 注意定义的private name相同animal = employee private、protected修饰符 protected 修饰符与 private 修饰符的行为相似，但有不同，protected 成员在派生类中仍然可以访问。 例子1 不能在Person类外使用name，但是可以通过子类Employee类实例方法访问，因为Employee是由Person派生而来。 class Person &#123; protected name: string constructor(name: string) &#123; this.name = name &#125;&#125;class Employee extends Person &#123; private department: string constructor(name: string, department: string) &#123; super(name) this.department = department &#125; public getElevatorPitch () &#123; return `你好，老弟。我叫 $&#123;this.name&#125; 在附近 $&#123;this.department&#125; 工作` &#125;&#125;let howard = new Employee('小刘', '小卖部')console.log(howard.getElevatorPitch())// 属性“name”受保护，只能在类“Person”及其子类中访问。ts(2445)console.log(howard.name) protected与类构造函数也可以被标记成protected。意味着，这个类不能在包含它的类外被实例化，但是能被继承class Person &#123; protected name: string protected constructor(theName: string) &#123; this.name = theName &#125;&#125;class Employee extends Person &#123; private department: string constructor(name: string, department: string) &#123; super(name) this.department = department &#125; public getElevatorPitch () &#123; return `你好，老哥。我叫$&#123;this.name&#125;，我家搁附近$&#123;this.department&#125;。` &#125;&#125;let howard = new Employee('二柱子', '洞拐八拐银行附近')// 类“Person”的构造函数是受保护的，仅可在类声明中访问。ts(2674)let john = new Person('铁蛋')]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day167-TypeScript基础小记-类（2）]]></title>
    <url>%2F2019%2F06%2F29%2F2019-06-29%2F</url>
    <content type="text"><![CDATA[要点 类的例子 继承 公共、私有与受保护的修饰符 类的例子class Greeter &#123; greeting: string constructor(message: string) &#123; this.greeting = message &#125; greet () &#123; return 'hello' + this.greeting &#125;&#125;let greeter = new Greeter('world')console.log(greeter) 继承-例子1 例子1： 类（Dog）从基类（Animal)中继承了属性和方法。Dog是一个派生类,它派生自Animal`基类`。 通过extends关键字，派生类通常被称作子类，基类通常被称作超类。 class Animal &#123; move(distanceInMeters: number = 0) &#123; console.log(`目标被动物吓退了 $&#123;distanceInMeters&#125;m`) &#125;&#125;class Dog extends Animal &#123; bark () &#123; console.log('汪汪汪') &#125;&#125;const dog = new Dog() // 创建一个Dog能够`bark()`和`move()`的实例dog.bark()dog.move(10)dog.bark() 继承-例子2 和例子1有点不同，这个派生类（子类）必须调用super()，它会执行基类（超类）的构造函数。 且，在构造函数里访问this的属性之前，一定要调用super()（这个是TypeScript强制执行的一条规则）。 例子2，演示了如何在子类里可以重写父类方法。Snake类和Horse类都创建了move方法，它们重写了从Animal继承来的move方法，使得move方法根据不同的类而具有不同的功能。 例子2中tom: Animal，tom被声明为Animal类型，但因为它的值是Horse类型（等于号右边部分），调用tom.move(90)时，它会调用Horse里重写的方法。 class Animal &#123; name: string constructor(theName: string) &#123; this.name = theName &#125; move (distanceInMeters: number = 0) &#123; console.log(`$&#123;this.name&#125; 跑了 $&#123;distanceInMeters&#125;米`) &#125;&#125;class Snake extends Animal &#123; constructor(name: string) &#123; super(name) &#125; move(distanceInMeters = 5) &#123; console.log('蛇出溜滑，遛了遛了..') super.move(distanceInMeters) &#125;&#125;class Horse extends Animal &#123; constructor(name: string) &#123; super(name) &#125; move(distanceInMeters = 45) &#123; console.log('我老马先跑一步...') super.move(distanceInMeters) &#125;&#125;let sam = new Snake('哟，这不是子类蛇嘛')let tom: Animal = new Horse('马哥，马哥，子类马，雷吼')sam.move()tom.move(90) 公共、私有与受保护的修饰符public、private publicclass Animal &#123; public name: string public constructor(theName: string) &#123; this.name = theName &#125; public move (distanceInMeters: number) &#123; console.log(`$&#123;this.name&#125; 移动 $&#123;distanceInMeters&#125;米。`) &#125;&#125; privateclass Animal &#123; private name: string constructor(theName: string) &#123; this.name = theName &#125;&#125;// 属性“name”为私有属性，只能在类“Animal”中访问。ts(2341)new Animal('Cat').name]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day166-TypeScript基础小记-继承(接口)]]></title>
    <url>%2F2019%2F06%2F28%2F2019-06-28%2F</url>
    <content type="text"><![CDATA[要点 继承接口。 一个接口继承多个接口，创建出多个接口的合成接口。 接口继承类。 继承接口interface Shape &#123; color: string&#125;interface Square extends Shape &#123; sideLength: number&#125;let square = &lt;Square&gt;&#123;&#125;square.color = 'red'square.sideLength = 6 继承多接口|合成接口 一个接口继承多个接口，创建出多个接口的合成接口。interface Shape &#123; color: string&#125;interface PenStroke &#123; penWidth: number&#125;interface Square extends Shape, PenStroke &#123; sideLength: number&#125;let square = &lt;Square&gt;&#123;&#125;square.color = 'red'square.sideLength = 9square.penWidth = 5.0 对象“多类型” 一个对象同时具有多种类型 interface Counter &#123; (start: number): string interval: number reset(): void&#125;function getCounter(): Counter &#123; let counter = &lt;Counter&gt;function (start: number): string &#123; return '' &#125; counter.interval = 123 counter.reset = function () &#123;&#125; return counter&#125;let c = getCounter()c(10)c.reset()c.interval = 5.0 接口继承类 接口继承一个类类型时，它会继承类的成员但不包括其实现。（大概就是：接口能声明所有类中存在的成员，但是不提供具体实现）SelectableControl包含了Control的所有成员,包括私有成员state。即：当接口继承了一个拥有私有成员或受保护成员的类时，这个接口类型只能是被这个类或其子类所实现。 SelectableControl包含了Control的所有成员,包括私有成员state因为state是私有成员，只能Control的子类才能实现SelectablControl接口。 class Control &#123; private state: any&#125;interface SelectableControl extends Control &#123; select(): void&#125;class Button extends Control implements SelectableControl &#123; select() &#123; &#125;&#125;class TextBox extends Control &#123; select() &#123; &#125;&#125;class Image implements SelectableControl &#123; select() &#123; &#125;&#125;class Location &#123;&#125; 参考 https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Interfaces.html]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day165-TypeScript基础小记-类]]></title>
    <url>%2F2019%2F06%2F27%2F2019-06-27%2F</url>
    <content type="text"><![CDATA[要点 类类型 类静态部分和实例部分的区别 直接操作类的静态部分 使用类表达式直接操作类的静态部分 类类型 强制一个类去符合实现接口interface ClockInterface &#123; currentTime: Date&#125;class Clock implements ClockInterface &#123; currentTime: Date = new Date() constructor(h: number, m: number) &#123;&#125;&#125;interface ClockInterface &#123; currentTime: Date setTime(d: Date): void&#125; 接口描述类的公共部分interface ClockInterface &#123; currentTime: Date // 在接口中描述一个方法，在类里实现 setTime(d: Date): void&#125;class Clock implements ClockInterface &#123; currentTime: Date = new Date() setTime(d: Date) &#123; this.currentTime = d &#125; constructor(h: number, m: number) &#123;&#125;&#125; 类静态部分和实例部分的区别interface ClockConstructor &#123; // h: hour, m: minute /** 构造器 */ new (h: number, m: number)&#125;// 类实现接口时，只对实例部分进行类型检查。而constructor存在于类的静态部分class Clock implements ClockConstructor &#123; currentTime: Date // 缺少构造函数实现。ts(2390) // constructor(h: number, m: number)&#125; 直接操作类的静态部分 定义两个接口，分别为构造函数和实例方法所用 interface ClockConstructor &#123; new (h: number, m: number): ClockInterface&#125;interface ClockInterface &#123; tick(): void&#125;/** ClockConstructor为构造函数所用 */function createClock (ctor: ClockConstructor, h: number, m: number): ClockInterface &#123; return new ctor(h, m)&#125;/** ClockInterface为实例方法所用 */class DigitalClock implements ClockInterface &#123; constructor(h: number, m: number) &#123;&#125; tick () &#123; console.log('beep') &#125;&#125;class AnalogClock implements ClockInterface &#123; constructor(h: number, m: number) &#123;&#125; tick () &#123; console.log('tick tock') &#125;&#125;let digital = createClock(DigitalClock, 12, 17)// 检查AnalogClock是否符合构造函数签名let analog = createClock(AnalogClock, 7, 32) 使用类表达式直接操作类的静态部分interface ClockConstructor &#123; new (h: number, m: number)&#125;interface ClockInterface &#123; tick()&#125;const Clock: ClockConstructor = class Clock implements ClockInterface &#123; constructor(h: number, m: number) &#123;&#125; tick () &#123; console.log('beep') &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day164-TypeScript基础小记-interface]]></title>
    <url>%2F2019%2F06%2F26%2F2019-06-26%2F</url>
    <content type="text"><![CDATA[要点接口的作用： 多个属性处理类型判断 接口描述函数类型 多个属性如何处理类型判断？function printLabel (labeledObj: &#123; label: string &#125;) &#123; console.log(labeledObj.label)&#125;let myObj = &#123; size: 10, label: 'Size 10 Object' &#125;printLabel(myObj)/** * 以上是对象只有一个label属性，多个属性如何处理？ */interface LabeledValue &#123; label: string&#125;function printLabel(labeledObj: LabeledValue) &#123; console.log(labeledObj.label)&#125;let myObj = &#123; size: 10, label: 'Size 10 Object' &#125;printLabel(myObj) 可选属性 interface里的值不是所有的都是必需的interface SquareConfig &#123; color?: string width?: number&#125;function createSquare (config: SquareConfig): &#123; color: string, area: number &#125; &#123; let newSquare = &#123; color: 'white', area: 100 &#125; if (config.color) &#123; newSquare.color = config.color &#125; if (config.width) &#123; newSquare.area = config.width * config.width &#125; return newSquare&#125;let mySquare = createSquare(&#123;color: 'black'&#125;)console.log(mySquare) 接口描述函数类型interface SearchFunc &#123; (source: string, subString: string): boolean&#125;let mySearch: SearchFuncmySearch = function (source: string, subString: string) &#123; let result = source.search(subString) return result &gt; 1&#125; 可索引的类型 ts支持两种索引签名：字符串和数字数字索引的返回值必须是字符串索引返回值类型的子类型因为用number来索引时，JS会将它转换成string然后再去索引对象。即：用100去索引等同于用“100”去索引。问题：dictionary模式 interface StringArray &#123; [index: number]: string&#125;let myArray: StringArraymyArray = ['liu', 'mon']// 当用number去索引StringArray时会得到string类型的返回值let myStr: string = myArray[0]console.log(myArray)class Animal &#123; name: string&#125;class Dog extends Animal &#123; // 养殖 breed: string&#125;// 错误：使用数值型的字符串interface NotOkay &#123; // 数字索引类型“Animal”不能赋给字符串索引类型“Dog”。ts(2413) // [x: number]: Animal [x: string]: Dog&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day163-正则点滴]]></title>
    <url>%2F2019%2F06%2F25%2F2019-06-25%2F</url>
    <content type="text"><![CDATA[正则 判断是否仅有数字或者”.”、”,”。 找出并“格式化”字符串中的所有数字。 解答 判断是否仅有数字或者”.”、”,”。 /^[0-9.,]+$/// 配合test用比较好。如：reg.test(str) 找出并“格式化”字符串中的所有数字。 (str.match(/\d+/g) || []).map(Number)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day162-键值对，以value为键的结果对象]]></title>
    <url>%2F2019%2F06%2F24%2F2019-06-24%2F</url>
    <content type="text"><![CDATA[题目const data = [ &#123; 'id': 1, name: 'a', 'code': 11 &#125;, &#123; 'id': 2, name: 'b', 'code': 22 &#125;, &#123; 'id': 3, name: 'c', 'code': 33 &#125;,] 以code值为key的结果对象 分析主要是[]的用法，灵活的很呐！ 代码let getKey = (data, key) =&gt; &#123; return data.map(item =&gt; &#123; return &#123; [item[key]]: item &#125; &#125;)&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day161-统计数组中所有对象相同属性值的总和，（假设值为整数）]]></title>
    <url>%2F2019%2F06%2F23%2F2019-06-23%2F</url>
    <content type="text"><![CDATA[题目输入：[&#123; x: 1, y: '1.pdf', z: 2 &#125;,&#123; x: 2, y: '2.pdf', z: 3 &#125;,&#123; x: 3, y: '3.pdf', z: 4 &#125;] 输出：&#123; x: 6, y: '01.pdf2.pdf3.pdf', z: 9 &#125; 代码function sumObjectsSameKey(...objs) &#123; return objs.reduce(function (acc, obj) &#123; for (let k in obj) &#123; if (obj.hasOwnProperty(k)) &#123; acc[k] = (acc[k] || 0) + obj[k] &#125; &#125; return acc &#125;, &#123;&#125;)&#125;console.log(sumObjectsSameKey(...arr)) 参考https://stackoverflow.com/questions/42488048/javascript-sum-of-two-object-with-same-properties]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day160-vuejs-CreateElement-children 的规范化]]></title>
    <url>%2F2019%2F06%2F22%2F2019-06-22%2F</url>
    <content type="text"><![CDATA[children 的规范化_createElement 接收的第 4 个参数 children 是任意类型的,所以要规范化。代码目录：&lt;src/core/vdom/helpers/normalzie-children.js&gt; 代码// The template compiler attempts to minimize the need for normalization by// statically analyzing the template at compile time.//// For plain HTML markup, normalization can be completely skipped because the// generated render function is guaranteed to return Array&lt;VNode&gt;. There are// two cases where extra normalization is needed:/* 注：functional component 函数式组件返回的是一个数组而不是一个根节点 *//* 场景1 */// 1. When the children contains components - because a functional component// may return an Array instead of a single root. In this case, just a simple// normalization is needed - if any child is an Array, we flatten the whole// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep// because functional components already normalize their own children./*该方法调用场景是 render 函数是编译生成的*/export function simpleNormalizeChildren (children: any) &#123; for (let i = 0; i &lt; children.length; i++) &#123; if (Array.isArray(children[i])) &#123; /* 注：flatten 整个 Array&lt;VNode&gt; */ return Array.prototype.concat.apply([], children) &#125; &#125; return children&#125;/* 场景2 */// 2. When the children contains constructs that always generated nested Arrays（注：嵌套数组）,// e.g. &lt;template&gt;, &lt;slot&gt;, v-for, or when the children is provided by user// with hand-written render functions / JSX. In such cases a full normalization// is needed to cater to all possible types of children values.export function normalizeChildren (children: any): ?Array&lt;VNode&gt; &#123; return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day159-__.range]]></title>
    <url>%2F2019%2F06%2F21%2F2019-06-21%2F</url>
    <content type="text"><![CDATA[求区间内所有连续数给出整数区间和步长，求区间内连续的数字，要求正序或倒序。 例如： 输入：[1, 5]，步长为1 输出：1，2，3，4，5 代码/** * https://github.com/lodash/lodash/blob/master/.internal/baseRange.js * @param &#123;number&#125; start 开始值 * @param &#123;number&#125; end 结束值 * @param &#123;number&#125; step 步长 */function baseRange(start, end, step, fromRight) &#123; let index = -1 let length = Math.max(Math.ceil((end - start) / (step || 1)), 0) const result = new Array(length) while (length--) &#123; // 从大到小，或者是从小到大 result[fromRight ? length : ++index] = start start += step &#125; return result&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day158-Virtual DOM 小结]]></title>
    <url>%2F2019%2F06%2F20%2F2019-06-20%2F</url>
    <content type="text"><![CDATA[createElement的定义createElement 方法创建 VNode。&lt;src/core/vdom/create-elemenet.js&gt;// wrapper function for providing a more flexible interface// without getting yelled at by flowexport function createElement ( context: Component, tag: any, data: any, children: any, normalizationType: any, alwaysNormalize: boolean): VNode | Array&lt;VNode&gt; &#123; if (Array.isArray(data) || isPrimitive(data)) &#123; normalizationType = children children = data data = undefined &#125; if (isTrue(alwaysNormalize)) &#123; normalizationType = ALWAYS_NORMALIZE &#125; // 对_createElement的封装，配置参数更加灵活 return _createElement(context, tag, data, children, normalizationType)&#125; _createElementexport function _createElement ( context: Component, // VNode 的上下文 tag?: string | Class&lt;Component&gt; | Function | Object, data?: VNodeData, // &lt;flow&gt;vnode.js&gt;目录中 children?: any, // VNode 的子节点 normalizationType?: number): VNode | Array&lt;VNode&gt; &#123; if (isDef(data) &amp;&amp; isDef((data: any).__ob__)) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Avoid using observed data object as vnode data: $&#123;JSON.stringify(data)&#125;\n` + 'Always create fresh vnode data objects in each render!', context ) return createEmptyVNode() &#125; // object syntax in v-bind if (isDef(data) &amp;&amp; isDef(data.is)) &#123; tag = data.is &#125; if (!tag) &#123; // in case of component :is set to falsy value return createEmptyVNode() &#125; // warn against non-primitive key if (process.env.NODE_ENV !== 'production' &amp;&amp; isDef(data) &amp;&amp; isDef(data.key) &amp;&amp; !isPrimitive(data.key) ) &#123; if (!__WEEX__ || !('@binding' in data.key)) &#123; warn( 'Avoid using non-primitive value as key, ' + 'use string/number value instead.', context ) &#125; &#125; // support single function children as default scoped slot if (Array.isArray(children) &amp;&amp; typeof children[0] === 'function' ) &#123; data = data || &#123;&#125; data.scopedSlots = &#123; default: children[0] &#125; children.length = 0 &#125; if (normalizationType === ALWAYS_NORMALIZE) &#123; children = normalizeChildren(children) &#125; else if (normalizationType === SIMPLE_NORMALIZE) &#123; children = simpleNormalizeChildren(children) &#125; let vnode, ns if (typeof tag === 'string') &#123; let Ctor ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag) if (config.isReservedTag(tag)) &#123; // platform built-in elements vnode = new VNode( config.parsePlatformTagName(tag), data, children, undefined, undefined, context ) &#125; else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) &#123; // component vnode = createComponent(Ctor, data, context, children, tag) &#125; else &#123; // unknown or unlisted namespaced elements // check at runtime because it may get assigned a namespace when its // parent normalizes children vnode = new VNode( tag, data, children, undefined, undefined, context ) &#125; &#125; else &#123; // direct component options / constructor vnode = createComponent(tag, data, context, children) &#125; if (Array.isArray(vnode)) &#123; return vnode &#125; else if (isDef(vnode)) &#123; if (isDef(ns)) applyNS(vnode, ns) if (isDef(data)) registerDeepBindings(data) return vnode &#125; else &#123; return createEmptyVNode() &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day157-Virtual DOM 小结]]></title>
    <url>%2F2019%2F06%2F19%2F2019-06-19%2F</url>
    <content type="text"><![CDATA[数据结构的定义Virtual DOM 就是用原生的 JS 对象去描述 DOM 节点。 vuejs借助了snabbdom这个库。 Virtual DOM用 VNode 这么一个 Class 去描述。 VNode 也是对真实 DOM 的一种抽象描述， VNode的核心定义是几个关键属性，标签名、数据、子节点、键值等。 其它属性都是都是用来扩展 VNode 的灵活性以及实现一些特殊 feature。 VNode是映射到真实 DOM 的渲染，不需要操作DOM的方法。 Vue.js 利用 createElement 方法创建 VNode，它定义在 src/core/vdom/create-elemenet.js 映射DOM映射到真实的 DOM 实际上要经历 VNode 的 create、diff、patch等过程]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day156-LeetCode 278. First Bad Version]]></title>
    <url>%2F2019%2F06%2F18%2F2019-06-18%2F</url>
    <content type="text"><![CDATA[题目You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad.You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. 分析直接用二分法搜索example：[1,2,3,4,5] --&gt; [1,1,1,0,0]max = 5, min = 1 -&gt; mid = 3 isBadVersion(3) = truemin = mid+1 = 4 -&gt; mid = 4 isBadVersion(4) = falsemax = mid = 4 -&gt; max &gt; min == false, end loop 题解/** * Definition for isBadVersion() * * @param &#123;integer&#125; version number * @return &#123;boolean&#125; whether the version is bad * isBadVersion = function(version) &#123; * ... * &#125;; *//** * @param &#123;function&#125; isBadVersion() * @return &#123;function&#125; */var solution = function(isBadVersion) &#123; /** * @param &#123;integer&#125; n Total versions * @return &#123;integer&#125; The first bad version */ return function(n) &#123; let min = 0 let max = n let mid // 二分法搜索 while (max &gt; min)&#123; mid = min + parseInt((max+min) / 2) if (isBadVersion(mid)) &#123; max = mid &#125; else &#123; min = mid + 1 &#125; &#125; return max &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day155-LeetCode 191. Number of 1 Bits]]></title>
    <url>%2F2019%2F06%2F17%2F2019-06-17%2F</url>
    <content type="text"><![CDATA[题目假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1:输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4 示例 2:输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 分析 二分法，但要注意给出的nums 不是完全的升序或降序。 题解class Solution &#123; public int search(int[] nums, int target) &#123; return search(nums, 0, nums.length - 1, target); &#125; private int search(int[] nums, int low, int high, int target) &#123; if (low &gt; high) return -1; int mid = (low + high) / 2; if (nums[mid] == target) return mid; if (nums[mid] &lt; nums[high]) &#123; if (nums[mid] &lt; target &amp;&amp; target &lt;= nums[high]) return search(nums, mid + 1, high, target); else return search(nums, low, mid - 1, target); &#125; else &#123; if (nums[low] &lt;= target &amp;&amp; target &lt; nums[mid]) return search(nums, low, mid - 1, target); else return search(nums, mid + 1, high, target); &#125; &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day154-LeetCode 191. Number of 1 Bits]]></title>
    <url>%2F2019%2F06%2F16%2F2019-06-16%2F</url>
    <content type="text"><![CDATA[题目Write a function that takes an unsigned integer and returns the number of ’1’ bits it has (also known as the Hamming weight). For example, the 32-bit integer ’11’ has binary representation 00000000000000000000000000001011, so the function should return 3. 分析 先把数字转二进制，然后再遍历1的个数 题解function hammingWeight () &#123; let secondS = n.toString(2).split(''); let count = 0 for (let i = 0; i &lt; secondS.length; i++) &#123; if (secondS % 2 === 1) &#123; count++ &#125; &#125; return count&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day153-LeetCode 198. House Robber]]></title>
    <url>%2F2019%2F06%2F15%2F2019-06-15%2F</url>
    <content type="text"><![CDATA[题目You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.（大意是：求最大不连续的值） 分析 假设为[m0,m1,m2,m3,….]，求最大的数 如果房子只有[m0], max = mo [m0,m1], max = Max(m0,m1) [m0,m1,m2], max = Max(m0+m2,m1) 题解function robber (nums) &#123; let maxSum = new Array() if(nums.length === 0) return 0 if(nums.length === 1) return nums[0] if(nums.length === 2) return Math.max(nums[1],nums[0]) maxSum.push(nums[0]) maxSum.push(Math.max(nums[0],nums[1])) for(let i = 2; i &lt; nums.length; i++) &#123; // Max(m0+m2,m1),计算公式 maxSum[i] = Math.max(nums[i] + maxSum[i-2], maxSum[i-1]) &#125; return maxSum.pop()&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day152-找出有序数组中连续的数]]></title>
    <url>%2F2019%2F06%2F14%2F2019-06-14%2F</url>
    <content type="text"><![CDATA[题目找出有序数组中连续的数，并按一定规则排列。（这个题来自今天的需求，要求选中一些指定的图片。且可以利用范围来选择。）input：[1, 3, 4, 10, 25, 26, 30, 31, 32, 33]output：1,3-4,10,25-26,30-33 分析每一个数，找出每个数和该数的下一个数加一是不是相等。利用“游标”的方法，挨个查找。 题解function compressArr (sortedArr) &#123; // 必须是有序数组 let start = sortedArr[0] let stop = start let arrLength = sortedArr.length // 注意这里sortedArr，如果是定义变量arr，则会变量提升 let resultStr = '' for (let i = 1; i &lt; arrLength; i++) &#123; // 等于前一个连续的值+1，即：连续值 if (sortedArr[i] === stop + 1) &#123; // 指向下一个元素 stop = sortedArr[i] &#125; else &#123; if (start === stop) &#123; resultStr += start + ',' &#125; else &#123; resultStr += start + '-' + stop + ',' &#125; // 重新初始化start和stop指向 start = sortedArr[i] stop = start &#125; &#125; // 处理最后的数 if (start === stop) &#123; resultStr += start &#125; else &#123; resultStr += start + '-' + stop &#125; return resultStr&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day151-LeetCode 141. Linked List Cycle]]></title>
    <url>%2F2019%2F06%2F13%2F2019-06-13%2F</url>
    <content type="text"><![CDATA[题目Given a linked list, determine if it has a cycle in it.Follow up: Can you solve it without using extra space? 分析求链表中是否有个循环 题解/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;boolean&#125; */function hasCycle (head) &#123; if (head === null || head.next === null) &#123; return false &#125; let node = head while (node !== null) &#123; if (node.flag) &#123; return true &#125; // 标记节点每一个跑过的节点 node.flag = true // 跑到下一个节点 node = node.next &#125; return false&#125; 快慢链表 两者步长不一样 public boolean hasCycle(ListNode head) &#123; ListNode slow = head, fast = head; while (fast != null &amp;&amp; fast.next != null) &#123; slow = slow.next; fast = fast.next.next; if (slow == fast) return true; &#125; return false;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day150-LeetCode 83. Remove Duplicates from Sorted List]]></title>
    <url>%2F2019%2F06%2F12%2F2019-06-12%2F</url>
    <content type="text"><![CDATA[题目Given a sorted linked list, delete all duplicates such that each element appear only once.For example,Given 1-&gt;1-&gt;2, return 1-&gt;2.Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3. 分析题目意思是移除一个有序单链表中重复的节点，根据单链表的特点next指针，可以判断相邻连续的节点是否相等。 题解/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */function deleteDuplicates(head) &#123; if (head === null || head.next === null) return let cur = head while(cur.next !== null) &#123; // 相邻连续节点是否相等 if (cur.val === cur.next.val) &#123; cur.next = cur.next.next &#125; else &#123; cur = cur.next &#125; &#125; return head&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day149-LeetCode 237. Delete Node in a Linked List]]></title>
    <url>%2F2019%2F06%2F11%2F2019-06-11%2F</url>
    <content type="text"><![CDATA[题目Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function. 分析将指定单链表中的next指针指向下一个节点value就行 题解/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; node * @return &#123;void&#125; Do not return anything, modify node in-place instead. */var deleteNode = function(node) &#123; node.val = node.next.val node.next = node.next.next&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day148-LeetCode 257. Binary Tree Paths]]></title>
    <url>%2F2019%2F06%2F10%2F2019-06-10%2F</url>
    <content type="text"><![CDATA[题目Given a binary tree, return all root-to-leaf paths.For example, given the following binary tree: 1 / \2 3 \ 5 All root-to-leaf paths are: [“1-&gt;2-&gt;5”, “1-&gt;3”] 分析和找深度的二叉树那个类似，这里是把找到的路径记录下来从root节点开始走，一直到最后的节点没有左右节点，就是一条路径 题解function findTreePath (nodes) &#123; if (!nodes) return // 存储记录的路径 let treePathList = [] findPath(root, '') return treePathList function findPath (node, str) &#123; if (node.left === null &amp;&amp; node.right === null) &#123; treePathList.push(str, node.val) &#125; else &#123; if (node.left !== null) &#123; // 累加路径 findPath(node.left, str + node.val + '-&gt;') &#125; if (node.right !== null) &#123; findPath(node.right, str + node.val + '-&gt;') &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day147-LeetCode 349. Intersection of Two Arrays]]></title>
    <url>%2F2019%2F06%2F09%2F2019-06-09%2F</url>
    <content type="text"><![CDATA[题目Given two arrays, write a function to compute their intersection. Example: Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2]. Note: Each element in the result must be unique. The result can be in any order. 分析选较短的数组去和长数组比较；短数组值依次遍历长数组；找短数组中有相应的值； 题解function intersection (arr1, arr2) &#123; let result = [] let longArr let shortArr if (arr1.length &gt; arr2.length) &#123; longArr = arr1 shortArr = arr2 &#125; else &#123; shortArr = arr1 longArr = arr2 &#125; for (let i = 0; i &lt; shortArr.length; i++) &#123; let value = shortArr[i] // 如果longArr中有shortArr的值，而且在交集数组中没有，则为新交集 if(longArr.indexOf(value) &gt;= 0 &amp;&amp; result.indexOf(value) === -1) &#123; result.push(value) &#125; &#125; return result&#125;// 其实es6可以用很快的方法解决let intersection = arr1.filter(x =&gt; new Set(arr2).has(x))]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day146-LeetCode 283. Move Zeroes]]></title>
    <url>%2F2019%2F06%2F08%2F2019-06-08%2F</url>
    <content type="text"><![CDATA[题目Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements. For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0]. Note: You must do this in-place without making a copy of the array.Minimize the total number of operations. 分析注意：只能是针对当前数组操作，不能是新增数组将数组中遍历的非零元素依次递增标记，以0为初始值，最后将标记的值作为数组元素下标。递增次数为非零元素个数，遍历完成之后，非零元素补零。 题解function moveZeros (arr) &#123; let index = 0 // 标记所有非零元素 for (let i = 0; i &lt; arr.length; i++) &#123; // n为非零元素 let n = arr[i] if (n !== 0) &#123; arr[index++] = n &#125; &#125; // 非零元素之外的元素补零 for (index; index &lt; arr.length; index++) &#123; arr[index] = 0 &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day145-LeetCode 121. Best Time to Buy and Sell Stock]]></title>
    <url>%2F2019%2F06%2F06%2F2019-06-07%2F</url>
    <content type="text"><![CDATA[题目Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1: Input: [7, 1, 5, 3, 6, 4] Output: 5 max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) Example 2: Input: [7, 6, 4, 3, 1] Output: 0 In this case, no transaction is done, i.e. max profit = 0. 分析数组中的元素，从index 0 到最后一位，都表示每天的股价变化。求给出的数组中，利益最大的一天。即，从后往前相减，整数最大的值 题解function maxProfit (prices) &#123; // 表示最低的股价，MAX_表示无限大 let min = Number.MAX_SAFE_INTEGER let maxProfit = 0 for (let i = 0; i &lt; prices.length; i++) &#123; // 冒泡找出最小值 if (prices[i] &lt; min) &#123; min = prices[i] &#125; // 当前可获利的值 let calProfit = prices[i] - min if(calProfit &gt; maxProfit) &#123; maxProfit = calProfit &#125; &#125; return maxProfit&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day144-LeetCode 112. Path Sum]]></title>
    <url>%2F2019%2F06%2F06%2F2019-06-06%2F</url>
    <content type="text"><![CDATA[题目Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.For example: Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ \7 2 1 return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. 分析leetcode 104的变形。用递归来计算每条路径的总和。求根节点到子树的每条可能路径的和，并检测是否和给出的随机数相等。 从父节点出发，如果父节点加左节点不等于给出的随机数，则回退父节点加右节点，如果不相等且子节点有左右子树则递归上述过程。直到找到和随机数相等的值返回true,否则返回false 题解function hasPathEqualSum (root, sum) &#123; if (root === null) return let list = [] // 计算总和 sumR2L(root, 0) return sumR2L(root, 0) function sumR2L(root, s) &#123; if (root.left === null &amp;&amp; root.right === null) &#123; // 到底的时候，判断总和是否是与sum相同 list.push(s) s += root.val return s === sum &#125; // 右边到底 if (root.left !== null &amp;&amp; root.right === null) &#123; return sumR2L(root.left, s + root.val) &#125; // 左边到底 if (root.left === null &amp;&amp; root.right !== null) &#123; return sumR2L(root.right, s + root.val) &#125; // 两边的树没有到底 return sumR2L(root.left, s + root.val) || sumR2L(root.right, s + root.val) &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day143-LeetCode 70. Climbing Stairs]]></title>
    <url>%2F2019%2F06%2F04%2F2019-06-04%2F</url>
    <content type="text"><![CDATA[题目You are climbing a stair case. It takes n steps to reach to the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? 分析这种从无穷之中找规律的题目，难免会想到动态规划，所以可以先分情况来~ n为阶梯数，p表示方法种类n = 1; p = 1n = 2; p = 1+1n = 3; p = 1+2n = 4; p = 3+2规律，斐波那契数列f(n) = f(n-1) + f(n-2) 题解function climbStairs (n) &#123; if (n &lt;= 1) return 1 let prev = 1 let cur = 1 // f(n) = f(n -1) + f(n -2) for (let i = 2; i &lt;= n; i++) &#123; let temp = cur cur = cur + prev prev = temp &#125; return cur&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day142-LeetCode 171. Excel Sheet Column Number]]></title>
    <url>%2F2019%2F06%2F03%2F2019-06-03%2F</url>
    <content type="text"><![CDATA[题目Related to question Excel Sheet Column TitleGiven a column title as appear in an Excel sheet, return its corresponding column number. For example:A -&gt; 1B -&gt; 2C -&gt; 3…Z -&gt; 26AA -&gt; 27AB -&gt; 28 分析总共26个字母，所以这个也可以算是26进制。 题解function titleToNumber (s) &#123; let sum = 0 let exp = 0 for(let i = s.length -1; i &gt;= 0; i--) &#123; // 转成数字 let v = s.charCodeAt(i) - 64 // 毎多一个代表26的n次方 v = v * Math.pow(26,exp++) sum += v &#125; return sum &#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day141-LeetCode 110. Balanced Binary Tree]]></title>
    <url>%2F2019%2F06%2F02%2F2019-06-02%2F</url>
    <content type="text"><![CDATA[题目Given a binary tree, determine if it is height-balanced.For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1. 分析求左右子树的最大深度即：左右子树的高度差为0 题解function isBalanceTree (root) &#123; if (root === null || (root.left === null &amp;&amp; root.right === null)) return true // 分别找出左右子树深度 let deepLeft = findDeepth (root.left) let deepRight = findDeepth (root.right) // 是否是平衡树 let isBalance = Math.abs(deepLeft - deepRight) &lt; 1 return isBalance &amp;&amp; isBalanceTree(root.left) &amp;&amp; isBalanceTree(root.right)&#125;function findDeepth (root) &#123; if (root === null) return 0 let deepLeftDeepth = findDeepth(root.left) + 1 let deepRightDeepth = findDeepth(root.right) + 1 return deepLeftDeepth &gt; deepRightDeepth ? deepLeftDeepth : deepRightDeepth&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day140-LeetCode 206. Reverse Linked List]]></title>
    <url>%2F2019%2F06%2F01%2F2019-06-01%2F</url>
    <content type="text"><![CDATA[题目Reverse a singly linked list.{ val:1, next: {val:2, next:null} } }{ val:2, next: {val:1, next:null} } } 分析链表反转 题解function reverseList (head) &#123; if (!head) &#123; return null &#125; if (!head.next) &#123; return head &#125; let prev = head let cur = head.next prev.next = null while (cur !== null) &#123; let temp = cur // 当前node指向下一个，不然会被后面操作影响 cur = cur.next // 只需要当前node的值，不需要他的next，temp.next = null // 之前的linked list加到当前node后面， temp.next = prev temp.next = prev prev = temp &#125; return prev&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day139-LeetCode 101. Symmetric Tree]]></title>
    <url>%2F2019%2F05%2F31%2F2019-05-31%2F</url>
    <content type="text"><![CDATA[题目Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: But the following [1,2,2,null,3,null,3] is not 1 / \ 2 2 / \ / \3 4 4 3把左子树反转就是右子树 分析这题是反转二叉树和比较二叉树相同的结合 先反转二叉树 比较反转后的二叉树是否相等 题解function isSymmetricTree (root) &#123; if (root === null || root.right === null || root.left === null) &#123; return true &#125; // 反转 root.left = revertTree(root.right) return isSameTree(root.left, root.right)&#125;function revertTree(node) &#123; if(node == null || node.left == null &amp;&amp; node.right == null) &#123; return node &#125; let temp = revertTree(node.left) node.left = revertTree(node.right) node.right = temp return node&#125;function isSameTree (leftNode, rightNode) &#123; // 空节点，递归结束 if (leftNode === null || rightNode === null) &#123; return true &#125; // 左右子树有一个为空 if (leftNode === null &amp;&amp; rightNode !== null || leftNode !== null &amp;&amp; rightNode === null) &#123; return false &#125; // 判断非空节点是否相等 if (leftNode !== rightNode) &#123; return false &#125; // 递归 return isSameTree(leftNode.right, rightNode.right) &amp;&amp; isSameTree(leftNode.left, rightNode.left)&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day138-LeetCode 235. Lowest Common Ancestor of a Binary Search]]></title>
    <url>%2F2019%2F05%2F30%2F2019-05-30%2F</url>
    <content type="text"><![CDATA[题目LeetCode 235. Lowest Common Ancestor of a Binary SearchGiven a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).” _6_ / \ 2 8 / \ / \ 0 4 7 9 / \3 5 For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. 分析注意这颗是中序遍历的二叉树，左子树节点值小于根节点值小于右子树节点值。 题解function lowestCommonAncestor (root, p, q) &#123; while(true)&#123; let value = root.val if(p.val &gt;= value &amp;&amp; value &gt;= q.val || p.val &lt;= value &amp;&amp; value &lt;= q.val)&#123; return root &#125; else if(p.val &gt; value &amp;&amp; q.val &gt; value)&#123; root = root.right &#125; else &#123; root = root.left &#125; &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day137-LeetCode 100. Same Tree]]></title>
    <url>%2F2019%2F05%2F29%2F2019-05-29%2F</url>
    <content type="text"><![CDATA[题目Given two binary trees, write a function to check if they are equal or not.Two binary trees are considered equal if they are structurally identical and the nodes have the same value.判断两棵二叉树是否完全相等 分析用递归比较简单点。 题解/** * Definition for a binary tree node. * function TreeNode(val) &#123; * this.val = val; * this.left = this.right = null; * &#125; */// 递归isSameTree (p, q) &#123; // 左右子树终止条件 if(p === null &amp;&amp; q === null)&#123; return true &#125; // one null, other is not null, false if(p !== null &amp;&amp; q === null || p === null &amp;&amp; q !== null)&#123; return false &#125; // val diff, false if(p.val !== q.val)&#123; return false &#125; // find next level of tree return isSameTree(p.right, q.right) &amp;&amp; isSameTree(p.left, q.left)&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day136-LeetCode 226. Invert Binary Tree]]></title>
    <url>%2F2019%2F05%2F28%2F2019-05-28%2F</url>
    <content type="text"><![CDATA[题目Invert a binary tree.反转二叉树输入 4 / \ 2 7 / \ / \1 3 6 9反转 4 / \ 7 2 / \ / \9 6 3 1 分析对树进行广度遍历，过程中左右节点进行交换，单节点则跳过。 题解function invert (treeNode) &#123; // 单节点跳过 if(treeNode === null || (treeNode.right === null &amp;&amp; treeNode.left === null))&#123; return treeNode &#125; // 相互交换，并递归 let temp = treeNode.left treeNode.left = invertTree(treeNode.right) treeNode.right = invertTree(temp) return treeNode&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day135-Maximum Depth of Binary Tree]]></title>
    <url>%2F2019%2F05%2F27%2F2019-05-27%2F</url>
    <content type="text"><![CDATA[题目Given a binary tree, find its maximum depth.The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. 分析就是判断二叉树的左右子树有没有值，有值的话就继续往下走。 题解function binaryTreeMaxDepth (root) &#123; return find (root) function find (node)&#123; // 判断节点为空或者到底部，即没有左右子树 if(node === null)&#123; return 0 &#125; let treeLeftDepth = 1 let treeRightDepth = 1 if(node.left !== null)&#123; // 递归 treeLeftDepth += find(node.left) &#125; if(node.right !== null)&#123; treeRightDepth += find(node.right) &#125; // 比较左右子树层数大小 return treeLeftDepth &gt; treeRightDepth ? treeLeftDepth : treeRightDepth &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day134-LeetCode 292. Nim Game]]></title>
    <url>%2F2019%2F05%2F26%2F2019-05-26%E3%80%81%2F</url>
    <content type="text"><![CDATA[题目（动态规划）You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend. 分析动态规划的话。先逐步分析。先分析可能的情况。 剩下1-3个石头，我赢。剩下4个石头，我先拿1-3个，输。剩下5个石头，我先拿1个，然后剩下4个轮到他先，我赢。先拿2-3个的话，我输。剩下6个石头，我先拿1个，回到上一步5个石头他先。我先拿两个，就是4个石头他先，他输。剩下7个石头，我先拿1个，回到上一步6个石头他先拿，他拿两个的话就回到5个石头情况，他赢。 我拿3个才能到状态4个石头他先拿，他输。所以，我得想办法让他面前的石头数量到4个石头，这样有5-7个石头时我先拿的话都可以赢。如果是8个石头,我先拿至少一个，剩下5-6个石头他先拿，只要他让我面前剩下4个，他就有优势，我都会输。 4和8为倍数关系。归纳总结出初步结论，有可能是4的倍数的时候，我先拿就输。 题解function canFirstWinNimGame (sum) &#123; if (sum &lt; 4) &#123; // 1-3的整数，先拿肯定赢 return true &#125; return n%4 !== 0 // 剩下的总数是4的倍数时，先拿肯定输&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day133-vuejs源码-template编译-笔记]]></title>
    <url>%2F2019%2F05%2F25%2F2019-05-25%2F</url>
    <content type="text"><![CDATA[前言包括$mount和render方法。 代码const mount = Vue.prototype.$mount/*挂载组件*/Vue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; query(el) /* istanbul ignore if */ if (el === document.body || el === document.documentElement) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.` ) return this &#125; const options = this.$options // resolve template/el and convert to render function /*优先使用render，不存在的时候编译template*/ if (!options.render) &#123; let template = options.template /*template存在的时候取template，不存在的时候取el的outerHTML*/ if (template) &#123; /*当template是字符串的时候*/ if (typeof template === 'string') &#123; if (template.charAt(0) === '#') &#123; template = idToTemplate(template) /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; !template) &#123; warn( `Template element not found or is empty: $&#123;options.template&#125;`, this ) &#125; &#125; &#125; else if (template.nodeType) &#123; /*当template为DOM节点的时候*/ template = template.innerHTML &#125; else &#123; /*报错*/ if (process.env.NODE_ENV !== 'production') &#123; warn('invalid template option:' + template, this) &#125; return this &#125; &#125; else if (el) &#123; /*获取element的outerHTML*/ template = getOuterHTML(el) &#125; if (template) &#123; /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; mark('compile') &#125; /*将template编译成render函数，这里会有render以及staticRenderFns两个返回，这是vue的编译时优化，static静态不需要在VNode更新时进行patch，优化性能*/ // ? const &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123; shouldDecodeNewlines, delimiters: options.delimiters &#125;, this) options.render = render options.staticRenderFns = staticRenderFns /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; mark('compile end') measure(`$&#123;this._name&#125; compile`, 'compile', 'compile end') &#125; &#125; &#125; /*Github:https://github.com/answershuto*/ /*调用const mount = Vue.prototype.$mount保存下来的不带编译的mount*/ return mount.call(this, el, hydrating)&#125; 参考聊聊Vue的template编译.MarkDown]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day132-小试牛刀的题目-1]]></title>
    <url>%2F2019%2F05%2F24%2F2019-05-24%2F</url>
    <content type="text"><![CDATA[前言一道构造数据结构的题目。src: [{id:1}, {id:1}, {id:2}]tgt: {1: [0,1], 2:[2]} 代码个人解法。希望以后想出更好的解法。function groupByProp (objArray, prop) &#123; return objArray.reduce((acc, cur, index) =&gt; &#123; let key = cur[prop] if (!acc[key]) &#123; acc[key] = [] &#125; acc[key].push(index) return acc &#125;, &#123;&#125;)&#125;// let data = [&#123;id:1&#125;, &#123;id:1&#125;, &#123;id:2&#125;]// console.log(groupByProp(data, 'id'))// &#123; '1': [ 0, 1 ], '2': [ 2 ] &#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day131-vuejs源码-数据绑定-3]]></title>
    <url>%2F2019%2F05%2F23%2F2019-05-23%2F</url>
    <content type="text"><![CDATA[前言在Observer中，有一个walk方法：在其构造器中，如果observer实例是对象则walk进行绑定walk方法会遍历对象的每一个属性进行defineReactive绑定defineReactive的作用则是通过Object.defineProperty为数据定义上getter\setter方法，进行依赖收集后闭包中的Deps会存放Watcher对象。触发setter改变数据时会通知Deps订阅者通知所有的Watcher观察者对象进行视图的更新。 代码/** * Define a reactive property on an Object. */export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) &#123; // 闭包Dep const dep = new Dep() const property = Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable === false) &#123; return &#125; // 如果之前定义过了就取出来 // cater（注：迎合） for pre-defined getter/setters const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set if ((!getter || setter) &amp;&amp; arguments.length === 2) &#123; val = obj[key] &#125; let childOb = !shallow &amp;&amp; observe(val) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; const value = getter ? getter.call(obj) : val if (Dep.target) &#123; /* 依赖收集 */ dep.depend() if (childOb) &#123; /* 子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend -- 引 */ childOb.dep.depend() /* 判断是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。 */ if (Array.isArray(value)) &#123; dependArray(value) &#125; &#125; &#125; return value &#125;, set: function reactiveSetter (newVal) &#123; /* 如果原本对象拥有getter方法则执行 */ const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== 'production' &amp;&amp; customSetter) &#123; customSetter() &#125; // #7981: for accessor properties without setter if (getter &amp;&amp; !setter) return /* 判断原本对象拥有setter方法，有的话直接执行setter */ if (setter) &#123; setter.call(obj, newVal) &#125; else &#123; val = newVal &#125; /* 新值需要重新进行observe，保证数据响应式 */ childOb = !shallow &amp;&amp; observe(newVal) /* 通知观察者 */ dep.notify() &#125; &#125;)&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day130-vuejs源码-数据绑定-2]]></title>
    <url>%2F2019%2F05%2F22%2F2019-05-22%2F</url>
    <content type="text"><![CDATA[前言这次是再一次看watcher.js中的东西了，一直对dep涉及的闭包有点模糊。希望这次能懂更多点。 代码// 再看数据绑定中的Watcher，class Watcher// ...变量定义get () &#123; /** * Dep中的pushTarget * export function pushTarget (target: ?Watcher) &#123; targetStack.push(target) Dep.target = target &#125; */ pushTarget(this) let value const vm = this.vm /* 执行了getter操作，看似执行了渲染操作，其实是执行了依赖收集。 在将Dep.target设置为自身观察者实例以后，执行getter操作。 譬如说现在的的data中可能有a、b、c三个数据，getter渲染需要依赖a跟c， 那么在执行getter的时候就会触发a跟c两个数据的getter函数， 在getter函数中即可判断Dep.target是否存在然后完成依赖收集， 将该观察者对象放入闭包中的Dep的subs中去。 */ if (this.user) &#123; try &#123; value = this.getter.call(vm, vm) &#125; catch (e) &#123; handleError(e, vm, `getter for watcher "$&#123;this.expression&#125;"`) &#125; &#125; else &#123; value = this.getter.call(vm, vm) &#125; // "touch" every property so they are all tracked as // dependencies for deep watching if (this.deep) &#123; /*递归*/ traverse(value) &#125; /** * dep中的popTarget * export function popTarget () &#123; targetStack.pop() Dep.target = targetStack[targetStack.length - 1] &#125; */ popTarget() this.cleanupDeps() return value&#125;/** * Add a dependency to this directive（）. */addDep (dep: Dep) &#123; const id = dep.id if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) &#123; dep.addSub(this) &#125; &#125;&#125;/** * Clean up for dependency collection. */cleanupDeps () &#123; /*移除所有观察者对象*/ let i = this.deps.length while (i--) &#123; const dep = this.deps[i] if (!this.newDepIds.has(dep.id)) &#123; dep.removeSub(this) &#125; &#125; let tmp = this.depIds this.depIds = this.newDepIds this.newDepIds = tmp this.newDepIds.clear() tmp = this.deps this.deps = this.newDeps this.newDeps = tmp this.newDeps.length = 0&#125;/** * Subscriber（注：调度者） interface. * Will be called when a dependency changes. */ /* 调度者接口，当依赖发生改变的时候进行回调。 */update () &#123; /* istanbul ignore else */ if (this.lazy) &#123; this.dirty = true &#125; else if (this.sync) &#123; /*同步则执行run直接渲染视图*/ this.run() &#125; else &#123; /*异步推送到观察者队列中，由调度者调用。*/ queueWatcher(this) &#125;&#125;/** * Scheduler job interface. * Will be called by the scheduler. */run () &#123; if (this.active) &#123; const value = this.get() if ( value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even // when the value is the same, because the value may // have mutated. /* 即便值相同，拥有Deep属性的观察者以及在对象／数组上的观察者应该被触发更新，因为它们的值可能发生改变。 */ isObject(value) || this.deep ) &#123; // set new value const oldValue = this.value /*设置新的值*/ this.value = value /*触发回调渲染视图*/ if (this.user) &#123; try &#123; this.cb.call(this.vm, value, oldValue) &#125; catch (e) &#123; handleError(e, this.vm, `callback for watcher "$&#123;this.expression&#125;"`) &#125; &#125; else &#123; this.cb.call(this.vm, value, oldValue) &#125; &#125; &#125;&#125;/** * Evaluate the value of the watcher. * This only gets called for lazy watchers. */ /*获取观察者的值*/evaluate () &#123; this.value = this.get() this.dirty = false&#125;/** * Depend on all deps collected by this watcher. */ /*收集该watcher的所有deps依赖*/depend () &#123; let i = this.deps.length while (i--) &#123; this.deps[i].depend() &#125;&#125;/** * Remove self from all dependencies' subscriber list. */ /*将自身从所有依赖收集订阅列表删除*/teardown () &#123; if (this.active) &#123; // remove self from vm's watcher list // this is a somewhat expensive operation so we skip it // if the vm is being destroyed. /*从vm实例的观察者列表中将自身移除，由于该操作比较耗费资源，所以如果vm实例正在被销毁则跳过该步骤。--引*/ if (!this.vm._isBeingDestroyed) &#123; remove(this.vm._watchers, this) &#125; let i = this.deps.length while (i--) &#123; this.deps[i].removeSub(this) &#125; this.active = false &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day129-vuejs源码-数据绑定原理-1]]></title>
    <url>%2F2019%2F05%2F21%2F2019-05-21%2F</url>
    <content type="text"><![CDATA[前言这里从initData开始入手initData作用是初始化data中的数据，之后Observer数据，监听数据的变化。 代码/** * https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js * initData主要是初始化data中的数据，将数据进行Observer，监听数据的变化，其他的监视原理一致 * @param vm */function initData (vm: Component) &#123; let data = vm.$options.data data = vm._data = typeof data === 'function' ? getData(data, vm) : data || &#123;&#125; // 判断data是否是纯对象 if (!isPlainObject(data)) &#123; data = &#123;&#125; process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm ) &#125; // proxy data on instance const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length // 遍历data中的一些声明 while (i--) &#123; const key = keys[i] if (process.env.NODE_ENV !== 'production') &#123; // 检查methods命名和data中命名的冲突 if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn( `Method "$&#123;key&#125;" has already been defined as a data property.`, vm ) &#125; &#125; // 检查props命名和data中命名的冲突 if (props &amp;&amp; hasOwn(props, key)) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `The data property "$&#123;key&#125;" is already declared as a prop. ` + `Use prop default value instead.`, vm ) &#125; else if (!isReserved(key)) &#123; // 将data中的属性代理到vm实例上 proxy(vm, `_data`, key) &#125; &#125; // observe data // 开始对数据进行绑定 // asRootData表示作为根数据，observe会递归对深层对象的绑定 observe(data, true /* asRootData */)&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day128-vuejs源码-事件机制]]></title>
    <url>%2F2019%2F05%2F20%2F2019-05-20%2F</url>
    <content type="text"><![CDATA[前言vuejs源码 v2.x.x 的实例方法 / 事件，$on，$once，$off，$emit 代码// &lt;.../core/instance/events.js&gt; on 20 Dec 2018// $on// 监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。-- https://cn.vuejs.org/v2/api/#vm-onconst hookRE = /^hook:/Vue.prototype.$on = function (event: string | Array&lt;string&gt;, fn: Function): Component &#123; const vm: Component = this // $on可以是数组值 if (Array.isArray(event)) &#123; for (let i = 0, l = event.length; i &lt; l; i++) &#123; vm.$on(event[i], fn) &#125; &#125; else &#123; (vm._events[event] || (vm._events[event] = [])).push(fn) // optimize hook:event cost by using a boolean flag marked at registration // instead of a hash lookup（注：利用布尔值标识是否注册时存在钩子事件，而不是利用hash查询） if (hookRE.test(event)) &#123; vm._hasHookEvent = true &#125; &#125; return vm&#125;// $once// 监听一个自定义事件，但是只触发一次，在第一次触发之后移除监听器。-- https://cn.vuejs.org/v2/api/#vm-onceVue.prototype.$once = function (event: string, fn: Function): Component &#123; const vm: Component = this function on () &#123; // $off表示将事件销毁，第一执行之后就销毁 vm.$off(event, on) // 调用方法 fn.apply(vm, arguments) &#125; on.fn = fn // 监听事件 vm.$on(event, on) return vm&#125;// $off// 移除自定义事件监听器。// 如果没有提供参数，则移除所有的事件监听器；// 如果只提供了事件，则移除该事件所有的监听器；// 如果同时提供了事件与回调，则只移除这个回调的监听器。https://cn.vuejs.org/v2/api/#vm-offVue.prototype.$off = function (event?: string | Array&lt;string&gt;, fn?: Function): Component &#123; const vm: Component = this // all if (!arguments.length) &#123; // 返回创建的空对象 vm._events = Object.create(null) return vm &#125; // array of events if (Array.isArray(event)) &#123; for (let i = 0, l = event.length; i &lt; l; i++) &#123; // 递归调用？ vm.$off(event[i], fn) &#125; return vm &#125; // specific event const cbs = vm._events[event] // 事件不存在则返回本身 if (!cbs) &#123; return vm &#125; // 事件置空 if (!fn) &#123; vm._events[event] = null return vm &#125; // specific handler // 找对应的方法fn，找到就移除 let cb let i = cbs.length while (i--) &#123; cb = cbs[i] if (cb === fn || cb.fn === fn) &#123; cbs.splice(i, 1) break &#125; &#125; return vm&#125;// $emit// 触发当前实例上的事件。附加参数都会传给监听器回调。Vue.prototype.$emit = function (event: string): Component &#123; const vm: Component = this if (process.env.NODE_ENV !== 'production') &#123; const lowerCaseEvent = event.toLowerCase() if (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) &#123; tip( `Event "$&#123;lowerCaseEvent&#125;" is emitted in component ` + `$&#123;formatComponentName(vm)&#125; but the handler is registered for "$&#123;event&#125;". ` + `Note that HTML attributes are case-insensitive and you cannot use ` + `v-on to listen to camelCase events when using in-DOM templates. ` + `You should probably use "$&#123;hyphenate(event)&#125;" instead of "$&#123;event&#125;".` ) &#125; &#125; let cbs = vm._events[event] if (cbs) &#123; // toArray：类数组转为数组 cbs = cbs.length &gt; 1 ? toArray(cbs) : cbs const args = toArray(arguments, 1) const info = `event handler for "$&#123;event&#125;"` for (let i = 0, l = cbs.length; i &lt; l; i++) &#123; // invokeWithErrorHandling 来自：&lt;src/core/util/error.js&gt;，避免嵌套调用时多次触发 invokeWithErrorHandling(cbs[i], vm, args, vm, info) &#125; &#125; return vm&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day127-vuejs源码-nextTick()-3]]></title>
    <url>%2F2019%2F05%2F19%2F2019-05-19%2F</url>
    <content type="text"><![CDATA[前言上一次，还记得在了解队列刷新的时候做了方法队列刷新完毕之后watcher会被推入watcher队列，最后做了调用了一个方法：nextTick(flushSchedulerQueue)但是没有对方法做一些了解，这里了解下flushSchedulerQueue()。 代码// &lt;src/core/observer/scheduler.js&gt;/** * Flush both queues and run the watchers. */function flushSchedulerQueue () &#123; currentFlushTimestamp = getNow() flushing = true let watcher, id // 注意排序的原因 // Sort queue before flush. // This ensures that: // 1. Components are updated from parent to child. (because parent is always // created before the child) // 2. A component's user watchers are run before its render watcher (because // user watchers are created before the render watcher) // 3. If a component is destroyed during a parent component's watcher run, // its watchers can be skipped. queue.sort((a, b) =&gt; a.id - b.id) // do not cache length because more watchers might be pushed // as we run existing watchers // 这里？？？ /*这里不用index = queue.length;index &gt; 0; index--的方式写是因为不要将length进行缓存，因为在执行处理现有watcher对象期间，更多的watcher对象可能会被push进queue*/ for (index = 0; index &lt; queue.length; index++) &#123; watcher = queue[index] if (watcher.before) &#123; watcher.before() &#125; id = watcher.id //之前推入队列时候的标记：function queueWatcher() has[id] = null watcher.run() // in dev build, check and stop circular updates.(注：检测函数中的死循环) if (process.env.NODE_ENV !== 'production' &amp;&amp; has[id] != null) &#123; circular[id] = (circular[id] || 0) + 1 if (circular[id] &gt; MAX_UPDATE_COUNT) &#123; warn( 'You may have an infinite update loop ' + ( watcher.user ? `in watcher with expression "$&#123;watcher.expression&#125;"` : `in a component render function.` ), watcher.vm ) break &#125; &#125; &#125; // keep copies of post queues before resetting state // 注： 这里的activatedChildren方法应该是属于queueActivatedComponent()函数中保存kept-alive组件 // slice() 拷贝 const activatedQueue = activatedChildren.slice() const updatedQueue = queue.slice() resetSchedulerState() // call component updated and activated hooks（注：调用钩子） callActivatedHooks(activatedQueue) callUpdatedHooks(updatedQueue) // devtool hook /* istanbul ignore if */ if (devtools &amp;&amp; config.devtools) &#123; devtools.emit('flush') &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day126-vuejs源码-nextTick()-2]]></title>
    <url>%2F2019%2F05%2F18%2F2019-05-18%2F</url>
    <content type="text"><![CDATA[前言继续nextTick()的探讨。这里引用的比较多，同时也更新了引用文章中对于vuejs源码的解释。 代码// https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js -- 版本24 Jan 2019/** * Defer a task to execute it asynchronously. */ /* 延迟一个任务使其异步执行，在下一个tick时执行，一个立即执行函数，返回一个function 这个函数的作用是在task或者microtask中推入一个timerFunc，在当前调用栈执行完以后以此执行直到执行到timerFunc 目的是延迟到当前调用栈执行完以后执行*/export const nextTick = (function () &#123; let isUsingMicroTask = false /*异步回调*/ const callbacks = [] /*标记位，有timerFunc被推送到任务队列中去则不需要重复推送*/ let pending = false /*下一个tick时的回调*/ function nextTickHandler () &#123; /*一个标记位，标记等待状态（即函数已经被推入任务队列或者主线程，已经在等待当前栈执行完毕去执行），这样就不需要在push多个回调到callbacks时将timerFunc多次推入任务队列或者主线程*/ pending = false /*执行所有callback*/ const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) &#123; copies[i]() &#125; &#125; // 这里是源码的一些解释 // Here we have async deferring wrappers using microtasks. // In 2.5 we used (macro) tasks (in combination with microtasks). // However, it has subtle problems when state is changed right before repaint // (e.g. #6813, out-in transitions). // Also, using (macro) tasks in event handler would cause some weird（注：奇怪的） behaviors // that cannot be circumvented(注：绕开) (e.g. #7109, #7153, #7546, #7834, #8109). // So we now use microtasks everywhere, again. // A major drawback of this tradeoff is that there are some scenarios （注：这种权衡的一个主要缺点是存在一些情况） // where microtasks have too high a priority and fire in between supposedly // sequential events (e.g. #4521, #6690, which have workarounds) // or even between bubbling of the same event (#6566). let timerFunc // The nextTick behavior leverages the microtask queue, which can be accessed // via either native Promise.then or MutationObserver. // MutationObserver has wider support, however it is seriously bugged in // UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It // completely stops working after triggering a few times... so, if native // Promise is available, we will use it: /* istanbul ignore next, $flow-disable-line */ /* 这里解释一下，一共有Promise、MutationObserver以及setTimeout三种尝试得到timerFunc的方法 按照Promise，MutationObserver，setTimeout优先级，使用timerFunc 优先使用Promise，在Promise不存在的情况下使用MutationObserver，这两个方法都会在microtask中执行，会比setTimeout更早执行，所以优先使用。 如果上述两种方法都不支持的环境则会使用setTimeout，在task尾部推入这个函数，等待调用执行。 参考：https://www.zhihu.com/question/55364497 */ if (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) &#123; /*使用Promise*/ var p = Promise.resolve() var logError = err =&gt; &#123; console.error(err) &#125; timerFunc = () =&gt; &#123; p.then(nextTickHandler).catch(logError) // In problematic UIWebViews, Promise.then doesn't completely break, but // it can get stuck in a weird state where callbacks are pushed into the // microtask queue but the queue isn't being flushed, until the browser // needs to do some other work, e.g. handle a timer. Therefore we can // "force" the microtask queue to be flushed by adding an empty timer. if (isIOS) setTimeout(noop) isUsingMicroTask = true &#125; &#125; else if (typeof MutationObserver !== 'undefined' &amp;&amp; ( isNative(MutationObserver) || // PhantomJS and iOS 7.x MutationObserver.toString() === '[object MutationObserverConstructor]' )) &#123; // use MutationObserver where native Promise is not available, // e.g. PhantomJS IE11, iOS7, Android 4.4 /*新建一个textNode的DOM对象，用MutationObserver绑定该DOM并指定回调函数，在DOM变化的时候则会触发回调,该回调会进入主线程（比任务队列优先执行），即textNode.data = String(counter)时便会触发回调*/ var counter = 1 var observer = new MutationObserver(nextTickHandler) var textNode = document.createTextNode(String(counter)) observer.observe(textNode, &#123; characterData: true &#125;) timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) &#125; // 新增一个标记位 isUsingMicroTask = true &#125; else &#123; // Fallback to setImmediate. // Techinically it leverages the (macro) task queue, // but it is still a better choice than setTimeout. /*使用setTimeout将回调推入任务队列尾部*/ timerFunc = () =&gt; &#123; setTimeout(nextTickHandler, 0) &#125; &#125; /* 推送到队列中下一个tick时执行 cb 回调函数 ctx 上下文 */ return function queueNextTick (cb?: Function, ctx?: Object) &#123; let _resolve /*cb存到callbacks中*/ callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch (e) &#123; handleError(e, ctx, 'nextTick') &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) if (!pending) &#123; pending = true timerFunc() &#125; if (!cb &amp;&amp; typeof Promise !== 'undefined') &#123; return new Promise((resolve, reject) =&gt; &#123; _resolve = resolve &#125;) &#125; &#125;&#125;)() 引自参考：JS 的 event loop 执行时会区分 task 和 microtask，引擎在每个 task 执行完毕，从队列中取下一个 task 来执行之前，会先执行完所有 microtask 队列中的 microtask。setTimeout 回调会被分配到一个新的 task 中执行，而 Promise 的 resolver、MutationObserver 的回调都会被安排到一个新的 microtask 中执行，会比 setTimeout 产生的 task 先执行。要创建一个新的 microtask，优先使用 Promise，如果浏览器不支持，再尝试 MutationObserver。实在不行，只能用 setTimeout 创建 task 了。为啥要用 microtask？根据 HTML Standard，在每个 task 运行完以后，UI 都会重渲染，那么在 microtask 中就完成数据更新，当前 task 结束就可以得到最新的 UI 了。反之如果新建一个 task 来做数据更新，那么渲染就会进行两次。 参考顾轶灵知乎的回答：https://www.zhihu.com/question/55364497/answer/144215284 MutationObserver新建一个textNode的DOM对象，用MutationObserver绑定该DOM并指定回调函数，在DOM变化的时候则会触发回调,该回调会进入microtask，即textNode.data = String(counter)时便会加入该回调。 setTimeout是最后的一种备选方案，它会将回调函数加入task中，等到执行。 综上，nextTick的目的就是产生一个回调函数加入task或者microtask中，当前栈执行完以后（可能中间还有别的排在前面的函数）调用该回调函数，起到了异步触发（即下一个tick时触发）的目的。 参考Vue.js异步更新DOM策略及nextTick]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day125-vuejs源码-nextTick()-1]]></title>
    <url>%2F2019%2F05%2F17%2F2019-05-17%2F</url>
    <content type="text"><![CDATA[前言了解vuejs中的异步更新DOM策略，了解vuejs操作DOM过程中一些原理。 代码// vuejs 中的 nextTick// 响应式数据发生变化的时候，它的setter函数会通知闭包中的Dep，Dep则会调用它管理的所有Watch对象。触发Watch对象的update实现。/** * Subscriber interface. * Will be called when a dependency changes. */// 在watcher.js文件中update () &#123; /* istanbul ignore else */ // this.lazy = !!options.lazy 和 deep什么的同级 if (this.lazy) &#123; this.dirty = true &#125; else if (this.sync) &#123; /*同步则执行run直接渲染视图*/ this.run() &#125; else &#123; /*异步推送到观察者队列中*/ queueWatcher(this) &#125;&#125;// &lt;scheduler.js&gt;/** * Push a watcher into the watcher queue. * Jobs with duplicate IDs will be skipped unless it's * pushed when the queue is being flushed. * // 队列刷新完毕之后watcher才会被推入watcher队列 */export function queueWatcher (watcher: Watcher) &#123; const id = watcher.id // 哈希表has，标记是否存在id，这个id指的是？ // 如果不是刷新状态也不是等待状态则进入刷新事件队列。 if (has[id] == null) &#123; has[id] = true if (!flushing) &#123; // 不在刷新状态中，直接推到队列中 queue.push(watcher) &#125; else &#123; // if already flushing, splice the watcher based on its id // if already past its id, it will be run next immediately. let i = queue.length - 1 while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123; i-- &#125; queue.splice(i + 1, 0, watcher) &#125; // queue the flush if (!waiting) &#123; waiting = true if (process.env.NODE_ENV !== 'production' &amp;&amp; !config.async) &#123; flushSchedulerQueue() return &#125; nextTick(flushSchedulerQueue) &#125; &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day124-设计 LazyMan 类 -笔记]]></title>
    <url>%2F2019%2F05%2F16%2F2019-05-16%2F</url>
    <content type="text"><![CDATA[前言设计 LazyMan 类，实现以下功能：LazyMan('Tony');// Hi I am TonyLazyMan('Tony').sleep(10).eat('lunch');// Hi I am Tony// 等待了10秒...// I am eating lunchLazyMan('Tony').eat('lunch').sleep(10).eat('dinner');// Hi I am Tony// I am eating lunch// 等待了10秒...// I am eating dinerLazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(10).eat('junk food');// Hi I am Tony// 等待了5秒...// I am eating lunch// I am eating dinner// 等待了10秒...// I am eating junk food 代码class LazyManClass &#123; constructor(name) &#123; this.taskList = []; this.name = name; console.log(`Hi I am $&#123;this.name&#125;`); setTimeout(() =&gt; &#123; this.next(); &#125;, 0); &#125; eat (name) &#123; var that = this; var fn = (function (n) &#123; return function () &#123; console.log(`I am eating $&#123;n&#125;`) that.next(); &#125; &#125;)(name); this.taskList.push(fn); return this; &#125; sleepFirst (time) &#123; var that = this; var fn = (function (t) &#123; return function () &#123; setTimeout(() =&gt; &#123; console.log(`等待了$&#123;t&#125;秒...`) that.next(); &#125;, t * 1000); &#125; &#125;)(time); this.taskList.unshift(fn); return this; &#125; sleep (time) &#123; var that = this var fn = (function (t) &#123; return function () &#123; setTimeout(() =&gt; &#123; console.log(`等待了$&#123;t&#125;秒...`) that.next(); &#125;, t * 1000); &#125; &#125;)(time); this.taskList.push(fn); return this; &#125; next () &#123; var fn = this.taskList.shift(); fn &amp;&amp; fn(); &#125;&#125;function LazyMan(name) &#123; return new LazyManClass(name);&#125;LazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(4).eat('junk food');]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day123-数据结构处理-数组]]></title>
    <url>%2F2019%2F05%2F15%2F2019-05-15%2F</url>
    <content type="text"><![CDATA[前言某公司 1 到 12 月份的销售额存在一个对象里面，如下：{1:222, 2:123, 5:888}，请把数据处理为如下结构：[222, 123, null, null, 888, null, null, null, null, null, null, null]。 代码// 简短： 这个和上次生成随机数那个很像啊，用到了数组的生成let obj = &#123;1:222, 2:123, 5:888&#125;;const result = [...Array(12)].map((_, index) =&gt; obj[index + 1] || null);// 或者 - 引// const result = Array.from(&#123; length: 12 &#125;).map((_, index) =&gt; obj[index + 1] || null);// 或者直接一行 - 引// Array.from(&#123;length:12&#125;,(v,i)=&gt;(&#123;1:222,2:123,5:888&#125;[i+1])||null)console.log(result)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day122-随机生成数组]]></title>
    <url>%2F2019%2F05%2F14%2F2019-05-14%2F</url>
    <content type="text"><![CDATA[前言题目：随机生成一个长度为 10 的整数类型的数组，例如 [2, 10, 3, 4, 5, 11, 10, 11, 20]，将其排列成一个新数组，要求新数组形式如下，例如 [[2, 3, 4, 5], [10, 11], [20]]。 代码/** * --- * 随机生成一个长度为 10 的整数类型的数组， * 例如 [2, 10, 3, 4, 5, 11, 10, 11, 20]， * 将其排列成一个新数组，要求新数组形式如下， * 例如 [[2, 3, 4, 5], [10, 11], [20]] */// 1. 生成两位整数,各个数生成的概率接近相等。（有问题，81-100之间的数有问题？）function getRandomIntDouble () &#123; let randomIntSingle = (Math.random() * 10).toFixed(0) return Math.pow(randomIntSingle, 2)&#125;// 2. 生成一个长度为10的随机数数组// let randomIntArr = Array.from(&#123;length: 10&#125;, _ =&gt; getRandomIntDouble())let randomIntArr = [...Array(10)].map(_ =&gt; getRandomIntDouble())// 3. 去重let uniqueArr = Array.from(new Set(randomIntArr))// 4. 排序let sortedUniqueArr = uniqueArr.sort((a, b) =&gt; a - b)// 5. 新数组，0~10,10~20...80~99各占一个数组// ----let obj = &#123;&#125;;sortedUniqueArr.map((i) =&gt; &#123; const intNum = Math.floor(i/10); if (!obj[intNum]) obj[intNum] = []; obj[intNum].push(i);&#125;)// 输出结果const resArr = [];for(let i in obj) &#123; resArr.push(obj[i]);&#125;console.log(resArr) Create a array with random values]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day121-数组扁平化-去重-升序]]></title>
    <url>%2F2019%2F05%2F13%2F2019-05-13%2F</url>
    <content type="text"><![CDATA[代码Array.from(new Set(arr.flat(Infinity))).sort((a,b)=&gt;&#123; return a-b&#125;)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day120-js深拷贝]]></title>
    <url>%2F2019%2F05%2F12%2F2019-05-12%2F</url>
    <content type="text"><![CDATA[前言来一个js的深拷贝，和JSON.stringify实现的还是有点区别的。 代码function deepCopy(obj)&#123; //判断是否是简单数据类型， if(typeof obj == "object")&#123; //复杂数据类型 var result = obj.constructor == Array ? [] : &#123;&#125;; for(let i in obj)&#123; result[i] = typeof obj[i] == "object" ? deepCopy(obj[i]) : obj[i]; &#125; &#125;else &#123; //简单数据类型 直接 == 赋值 var result = obj; &#125; return result;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day119-实现一个instanceOf笔记]]></title>
    <url>%2F2019%2F05%2F10%2F2019-05-11%2F</url>
    <content type="text"><![CDATA[前言话不多说，这篇是水篇。 代码// 实现一个instanceOffunction myInstanceOf(left, right) &#123; let proto = left.__proto__ let prototype = right.prototype while (true) &#123; if (!proto) &#123; return false &#125; if (proto === prototype) &#123; return false &#125; proto === proto.__proto__ &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day118-手写简单的函数柯里化-笔记]]></title>
    <url>%2F2019%2F05%2F10%2F2019-05-10%2F</url>
    <content type="text"><![CDATA[前言函数柯里化是属于高阶函数中一种常见的技术。特点就是参数复用、提前返回和延迟执行。 代码function curry (fn, args) &#123; var length = fn.length var args = args || [] return function () &#123; newArgs = args.concat(Array.prototype.slice.call(arguments)) if (newArgs.length &lt; length) &#123; return curry.call(this, fn, newArgs) &#125; else &#123; return fn.apply(this, newArgs) &#125; &#125;&#125;function multiFn(a, b, c) &#123; return a * b * c&#125;var multi = curry(multiFn)multi(1)(2)(3)multi(1,2,3)multi(1)(2,3)multi(1,2)(3)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day117-手写简单防抖]]></title>
    <url>%2F2019%2F05%2F09%2F2019-05-09%2F</url>
    <content type="text"><![CDATA[前言其实就是一个apply调用。非常简单。重点是理解防抖和节流这两个概念吧。首次事件发生之后，需要延迟(wait)时间处理。延迟时间段内有第二次事件，则以第二次事件为准延迟处理。知道最后一次时间段内没有事件，则执行最后一次。 代码 debounce function debounce (fn, wait, immediate) &#123; let timer return function () &#123; // 注意arguments是当前函数内的参数 if (immediate) &#123; fn.apply(this, arguments) &#125; if (timer) &#123; clearTimeout(timer) &#125; timer = setTimeout(() =&gt; &#123; fn.apply(this, arguments) &#125;, wait) &#125;&#125; throttle function throttle (fn, wait) &#123; let prev = new Date() return function () &#123; const now = new Date() // 在wait时间内只执行一次 if (now - prev &gt; wait) &#123; // 注意arguments是当前函数内的参数 fn.apply(this, arguments) prev = new Date() &#125; &#125;&#125; 总结就是：throttle限制函数调用频率，debounce则限制函数调用速率]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day116-手写JSON.stringify]]></title>
    <url>%2F2019%2F05%2F08%2F2019-05-08%2F</url>
    <content type="text"><![CDATA[前言没啥可说的，这篇比较水。JSON.stringify(value[, replacer [, space]]) 代码function jsonStringify(obj) &#123; let type = typeof obj if (type !== "object") &#123; // undefined 什么的会被忽略，循环引用也会被忽略 if (/string|undefined|function/.test(type)) &#123; obj = '"' + obj + '"' &#125; return String(obj) &#125; else &#123; let json = [] let arr = Array.isArray(obj) for (let k in obj) &#123; let v = obj[k] let type = typeof v if (/string|undefined|function/.test(type)) &#123; v = '"' + v + '"' &#125; else if (type === "object") &#123; v = jsonStringify(v) &#125; json.push((arr ? "" : '"' + k + '":') + String(v)) &#125; return (arr ? "[" : "&#123;") + String(json) + (arr ? "]" : "&#125;") &#125;&#125; 参考JavaScript手写代码无敌秘籍]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day115-实现事件类Event]]></title>
    <url>%2F2019%2F05%2F07%2F2019-05-07%2F</url>
    <content type="text"><![CDATA[前言源起：同页面组件间通信使用事件监听和派发的方式，而不是直接相互调用组件方法。用[订阅发布模式]，保证组件的独立性和降低组件间耦合度。 · 核心：核心是一个事件类型对应回调函数的数据设计。 实现功能本质上是一个观察者模式的实现。且Node.js原生自带EventEmitter模块，所以这部分是比较重要的。实现一个事件类Event ，包含下面功能： 绑定事件 解绑事件 派发事件 on(eventName, func)： 监听 eventName事件， 事件触发的时候调用 func函数 emit(eventName, arg1, arg2, arg3,arg4…)： 触发eventName 事件, 并且把参数 arg1, arg2, arg3,arg4…传给事件处理函数 off(eventName, func)： 停止监听某个事件 参考实现一个Event类（发布订阅模式）]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day114-实现new运算符（2）]]></title>
    <url>%2F2019%2F05%2F06%2F2019-05-06%2F</url>
    <content type="text"><![CDATA[前言new 模拟实现大致思路： 建立一个新对象 通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上 实例可以访问原型上的属性 原型的知识复习[[prototype]] 是什么？JavaScript中的对象，都有一个特殊的[[prototype]]内置属性，其实就是对于其他对象的引用。（你不知道的JavaScript-上卷-第五章）__proto__ 是什么？__proto__ ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。new.target 是什么？new.target属性允许你检测函数或构造方法是否是通过new运算符被调用的。在通过new运算符被初始化的函数或构造方法中，new.target返回一个指向构造方法或函数的引用。在普通的函数调用中，new.target 的值是undefined。 原型关系图： 实现代码function myObjectFactory () &#123; var Constructor = [].shift.call(arguments) // 取外部传入的构造器 var newObj = Object.create(Constructor.prototype) // newObj也可以这么写 /** * var obj = new Object() * obj.__proto__ = Constructor.prototype */ var ctorResult = Constructor.apply(newObj, arguments) // 判断返回的值是不是一个对象，如果是一个对象，则返回对象 // 注意：判ctorResult是否空 return typeof ctorResult === 'object' ? ctorResult||newObj : newObj&#125; 另外一种实现unction New(func) &#123; var res = &#123;&#125;; if (func.prototype !== null) &#123; res.__proto__ = func.prototype; &#125; var ret = func.apply(res, Array.prototype.slice.call(arguments, 1)); if ((typeof ret === "object" || typeof ret === "function") &amp;&amp; ret !== null) &#123; return ret; &#125; return res;&#125;var obj = New(A, 1, 2);// equals tovar obj = new A(1, 2); 引自：实现一个new操作符 测试// 测试用例-1function Test (name) &#123; this.name = name this.habit = 'Games'&#125;Test.prototype.age = 22Test.prototype.sayYourName = function () &#123; console.log('I am ' + this.name);&#125;var person = myObjectFactory(Test, 'zhangsan')console.log(person.name) // zhangsanconsole.log(person.habit) // Gamesconsole.log(person.age) // 22person.sayYourName() // I am zhangsan// 测试用例-2 虚实__proto__(Object.create(null))function Otaku (age) &#123;&#125;Otaku.prototype.sayHello = function() &#123; console.log('hello')&#125;var person = myObjectFactory(Otaku, 'Kevin', '18');console.log(person) // Otaku &#123;&#125;person.sayHello() // hello 参考JavaScript深入之new的模拟实现js中_proto_和prototype的区别和关系？怎么实现newnew​.target]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day113-实现new运算符（1）]]></title>
    <url>%2F2019%2F05%2F05%2F2019-05-05%2F</url>
    <content type="text"><![CDATA[前言一些实现new运算符的思路整理。 new 运算符，new关键字的操作（MDN）： Creates a blank, plain JavaScript object; 创建一个空的简单JavaScript对象（即{}）； Links (sets the constructor of) this object to another object; 链接该对象（即设置该对象的构造函数）到另一个对象 ； Passes the newly created object from Step 1 as the this context; 将步骤1新创建的对象作为this的上下文 ； Returns this if the function doesn’t return its own object. 如果该函数没有返回对象，则返回this。 new Foo() 发生了什么？当代码 new Foo(…) 执行时，会发生以下事情： 一个继承自 Foo.prototype 的新对象被创建。 使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象。new Foo 等同于 Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。 由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day112-手写原生bind()-2]]></title>
    <url>%2F2019%2F05%2F04%2F2019-05-04%2F</url>
    <content type="text"><![CDATA[前言之前实现的bind()，能返回新函数，也能参数传递，实际原生的bind()还能实现构造函数的效果。这个用法也是很常用的。其中还涉及到绑定函数时，需要了解new 的模拟实现。 MDN上作为构造函数的绑定函数，如下。 // bind() 作为构造函数的绑定函数function Point(x, y) &#123; this.x = x this.y = y&#125;Point.prototype.toString = function() &#123; return this.x + ',' + this.y&#125;var YAxisPoint = Point.bind(null, 0/*x*/)var axisPoint = new YAxisPoint(5)var result = axisPoint.toString()console.log(result) // 0,5 做一些改动。// 改动var contextObj = &#123; x: '1', y: '2'&#125;var YAxisPoint2 = Point.bind(contextObj)var result2 = new YAxisPoint('1', '9')// 绑定的 this 失效console.log(YAxisPoint2.x) // undefined 实现代码代码里有些要注意的点。Function.prototype.myBind = function (ct) &#123; var _self = this var args = Array.prototype.slice.call(arguments, 1) // 原型变量 var fNOP = function () &#123;&#125; var fBound = function () &#123; // 注意：arguments是当前函数的参数 var bindArgs = Array.prototype.slice.call(arguments) // fBound做构造函数时，将绑定函数的this指向该实例，让实例获得来自绑定函数的值 return _self.apply(fNOP.prototype.isPrototype(this) ? this : ct, args.concat(bindArgs)) &#125; // 实例继承绑定函数原型 // fBound.prototype = this.prototype // 这里args长度会变化？？？ if (this.prototype) &#123; // 维护原型关系，空函数中转 fNOP.protytype = this.prototype &#125; fBound.prototype = new fNOP() return fBound&#125; 一些细节： 这部分实现创建的绑定函数所有的 length 属性并不是同ECMA-262标准一致的：它创建的函数的 length 是0，而在实际的实现中根据目标函数的 length 和预先指定的参数个数可能会返回非零的 length。 参考JavaScript深入之bind的模拟实现MDN(中文版)Function​.prototype​.bind()MDN(英文版)Function​.prototype​.bind()]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day111-手写原生bind()-1]]></title>
    <url>%2F2019%2F05%2F03%2F2019-05-03%2F</url>
    <content type="text"><![CDATA[前言一般bind()用的比较多的就是创建绑定函数，还有就是偏函数。所以这里可能就是从bind函数的一般用法来考虑实现。MDN上的Polyfill借用slice()，concat()，call()方法。这里也是差不多的实现方法。 MDN上的例子 this.x = 9; // 在浏览器中，this指向全局的 "window" 对象var module = &#123; x: 81, getX: function() &#123; return this.x &#125;&#125;module.getX() // 81//注意：新手容易错的地方-将一个方法从对象中拿出来，会丢失原来的对象var retrieveX = module.getXretrieveX()// 返回9 - 因为函数是在全局作用域中调用的 利用bind处理 // 创建一个新函数，把 'this' 绑定到 module 对象// 新手可能会将全局变量 x 与 module 的属性 x 混淆原始的对象创建一个绑定函数var boundGetX = retrieveX.bind(module)boundGetX() // 81 代码 实现参数的传递Function.prototype.myBind = function (ct) &#123; var self = this // 获取从第二个参数到最后一个参数 var args = Array.prototype.slice.call(arguments, 1) return function () &#123; // 注意：arguments指bind返回的函数传入的参数 var bindArgs = Array.prototype.slice.call(arguments) self.apply(ct, args.concat(bindArgs)) &#125;&#125; 未完。。。 参考MDN]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day110-手写原生call()]]></title>
    <url>%2F2019%2F05%2F02%2F2019-05-02%2F</url>
    <content type="text"><![CDATA[前言call()反正我是用的比较少吧，但是从大家的使用量来说，这个函数是非常的重要。因为他有一些方法，起了很重要的作用。比如简单的继承，指定上下文等。 用法 - MDN function Product(name, price) &#123; this.name = name this.price = price + '++'&#125;function Food(name, price) &#123; // 下面的this表示Product在执行时真正的this值(严格模式。非严格模式则是指向全局对象) Product.call(this, name, price) this.category = 'food'&#125;console.log(new Food('cheese', 5).name) 代码-call() 实现fun.protytype.myCall思路ES3 ： 步骤一确定参数数量 先实现确定参数数量的myCall，因为function.prototype.call(thisArg, arg1, arg2, …),实际上是不确定参数的 fun的参数全部存到fun的临时处fun.temp fun.temp() 输出在fun中存有的参数 删除fun中新增的temp，用delete 其他实现的思路好像都差不多。 Function.prototype.myCall = function (args) &#123; args.temp = this args.temp() delete args.temp&#125; 步骤二不确定参数数量 实现fun.protytype.myCall思路ES3 ： 对call的参数进行处理，用slice来分开参数 对分开之后的参数做不同处理 注意：非严格模式下thisArgs的null\undefined指向全局变量（浏览器是window） 用eval来连接argsFunction.prototype.myCall = function (args) &#123; // null错误处理 args = args || window args.temp = this var result if (!args) &#123; result = args.temp() &#125; else &#123; var argsList = [] // 第二个参数及其以后的都存入数组, 注意arguments for (var i = 1, l = arguments.length; i &lt; l; i++) &#123; argsList.push('arguments[' + i + ']') &#125; // todo: eval不是很推荐的方法，需要一个好的方式连接 eval() https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval result = eval('args.temp(' + argsList + ')') &#125; delete fn.temp return result&#125; // 待测试 代码-apply()apply()和call()差不多，就是差在apply传入数组参数。 Function.prototype.myApply() = function (thisArg, argsArr) &#123; // 注意Object() thisArg = Object(thisArg) || window thisArg.temp = this var result if (!argsArr) &#123; result = thisArg.temp &#125; else &#123; // 注意i = 0 var arrTemp = [] for (var i = 0, l = argsArr.length; i &lt; l; i++) &#123; arrTemp.push('argsArr[' + i + ']') &#125; result = eval('thisArg.temp(' + arrTemp + ')') &#125; return result 参考JavaScript深入之call和apply的模拟实现 能否模拟实现JS的call和apply方法不能使用call,apply,bind，如何用js实现call或者apply的功能？]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day109-ts实现mvvm-笔记（2）]]></title>
    <url>%2F2019%2F05%2F01%2F2019-05-01%2F</url>
    <content type="text"><![CDATA[前言数组的依赖收集？？？ 代码import Dep from "../../2019-04/30/vuejs/dep";// 上文2019-04-30-vuejs// 数组的依赖收集function defineReactive(obj: any, key: string, val?: any) &#123; // ... if (Dep.target) &#123; dep.depend() if (childOb) &#123; childOb.dep.depend() if (Array.isArray(value)) &#123; dependArray(value) &#125; &#125; &#125; // ...&#125;function dependArray (value: any[]) &#123; for (let e, i = 0, l = value.length; i &lt; l; i++) &#123; e = value[i] // 多维数组？？ e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend() if (Array.isArray(e)) &#123; dependArray(e) &#125; &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day108-ts实现mvvm-笔记（1）]]></title>
    <url>%2F2019%2F04%2F30%2F2019-04-30%2F</url>
    <content type="text"><![CDATA[前言Vue3.0的源码要用typescript来编写，同时个人随着近期typescript的练习渐渐变多，比如上周就用typescript写了，国际化的文本提取解析和替换（其中涉及到babel），也感觉到静态语言的强大。所以就慢慢的上手typescript咯。 代码-依赖收集-dep之前依赖收集这部分还是有点迷糊的，所以这次着重先去尝试着完全理解依赖收集这部分，尤其是Dep.target = null的上下文发生的事情。还是比较习惯先上代码来说话。 dep.js关于 Observer, Dep, Watcher相互间的联系总结出Dep的几句话： Dep实质是个数组，放置监听这个Observer的Watcher，当Observer对应的值变化时，就通知Dep中的所有Watcher执行callback。 闭包中的Dep保存这个键的Watcher Watcher该放进哪些Dep中规定一个全局变量，初始化null，依赖收集阶段，让全局变量指向Watcher。 主要还是Dep和Watcher是怎样的关系，这点容易迷糊。 代码 // util一些检验方法import &#123; remove &#125; from './util'import &#123; Watcher &#125; from './watcher'let uid = 0export default class Dep &#123; // Dep.target 即全局变量 public static target: Watcher | null = null public id: number public subs: Watcher[] constructor() &#123; this.id = uid++ this.subs = [] &#125; public addSub (sub: Watcher) &#123; this.subs.push(sub) &#125; public removeSub (sub: Watcher) &#123; remove(this.subs, sub) &#125; // Dep.target, ????? public depend () &#123; if (Dep.target) &#123; this.addSub(Dep.target) &#125; &#125; public notify() &#123; // 防止数组变化，先复制一份？??? const subs = this.subs.slice() for (let i = 0, l = subs.length; i &lt; l; i++) &#123; // Watcher上定义的update方法 subs[i].update() &#125; &#125;&#125;// 注意： 这里vuejs源码中还有加了一段。(vue/src/core/observer/dep.js, 318f29f on 10 Mar 2018)// the current target watcher being evaluated.// this is globally unique because there could be only one// watcher being evaluated at any time.// Dep.target = null// const targetStack = []// export function pushTarget(_target: ?Watcher) &#123;// if (Dep.target) targetStack.push(Dep.target)// Dep.target = _target // &#125;// export function popTarget () &#123;// Dep.target = targetStack.pop()// &#125; watcher.jsimport Dep from './dep'let uid = 0export class Watcher &#123; public id: number public value: any public target: any public getter: (target: any) =&gt; any public callback: (newVal: any, oldVal: any) =&gt; void constructor(target: any, expression: string, callback: (newVal: any, oldVal: any) =&gt; void) &#123; this.id = uid++ this.target = target this.getter = parsePath(expression) this.callback = callback this.value = this.get() &#125; /** * 依赖收集阶段 * Evaluate the getter, and re-collect dependencies. */ public get() &#123; // 进入依赖收集阶段 Dep.target = this let value: any const obj = this.target try &#123; // 调用getter,对应键的dep中放入了这个watcher value = this.getter(obj) &#125; finally &#123; // 退出依赖收集阶段 Dep.target = null &#125; return value &#125; public update() &#123; this.run() &#125; public run() &#123; this.getAndInvoke(this.callback) &#125; public getAndInvoke(cb: (newVal: any, oldVal: any) =&gt; void) &#123; // 监视目标为对象或数组的?? if (value !== this.value || isObject(value)) &#123; const oldVal = this.value this.value = value // 回调 cb.call(this.target, value, oldVal) &#125; &#125; // 简单的解析一个路径 const bailRE = /[^\w.$]/ functiono parsePath(path: string): any &#123; if (this.bailRE.test(path)) &#123; return &#125; const segments = path.split(".") return (obj: any) =&gt; &#123; for (const segment of segments) &#123; if (!obj) &#123; return &#125; obj = obj[segment] &#125; return obj &#125; &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day107-typescript实现promise]]></title>
    <url>%2F2019%2F04%2F29%2F2019-04-29%2F</url>
    <content type="text"><![CDATA[前言最近某个babel的项目的时候接触到了typescript，感觉这个世界还是静态语言的天下啊。赶紧学起来。当然学静态语言，单元测试也是很重要的一部分。但是这个过程看来有点漫长，慢慢来吧。本文主要是笔记，看别人怎么实现promisejs。先看看实现promise标准和比较完美的Bluebird方案。这篇文章有点扯，只是写了一部分，并没有写完全。0.0 实现（部分）接口type HandlerOnSuccess&lt;T, U = any&gt; = (value: T) =&gt; U | Thenable&lt;U&gt;;type HandlerOnFail&lt;U = any&gt; = (reason: any) =&gt; U | Thenable&lt;U&gt;;interface Handler&lt;T, U&gt; &#123; onSuccess: HandlerOnSuccess&lt;T, U&gt;; onFail: HandlerOnFail&lt;U&gt;;&#125; 构造器等class PQ&lt;T&gt; &#123; private state: States = States.PENDING private handlers: Handler&lt;T, any&gt;[] = [] private value: T | any public static errors = errors // 构造器constructor public constructor(callback: (resolve: Resolve&lt;T&gt;, reject: Reject) =&gt; void) &#123; try &#123; // 回调参数this.resolve,this.reject callback(this.resolve, this.reject) &#125; catch (error) &#123; this.reject(error) &#125; &#125; private setResult = (value: T | any, state: States) =&gt; &#123; const set = () =&gt; &#123; if (this.state !== States.PENDING) &#123; return null &#125; if (isThenable(value)) &#123; return (value as Thenable&lt;T&gt;).then(this.resolve, this.reject) &#125; this.value = value this.state = state return this.executeHandlers() &#125; setTimeout(set, 0) &#125;&#125; 参考Implementing Promises In JavaScript]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day106-promise-then方法]]></title>
    <url>%2F2019%2F04%2F28%2F2019-04-28%2F</url>
    <content type="text"><![CDATA[前言本文主要是then方法的实现，以及thenable的实现，then链式调用。 实现// promise then方法实现-笔记// Promise/A标准要求返回一个新对象，Promise/A+没有要求。// 注意：then方法里需要onResolved或者onRejected,必须符合标准thenableMyPromise.prototype.then= function (resolve, reject) &#123; const _self = this const myPromise // then方法需要是function onResolved = typeof onResolved === 'function' ? onResolved : function () &#123;&#125; onReject = typeof onReject === 'function' ? onReject : function () &#123;&#125; if (_self.status === 'resolved') &#123; return myPromise = new Promise(function (resolve, reject) &#123; try &#123; // 取onResolved结果 let x = onResolved(_self.data) // myPromise的onResolved的返回值是一个promise对象？ if (x instanceof Promise) &#123; x.then(resolve, reject) &#125; resolve(x) &#125; catch (error) &#123; reject(error) &#125; &#125;) &#125; if (_self.status === 'rejected') &#123; return myPromise = new Promise(function (resolve, reject) &#123; try &#123; let x = onReject(_self.data) if (x instanceof Promise) &#123; x.then(resolve, reject) &#125; // 当然是没有reject &#125; catch (error) &#123; reject(error) &#125; &#125;) &#125; if (_self.status === 'pending') &#123; // 放入数组中 return myPromise = new Promise(function (resolve, reject) &#123; _self.onResolvedCallback.push(function (value) &#123; try &#123; let x = onResolved(_self.data) if (x instanceof Promise) &#123; x.then(resolve, reject) &#125; &#125; catch (error) &#123; reject(error) &#125; &#125;) _self.onRejectedCallback.push(function (reason) &#123; // try...catch, 同上 &#125;) &#125;) &#125;&#125;// 根据值来决定myPromise的状态/** * Promise/A+标准规范 https://promisesaplus.com/#point-47 * @param &#123;*&#125; myPromise * @param &#123;*&#125; value onFulfilled or onRejected的结果 * @param &#123;*&#125; resolve * @param &#123;*&#125; reject */function resolvePromise(myPromise, value, resolve, reject) &#123; let then // 接到结果之后往后抛，then链式调用？ let thenCalledOrThrow = false if (myPromise === value) &#123;// 如果myPromise和value引用同一个对象，抛TypeError错,规范：2.3.1 return reject(new TypeError('value和myPromise引用的同一个对象')) &#125; if(value instanceof Promise) &#123;// 如果value是一个promise就用其声明， 2.3.2 if (value.status === 'pending') &#123; // value的最终状态并没有确定，就必须要等确定fulfilled或rejected， 2.3.2.1 value.then(function (value) &#123; resolvePromise(myPromise, value, resolve, reject) &#125;, reject) &#125; else &#123; // 确定了直接取值fulfilled或rejected 2.3.2.2 \ 2.3.2.3 value.then(resolve, reject) &#125; return &#125; // 实现的不是很详细，和标准规范可能有点出入。 if ((value !== null) &amp;&amp; ((typeof value === 'object') || (typeof value === 'function'))) &#123; try &#123; then = value.then // 如果检查到value.then的结果有错，则抛错 if (typeof then === 'function') &#123; then.call(value, function reject(err) &#123; if (thenCalledOrThrow) return // ??? thenCalledOrThrow = true return reject(err) &#125;) &#125; else &#123; resolve(value) &#125; &#125; catch (error) &#123; // if (thenCalledOrThrow) return thenCalledOrThrow = true return reject(e) &#125; &#125; else &#123; resolve(x) &#125;&#125; 参考剖析Promise内部结构]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day105-依据对象属性去重]]></title>
    <url>%2F2019%2F04%2F27%2F2019-04-27%2F</url>
    <content type="text"><![CDATA[前言直接上代码吧，这个稍微简单点。 let arr = [ [ '测', '测试2' ], [ '测', '测试2' ] ]// 根据属性去重function unique(arr) &#123; const res = new Map(); return arr.filter((a) =&gt; &#123; console.log(a[0]) return !res.has(a[0]) &amp;&amp; res.set(a[0], 1) &#125;)&#125;console.log(unique(arr))]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day103-vuejs源码-updateChildren（1）]]></title>
    <url>%2F2019%2F04%2F25%2F2019-04-25%2F</url>
    <content type="text"><![CDATA[前言主要是子节点中新老节点怎么相互去比较，替换。diff操作。 代码// vuejs 源码 updateChildren// 上一篇patchVnode中有这些参数的关系function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123; let oldStartIdx = 0; let newStartIdx = 0; let oldEndIdx = oldCh.length - 1; let oldEndVnode = oldCh[oldEndIdx] let newEndIdx = newCh.length - 1 let newStartVnode = newCh[0] let newEndVnode = newCh[newEndIdx] let oldKeyToIdx, idxInOld, elmToMove, refElm // removeOnly is a special flag used only by &lt;transition-group&gt; // to ensure removed elemtents stay in correct relative positions // during leaving transtions const canMove = !removeOnly // 新老节点两列，相互两两比较，直到某个相遇的点循环结束 while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (isUndef(oldStartVnode)) &#123; oldStartVnode = oldCh[++oldStartIdx] // vnode has been moved left &#125; else if (isUndef(oldEndVnode)) &#123; oldEndVnode = oldCh[--oldEndIdx] &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123; // 如果指定key是相同的就判定为同一个节点 // patchVnode = oldCh[++oldStartIdx] patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartVnode] &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; // 开始节点到结束节点判断是否相同 patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; // Vnode moved right // oldStartVnode和newEndVnode首尾相连，老的连在新的后面，进行pathchVnode之后，还要将真实DOM节点移到oldEndVnode的后面 patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue) canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; // Vnode moved left // oldEndVnode和newStartVnode首尾相连，新的连在老的后面 canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] &#125; else &#123; // 如果是交叉相连的，？？？ /* 引自参考https://github.com/answershuto 生成一个key与旧VNode的key对应的哈希表（只有第一次进来undefined的时候会生成，也为后面检测重复的key值做铺垫） 比如childre是这样的 [&#123;xx: xx, key: 'key0'&#125;, &#123;xx: xx, key: 'key1'&#125;, &#123;xx: xx, key: 'key2'&#125;] beginIdx = 0 endIdx = 2 结果生成&#123;key0: 0, key1: 1, key2: 2&#125; */ if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) /*如果newStartVnode新的VNode节点存在key并且这个key在oldVnode中能找到则返回这个节点的idxInOld（即第几个节点，下标）*/ idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null if (isUndef(idxInOld)) &#123; // New element /*newStartVnode没有key或者是该key没有在老节点中找到则创建一个新的节点*/ createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm) newStartVnode = newCh[++newStartIdx] &#125; else &#123; /*获取同key的老节点*/ elmToMove = oldCh[idxInOld] /* istanbul ignore if */ if (process.env.NODE_ENV !== 'production' &amp;&amp; !elmToMove) &#123; /*如果elmToMove不存在说明之前已经有新节点放入过这个key的DOM中，提示可能存在重复的key，确保v-for的时候item有唯一的key值*/ warn( 'It seems there are duplicate keys that is causing an update error. ' + 'Make sure each v-for item has a unique key.' ) &#125; if (sameVnode(elmToMove, newStartVnode)) &#123; /*如果新VNode与得到的有相同key的节点是同一个VNode则进行patchVnode*/ patchVnode(elmToMove, newStartVnode, insertedVnodeQueue) /*因为已经patchVnode进去了，所以将这个老节点赋值undefined，之后如果还有新节点与该节点key相同可以检测出来提示已有重复的key*/ oldCh[idxInOld] = undefined /*当有标识位canMove实可以直接插入oldStartVnode对应的真实DOM节点前面*/ canMove &amp;&amp; nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm) newStartVnode = newCh[++newStartIdx] &#125; else &#123; // same key but different element. treat as new element /*当新的VNode与找到的同样key的VNode不是sameVNode的时候（比如说tag不一样或者是有不一样type的input标签），创建一个新的节点*/ createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm) newStartVnode = newCh[++newStartIdx] &#125; &#125; &#125; &#125; if (oldStartIdx &gt; oldEndIdx) &#123; /*全部比较完成以后，发现oldStartIdx &gt; oldEndIdx的话，说明老节点已经遍历完了，新节点比老节点多，所以这时候多出来的新节点需要一个一个创建出来加入到真实DOM中*/ refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue) &#125; else if (newStartIdx &gt; newEndIdx) &#123; /*如果全部比较完成以后发现newStartIdx &gt; newEndIdx，则说明新节点已经遍历完了，老节点多余新节点，这个时候需要将多余的老节点从真实DOM中移除*/ removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx) &#125; &#125;&#125; 参考 learnVue]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day102-vuejs源码-patchVnode]]></title>
    <url>%2F2019%2F04%2F24%2F2019-04-24%2F</url>
    <content type="text"><![CDATA[前言主要是讲新旧节点是怎么判断进行替换的。 先理一下思路,这类的条件语句比较多,主要是节点和文本的替换，但是理完下来感觉还是蛮清爽的。 判断新旧节点同时存在，又是同一个节点，而且只能渲染一次，那么只需要相互替换组件实例就行 通过钩子，判断新老节点都有子节点oldCh的话，就对子节点进行diff，调用updateChildren方法 新旧节点，新节点有子节点，但是旧的没有，就清空旧的文本内容后，为当前DOM节点插入新节点 新旧节点，新节点没有子节点，但是旧的有，就移除该DOM节点的所有子节点 新旧节点都没有子节点的时候，就只是文本的替换 代码function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) &#123; if (oldVnode === vnode) &#123; return &#125; // reuse(重用) element for static trees // note we only do this if the vnode is cloned - // if the new node is not cloned it means the render functions have been // reset by the hot-reload-api and we need to do a proper re-render. // 比较新旧是否相同且新节点是否标记了once // 第一步 if (isTrue(vnode.isStatic) &amp;&amp; isTrue(oldVnode.isStatic) &amp;&amp; vnode.key === oldVnode.key &amp;&amp; (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) &#123; vnode.elm = oldVnode.elm vnode.componentInstance = oldVnode.componentInstance return &#125; // 第二步 let i const data = vnode.data // 判断钩子是否存在 if (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) &#123; i(oldVnode, vnode) &#125; const elm = vnode.elm = oldVnode.elm const oldCh = oldVnode.children const ch = vnode.children // 判断是否有子节点存在？ if (isDef(data) &amp;&amp;isPatchable(vnode)) &#123; for (i = 0; i &lt; cbs.update.length; ++i) &#123; cbs.update[i](oldVnode, vnode) &#125; if (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) &#123; i(oldVnode, vnode) &#125; &#125; // 有文本内容存在 if (isUndef(vnode.text)) &#123; if(isDef(oldCh) &amp;&amp; isDef(ch)) &#123; if (oldCh !== ch) &#123; updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly) &#125; &#125; else if (isDef(ch)) &#123; // 第三步 if (isDef(oldVnode.text)) &#123; nodeOps.setTextContent(elm, '') &#125; // 注意，这里要添加节点了！ addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue) &#125; else if (isDef(oldCh)) &#123; removeVnodes(elm, oldCh, 0, oldCh.length -1) &#125; else if (isDef(oldVnode.text)) &#123; // 只有老节点有子节点 nodeOps.setTextContent(elm, '') &#125; &#125; else if (oldVnode.text !== vnode.text) &#123; // 设置文本内容，条件语句走到最后 nodeOps.setTextContent(elm, vnode.text) &#125; // 调用postpatch钩子 if (isDef(data)) &#123; if(isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) &#123; i(oldVnode, vnode) &#125; &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day101-vuejs源码-patch-笔记]]></title>
    <url>%2F2019%2F04%2F23%2F2019-04-23%2F</url>
    <content type="text"><![CDATA[前言本文主要是记录下读vuejs源码中virtualDom部分，注释一小部分的patch核心diff算法。算法通过同层的树节点进行比较而非对树进行逐层搜索遍历的方式，所以时间复杂度只有O(n)，是一种相当高效的算法下面截取的代码部分是createPatchFunction(一个patch函数)的返回值， oldValue 与 vnode在sameVnode的时候才会进行patchVnode。 代码return function patch(oldValue, vnode, hydrating, removeOnly, parentElm, refElm) &#123; // vnode不存在则直接销毁钩子 if (isUndef(vnode)) &#123; if (isDef(oldVnode)) invokeDestroyHook(oldValue) return &#125; let isInitialPatch = false const insertedVnodeQueue = [] if (isUndef(oldVnode)) &#123; // 空挂载（像是组件），创建新的root节点 // oldValue未定义时，即为root节点时，创建一个新节点 isInitialPatch = true createElm(vnode, insertedVnodeQueue, parentElm, refElm) &#125; else &#123; // 标记旧的VNode是否有nodeType ?? const isRealElement = isDef(oldVnode, vnode) if (!isRealElement &amp;&amp; sameVnode(oldValue, vnode)) &#123; patchVnode(oldValue, vnode, insertedVnodeQueue, removeOnly) &#125; else &#123; if (isRealElement) &#123; // 挂载到一个真的节点 // 检查是否是服务端渲染的内容且if we can perform a successful hydration(是否我们可以合并到真实DOM) if (oldVnode.nodeType === 1 &amp;&amp; oldValue.hasAttribute(SSR_ATTR)) &#123; oldVnode.removeAttribute(SSR_ATTR) hydrating = true &#125; if (isTrue(hydrating)) &#123; // 需要合并到真实DOM if(hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123; invokeInsertHook(vnode, insertedVnodeQueue, true) return oldValue &#125; else if (ProcessingInstruction.env.NODE_ENV !== 'production') &#123; warn( 'The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing ' + 'full client-side render.' ) &#125; &#125; // 如果不是服务端渲染或者合并到真实DOM失败，则创建一个空的VNode节点替换它 oldValue = emptyNodeAt(oldVnode) &#125; // 取代现有元素 const oldElm = oldValue.elm const parentElm = nodeOps.parentNode(oldElm) createElm( vnode, insertedVnodeQueue, // ??? // extremely rare edge case: do not insert if old element is in a // leaving transition. Only happens when combining transition + // keep-alive + HOCs. (#4590) oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm) ) if (isDef(vnode.parent)) &#123; // 组件根节点被替换，遍历更新父节点element let ancestor = vnode.parent while (ancestor) &#123; ancestor.elm = vnode.elm ancestor = ancestor.parent &#125; if (isPatchable(vnode)) &#123; // 调用create回调 for (let i = 0; i &lt; cbs.create.length; ++i) &#123; cbs.create[i](emptyNode, vnode.parent) &#125; &#125; &#125; if (isDef(parentElm)) &#123; // 移除老节点 removeVnodes(parentElm, [oldValue], 0, 0) &#125; else if (isDef(oldValue.tag)) &#123; invokeDestroyHook(oldVnode) &#125; &#125; &#125; invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch) return vnode.elm&#125; 参考learnVue]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day100-vuejs源码-VNode笔记]]></title>
    <url>%2F2019%2F04%2F22%2F2019-04-22%2F</url>
    <content type="text"><![CDATA[前言 vuejs中的VirtualDOM（VNode）在重新渲染ViewModel时非常重要。什么时候调用？ 数据变化 -&gt; set监测到 -&gt;dep.notify()通知Watcher -&gt;Watcher调用其get()监测新值之后update()??还是直接通过get方法执行vm._update(vm._render(), hydrating) _update方法Vue.prototype._update = function (vnode: VNode, hydrating?: Boolean) &#123; const vm: Component = this if (vm._isMounted) &#123; callHook(vm, 'beforeUpdate') &#125; const prevEl = vm.$el const prevVnode = vm._vnode const prevActiveInstance = activeInstance activeInstance = vm vm._vnode = vnode // Vue.prototype.__patch__ is injected in entry points // based on the rendering backend used. // _patch_被用作一个入口 if (!prevVnode) &#123; // initial render,新老vnode节点相比较 vm.$el = vm.__patch__( vm.$el, vnode, hydrating, false, vm.$options._parentElm, vm.$options._refElm ) &#125; else &#123; // updates vm.$el = vm.__patch__(prevVnode, vnode) &#125; activeInstance = prevActiveInstance // update __vue__ reference if (vm.$el) &#123; vm.$el.__vue__ = vm &#125; // if parent is an HOC, update its $el as well if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123; vm.$parent.$el = vm.$el &#125; // updated hook is called by the scheduler to ensure that children are // updated in a parent's updated hook.&#125; 参考 VirtualDOM与diff(Vue实现).MarkDown]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day99-双向绑定-Compile]]></title>
    <url>%2F2019%2F04%2F21%2F2019-04-21%2F</url>
    <content type="text"><![CDATA[前言在之前的讨论中，漏掉了解析模板指令模块Compile。这里摘抄一个作者实现的案例。另外，上一篇也有大量参考该作者该案例，说明下。该作者文章详情 代码单独看的话有点难理解啊。Compile.prototype = &#123; // ... 省略 compileElement: function(el) &#123; let childNodes = el.childNodes, me = this; // 遍历所有节点及其子节点 [].slice.call(childNodes).forEach(function(node) &#123; let text = node.textContent // 表达式文本 let reg = /\&#123;\&#123;(.*)\&#125;\&#125;/ // 文本正则 // 按元素节点方式编译,这里要区分Text? if (me.isElementNode(node)) &#123; me.compile(node) &#125; else if (me.isTextNode(node) &amp;&amp; reg.test(text)) &#123; me.compileText(node, RegExp.$1) &#125; // 遍历编译子节点(递归) if (node.childNodes &amp;&amp; node.childNodes.length) &#123; me.compileElement(node) &#125; &#125;) &#125;, // 这里有点不好理解 compile: function(node) &#123; let nodeAttrs = node.attributes, me = this; [].slice.call(nodeAttrs).forEach(function(attr) &#123; // 规定：指令以 v-xxx 命名 // 如 &lt;span v-text="content"&gt;&lt;/span&gt; 中指令为 v-text let attrName = attr.name // v-text if (me.isDirective(attrName)) &#123; let exp = attr.value // content let dir = attrName.substring(2) // text if (me.isEventDirective(dir)) &#123; // 事件指令, 如 v-on:click compileUtil.eventHandler(node, me.$vm, exp, dir) &#125; else &#123; // 普通指令 compileUtil[dir] &amp;&amp; compileUtil[dir](node, me.$vm, exp) &#125; &#125; &#125;) &#125;&#125;// 指令处理集合let compileUtil = &#123; text: function(node, vm, exp) &#123; this.bind(node, vm, exp, 'text') &#125;, // ...省略 bind: function(node, vm, exp, dir) &#123; let updaterFn = updater[dir + 'Updater'] // 第一次初始化视图 updaterFn &amp;&amp; updaterFn(node, vm[exp]) // 实例化订阅者，此操作会在对应的属性消息订阅器中添加了该订阅者watcher new Watcher(vm, exp, function(value, oldValue) &#123; // 一旦属性值有变化，会收到通知执行此更新函数，更新视图 updaterFn &amp;&amp; updaterFn(node, value, oldValue) &#125;) &#125;&#125;// 更新函数,调用对应的指令更新函数进行绑定let updater = &#123; textUpdater: function(node, value) &#123; node.textContent = typeof value == 'undefined' ? '' : value &#125; // ...省略&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day98-双向绑定中的依赖收集-浅浅浅析]]></title>
    <url>%2F2019%2F04%2F20%2F2019-04-20%2F</url>
    <content type="text"><![CDATA[前言vuejs-双向绑定中的Dep.target（即依赖收集）要从双向绑定思路说起（这里的双像绑定当然指的是vuejs的数据劫持+发布者-订阅者模式）。 model-view-viewmodel实现思路首先要实现Observer，监听属性变动（数据劫持）。实现时将observe的对象进行递归遍历，包括子属性对象的属性，都加上setter和getter,使其都能监听数据变化（用递归）。监听变化之后？通知订阅者用一个数组来收集订阅者，数据变动就通知（notify()），之后再进行更新（update()）。谁是订阅者？如何往订阅器中添加订阅者？通过dep（即dependency）来添加订阅者（Watcher），但是dep要在监听变化时通知订阅者。那么就可能需要闭包操作（Dep.target，即可以在Dep定义一个全局target属性）,在监听时检测到数据就在闭包内暂存watcher WatcherWatcher订阅者作为Oberver和Compile之间通信的桥梁自身实例化时往属性订阅器(dep)里面添加自己自己有一个update() 方法，等属性变动时属性订阅器通知再调用update()方法，触发COmplie中绑定的回调。Dep.target在watcher中的get方法时。会用到依赖收集。Dep.target = this; // 将当前订阅者指向自己let value = this.obj[key]; // 触发getter，添加自己到属性订阅器中Dep.target = null; // 添加完毕，重置 实例化Watcher时，调用get()方法，通知Dep.target = watcherInstance标记订阅者时当前watcher实例可以触发属性定义的getter方法，然后在属性的订阅器dep添加当前watcher实例（即将当前订阅者指向自己）使得属性值变化的时候，watcherInstance收到更新通知。一个基本的思路大概就是这些，一步步建立起来的逻辑。可能有些地方还没有理清楚，需要再加深理解。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day97-Proxy-实现观察者模式]]></title>
    <url>%2F2019%2F04%2F19%2F2019-04-19%2F</url>
    <content type="text"><![CDATA[前言Vue3.0之后用Proxy代替Object.defineProperty。来尝个鲜，看看怎样实现一个简单的观察者模式。 代码class Dep &#123; // 添加订阅者，通知变化（依赖收集类Dep） constructor() &#123; this.subs = new Set() &#125; addSub(sub) &#123; // 添加订阅者 this.subs.add(sub) &#125; notify(key) &#123; // 通知订阅者更新 // 修改data中数据的时候会触发Watcher的notify，从而回调渲染函数 this.subs.forEach(sub =&gt; &#123; sub.update() &#125;) &#125;&#125;class Watcher &#123; // 观察者，订阅数据变化，绑定更新函数，添加订阅者，更新视图 constructor(obj, key, cb) &#123; this.obj = obj, this.key = key, this.cb = cb // 回调 this.value = this.get() &#125; get() &#123; // 将自身添加到dep中 // 观察者Watcher实例赋值给全局的Dep.target // 触发render操作只有被Dep.target标记过的才会进行依赖收集 Dep.target = this // 将当前订阅者指向自己 let value = this.obj[this.key] // 触发getter，添加自己到属性订阅器中 Dep.target = null // 添加完毕，重置 return value &#125; update () &#123; // 观察是否有新的值 let newVal = this.obj[this.key] if (this.value !== newVal) &#123; this.cb(newVal) this.value = newVal &#125; &#125;&#125;function Observer (obj) &#123; // 劫持监听所有属性 Object.keys(obj).forEach(key =&gt; &#123; if (typeof obj[key] === 'object') &#123; obj[key] = Observer(obj[key]) &#125; &#125;) let dep = new Dep() let handler = &#123; get: function (target, key, receiver) &#123; // 依赖收集的时候回addSub到sub中 Dep.target &amp;&amp; dep.addSub(Dep.target) return Reflect.get(target, key, receiver) &#125;, set: function (target, key, value, receiver) &#123; let result = Reflect.set(target, key, value, receiver) dep.notify() // 发布 return result &#125; &#125; return new Proxy(obj, handler)&#125;// 例子let data = &#123; name: 'lmislm'&#125;function who(data) &#123; console.log('my name is', data)&#125;function what(data) &#123; console.log('just do', data)&#125;data = Observer(data)new Watcher(data, 'name', who)// 新值旧值一样需要判断data.name = 'lmislm2'new Watcher(data, 'what', what)data.what = 'IT'// my name is lmislm2// just do IT]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day96-ES6-类机制]]></title>
    <url>%2F2019%2F04%2F18%2F2019-04-18%2F</url>
    <content type="text"><![CDATA[前言 类机制核心-关键字-class表示一个块-定义一个函数原型的成员。 ES6中增加了语法糖extends和super。extends 用来在两个函数原型之间建立[[Prototype]]委托链接，即所谓的“原型继承” extends和super 注意super不同位置起的作用。 class Foo &#123; constructor(a, b) &#123; this.x = a this.y = b &#125; gXYZ () &#123; return this.x * this.y &#125;&#125;// 把Bar.prototype的[[Prototype]]连接到Foo.prototypeclass Bar extends Foo &#123; constructor(a, b , c) &#123; // super具体指Foo super(a, b) this.z = c &#125; gXYZ () &#123; // super具体指Foo.prototype return super.gXYZ() * this.z &#125;&#125;let b = new Bar(5, 1, 4)console.log(b.x) // 5console.log(b.y) // 1console.log(b.z) // 4console.log(b.gXYZ()) // 20]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day95-join(..)简单实现]]></title>
    <url>%2F2019%2F04%2F17%2F2019-04-17%2F</url>
    <content type="text"><![CDATA[前言实现简单的join()方法。 代码// fakeJoin(arr, connector)function fakeJoin(arr, connector) &#123; let str = '' for (let i = 0; i &lt; arr.length; i++) &#123; if (i &gt; 0) &#123; str += connector &#125; if (arr[i] !== undefined) &#123; str += arr[i] &#125; &#125; return str&#125;let a = new Array(3)console.log(fakeJoin(a, '-'))]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day94-寄生组合式继承]]></title>
    <url>%2F2019%2F04%2F16%2F2019-04-16%2F</url>
    <content type="text"><![CDATA[前言组合式继承存在一定的局限性，即为了得到一个副本，去指定子类型的原型而调用超类型的构造函数。可以通过借用构造函数来继承属性，通过原型链混成形式来继承方法。不用为了指定子类型的原型而调用超类型的构造函数,再将结果指定给子类型的原型。本质上就是用寄生式组合继承来继承超类型的原型，然后将结果指定给子类型的原型。 Photo by Jenny Caywood on Unsplash 简单形式简单的寄生式组合继承组合形式。function inheritPrototype (subType, superType) &#123; // 创建对象，创建超类型副本 let prototype = object(superType.prototype) // 增强对象，添加属性constructor,弥补因重写类型失去默认的constructor属性 prototype.constructor = subType // 指定对象，将新创建的对象赋值给子类型的原型 subType.prototype = prototype&#125; 应用替换为子类型原型赋值的语句（例子详情参考组合继承）function SuperType (name) &#123; this.name = name this.colors = ['red', 'blue', 'green']&#125;SuperType.prototype.sayName = function () &#123; console.log(this.name)&#125;function SubType(name, age) &#123; SuperType.call(this, name) this.age = age&#125;// SubType.prototype = new SuperType()// SubType.prototype.constructor = SubType// SubType.prototype.sayAge = function () &#123;// console.log(this.age)// &#125;// 替换inheritPrototype(SubType, SuperType)SubType.prototype.sayAge = function () &#123; console.log(this.age)&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day93-组合继承]]></title>
    <url>%2F2019%2F04%2F15%2F2019-04-15%2F</url>
    <content type="text"><![CDATA[前言原型链虽然很强大，但是实现继承还是存在一些问题的。比如引用类型值问题。当然这个问题的解决也有一些，如用apply()，call()，或是借用构造函数。 apply() call() 解决原型中包含引用类型值所带来问题的过程中。可以借用构造函数。// --即在子类型构造函数的内部调用超类型构造函数。// --也可以用apply()和call()方法在新创建的对象上执行构造函数。function SuperType() &#123; this.colors = ['red', 'blue', 'green'] &#125;function SubType() &#123; // 继承了SuperType,解决饮用类型值问题 SuperType.call(this)&#125;// 直接继承的写法，会导致引用类型值问题// SubType.prototype = new SuperType()let instance1 = new SubType()instance1.colors.push('black')console.log(instance1.colors)let instance2 = new SubType()console.log(instance2.colors) 借用构造函数 组合继承function SuperType(name) &#123; this.name = name this.colors = ['red', 'blue', 'black']&#125;SubType.prototype.sayName = function () &#123; console.log(this.name)&#125;function SubType(name, age) &#123; SuperType.call(this, name) this.age = age&#125;// 继承方法SubType.prototype = new SuperType()SubType.prototype.constructor = SubType()SubType.prototype.sayAge = function () &#123; console.log(this.age)&#125;let instance11 = new SubType('zhangsan', 12)// 继承了SuperType()instance11.colors.push('black')console.log(instance11.colors) // 'red, blue, black'instance11.sayName() // 'zhangsan'instance11.sayAge() // 12]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day92-promise单一值传递（局限性）]]></title>
    <url>%2F2019%2F04%2F13%2F2019-04-13%2F</url>
    <content type="text"><![CDATA[前言promise只能是一个完成值和一个拒绝理由。但是这造成了现状只能是构造一个值封装来保存多个信息。 Photo by Min Wu on Unsplash Promise的分裂值异步产生的两个值，封装到一个数组值中通过promise传输function getY(x) &#123; return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve((3*x) - 1) &#125;, 100) &#125;)&#125;function foo(bar, baz) &#123; let x = bar * baz return getY(x) .then(function(y) &#123; // 把两个值封装在容器中 return [x, y] &#125;)&#125;foo (10, 20).then(function (msg) &#123; let x = msgs[0] let y = msgs[1] console.log(x, y) // 200 599&#125;) 展开/传递参数利用apply.bind的技巧。function spread (fn) &#123; return Function.apply.bind(fn, null)&#125;Promise.all(foo(10, 20)).then(spread(function (x, y) &#123; console.log(x, y) // 200 599&#125;)) 数组解构赋值ES6这个比上面的都更加的灵活。Promise.all(foo(10, 20)).then(function (msgs) &#123; let [x,y] = msgs console.log(x, y) // 200 599&#125;) 更好的。Promise.all(foo(10, 20)).then(function ([x,y]) &#123; console.log(x,y) // 200 599&#125;)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day91-Promise的并发迭代]]></title>
    <url>%2F2019%2F04%2F12%2F2019-04-12%2F</url>
    <content type="text"><![CDATA[前言多任务执行。对所有Promise执行某个任务。 实现版本一// Promise 的并发迭代// 不太好的方法if (!Promise.map) &#123; Promise.map = function (vals, cb) &#123; // 一个等待所有map的promise的新promise return Promise.all( // 一般数组把map(..),把值数组转换成为promise数组 vals.map(function (val) &#123; // 用val异步map之后决议的新promise替换val return new Promise(function (resolve) &#123; cb(val, resolve) &#125;) &#125;) ) &#125;&#125;// 这里不能发送异步reject信号，映射的回调中(cb(..))出现同步的异常或错误// 主Promise.map(..)返回的Promise就会拒绝 较好的方法// 较好的方法let p1 = Promise.resolve(21)let p2 = Promise.resolve(42)let p3 = Promise.resolve('oops 404')// 列表值加倍，即使是在Promise中Promise.map([p1,p2,p3], function (pr, done) &#123; // 保证这一条本身就是Promise Promise.resolve(pr) .then( // 提取值作为v function (v) &#123; // map完成的v到新值 done(v*2) &#125;, // 或者map到promise拒绝消息 done )&#125;).then(function (vals) &#123; console.log(vals) // [42, 84, 'oops 404]&#125;)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day90-支持Promise的Generator Run]]></title>
    <url>%2F2019%2F04%2F11%2F2019-04-11%2F</url>
    <content type="text"><![CDATA[前言专门处理。生成器yield出Promise，然后其控制生成器的迭代器来执行它，直到结束。 Photo by Johannes Krupinski on Unsplash 代码function run (gen) &#123; let args = [].slice.call(arguments, 1), it // 在当前上下文初始化生成器 it = gen.apply(this, args) // 返回一个promise用于生成器完成 return Promise.resolve() .then(function handleNext(value) &#123; // 对下一个yield出的值运行 let next = it.next(value) return (function handleResult(next) &#123; // 生成器运行完毕了吗 if (next.done) &#123; return next.value &#125; else &#123; //否则继续运行 return Promise.resolve(next.value) .then( // 成功就恢复异步循环，把决议的值发回生成器 handleNext, // 如果value是被拒绝的promise // 就把错误传回生成器进行出错处理 function handleErr (err) &#123; return Promise.resolve( it.throw(err) ) .then(handleResult) &#125; ) &#125; &#125;)(next) &#125;)&#125; 应用function *main() &#123; // ..&#125;run(main)// 自动异步运行你传给它的生成器]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day89-回调未调用（Promise）]]></title>
    <url>%2F2019%2F04%2F10%2F2019-04-10%2F</url>
    <content type="text"><![CDATA[前言回调函数本身包含JavaScript错误，Promise本身永远不被决议。怎么办？ 竞态(高级抽象机制)// 用于超时一个Promise的工具function timeoutPromise (delay) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject('timeout!') &#125;, delay) &#125;)&#125;// 设置foo()超时Promise.race([ foo(), timeoutPromise(3000)]).then( function () &#123; // foo(..)及时完成 &#125;, function (err) &#123; // 或者foo()被拒绝，只是没能按时完成 // 查看err来了解是哪种情况 &#125;)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day88-异步迭代生成器]]></title>
    <url>%2F2019%2F04%2F09%2F2019-04-09%2F</url>
    <content type="text"><![CDATA[前言本文展示一个任务流程控制，通过生成器来解决解决回调问题。 Photo by Dan Magatti on Unsplash 回调方法function foo(x, y, cb) &#123; ajax( 'http://some.url.1', cb )&#125;foo (11, 32, function(err, next) &#123; if (err) &#123; console.error(err) &#125; else &#123; console.log(text) &#125;&#125;) 生成器方法实现// 通过生成器来表达同样的任务流程控制function foo(x, y) &#123; ajax( 'http://some.url.1', function(err, next) &#123; if (err) &#123; // 向*main()抛出一个错误 it.throw(err) &#125; else &#123; // 响应数据恢复生成器 it.next(data) &#125; &#125; )&#125;function *main() &#123; try &#123; // 重要的部分。调用一个普通函数foo(..),且能从ajax调用中得到text,即使函数是异步。 let text = yield foo(11, 31) console.log(text) &#125; catch (err) &#123; console.error(err) &#125;&#125;let it = main()// 启动！it.next()]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day87-生成器迭代器]]></title>
    <url>%2F2019%2F04%2F08%2F2019-04-08%2F</url>
    <content type="text"><![CDATA[前言生成器实现day86中的something无限数字序列生产者 Photo by Paulin Malet on Unsplash 实现生产者function *something() &#123; let nextVal while (true) &#123; if (nextVal === undefined) &#123; nextVal = 1 &#125; else &#123; nextVal = (3 * nextVal) + 6 &#125; // 生成器在每次迭代中暂停. // 通过yield返回到主程序或事件循环队列中。 // --函数*something()的作用域会被保持（即不需要闭包在调用直接保持变量作用域） yield nextVal &#125;&#125; 应用for…of循环使用*something()生成器 注意这里是something()而不是something。因为这里something是生成器不是迭代器。something()调用产生一个迭代器，但是for…of需要一个iterable（可迭代：一个包含在其值上迭代的迭代器的对象）。这是因为生成器的迭代器也有一个Symbol.iterator函数,而这个函数做的就是return this,和之前迭代器里定义的iterable something一样，即生成器的迭代器也是一个iterable（可迭代）。 for (let v of something()) &#123; console.log(v) // 不要死循环 if (v &gt; 500) &#123; break &#125;&#125;// 1 9 33 105 321 969]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day86-生产者与迭代器]]></title>
    <url>%2F2019%2F04%2F07%2F2019-04-07%2F</url>
    <content type="text"><![CDATA[前言假定你要产生一系列值，其中每个值都与前面一个有特定的关系。要实现这一点，需要一个有状态的生产者能够记住其生成的最后一个值。 生产者与迭代器（实现一个直接使用函数闭包的版本）/** * 数字序列生成器 */let gimmeSomething = (function () &#123; let nextVal return function () &#123; if (nextVal === undefined) &#123; nextVal = 1 &#125; else &#123; nextVal = (3 * nextVal) + 6 &#125; return nextVal &#125;&#125;)()注意这里console一个和多个是不一样的console.log(gimmeSomething()) // 1console.log(gimmeSomething()) // 9console.log(gimmeSomething()) // 33 为数字迭代生成器生成标准的迭代器接口迭代器是一个定义好的借口，用于从一个生产者一步步得到一系列值。JavaScript 迭代器的接口，与多数语言类似，就是每次想要从生产者得到下一个值的时候调用next()let something = (function () &#123; let nextVal return &#123; // for...of循环需要 [Symbol.iterator]: function () &#123; return this &#125;, // 标准迭代器接口方法 next: function () &#123; if (nextVal === undefined) &#123; nextVal = 1 &#125; else &#123; nextVal = (3 * nextVal) + 6 &#125; return &#123; done: false, value: nextVal &#125; &#125; &#125;&#125;)()console.log(something.next().value) // 1console.log(something.next().value) // 9 参考引自：《你不知道的JavaScript - 中》]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day85-事件循环最基本的伪代码]]></title>
    <url>%2F2019%2F04%2F06%2F2019-04-06%2F</url>
    <content type="text"><![CDATA[事件循环通过一小段伪代码来了解一下这个“事件循环”概念。 // 事件循环伪代码// event loop是一个用作队列的数组let eventLoop = []let event// 永远执行while (true) &#123; // 一次tick if (eventLoop.length &gt; 0) &#123; // 拿到队列的下一个事件 event = eventLoop.shift() // 现在，执行下一个事件 try &#123; event() &#125; catch (error) &#123; reportError(err) &#125; &#125;&#125;// 注意setTimeOut()并没有把你的回调函数挂在事件循环队列中，只是设定一个定时器。// 当定时器到时后，环境会把你的回调函数放在事件循环中，这样，在未来某个时刻的tick就会摘下// 并执行这个回调。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day84-实现原型链(基本模式)]]></title>
    <url>%2F2019%2F04%2F05%2F2019-04-05%2F</url>
    <content type="text"><![CDATA[碎碎念 实现原型链有一种基本模式，其代码大致如下。 // 实现原型链 基本模式function SuperType () &#123; this.property = true&#125;SuperType.prototype.getSuperValue = function () &#123; return this.property&#125;function SubType() &#123; this.subproperty = false&#125;SubType.prototype = new SuperType()SubType.prototype.getSuperValue = function () &#123; return this.subproperty&#125;let instance = new SubType()console.log(instance.getSuperValue()) // true]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day83-element表格列合并]]></title>
    <url>%2F2019%2F04%2F04%2F2019-04-04%2F</url>
    <content type="text"><![CDATA[表格合并(跨行或者跨列）有个小需求是表格根据某些属性来合并。element官方提供了方法。但是没有详细的例子。这里记录下一个小例子。 例子// 这里的实现方法可以变化，但是大体思路是一样的。找到某个元素上下前后元素是否相等，相等则为0。getSpanArr(data) &#123; for (var i = 0; i &lt; data.length; i++) &#123; if (i === 0) &#123; this.spanArr.push(1); this.pos = 0 &#125; else &#123; // 判断当前元素与上一个元素是否相同 // 这里其实可以简化成table的属性。改成可以配置的选项。 if (data[i].name === data[i - 1].name) &#123; this.spanArr[this.pos] += 1; this.spanArr.push(0); &#125; else &#123; this.spanArr.push(1); this.pos = i; &#125; &#125; &#125;&#125; element :span-method=”cellMerage”\ cellMerge(&#123; row, column, rowIndex, columnIndex &#125;) &#123; if (columnIndex === 0) &#123; const _row = this.spanArr[rowIndex]; const _col = _row &gt; 0 ? 1 : 0; return &#123; rowspan: _row, colspan: _col &#125; &#125;&#125; 原文：https://blog.csdn.net/qq_29468573/article/details/80742646]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day82-中文排序]]></title>
    <url>%2F2019%2F04%2F03%2F2019-04-03%2F</url>
    <content type="text"><![CDATA[碎碎念最近有中文排序的需求，这种排序要根据中文推出中文拼音然后再排序。所以免不了查字典。这类的还是比较成熟的，有成熟的方案。比如pinyin.js。 pinyin.js安装 npm i pinyin 下面以对象的排序为例，其实这个例子官方文档是有的。需要看仔细的可以去官方文档看，还是较为详细的。这里只是简单地引导一下。 const pinyin = require('pinyin')let data = [&#123;a: '牛', b: '11'&#125;, &#123;a: '啊', b: '22'&#125;, &#123;a: '到', b: '33'&#125;, &#123;a: 'ab', b: '53'&#125;]// console.log(data.sort(pinyin.compare(a)))// const data = '我要排序'.split('');// 建议将汉字的拼音持久化存储起来。// const pinyinData = data.map(han =&gt; (&#123;// zi: han.a,// py: pinyin(han.a)[0][0], // 可以自行选择不同的生成拼音方案和风格。// &#125;))const pinyinData = data.map(han =&gt; (&#123; ...han, py: pinyin(han.a)[0][0], // 可以自行选择不同的生成拼音方案和风格。&#125;))const sortedData = pinyinData.sort((a, b) =&gt; &#123; return a.py.localeCompare(b.py);&#125;).map(d =&gt; &#123; return d.zi&#125;);console.log(pinyinData)console.log(sortedData)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day81-了解无头浏览器Puppeteer]]></title>
    <url>%2F2019%2F04%2F02%2F2019-04-02%2F</url>
    <content type="text"><![CDATA[前言无头浏览器主要是用代码来模拟浏览器操作，如摘取页面元素，进行用户名和密码输入等无界面操作。下面的例子主要是站在JS的角度用Puppeteer来进行简单的了解。因为最近有个小东西可能需要用到。 一小段例子先安装 npm i puppeteer const puppeteer = require('puppeteer');async function getPic() &#123; const browser = await puppeteer.launch(&#123;headless: false&#125;) const page = await browser.newPage() // 指定跳向某个页面 await page.goto('https://zhidao.baidu.com/question/446485875.html') // 截图操作 await page.screenshot(&#123;path: 'hello-world.png'&#125;) // await page.waitForNavigation('load') // await page.click('#evaluate-3025447784') // await page.evaluate(() =&gt; &#123; // document.querySelector('#evaluate-3025447784').click() // console.log(window.document.querySelector('#evaluate-3025447784')) // &#125;) // 清空浏览器的cookies // await page._client.send('Network.clearBrowserCookies') await browser.close()&#125;getPic() 打开浏览器，跳转到指定页面，然后截图之后关闭浏览器。整个过程为异步进行。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day80-vuejs源码解析]]></title>
    <url>%2F2019%2F04%2F01%2F2019-04-01%2F</url>
    <content type="text"><![CDATA[碎碎念今天就是想简单的讲讲Vuejs源码中一些比较重要的部分。 愚人节快乐！！：）Vuejs源码解析正在研读中哈]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day79-理由-休息]]></title>
    <url>%2F2019%2F03%2F31%2F2019-03-31%2F</url>
    <content type="text"><![CDATA[碎碎念相信我，今天虽然是玩了一会儿游戏，但是我还是看书了的。红宝书还是看了一些的。所以今天主要还是玩了一天。我怎么这么能玩，立下的一些flag都要倒下了？]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day78-订阅发布者模式]]></title>
    <url>%2F2019%2F03%2F30%2F2019-03-30%2F</url>
    <content type="text"><![CDATA[订阅者-发布者模式前言，最近这个模式非常的火。刚好看书又看到这里。所以就跟着敲了一遍代码，把最基本的思想理了下。 小例子/** * * 订阅者-发布者模式（添加给所有对象） */let event = &#123; clientList: [], // 缓存对象，存放订阅者的回调函数 listen: function (key, fn) &#123; // 订阅消息 if (!this.clientList[key]) &#123; this.clientList = [] // 如果没有订阅过key类的消息，创建一个缓存列表 &#125; this.clientList[key].push(fn) // 订阅消息加入缓存列表 &#125;, trigger: function () &#123; // 发布消息 let key = Array.prototype.shift.call(arguments) let fns = this.clientList[key] if (!fns || fns.length === 0) &#123; return false &#125; for (let i = 0, fn; fn = fns[i++];) &#123; fn.apply(this, arguments) &#125; &#125;&#125;// 给所有对象动态安装发布-订阅功能let installEvent = function (obj) &#123; for (let i in event) &#123; obj[i] = event[i] &#125;&#125;// 实例-给对象salesOffices 动态增加发布-订阅功能let salesOffices = &#123;&#125;installEvent(salesOffices)salesOffices.listen('squareMeter88', function (price) &#123; console.log('price=' + price)&#125;)salesOffices.listen('squareMeter100', function (price) &#123; console.log('price=' + price)&#125;)salesOffices.trigger('squareMeter88', 200000)salesOffices.trigger('squareMeter100', 300000) end-]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day77-理由-休息]]></title>
    <url>%2F2019%2F03%2F29%2F2019-03-29%2F</url>
    <content type="text"><![CDATA[碎碎念明天有双休了！！yeah!]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day76-理由-修bug]]></title>
    <url>%2F2019%2F03%2F28%2F2019-03-28%2F</url>
    <content type="text"><![CDATA[碎碎念最近是真的比较忙啊。虽然比较忙，但是从平时的一些聊天中还是感觉到和别人的一些差距。这个还是要靠平时多做做题目来补全啊。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day75-理由-犯困]]></title>
    <url>%2F2019%2F03%2F27%2F2019-03-27%2F</url>
    <content type="text"><![CDATA[碎碎念这段时间果然记录下来是有点用处的！发现自己偷懒的轨迹了。自己一无所成啊。这些天都是以繁忙为借口，一直在逃避写一篇好的日志。这样是不行的啊。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day74-理由-提测]]></title>
    <url>%2F2019%2F03%2F26%2F2019-03-26%2F</url>
    <content type="text"><![CDATA[碎碎念最近项目终于开始提测了！这是比较好的事。然后就是最近阮一峰的ES6看了一遍了！现在开始准备看Vue技术揭秘，这是源码级别了吧！这是第二次想要阅读源码了！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day73-理由-心累]]></title>
    <url>%2F2019%2F03%2F25%2F2019-03-25%2F</url>
    <content type="text"><![CDATA[碎碎念今天又是一天，一直忙活项目的事情。暂时水到这里吧。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day72-理由-懈怠]]></title>
    <url>%2F2019%2F03%2F24%2F2019-03-24%2F</url>
    <content type="text"><![CDATA[碎碎念今天一口气喝了一罐红牛，突然感觉有点晕晕的啊。很久没有锻炼？看来是时候好好锻炼下！他们今天三个人，下楼打球，才打了半个小时就气喘嘘嘘上来了，我肯定也不例外啊，身体素质肯定又下去了！一定要锻炼啊！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day71-理由-紧张]]></title>
    <url>%2F2019%2F03%2F23%2F2019-03-23%2F</url>
    <content type="text"><![CDATA[碎碎念项目这几天就要提测了！有点期待全通过！希望不要出什么大的问题！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day70-理由-冲刺]]></title>
    <url>%2F2019%2F03%2F22%2F2019-03-22%2F</url>
    <content type="text"><![CDATA[碎碎念这几天最忙的就是项目了。这几天项目冲刺。可能要在4月份之前就要上线了。所以这个文章什么的，这个月看起来水的很。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day69-理由-项目]]></title>
    <url>%2F2019%2F03%2F21%2F2019-03-21%2F</url>
    <content type="text"><![CDATA[碎碎念啥也不说了！今天回来的真的很晚！早点睡觉吧！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day68-理由-划水]]></title>
    <url>%2F2019%2F03%2F20%2F2019-03-20%2F</url>
    <content type="text"><![CDATA[碎碎念今天是真的忘了提交了啊！又忘了push要写的日记内容。所以只能是这里划一下水。]]></content>
      <categories>
        <category>xx</category>
      </categories>
      <tags>
        <tag>xx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day67-数组对象去重]]></title>
    <url>%2F2019%2F03%2F19%2F2019-03-19%2F</url>
    <content type="text"><![CDATA[前言之前都是总结的数组去重，这次记录一个简单的例子，数组对象怎么利用reduce方法去重。 代码本节包含去重前的数组和去重数组方法和去重之后的结果。let a = [&#123;label: 'all', value: 0&#125;, &#123;label: 'all', value: 0&#125;, &#123;label: 'trans', value: 2&#125;, &#123;label: 'edit', value: 3&#125;]let obj = &#123;&#125;let res = a.reduce((item, next) =&gt; &#123; obj[next.value] ? '' : obj[next.value] = true &amp;&amp; item.push(next) return item&#125;, []) 输出： [ { label: ‘all’, value: 0 }, { label: ‘trans’, value: 2 }, { label: ‘edit’, value: 3 } ]]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day66-理由-挺忙]]></title>
    <url>%2F2019%2F03%2F18%2F2019-03-18%2F</url>
    <content type="text"><![CDATA[碎碎念最近有短短续续的看设计模式，但是进展还是非常的缓慢的。这几天习惯了早点下车，离家有一段距离的时候再下车。感觉这几天心情平静的很啊。end~]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day65-问题小结]]></title>
    <url>%2F2019%2F03%2F17%2F2019-003-17%2F</url>
    <content type="text"><![CDATA[前言最近一段时间在微信群里收藏了一些常见的问题。今天来列一下这些问题。以下问题有可能有点乱，随机收集的。 问题网络基础知识 - 腾讯懒函数 - 封装, 解决办法重写函数let foo = function () &#123; let t = new Date() foo = function () &#123; return t &#125; return foo()&#125; Vue技术内幕Vue.js 技术揭秘可视化理解JS事件循环机制观察者模式和发布订阅模式的区别怎么理解模块化 - 头条vdom diff排序、AST?二叉树非递归遍历，我写了一个前序遍历 - ？有没有手动搭建webpack工程mvvm的原理、mvc的缺点、vuex用来做什么有什么替代方案、小程序的坑、移动端适配、模块化组件化各自的优缺点、如何封装网络请求，要注意什么？递归实现数组内元素反转手写懒加载实现说到变量提升，class 声明一个类时，存在变量提升么？（不存在。因为要方便类的继承，先声明子类再声明父类；）问 事件循环为什么设计成微任务宏任务http2的多路复用，怎么实现的、Keep alive、缓存机制、cache control的一些值的区别setState发生了什么、react setState直接要diff整个component？手写json.stringifyDP算法题嵌套数组环形遍历数组里1-10 10个元素顺序排序，然后让随机打乱用几次for 怎么实现介绍原生datepicker技术细节element ui 中，在下拉菜单组件中，为什么下拉框里的内容要放在body标签里，而不是直接放在这个组件上？websocket面试加分项vuex和redux有什么区别Webpack的tree shakingString类型如何在不使用Number、parseInt、+、-、*、\/的情况下转换成Number？vue和react区别-&gt;vue2.0 3.0响应区别-&gt;set问题， 寄生组合继承中 将父类的原型赋值给了过渡函数的原型然后用过渡函数的实例再赋值给子类(中间修改了过渡函数的constructor指向到子类) 为什么不直接将父类的原型直接赋值给子类的原型呢？部署cdn - ？阻止冒泡使用 ECMAScript（JS）代码实现一个事件类Event，包含下面功能：绑定事件、解绑事件和派发事件。书《JavaScript设计模式》-张容铭，《设计模式之禅》-机械工业出版社 - 大宏如何调试node的 有没有远程调试过线上服务？]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day64-模板语法]]></title>
    <url>%2F2019%2F03%2F16%2F2019-03-16%2F</url>
    <content type="text"><![CDATA[背景vuejs项目中有个需求，在notification消息提示中某个部分需要有点击事件。UI用的element。想到用模板的方法来构造。 element-ui Notification onClick 触发方式组件中有两种触发的方式，但是都没有很好的满足需求。 点击时触发this.$notify.warning(&#123; dangerouslyUseHTMLString: true, duration: 0, message: `$&#123;this.createdFailedMember&#125;个成员创建失败！&lt;a id="message" style="color: #66b1ff;text-decoration: underline;cursor:pointer;" @click=aclick(event)"&gt;前往查看&lt;/a&gt;`, onClick: function () &#123; console.log(1) &#125;&#125;) 创建时触发this.$notify.warning(&#123; dangerouslyUseHTMLString: true, duration: 0, message: `$&#123;this.createdFailedMember&#125;个成员创建失败！&lt;a id="message" style="color: #66b1ff;text-decoration: underline;cursor:pointer;" @click=aclick(event)"&gt;前往查看&lt;/a&gt;`, onClick: (function () &#123; console.log(1) &#125;)()&#125;) 渲染函数比较灵活的render 函数。非常好用，但是没有模板语法那么简洁。this.$notify.warning(&#123;message: h( 'div', &#123; style: &#123;display: 'inline-block'&#125; &#125;, [ h('span', `$&#123;this.createdFailedMember&#125;个成员创建失败！`), h('a', &#123; style: &#123;color: '#409EFF', cursor: 'pointer', 'text-decoration': 'underline'&#125;, on: &#123; click: this.clickNotificationMsg &#125; &#125;, '前往查看') ])&#125;)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day64-模板语法]]></title>
    <url>%2F2019%2F03%2F16%2F2019-03-1111%2F</url>
    <content type="text"><![CDATA[背景vuejs项目中有个需求，在notification消息提示中某个部分需要有点击事件。UI用的element。想到用模板的方法来构造。 element-ui Notification onClick 触发方式组件中有两种触发的方式，但是都没有很好的满足需求。 点击时触发this.$notify.warning(&#123; dangerouslyUseHTMLString: true, duration: 0, message: `$&#123;this.createdFailedMember&#125;个成员创建失败！&lt;a id="message" style="color: #66b1ff;text-decoration: underline;cursor:pointer;" @click=aclick(event)"&gt;前往查看&lt;/a&gt;`, onClick: function () &#123; console.log(1) &#125;&#125;) 创建时触发this.$notify.warning(&#123; dangerouslyUseHTMLString: true, duration: 0, message: `$&#123;this.createdFailedMember&#125;个成员创建失败！&lt;a id="message" style="color: #66b1ff;text-decoration: underline;cursor:pointer;" @click=aclick(event)"&gt;前往查看&lt;/a&gt;`, onClick: (function () &#123; console.log(1) &#125;)()&#125;) 渲染函数比较灵活的render 函数。非常好用，但是没有模板语法那么简洁。this.$notify.warning(&#123;message: h( 'div', &#123; style: &#123;display: 'inline-block'&#125; &#125;, [ h('span', `$&#123;this.createdFailedMember&#125;个成员创建失败！`), h('a', &#123; style: &#123;color: '#409EFF', cursor: 'pointer', 'text-decoration': 'underline'&#125;, on: &#123; click: this.clickNotificationMsg &#125; &#125;, '前往查看') ])&#125;)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day63-理由-忘提交]]></title>
    <url>%2F2019%2F03%2F15%2F2019-03-15%2F</url>
    <content type="text"><![CDATA[碎碎念今天又写了一天的代码，还是抠细节，抠细节真的很没效率啊。本来写了一些小例子。忘了提交代码了啊。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day62-理由-感悟]]></title>
    <url>%2F2019%2F03%2F14%2F2019-03-14%2F</url>
    <content type="text"><![CDATA[碎碎念今天本来想优化代码的，看了很久的代码，最后还是没有优化，代码还是和原来一样。崩溃啊。实在是不愿意写下一些重复的代码，尤其是面条代码。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day61-理由-忙碌]]></title>
    <url>%2F2019%2F03%2F13%2F2019-03-13%2F</url>
    <content type="text"><![CDATA[碎碎念今天把昨天的问题解决了，业务上还有很多细节没有去处理。今天早点睡吧。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day60-理由-头疼]]></title>
    <url>%2F2019%2F03%2F12%2F2019-03-12%2F</url>
    <content type="text"><![CDATA[碎碎念今天下午居然碰到一个问题卡了一整个下午！关键是我现在都还没有解决。是有关vuejs中computed的getter、settter问题。头疼头疼。明天早上再去解决吧。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day59-理由-繁忙]]></title>
    <url>%2F2019%2F03%2F11%2F2019-03-11%2F</url>
    <content type="text"><![CDATA[碎碎念写了一整天的业务代码啊！！这种情况基本是腾不出时间来，写一些小累积。今天就到这吧。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day58-理由-吃撑]]></title>
    <url>%2F2019%2F03%2F10%2F2019-03-10%2F</url>
    <content type="text"><![CDATA[碎碎念今天真的是看书了！看的设计模式。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day57-理由-懒惰]]></title>
    <url>%2F2019%2F03%2F09%2F2019-03-09%2F</url>
    <content type="text"><![CDATA[碎碎念最近感觉有点累！还是早点睡觉吧！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day56-理由-拖延]]></title>
    <url>%2F2019%2F03%2F08%2F2019-03-08%2F</url>
    <content type="text"><![CDATA[碎碎念今天身边头号新闻，公司获得了1800万投资啊！嗯，有点兴奋！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day55-uncurrying]]></title>
    <url>%2F2019%2F03%2F07%2F2019-03-07%2F</url>
    <content type="text"><![CDATA[背景让对象借用原本不属于他的方法，我们可以用call,apply把任意对象当做this传入某个方法。有没有能够把this提取出来，并得到更广的适用性？ uncurrying 实现 实现方式之一 Function.prototype.uncurrying = function () &#123; let self = this return function () &#123; let obj = Array.prototype.shift.call(arguments) return self.apply(obj, arguments) &#125;&#125; 实现方法二 Function.prototype.uncurrying = function () &#123; let self = this return function () &#123; return Function.prototype.call.apply(self, arguments) &#125;&#125; uncurrying应用通过uncurrying方式，push 函数的作用和Array.prototype.push.call()一样 方法一的应用 let push = Array.prototype.push.uncurrying()let obj = &#123; 'length': 1, '0': 1&#125;push(obj, 2)console.log(obj) 发生了什么？ Function.prototype.uncurrying = function () &#123; let self = this // self 此时是Array.prototype.push() return function () &#123; let obj = Array.prototype.shift.call(arguments) /** * obj是&#123; * 'length': 1, * '0': 1 * &#125; * argument 对象的第一个元素被截去，剩下[2] */ return self.apply(obj, arguments) &#125;&#125; 参考[1].《JavaScript设计模式与开发实践》- 曾探]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day54-理由-ss挂了]]></title>
    <url>%2F2019%2F03%2F06%2F2019-03-06%2F</url>
    <content type="text"><![CDATA[碎碎念下午突然不能google了，Ping一下我服务器地址，是可以的，端口被封了！于是开始折腾了。可能是最近两会吧。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day53-两数组-集合运算]]></title>
    <url>%2F2019%2F03%2F05%2F2019-03-05%2F</url>
    <content type="text"><![CDATA[背景选择语言对的时候，源语言和目标语言选项要互斥。由此联想到交集、差集、补集、并集的JS如何实现。本文小结ES5和ES6的一些实现方法。 [Photo by Ant Rozetsky on Unsplash] ES5实现 数据let arrA = [‘a’, 3, 5, ‘d’, ‘o’]let arrB = [‘b’, 5, ‘o’, ‘x’, ‘g’, ‘b’]filter+indexOf+concat 交集 let intersection = arrA.filter(v =&gt; &#123; return arrB.indexOf(v) &gt; -1&#125;)console.log(intersection)// [ 5, 'o' ] 差集 arrA与arrB的差集 let r = arrA.filter(v =&gt; &#123; return arrB.indexOf(v) &gt; -1&#125;)console.log(r)// [ 'a', 3, 'd' ] 补集 let complementarySet = arrA.filter(v =&gt; !(arrB.indexOf(v) &gt; -1)).concat(arrB.filter(v =&gt; !(arrA.indexOf(v) &gt; -1)))console.log(complementarySet) // [ 'a', 3, 'd', 'b', 'x', 'g', 'b' ] 并集 let unionSet = arrA.concat(arrB.filter(v =&gt; !(arrA.indexOf(v) &gt; -1)))console.log(unionSet)// [ 'a', 3, 5, 'd', 'o', 'b', 'x', 'g', 'b' ] ES6实现 数据let arrA = [‘a’, 3, 5, ‘d’, ‘o’]let arrB = [‘b’, 5, ‘o’, ‘x’, ‘g’, ‘b’]filter+Set+has 交集 let intersection = arrA.filter(x =&gt; new Set(arrB).has(x))console.log(intersection)// [ 5, 'o' ] 差集 arrA与arrB的差集 let diffSet = arrA.filter(x =&gt; !new Set(arrB).has(x))console.log(diffSet)// [ 'a', 3, 'd' ] 补集 let complementarySet = [...arrA.filter(x =&gt; !new Set(arrB).has(x)), ...arrB.filter(x =&gt; !new Set(arrA).has(x))]console.log(complementarySet)// [ 'a', 3, 'd', 'b', 'x', 'g', 'b' ] 并集 let unionSet = Array.from(new Set([...arrA, ...arrB]))console.log(unionSet)// [ 'a', 3, 5, 'd', 'o', 'b', 'x', 'g' ]]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day52-理由-太忙]]></title>
    <url>%2F2019%2F03%2F04%2F2019-03-04%2F</url>
    <content type="text"><![CDATA[碎碎念今天有事，写了一整天的代码！这个就不能怪我忘了选博客内容了！理由是本来想提交代码的，结果忘了push代码，所以今天没有一个正经的博客内容。这是第六个理由！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day51-理由-懒惰]]></title>
    <url>%2F2019%2F03%2F03%2F2019-03-03%2F</url>
    <content type="text"><![CDATA[碎碎念今天忘了提交代码了，所以这里没有小总结！而且今天加班一天！写了一天的代码！至此，头一次，达成连续两天周末加班成就！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day50-清除浮动]]></title>
    <url>%2F2019%2F03%2F02%2F2019-03-02%2F</url>
    <content type="text"><![CDATA[背景慢慢的开始把一些最基础的知识点记下来。清除浮动的两种方法。overflow和伪类after。 css-float-hack 结构&lt;div class="float-container clearfix"&gt; &lt;div style="float:right;"&gt;&lt;/div&gt;&lt;/div&gt; 方法目前有两种方法清除浮动 方法一 overflow.clearfix &#123; overflow: auto;&#125; 控制不好margins 和padding 就会出现scrollbars 方法二 ::after.clearfix::after &#123; content: ""; clear: both; display: table;&#125; 这个方法比较常用。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day49-理由-没周末]]></title>
    <url>%2F2019%2F03%2F01%2F2019-03-01%2F</url>
    <content type="text"><![CDATA[碎碎念今天真的是不知道为啥，提不起一点劲。可能是最近事情比较多吧。这个月开始，一个月都没周末，唉！回到家就只想看点视频什么。看到了B站的《西游记之大圣归来》。真的是蛮精彩！强烈推荐。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day48-GitError]]></title>
    <url>%2F2019%2F02%2F28%2F2019-02-28%2F</url>
    <content type="text"><![CDATA[背景windows的电脑端ss开的局部代理，hosts经常有时会被莫名其妙的修改。这次就比较奇怪了，git连不上github.com显示connect error。以为密钥什么的错误，之后才意识到可能是hosts的问题。 问题 SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443 解决 进到.ssh目录 cd ~/.ssh/touch config 将下面内容添加到config(非注释部分) Host github.comUser gitHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443 就ok了！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day48-理由4-忙碌]]></title>
    <url>%2F2019%2F02%2F27%2F2019-02-27%2F</url>
    <content type="text"><![CDATA[碎碎念今天又是一个死循环的一天。总结下今天，碰到一个问题，不去深究其中内因。不断地去尝试，试错。嗯，典型的不过脑子了。典型的不能很好地冷静下来。下次碰到问题一定把不能莽撞，一定要冷静下来，要冷静地好好想想，冷静地理一下，才不会浪费时间毫无头绪。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day47-多选过滤]]></title>
    <url>%2F2019%2F02%2F26%2F2019-02-26%2F</url>
    <content type="text"><![CDATA[背景今天有个需求，select下拉框中可以选中多个标签，并将这些标签作为过滤条件。以往都是单条件下拉框过滤，现在需要选择框中有多个选择条件，而且这个条件是动态变化。 代码let arr = ["1", "3"]// 数据源let data = [&#123; state: 1 &#125;, &#123; state: 2 &#125;, &#123; state: 3 &#125;]let d = data.filter(v =&gt; &#123; return arr.every(k =&gt; &#123; k = v.state return arr.indexOf(k.toString()) !== -1 &#125;)&#125;)// console.log(arr.every(v =&gt; v === 1))console.log(d) 参考[1]. Array.prototype.filter()[2]. JS 对象数组根据多个条件过滤[3]. JS中的数组过滤，从简单筛选到多条件筛选]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day46-理由-心累]]></title>
    <url>%2F2019%2F02%2F25%2F2019-02-25%2F</url>
    <content type="text"><![CDATA[碎碎念哇，最近移动端项目遇到了瓶颈，感觉有点心累啊！脑海里其他技术之外的事情又不停的在绕圈圈。哇咔咔~专心点吧！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day45-闭包的小例子]]></title>
    <url>%2F2019%2F02%2F24%2F2019-02-24%2F</url>
    <content type="text"><![CDATA[封装变量在平时运用中，闭包用的比较多的还是对于函数或者变量的封装。本文借鉴一个小例子，示范闭包的应用。 原函数let mult = function () &#123; let a = 1 for (let i = 0; i &lt; arguments.length; i++) &#123; a = a * arguments[i] &#125; return a&#125;console.log(mult(1, 2, 3)) // 6 封装变量let cache = &#123;&#125; // 注意是全局变量let mult = function () &#123; let args = Array.prototype.join.call(arguments, ',') if (cache[args]) &#123; return cache[args] &#125; console.log('==') let a = 1 for (let i = 0; i &lt; arguments.length; i++) &#123; a = a * arguments[i] &#125; return cache[args] = a&#125;console.log(mult(1,2,3))console.log(mult(1,2,3))// ==// 6// 6 优化全局变量 很错误的方法啊！ let mult = function () &#123; let cache = &#123;&#125; let args = Array.prototype.join.call(arguments, ',') if (cache[args]) &#123; return cache[args] &#125; console.log('==') let a = 1 for (let i = 0; i &lt; arguments.length; i++) &#123; a = a * arguments[i] &#125; return cache[args] = a&#125;console.log(mult(1, 2, 3))console.log(mult(1, 2, 3))// ==// 6// 6 正确方法之一 let mult = (function () &#123; let cache = &#123;&#125; return function () &#123; let args = Array.prototype.join.call(arguments, ',') if (cache[args]) &#123; return &#125; let a = 1 for (let i = 0; i &lt; arguments.length; i++) &#123; a = a * arguments[i] &#125; return cache[args] = a &#125;&#125;)()console.log(mult(1, 2 ,3))console.log(mult(1, 2 ,3))// ==// 6// 6 提炼函数let mult = (function () &#123; let cache = &#123;&#125; let calculate = function () &#123; let a = 1 for (let i = 0; i &lt; arguments.length; i++) &#123; a = a * arguments[i] &#125; return a &#125; return function () &#123; let args = Array.prototype.join.call(arguments, ',') if (args in cache) &#123; return cache[args] &#125; console.log('++') return cache[args] = calculate.apply(null, arguments) &#125;&#125;)()console.log(mult(1, 2, 3))// 6 以上就是我要说的话了，show code.–end]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day44-bind]]></title>
    <url>%2F2019%2F02%2F23%2F2019-02-23%2F</url>
    <content type="text"><![CDATA[bind的简单实现 最基本的Function.prototype.bind = function (context) &#123; let self = this return function () &#123; return self.apply(context, arguments) &#125;&#125;let obj = &#123; id: '1'&#125;let func = (function () &#123; console.log(this.id)&#125;).bind(obj)func()// 1 基本的PLUSFunction.prototype.bind = function () &#123; let self = this // 原函数 let context = [].shift.call(arguments) // this 上下文 let args = [].slice.call(arguments) // 剩余参数转化成数组 return function () &#123; return self.apply(context, [].concat.call(args, [].slice.call(arguments))) // 组合分别传入的参数 &#125;&#125;let obj = &#123; id: '1'&#125;let func = function (a, b, c, d) &#123; console.log(this.id) console.log([a, b, c, d])&#125;.bind(obj, 1, 2)func(3, 4)// 1// [ 1, 2, 3, 4 ] –end]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day43-理由-陪聊]]></title>
    <url>%2F2019%2F02%2F22%2F2019-02-22%2F</url>
    <content type="text"><![CDATA[碎碎念一个妹子突然找我，聊家事。聊了快一晚上了。感叹，不容易啊！家庭不容易啊！不容易啊！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day42-理由-评审]]></title>
    <url>%2F2019%2F02%2F21%2F2019-02-21%2F</url>
    <content type="text"><![CDATA[碎碎念居然说，3月份要没有周末，吓死我了！因为项目说是很急，我看项目量也不小啊！吓人吓人。今天评审时间就用了很久，5点到晚上7点半，之后8点到9点，吓人啊。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day41-“练字”-"debouncejs"]]></title>
    <url>%2F2019%2F02%2F20%2F2019-02-20%2F</url>
    <content type="text"><![CDATA[debounce本文主要是临摹Lodashjs中debouncejs源代码。对一部分细节进行了解，代码中会附上链接并写中文注释。分为两部分：loadsh-debounce是来自官方v4.17.5文档的解释。源代码是来自官方github上的代码，日期为2019-2-20之前。 lodash-debounce 背景_.debounce(func, [wait=0], [options={}]) 描述Creates a debounced function that delays invoking func until after wait milliseconds have elapsed since the last time the debounced function was invoked. The debounced function comes with a cancel method to cancel delayed func invocations and a flush method to immediately invoke them. Provide options to indicate whether func should be invoked on the leading and/or trailing edge of the wait timeout. The func is invoked with the last arguments provided to the debounced function. Subsequent calls to the debounced function return the result of the last func invocation. Note:If leading and trailing options are true, func is invoked on the trailing edge of the timeout only if the debounced function is invoked more than once during the wait timeout.If wait is 0 and leading is false, func invocation is deferred until to the next tick, similar to setTimeout with a timeout of 0. Argumentsfunc (Function): The function to debounce.[wait=0] (number): The number of milliseconds to delay.[options={}] (Object): The options object.[options.leading=false] (boolean): Specify invoking on the leading edge of the timeout.[options.maxWait] (number): The maximum time func is allowed to be delayed before it’s invoked.[options.trailing=true] (boolean): Specify invoking on the trailing edge of the timeout. Returns(Function): Returns the new debounced function. 源代码-加一些解析/** * lodash 中的debounce实现 *//** 常量 *//** lodash https://github.com/lodash/lodash/blob/master/.internal/freeGlobal.js *//** Detect free variable `global` from Node.js. */const freeGlobal = typeof global == 'object' &amp;&amp; global !== null &amp;&amp; global.Object === Object &amp;&amp; global/** lodash https://github.com/lodash/lodash/blob/master/.internal/root.js *//** Detect free variable `self`. */const freeSelf = typeof self == 'object' &amp;&amp; self !== null &amp;&amp; self.Object === Object &amp;&amp; self/** Used as a reference to the global object. */const root = freeGlobal || freeSelf || Function('return this')()/** 判断对象 */function isObject(value) &#123; const type = typeof value return value != null &amp;&amp; (type == 'object' || type == 'function')&#125;/** debounce */function debounce(func, wait, options) &#123; let lastArgs, lastThis, maxWait, result, timerId, lastCallTime let lastInvokeTime = 0 let leading = false let maxing = false let trailing = true // Bypass `requestAnimationFrame` by explicitly setting `wait=0`. // 注意(!wait &amp;&amp; wait)写法,通过``明确设置wait=0 // requestAnimationFrame接受一个动画执行函数作为参数，这个函数的作用是仅执行一帧动画的渲染。回调函数会在浏览器下一次重绘之前执行 // requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧 // 在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量。 // 调用requestAnimationFrame后，它会要求浏览器根据自己的频率进行一次重绘，它接收一个回调函数作为参数，在即将开始的浏览器重绘时，会调用这个函数，并会给这个函数传入调用回调函数时的时间作为参数。由于requestAnimationFrame的功效只是一次性的，所以若想达到动画效果，则必须连续不断的调用requestAnimationFrame // cancelAnimationFrame 取消requestAnimationFrame的回调 // https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame const useRAF = (!wait &amp;&amp; wait !== 0 &amp;&amp; typeof root.requestAnimationFrame === 'Function') if (typeof func !== 'function') &#123; throw new TypeError('Exception a function') &#125; // 一元正号将字符串转换成整数和浮点数形式，转换非字符串值 true，false 和 null,小数和十六进制格式字符串。 // 负数形式字符串也可以转换成数值（对于十六进制不适用）。如果它不能解析一个值，则计算结果为 NaN。 wait = +wait || 0 if (isObject(options)) &#123; leading = !!options.leading maxing = 'maxWait' in options maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait trailing = 'trailing' in options ? !!options.trailing : trailing &#125; function invokeFunc(time) &#123; const args = lastArgs const thisArg = lastThis lastArgs = lastThis = undefined lastInvokeTime = time result = func.apply(thisArg, args) return result &#125; // 定时器 function startTimer(pendingFunc, wait) &#123; if (useRAF) &#123; root.cancelAnimationFrame(pendingFunc) return root.requestAnimationFrame(pendingFunc) &#125; return setTimeout(pendingFunc, wait) &#125; // 取消定时器 function cancelTimer (id) &#123; if (useRAF) &#123; return root.cancelAnimationFrame(id) &#125; clearTimeout(id) &#125; // 函数在每个等待时延的开始被调用 function leadingEdge (time) &#123; // Reset any `maxWait` timer // 重置最长等待定时器 lastInvokeTime = time // Start the timer for the trailing edge. // 开启？？定时器 timerId = startTimer(timerExpired, wait) // Invoke the leading edge // 执行 return leading ? invokeFunc(time) : result &#125; function remainingWait(time) &#123; const timeSinceLastCall = time - lastCallTime const timeSinceLastInvoke = time - lastInvokeTime const timeWaiting = wait - timeSinceLastCall return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting &#125; function shouldInvoke(time) &#123; const timeSinceLastCall = time - lastCallTime const timeSinceLastInvoke = time - lastInvokeTime // Either this is the first call, activity has stopped and we're at the // trailing edge, the system time has gone backwards and we're treating // it as the trailing edge, or we've hit the `maxWait` limit. return (lastCallTime === undefined || (timeSinceLastCall &gt;= wait) || (timeSinceLastCall &lt; 0) || (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait)) &#125; function timerExpired() &#123; const time = Date.now() if (shouldInvoke(time)) &#123; return trailingEdge(time) &#125; // Restart the timer. timerId = startTimer(timerExpired, remainingWait(time)) &#125; function trailingEdge(time) &#123; timerId = undefined // only invoke if we have `lastArgs` which means `func has been debounced at least once if (trailing &amp;&amp; lastArgs) &#123; return invokeFunc(time) &#125; lastArgs = lastThis = undefined return result &#125; function cancel () &#123; if (timerId !== undefined) &#123; cancelTimer(timerId) &#125; lastInvokeTime = 0 lastArgs = lastCallTime = lastThis = timerId = undefined &#125; // 立即执行 function flush () &#123; return timerId === undefined ? result : trailingEdge(Data.now()) &#125; function pending () &#123; return timerId !== undefined &#125; function debounce(...args) &#123; const time = Date.now() const isInvoking = shouldInvoke(time) lastArgs = args lastThis = this lastCallTime = time if (isInvoking) &#123; if (timerId === undefined) &#123; return leadingEdge(lastCallTime) &#125; if (maxing) &#123; // Handle invocations in a tight loop. // 多循环中处理调用 timerId = startTimer(timerExpired, wait) return invokeFunc(lastCallTime) &#125; &#125; if (timerId === undefined) &#123; timerId = startTimer(timerExpired, wait) &#125; return result &#125; debounced.cancel = cancel debounced.flush = flush debounced.pending = pending return debounced&#125; 资料附上Lodashjs文档中一篇资料来解释防抖和节流。debouncing-throttling-explained-examples https://css-tricks.com/debouncing-throttling-explained-examples/ 参考github源代码-lodash/debounce.js文档-_.debounce(func, [wait=0], [options={}])]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day40-“繁忙”]]></title>
    <url>%2F2019%2F02%2F19%2F2019-02-19%2F</url>
    <content type="text"><![CDATA[今天元宵节，“猿宵节”啊！节日快乐！其实今天是项目这边有点忙，没有写完编程日志，恰巧元宵节，所以这就是我不好好写日志的理由，哈哈。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day39-做题]]></title>
    <url>%2F2019%2F02%2F18%2F2019-02-18%2F</url>
    <content type="text"><![CDATA[题目console.log(['1', '2', '3'].map(parseInt))// 输出什么？ 答案[ 1, NaN, NaN ] 详解 这个应该是考map语法、进制转换和parseInt语法 易错点 parseInt(string, radix) - radix - 根 - （基数）范围：[2, 36] string 要被解析的值，无法被转化成数值类型，则返回NaN 代码扩展实际执行的代码是： ['1', '2', '3'].map((item, index) =&gt; &#123; return parseInt(item, index)&#125;) parseInt（string, radix) radix关于parseInt基数的处理(MDN)基数radix为 undefined，或者基数为 0 或者没有指定的情况下，JavaScript 作如下处理：如果 parseInt 遇到了不属于radix参数所指定的基数中的字符那么该字符和其后的字符都将被忽略。接着返回已经解析的整数部分。parseInt 将截取整数部分。开头和结尾的空白符允许存在，会被忽略 string 如果字符串 string 以”0x”或者”0X”开头, 则基数是16 (16进制). 如果字符串 string 以”0”开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。 如果字符串 string 以其它任何值开头，则基数是10 (十进制)。 解决（延伸）目前掌握的可能有两种方法： 方法一：利用函数柯里化来取map的数组index为0时的值，因为默认为10进制。 方法二：利用Number。方法一：let unary = fn =&gt; val =&gt; fn(val)let parse = unary(parseInt)let res_0 = ['1', '2', '3'].map(parse)console.log(res_0) 来自 30secondsofcode的unary方法。 let unary = fn =&gt; val =&gt; fn(val) 等价于下面function unary_1(fn) &#123; return function (val) &#123; return fn(val) &#125; &#125; 方法二：let res_1 = [‘10’,’10’,’10’,’8’,’10’].map(Number)console.log(res_1)来自[‘1’, ‘2’, ‘3’].map(parseInt) what &amp; why ? 练习 console.log(parseInt(1, 2)) console.log(parseInt(5, 4)) 参考[1]. 第二题：[‘1’, ‘2’, ‘3’].map(parseInt) 解析[2]. Array.prototype.map()[3]. parseInt]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day38-“摸鱼”]]></title>
    <url>%2F2019%2F02%2F17%2F2019-02-17%2F</url>
    <content type="text"><![CDATA[碎碎念摸了一天的鱼，昨天还是说要看书一天，结果今天中午才起来啊。然后一下午就是光玩儿了。到了晚上才看一会儿书。罪过罪过啊。看书看书！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day37-杂谈]]></title>
    <url>%2F2019%2F02%2F16%2F2019-02-16%2F</url>
    <content type="text"><![CDATA[碎碎念三天打鱼两天晒网，可能说的就是我写博客的状态没错了。今天是周末，待着一天，上午看电影，下午玩游戏，一点书都没看的人就是我了。明天看书！看书！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day36-杂谈]]></title>
    <url>%2F2019%2F02%2F15%2F2019-02-15%2F</url>
    <content type="text"><![CDATA[碎碎念今天是考研成绩出来的一天。恍恍惚惚，一年前的这个时候我还在过年，恍惚间一年已经过了。早上七点就醒了，不知道这有没有什么关系，但重要的是一年前的这个时候，我一晚上没睡着，结果第二天这个时候，消息并没有那么好。这都是一年前的事情了。谈一谈吧。这两天在做移动端的支付宝支付。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day35-杂谈]]></title>
    <url>%2F2019%2F02%2F14%2F2019-02-14%2F</url>
    <content type="text"><![CDATA[碎碎念发现要是女生和代码一样容易理解就好了，出错的几率也太大了。因为你费劲输入一大堆代码，最后错都不会报，根本不知道会不会运行。衰(′д｀ )…彡…彡有时候有些人你付出，更本就不会有任何反应。世事难料啊。情人节快乐！祝你们原地爆炸！ -end]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day34-deepClone]]></title>
    <url>%2F2019%2F02%2F13%2F2019-02-13%2F</url>
    <content type="text"><![CDATA[拷贝探究一下深拷贝，本文主要是浅拷贝、深拷贝的简单实现，并对循环引用就行一些了解。 准备let data = &#123; id: '1', segment: &#123; hitinfos: &#123; // 浅拷贝时rule为rule: [Object] rule: &#123; a: 'no-placeholder', b: 'no-tag' &#125;, level: 4 &#125;, atoms: [ &#123; tgt: 'you dont know', src: '你不知道' &#125;, &#123; id: 1, tgt: 'what', src: '什么' &#125; ] &#125;, arr: [&#123; id: 1, arr: 'arr1' &#125;], value_1: undefined, value_2: null, value_3: true&#125; 浅拷贝 简单的对象浅拷贝（只遍历一层）-拷贝引用 function cloneShadow(src) &#123; let tgt = &#123;&#125; // 为什么不直接用“=”赋值 for (let prop in src) &#123; // 或者用if (Object.hasOwnProperty(prop)) &#123; if (Object.prototype.hasOwnProperty.call(src, prop)) &#123; tgt[prop] = src[prop] &#125; &#125; return tgt&#125;let test = cloneShadow(data)data.id = 2console.log(test)console.log(data)console.log(test) 深拷贝 递归对象深拷贝（遍历多层）function deepClone(src) &#123; // 非对象 if (src &amp;&amp; typeof src !== 'object') &#123; return src // throw new TypeError('Except Object, got' + (typeof src)) &#125; // 初始化 let tgt = Array.isArray(src) ? [] : &#123;&#125; for (let prop in src) &#123; if (Object.prototype.hasOwnProperty.call(src, prop)) &#123; // value为null或者undefined则返回原值(typeof null === 'object') if (typeof src[prop] === 'object') &#123; tgt[prop] = deepClone(src[prop]) &#125; else &#123; tgt[prop] = src[prop] &#125; &#125; &#125; return tgt&#125;let test_1 = deepClone(data)console.log(test_1)console.log(data)console.log(test_1) 拷贝循环引用 拷贝循环引用（JSON方法抛异常）function deepCloneCircle(src) &#123; if (src &amp;&amp; src !== 'object') return src let tgt = Array.isArray(src) ? [] : &#123;&#125; for (let prop in src) &#123; if (Object.prototype.hasOwnProperty.call(src, tgt)) &#123; if (src[prop] &amp;&amp; src[prop] === 'object') &#123; tgt[prop] = deepCloneCircle(src[prop]) &#125; else &#123; tgt[prop] = src[prop] &#125; &#125; &#125; return tgt&#125;let test = deepCloneCircle(data)console.log(test) 参考：[1]. JavaScript中的浅拷贝和深拷贝[2]. 【进阶4-3期】面试题之如何实现一个深拷贝]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day33-css居中]]></title>
    <url>%2F2019%2F02%2F12%2F2019-02-12%2F</url>
    <content type="text"><![CDATA[居中总结经常会碰到一些居中的问题，这里尝试进行一些总结。分为垂直居中和水平居中。 水平居中 行内或类行内元素(inline/inline-block/inline-table/flex)：text-align: center; 块级元素： margin: 0 auto; 多个块级元素：display: inline-block; 垂直居中 行内或类行内元素: 单行：padding-top与padding-bottom 等值、或line-height与height 等值 多行：单行padding等值，或display: table-cell 用vertical-align：middle; 块级元素： – 待续]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三十二天2019-02-01]]></title>
    <url>%2F2019%2F02%2F01%2F2019-02-01%2F</url>
    <content type="text"><![CDATA[碎碎念最近又开始关注到Nodejs了，因为在探究js的一些原理的时候，不可避免的会注意到js的一些应用场景的不同，这两天看到了一篇很好的介绍Nodejs入门的文章，【全文】狼叔：如何正确的学习Node.js。看这篇文章还是比较有感触的，文章本身结合自身的体验从Nodejs诞生以来讲到近些年的趋势，当然我觉得最准的还是属于对于React.js和Vue.js的趋势的描述。这篇文章偏向于说教，也是说给初学Nodejs的人所听的，详细的地方在于介绍了一些该看的书本，和一些练习代码的方法，比如学会Nodejs要多看一些NPM包的源码，按作者来说就是一天5个NPM包阅读。这个对我来说感触是非常深的，本人觉得是，只有真正的上手，你才能说是真的开始去掌握这门东西。我觉得文章是真的比较详细，还提供一些资料，也提出了一些问题，比如，“在变化多端的大前端背景之下，该如何精进？”。文章本身可能探讨的比较多，也探讨了，Nodejs在各类编程语言中的比较，比如和java比较的优劣。总得来说，是一篇不可多得的好文。有幸看到这种文章。看来以后还是要多看专门的社区，去浏览一些文章，增长一些见识，拓宽一些视野。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三十一天2019-01-31]]></title>
    <url>%2F2019%2F01%2F31%2F2019-01-31%2F</url>
    <content type="text"><![CDATA[leetCode今天想到了Leetcode的题目，又捡起来做了一道题目。可能比较简单，就当是回忆的题目吧，以后捡起来题目都比较方便。慢慢来吧。坚持下去也好。也不是宁缺毋滥这种借口，是不存在的，还是得每天坚持写点日记，这样以后就能够进行阶段性总结，也可以看以前的东西，希望养成习惯。 Add Two Numbers** [2] Add Two Numbers** https://leetcode.com/problems/add-two-numbers/description/** algorithms* Medium (30.32%)* Total Accepted: 733.3K* Total Submissions: 2.4M* Testcase Example: '[2,4,3]\n[5,6,4]'** You are given two non-empty linked lists representing two non-negative* integers. The digits are stored in reverse order and each of their nodes* contain a single digit. Add the two numbers and return it as a linked list.* * You may assume the two numbers do not contain any leading zero, except the* number 0 itself.* * Example:* * * Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)* Output: 7 -&gt; 0 -&gt; 8* Explanation: 342 + 465 = 807.* * */ 题目框架** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var addTwoNumbers = function(l1, l2) &#123; 题解var addTwoNumbers = function(l1, l2) &#123; /** * 方法一 */ let List = new ListNode(0) let head = List let sum = 0 let carray = 0 while (l1 !== null || l2 !== null || sum &gt; 0) &#123; if (l1 !== null) &#123; sum = sum + l1.val l1 = l1.next &#125; if (l2 !== null) &#123; sum = sum + l2.val l2 = l2.next &#125; if (sum &gt;= 10) &#123; carray = 1 sum = sum - 10 &#125; head.next = new ListNode(sum) head = head.next sum = carray carray = 0 &#125; return List.next /** * 方法二 */ // let node = null // const carray = arguments[2] // if (l1 || l2) &#123; // // 加上进位 // const val1 = l1 ? l1.val1 : 0 // const val2 = l2 ? l2.val2 : 0 // const next1 = l1 ? l1.next : null // const next2 = l2 ? l2.next : null // const val = carry ? val1 + val2 + 1 : val1 + val2 // node = new ListNode(val % 10) // node.next = addTwoNumbers(next1, next2, val &gt;= 10) // &#125; else if (carray) &#123; // node = new ListNode(1) // node.next = null // &#125; // return node&#125;; –end–]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三十天2019-01-30]]></title>
    <url>%2F2019%2F01%2F30%2F2019-01-30%2F</url>
    <content type="text"><![CDATA[上线很晚啊，今天，有点困。还是早点睡吧，这些天。今天碰到个问题。vm.$attrs传入的不识别横线方式，爷组件传入的不会自动将驼峰转为横线模式。 –end–]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二十九天2019-01-29]]></title>
    <url>%2F2019%2F01%2F29%2F2019-01-29%2F</url>
    <content type="text"><![CDATA[碎碎念刚看了下，搁置了四天没写技术文章了，好几篇只有上文，没有下文。这个毛病从写日志体现出来了，说明得改，这还说明了，写日志的好处啊，能够从记录中发现问题。可能这就是今天鸽的理由吧。这几天快接近年末了，又期待，又不期待，真是很纠结。我发现，什么时候都有很多事，看你怎么去对待，永远不会说等到没事的时候。要调整好情绪再说。此处，鸽。 –end–]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二十八天2019-01-28]]></title>
    <url>%2F2019%2F01%2F28%2F2019-01-28%2F</url>
    <content type="text"><![CDATA[碎碎念今天回来的比较晚，可能事情比较多吧。又想起了以前的事。唉，洗洗早点睡吧。几天就这几句唠唠叨叨的话了。 –end–]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二十七天2019-01-27]]></title>
    <url>%2F2019%2F01%2F27%2F2019-01-27%2F</url>
    <content type="text"><![CDATA[今天上午看了一部动漫，B站Lex推荐的。看完之后感叹这两天动漫质量的提高，动漫三观简直不能再正，满满的正能量。这种动漫真是难怪不火。动漫名字叫《超能力少女》但是整个片并不是一部打斗片，而是一部以一位来自异世界超能力少女生活为主线另一位异世界超能力少女为辅，讲述了来到这个世界之后，两个少女面对不同的家庭之间各自的努力和奋斗故事，在女二号身上，看到了满满的正能量，与女一号富有的生活对比，个人感觉女二号的勤奋和人品更像是这部故事讲述的主题。同时，这个故事也对于日本的黑帮进行了一些美化。虽然故事剧情并没有像标题和开头一幕一样热血，但是剧情本身还是非常精彩！这里好像说了绕口令。但就是夸这部动漫吧。 –end–]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二十六天2019-01-26]]></title>
    <url>%2F2019%2F01%2F26%2F2019-01-26%2F</url>
    <content type="text"><![CDATA[碎碎念今天公司年会，这是个不写log的好理由，对吧？我也是这么觉得。回到家已经很晚了，晚上11点才到家，就真的不想再写日志了。就这样结束今天的日志环节吧。 –end–]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二十五天2019-01-25]]></title>
    <url>%2F2019%2F01%2F25%2F2019-01-25%2F</url>
    <content type="text"><![CDATA[js 常用数组方法小结 （2）碎碎念有些数组方法会经常用，这里今天就介绍一下reduce()方法和find()方法。 Array.protytype.reduce()背景看完一些方法，目前来说，reduce()方法，能实现的比较多，且我之前看到的文章中对其的推崇是比较多的。据说它能做很多事情。昨天看了下MDN上的介绍和几个例子，确实感觉其功能的强大。本文基于MDN上的代码以笔记的形式注释，先对功能做栗子，然后对方法进行一些描述。 举个栗子一些简单的例子 累加数组中的值？ let sum = [3, 9, 12, 34].reduce((accumulator, currentValue, currentIndex, array) =&gt; &#123; return accumulator + currentValue&#125;)console.log(sum) // 58 累加对象数组中的值？ let sum = [&#123;x: 1&#125;, &#123;x:2&#125;, &#123;x:3&#125;].reduce((accumulator, currentValue) =&gt; &#123; // 将键名为x的逐个累加到累加器中 return accumulator + currentValue.x&#125;, 0)console.log(sum) // 6 initialValue 为初始值，且初始值是必须提供的 二维数组转为一维数组？let flattened = [[0, 1], [2, 3], [4, 5]].reduce((acc, cval, cidx, arr) =&gt; &#123; // 初始值为空数组，取出当前下标数组中的值，放入累加器中的空数组，逐个累加 return acc.concat(cval)&#125;, [])console.log(flattened) 一些稍微复杂点的 计算数组中每个元素出现的次数？ let arr = [1, 3, 54, 21, 1]let count = arr.reduce((acc, cval) =&gt; &#123;// 这里要注意是在累加器中去寻找是否存在值 if (cval in acc) &#123; // 以对象形式赋值，真个reduce过程一次次去遍历 acc[cval]++ &#125; else &#123; acc[cval] = 1 &#125; return acc&#125;, &#123;&#125;)console.log(count) // &#123; '1': 2, '3': 1, '21': 1, '54': 1 &#125; 属性对object分类？ let people = [ &#123; name: 'Alice', age: 21 &#125;, &#123; name: 'Max', age: 20 &#125;, &#123; name: 'Jane', age: 20 &#125;]function groupBy (objArr, property) &#123; return objArr.reduce((acc, obj) =&gt; &#123; // 键名 let key = obj[property] // 判断累加器中是否有重复的元素 if(!acc[key]) &#123; acc[key] = [] &#125; acc[key].push(obj) return acc &#125;, &#123;&#125;)&#125;let groupedByPeople = groupBy(people, 'age')console.log(groupedByPeople) 使用扩展运算符和initialValue绑定包含在对象数组中的数组简单点说就是取出数组集合中对象中的数组 let friends = [&#123; name: 'Anna', books: ['Bible', 'Harry Potter'], age: 21&#125;, &#123; name: 'Bob', books: ['War and peace', 'Romeo and Juliet'], age: 26&#125;, &#123; name: 'Alice', books: ['The Lord of the Rings', 'The Shining'], age: 18&#125;]// 列出所有包含的书籍// 题目不容易理解，好好一想，就容易的多，还得对扩展符了解的比较多点就更容易上手let containerBook = friends.reduce((prev, curr) =&gt; &#123; return [...prev, ...curr.books]&#125;, [])console.log(containerBook) 然后，鸽了鸽了。先写到这里吧。时间又不够了。 参考[1]. Array.prototype.reduce()–end–]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二十四天2019-01-24]]></title>
    <url>%2F2019%2F01%2F24%2F2019-01-24%2F</url>
    <content type="text"><![CDATA[碎碎念今天一天写代码有点不在状态，可能是最近有点不太对，不是疲累也可能是心事又多了起来。原本计划今天继续上文或者上上文的。现在看来真的只能是搁了。最近图片可能会风格比较和以前不一样。这是问人要的哈。嘿嘿。 –end–]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二十三天2019-01-23]]></title>
    <url>%2F2019%2F01%2F23%2F2019-01-23%2F</url>
    <content type="text"><![CDATA[js 常用数组方法小结碎碎念今天这个数组对象操作写的有点多啊，特此来小结一下，一些常用的方法的基本操作。 Array.prototype.filter()表格过滤用的比较多大概用法就是过滤数组或者数组集合中一些不符合条件的数组元素和集合。也可以用来过滤数组中一些undefined和null。例子：[1]const fruits = [&apos;apple&apos;, &apos;banana&apos;, &apos;grapes&apos;, &apos;mango&apos;, &apos;orange&apos;];/** * Array filters items based on search criteria (query) */const filterItems = (query) =&gt; &#123; return fruits.filter((el) =&gt; // 过滤的条件 el.toLowerCase().indexOf(query.toLowerCase()) &gt; -1 );&#125;// 根据条件过滤之后的数组console.log(filterItems(&apos;ap&apos;)); // [&apos;apple&apos;, &apos;grapes&apos;]console.log(filterItems(&apos;an&apos;)); // [&apos;banana&apos;, &apos;mango&apos;, &apos;orange&apos;] 过滤数组中空值let newArray = oldArray.filter(s =&gt; s.value != null) filter() 的实现 利用for循环以及push构造数组[1]// Polyfill Array.prototype.filter()function newFilter() &#123; if (!Array.prototype.newFilter) &#123; // 可以带thisArg Array.prototype.newFilter = (fun /* , thisArg*/) =&gt; &#123; // void(0)（等同于void 0） 差不多等于 undefined if (this === void 0 || this === null) &#123; throw new TypeError() &#125; // Object构造函数为给定值创建一个对象包装器 let t = Object(this) // 所有非数值转换成0, 所有大于等于 0 等数取整数部分 // Shifts a in binary representation b (&lt; 32) bits to the right, discarding bits shifted off, and shifting in 0s from the left. let len = t.length &gt;&gt;&gt; 0 if (typeof fun !== &apos;function&apos;) &#123; throw new TypeError() &#125; let res = [] // arguments对象不是一个 Array 。它类似于Array，但除了length属性和索引元素之外没有任何Array属性 // 没有 pop 方法。但是它可以被转换为一个真正的Array：args = Array.from(arguments) // 所以这个地方用arguments可能有错？ let thisArg = arguments.length &gt;= 2 ? arguments[1] : void 0 // t = Object(this) for (let i = 0; i&lt; len; i++) &#123; // prop in object, 检查object（或其原型链）是否包含具有指定名称的属性的对象 if (i in t) &#123; let val = t[i] // NOTE: Technically this should Object.defineProperty at // the next index, as push can be affected by // properties on Object.prototype and Array.prototype. // But that method&apos;s new, and collisions should be // rare, so use the more-compatible alternative. // 满足filter中的条件的话就push进数组res,filter回调函数的三个参数：元素值，元素索引，原数组 // thisArg: 当前在数组中处理的元素 // val: 正在处理元素在数组中的索引 if (fun.call(thisArg, val, i, t)) res.push(val) &#125; &#125; &#125; &#125;&#125; Array.prototype.reduce()鸽到下期再讲吧，好像我已经鸽了很多东西了。额。–end–]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二十二天2019-01-22]]></title>
    <url>%2F2019%2F01%2F22%2F2019-01-22%2F</url>
    <content type="text"><![CDATA[组件通信-祖孙本文将结合例子，简单讲解下vuejs文档中的实例属性：vm.$attrs和vm.$listeners。 碎碎念因为项目中大多用Vuex来通信，但是用多了之后感觉简单的组件之间的通信再用构造vuex的mutation，写起来比较费，当然父子之间的通信肯定是用emit更实在。 写个“栗子” 三个组件：grandfather &gt; father &gt; son祖宗组件Vue.component(&apos;grandfather&apos;, &#123;props: [],template: `&lt;div&gt; &lt;father :getGrandsonData=&quot;grandfatherData&quot; // 传值 @getGrandsonEvent=&quot;grandfatherEvent&quot; // 事件 &gt;&lt;/father&gt; &lt;/div&gt; `data: function () &#123; return &#123; grandfatherData: &quot;hello, i&apos;m your grandfather&quot; &#125; &#125;,methods: &#123; grandfatherEvent (val) &#123; // 这里接到了“hello, i&apos;m your grandson” console.log(val) // hello, i&apos;m your grandson &#125;&#125;&#125;) 父亲组件Vue.component(&apos;father&apos;, &#123;props: [], // 注意这里props不需要再父组件声明template:\`&lt;div&gt; &lt;grandson v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot; &gt;&lt;/grandson&gt; \`&lt;/div&gt;&#125;) 孙子组件Vue.component(&apos;grandson&apos;, &#123;props: [],template:` &lt;input type=&quot;text&quot; v-model=&quot;grandsonMsgToGrandfather&quot; @input=&quot;sendToGrandfatherEvent&quot; &gt;&#123;&#123;$attrs.grandfatherData&#125;&#125;&lt;/div&gt; `data: function () &#123; return &#123; grandsonMsgToGrandfather: &quot;hello, i&apos;m your grandson&quot; &#125;&#125;,method: &#123; sendToGrandfatherEvent () &#123; this.$emit(&apos;getGrandsonEvent&apos;, sonMsgToGrandfather ) &#125;&#125;&#125;) 注意：这里的代码并没有验证过,只是大概写个简单的demo 上文档vm.$attrs vm.$attrs类型：{ [key: string]: string }只读详细：包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件——在创建高级别的组件时非常有用。 vm.$listeners vm.$listeners类型：{ [key: string]: Function | Array&lt;Function&gt; }只读详细：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件——在创建更高层次的组件时非常有用。 参考[1]. https://cn.vuejs.org/v2/api/#vm-attrs 、https://cn.vuejs.org/v2/api/#vm-listeners[2]. vue的通信方式（二）—祖父孙三个级别的之间的隔代通信 —end—]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二十一天2019-01-21]]></title>
    <url>%2F2019%2F01%2F21%2F2019-01-21%2F</url>
    <content type="text"><![CDATA[碎碎念今天又重温了一小下（事件循环）Event Loop，如何去区分MicroTask（微任务）,MacroTask（宏任务），说实话我还没有非常精确的去理解到位，做顺序题目，也会做错，理解的不充分不到位。去看了下MDN1,发现并没有解释的很详细，除了解释Nodejs中和浏览器中的EventLoop有点不同，其他简短的语言倒像是解释setTimeout()是“非等待一定时间之后执行”这一概念。 Event Loop - 上下面来稍微再温习下这个东西。承上启下，为Promise()的深入理解做更好的准备。 背景JavaScript这种并发模型基于“事件循环” ，是单线程的，不像是C语言任何位置被终止，它是异步而不阻塞主进程执行。Event Loop起到很重要的作用， JavaScript处理 I/O 通常通过事件和回调来执行。本文简单的入门一下Event Loop这个东西，大概有个映像就行。 任务js引擎的两种任务 MacroTask: setTimeout, setInterval, setImmediate,I/O, UI rendering MicroTask: Promise, process.nextTick, Object.observe, MutationObserver, MutaionObserver调度机制不同的任务行为并不一样，执行的先后顺序不一样。具体怎么个不一样，这里拿个例子2。setTimeout(function() &#123; console.log(4);&#125;, 0);var promise = new Promise(function executor(resolve) &#123; console.log(1); for (var i = 0; i &lt; 10000; i++) &#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(2);&#125;).then(function() &#123; console.log(5);&#125;);console.log(3); Nodejs输出： 1 2 3 5 4浏览器输出：1 2 3 5 undefined 4注：这里不讨论Nodejs和浏览器的异同 MicroTask 和 Macro Task的执行顺序 - 描述 Event Loop 开始 MicroTasks 队列开始执行至结束 检查MacroTask 队列是否有待执行，有则跳到4，无则跳到6 MacroTask队列“抽取”一个任务，执行至结束 检查MicroTasks 是否执行完毕，若有则跳到2，无则跳到3 结束Event Loop 以上整个过程就是Event Loop（事件循环）。 这里有个疑问，就是5为什么还要检查是否执行完毕，因为2已经检查过了，是什么事件遗留到了5？ MicroTask 和 Macro Task的执行顺序 - 图文一张图来解释下3（这张图是引用的，可能需要重画下，可能加上Event table会更好点）。 图怎么理解呢?宏任务作为入口的话，setTimeout不是第一个执行？是这么个解释的，拿调度机制中的代码说事。先把两种任务再放一遍。 MacroTask: setTimeout, setInterval, setImmediate,I/O, UI renderingMicroTask: Promise, process.nextTick, Object.observe, MutationObserver, MutaionObserver 整段代码作为宏任务进入主线程。 遇到setTimeout(), 回调函数注册后分发到宏任务Event Queue。// 回调函数注册？ 接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。// 立即执行？ 遇到console.log()，立即执行。 整段代码作为一次宏任务执行结束，进入微任务判断。Event Queue里有then函数，执行。 第二轮循环，开始新的宏任务。从宏任务Event Queue中去检查。发现setTimeout回调函数，立即执行。 到这里如果还不懂的话，可以到参考资料的3去看看，写的比较详细，我这里只是笔记形式简单总结下。 Promise 和 process.nextTick() 的先后顺序？- 后续这里就放到下一篇Event Loop再说吧。– end – 参考[1]. 并发模型与事件循环[2]. 理解event loop（浏览器环境与nodejs环境）[3]. 这一次，彻底弄懂 JavaScript 执行机制]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二十天2019-01-20]]></title>
    <url>%2F2019%2F01%2F20%2F2019-01-20%2F</url>
    <content type="text"><![CDATA[碎碎念今天下午就光玩游戏了~感觉需要放空自己啊，这是个玩游戏的好借口。但确实，今天下午看了一会儿电影，上午下午中间节点看完了《楚门的世界》（《The Truman Show》)。 这个电影，在高中的时候就很受它影响，我指的影响，大概是你看完一部电影之后，很长时间都会去回味这部电影的味道，这部电影的含义。九九八十一难，最后的一个“释然”的态度？ 再然后看了《天气预报员》？这是部慢热的剧情，感觉还是没有看下去的劲头，挖个坑吧，改天再看。然后尝试看了部石原里美日剧，嗯，看了一部分就看不下去了。然后接着就游戏了。本来想LOL的，结果愣是没有劲头，开了一局游戏都退了，看来游戏真的是没什么好玩的。然后，玩CSGO，感觉还是比较考验临场发挥的，碰到敌我实力不相上下的时候，整个人的荷尔蒙就都上来了，感觉还是对于放空自己比较有效果的。一直玩到了，晚上8点啊。你可是也有一堆事情要做的啊，怎么玩起游戏来了。说不玩游戏的，真香。 –end–]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十九天2019-01-19]]></title>
    <url>%2F2019%2F01%2F19%2F2019-01-19%2F</url>
    <content type="text"><![CDATA[碎碎念今天碰到一个需求，就是在element-ui表格中，列表操作这一列有下载和删除按钮，需要点击某一行的下载按钮，该行下载按钮显示正在下载的loading状态。这个看了下，应该只能是通过在scope.row对象中加属性，比如：isDownloading。这个就要求新属性isDownloading，能够具有响应式特性。 深入响应式原理 追踪变化下面这张图，是基于Object.defineProperty 实现响应式的关键。 不巧的是，受现代 JavaScript 的限制 (而且 Object.observe 也已经被废弃)，Vue 不能检测到对象属性的添加或删除。[1] Vue 不允许在已经创建的实例上动态添加新的根级响应式属性 (root-level reactive property)。然而它可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上：[1] 添加响应式属性使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象 一个已有对象添加多个属性// 代替 Object.assign(this.someObject, { a: 1, b: 2 })this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 }) vuejs 提供的Api Vue.set( target, key, value )参数： {Object | Array} target{string | number} key{any} value返回值： 设置的值。用法： 向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 (比如 this.myObject.newProperty = ‘hi’)注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象。 注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象。 实践实践了一下，响应式的对象。在拉取list的forEach里新增一个响应式属性，this.$set(this.list, &#39;isDownloading&#39;, false)。然后就可以在操作前置true,操作后false。在列表的地方就可以用响应式的isDownloading属性了！ 参考[1]. https://cn.vuejs.org/v2/guide/reactivity.html#%E5%A6%82%E4%BD%95%E8%BF%BD%E8%B8%AA%E5%8F%98%E5%8C%96[2]. https://cn.vuejs.org/v2/api/#Vue-set——————————————————-end———————————————————–]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十八天2019-01-18]]></title>
    <url>%2F2019%2F01%2F18%2F2019-01-18%2F</url>
    <content type="text"><![CDATA[碎碎念今天写了一上午的技术，写后台管理，感觉时间过得好快啊。因为最近可能有需要部署一些应用在服务器上，所以最近又开始捡起Docker这个东西。今晚上复习了一下。具体的一些基本操作如下。 docker-ubuntu 准备Docker 要求 Ubuntu 系统的内核版本高于 3.10 uname -r 查看内核版本 安装 wget -qO- https://get.docker.com/ | sh 测试安装 docker run hello-world‘hello-world’ 是一个镜像，没有的话会默认pull 容器操作 docker ps -a // 列出所有创建的container docker ps -aq // 列出所有创建的container 的ID docker ps // 列出正在运行的容器container docker system df // 查看镜像、容器、数据卷所占用的空间 docker top // 查看容器的进程 docker stop // 停止容器（名字要全） docker rm // 删除指定名容器 镜像操作 docker image ls // 列出已经下载下来的镜像 docker images // 列出所有所有镜像 docker rmi &lt; image ID&gt; // (注：ID列出前几位就行了) 拉取ubuntu docker pull ubuntu:16.04 镜像操作 docker run -t -i ubuntu:16.04 /bin/bash // 运行容器 docker tag :&lt;新标签&gt; // ID只需要前几位就行 docker port // 查看端口的绑定 构建镜像 cat Dockerfile 参考[1]. http://www.runoob.com/docker/docker-container-usage.html[2]. https://yeasy.gitbooks.io/docker_practice/container/stop.html————————————————————————end———————————————————————-]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十七天2019-01-17]]></title>
    <url>%2F2019%2F01%2F17%2F2019-01-17%2F</url>
    <content type="text"><![CDATA[碎碎念今天眼睛好困啊好困啊！最近可能脑子里事情太多了！还是早点睡的好！乱七八糟的事情先放一边。今天看了Readability，准备用这个来做一些翻译相关的东西。感觉很厉害啊，这个东西。总之先粗略的console.log(),至于以后的什么并发什么的，这个等流量上去了之后再说，先把东西一个个做出来吧。总觉得Nodejs做的应该不会太差。明天记得预约体检！！ 就这样，又水了一天。早点睡吧。晚安。–end]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十六天2019-01-16]]></title>
    <url>%2F2019%2F01%2F16%2F2019-01-16%2F</url>
    <content type="text"><![CDATA[碎碎念恍恍惚惚，已经坚持写博客16天了，这是个“不小的成就”啊。回想过的这些天的博客，发现深度不够，停留在表面。博客写到表层的东西，肤浅的东西就浅尝辄止。这是个很大的问题。也是这些天博客记录下来之后发现的问题点。接下来就是对过去的整个东西进行一些梳理。自从博客开始记录生活以来。总共写了下面这几个事情： Object.assign（）// 上下已经完 new 操作符 // 简单地对原型和继承关系进行了复习 Vue源码解析 // 对于整个Vue源码的入口有了清晰的认识，意思就是，读源码开始上路 接下去 接下去可能还想开坑Vuex，这个坑，可能是因为在一些写法上，总觉得不够优雅，可能需要读一些开源的项目是怎么做的。可以的话，从很早就有的饿了么APP这个开始读一下，看他是怎么设计软件的。也可能继续开坑Loadshjs，研究如何实现deep clone或者是研究Promise,以及Even Loop其次，一直以来很重要的事，就是网络基础知识，比如HTTP里面的RTT这种知识，都必须熟练掌握。另外就是一直放了很久的Nodejs项目，改学会怎么写出好接口了。所以，这个地方也得去读Nodejs怎么学。再深入一点，可能需要读一些开源的项目了。这些在github上面关注的时候，有star，所以，这个不用太心急。偶尔逛逛github就出来了。这些都是很久的坑，暂时还不打算开。但是对于阅读源码是很有帮助的。毕竟是基础嘛。但是先开哪个坑，这个是有必要先想想，因为当务之急手下也还有一些bug没有解决。长久看，这种基础东西都是必须要懂的，不懂不行啊。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十五天2019-01-15]]></title>
    <url>%2F2019%2F01%2F15%2F2019-01-15%2F</url>
    <content type="text"><![CDATA[碎碎念 国际化今天对国际化进行了总结，作为第二个发表的人，我发现讲话水平有提高哦，讲的也有层次感了，思路也还算清晰。话说到国际化，确实啊，这个国际化怎么去做，怎么提取需要翻译的全部文本转为变量呢，这个前期工作很繁琐，实际翻译效率并不高。 手机端适配最近在做手机端适配，要写两套样式。发现还是蛮繁琐的，不过还好，如果原来的页面是自适应的话，那么样式就会简单很多。 关于最近一些技术上新的路子今早发现其实看Node.js一些源码解析片段可能会很快的就深入到js当中，比如Promise涉及到的SetTimeout()引出来的Even Loop等一些概念。其实可能没有想象中那么深奥，可能是不小心复杂化了。–end]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十四天2019-01-14]]></title>
    <url>%2F2019%2F01%2F14%2F2019-01-14%2F</url>
    <content type="text"><![CDATA[碎碎念今天写了一天的适配移动端样式，发现还好，并不是原来想象中的那么难。早上公交上，也看了Vue的源码分析，渐入佳境吧，慢慢的也看的越来越没有障碍了。 Vue源码-笔记Vue 构造函数function Vue (options) &#123; if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !(this instanceof Vue)) &#123; warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;) &#125; this._init(options)&#125; _init 方法 Vue.prototype._init = function (options?: Object) &#123; const vm: Component = this // a uid vm._uid = uid++ // a flag to avoid this being observed vm._isVue = true // merge options if (options &amp;&amp; options._isComponent) &#123; // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options) &#125; else &#123;// 走这一步分析 vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ) &#125; /* istanbul ignore else */ if (process.env.NODE_ENV !== &apos;production&apos;) &#123; initProxy(vm) &#125; else &#123; vm._renderProxy = vm &#125; // expose real self vm._self = vm initLifecycle(vm) initEvents(vm) callHook(vm, &apos;beforeCreate&apos;) initState(vm) callHook(vm, &apos;created&apos;) initRender(vm) &#125; Vue第一步 使用策略对象合并参数选项export function resolveConstructorOptions (Ctor: Class&lt;Component&gt;) &#123; let options = Ctor.options if (Ctor.super) &#123; const superOptions = Ctor.super.options const cachedSuperOptions = Ctor.superOptions const extendOptions = Ctor.extendOptions if (superOptions !== cachedSuperOptions) &#123; // super option changed Ctor.superOptions = superOptions extendOptions.render = options.render extendOptions.staticRenderFns = options.staticRenderFns extendOptions._scopeId = options._scopeId options = Ctor.options = mergeOptions(superOptions, extendOptions) if (options.name) &#123; options.components[options.name] = Ctor &#125; &#125; &#125; return options&#125; Vue.super 用来处理继承 mergeOptions// 1、引用依赖import Vue from &apos;../instance/index&apos;其他引用...// 2、合并父子选项值为最终值的策略对象，此时 strats 是一个空对象，因为 config.optionMergeStrategies = Object.create(null)const strats = config.optionMergeStrategies// 3、在 strats 对象上定义与参数选项名称相同的方法strats.el = strats.propsData = function (parent, child, vm, key)&#123;&#125;strats.data = function (parentVal, childVal, vm)config._lifecycleHooks.forEach(hook =&gt; &#123; strats[hook] = mergeHook&#125;)config._assetTypes.forEach(function (type) &#123; strats[type + &apos;s&apos;] = mergeAssets&#125;)strats.watch = function (parentVal, childVal)strats.props =strats.methods =strats.computed = function (parentVal: ?Object, childVal: ?Object)// 默认的合并策略，如果有 `childVal` 则返回 `childVal` 没有则返回 `parentVal`const defaultStrat = function (parentVal: any, childVal: any): any &#123; return childVal === undefined ? parentVal : childVal&#125;// 4、mergeOptions 中根据参数选项调用同名的策略方法进行合并处理export function mergeOptions ( parent: Object, child: Object, vm?: Component): Object &#123; // 其他代码 ... const options = &#123;&#125; let key for (key in parent) &#123; mergeField(key) &#125; for (key in child) &#123; if (!hasOwn(parent, key)) &#123; mergeField(key) &#125; &#125; function mergeField (key) &#123; const strat = strats[key] || defaultStrat options[key] = strat(parent[key], child[key], vm, key) &#125; return options&#125; 内容比较丰富，信息量有点大，慢慢来吧，暂时先到这，下次得加快进度看。–end]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十三天2019-01-13]]></title>
    <url>%2F2019%2F01%2F13%2F2019-01-13%2F</url>
    <content type="text"><![CDATA[碎碎念今天一天上午做饭，下午看电影，一天吧~做了个肉炒腐竹，看电影《雨果》、《美丽心灵》。 不得不说，电影《雨果》中的场景构建的是非常的漂亮，不知道是色彩的原因还是其他，其中包含了很多的机械，一些机械钟类转轴，非常的精美，整个故事的价值观，取向，也非常的完美！不可多得的好电影啊。看完这部电影，才知道什么叫做法国式的浪漫，看来法国式的浪漫不只是与常见的爱情，还在于法国的电影中所体现出的人物的绅士。 接下来的一部电影就是《美丽心灵》，这部电影183分钟，真的是看的人惊心动魄，不是各种悬疑故事，也不是各种打斗场面，而是来自内心的那种波澜起伏，主人公战胜精神病的坚强的意志，更赞的是电影标题所突出的人的心灵美。也是被片中的主人公的爱情喂饱了狗粮，甚至完全可以当做爱情片来看，“You are reason, you are all my reason”。但我更认为这部电影带给人的力量不仅限于此。不多说了，这电影一定推荐大家看。 –end]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十二天2019-01-12]]></title>
    <url>%2F2019%2F01%2F12%2F2019-01-12%2F</url>
    <content type="text"><![CDATA[今天一天还算是过的比较快，看了两三部电影，感觉还好，虽然都是些老电影。早上起来也做饭了，时间刚到中午就做好了，时间点掐的很完美嘛。就是今天没有看书这点，不是很好。睡觉之前还是看看书吧。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十一天2019-01-11]]></title>
    <url>%2F2019%2F01%2F11%2F2019-01-11%2F</url>
    <content type="text"><![CDATA[呦呦呦，上线了一个功能！所以今天回来的可能有点晚啊！今天临上线前又更新了一点需求，这个更新需求这个事情，对于有些场景来说，真的是不可避免啊，但是这个问题本身可能是在敲定最终需求的时候，需求不明确所导致的，但是整个过程怎么去优化，还是个很大的问题。所以，我觉得最后优化的空间还会很大的。好吧，好像说了很多的空话，但实际上是有点想吐槽下自己代码效率的，对于更新速度快的需求不能够很好的对代码进行解耦和快速的组装，这个说明在设计代码的时候还是很有必要加强训练！ – end]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十天2019-01-10]]></title>
    <url>%2F2019%2F01%2F10%2F2019-01-10%2F</url>
    <content type="text"><![CDATA[碎碎念最近都没有不同的图片可以贴了，还需要找点图片啊。今天早上看了下怎么实现new操作符，感觉又回到了，原型和原型链的理解，“new”一个函数的时候，到底发生了什么？兜兜转转看来还是这个理解的不到位。说起理解不到位，让我想起了，今天写业务代码的时候，写到Vue渲染先后顺序这个地方，愣是卡了很久。看来这是对于整个的Vue运行机制还掌握的不够。 笔记-new操作符-上“new” 发生了什么先来看看MDN上是怎么解释的？2 语法new constructor[([arguments])] // constructor：指定对象实例的类型的类或函数 描述 当代码 new Foo(…) 执行时，会发生以下事情： 一个继承自 Foo.prototype 的新对象被创建。 使用指定的参数调用构造函数 Foo ，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。 由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤） 网友总结的[1] 创建了一个全新的对象。 这个对象会被执行[[Prototype]]（也就是proto）链接。 生成的新对象会绑定到函数调用的this。 通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。 如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用会自动返回这个新的对象。 这个是总结出来的，总觉得有点不科学啊。但目前好像是最好的办法，通过new的功能反推new的实现。 补充使用 Function.prototype 属性将共享属性添加到以前定义的对象类型function Car() &#123;&#125;car1 = new Car()Car.prototype.color = nullconsole.log(car1.color) // null 怎么实现new/** * 模拟实现 new 操作符 * @param &#123;Function&#125; ctor [构造函数] * @return &#123;Object|Function|Regex|Date|Error&#125; [返回结果] */function newOperator(ctor)&#123; if(typeof ctor !== 'function')&#123; throw 'newOperator function the first param must be a function'; &#125; // ES6 new.target 是指向构造函数 // new.target 后面会补充下 newOperator.target = ctor; // 1.创建一个全新的对象， // 2.并且执行[[Prototype]]链接 // 4.通过`new`创建的每个对象将最终被`[[Prototype]]`链接到这个函数的`prototype`对象上。 var newObj = Object.create(ctor.prototype); // ES5 arguments转成数组 当然也可以用ES6 [...arguments], Aarry.from(arguments); // 除去ctor构造函数的其余参数 var argsArr = [].slice.call(arguments, 1); // 3.生成的新对象会绑定到函数调用的`this`。 // 获取到ctor函数返回结果 var ctorReturnResult = ctor.apply(newObj, argsArr); // 小结4 中这些类型中合并起来只有Object和Function两种类型 typeof null 也是'object'所以要不等于null，排除null var isObject = typeof ctorReturnResult === 'object' &amp;&amp; ctorReturnResult !== null; var isFunction = typeof ctorReturnResult === 'function'; if(isObject || isFunction)&#123; return ctorReturnResult; &#125; // 5.如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)，那么`new`表达式中的函数调用会自动返回这个新的对象。 return newObj;&#125; 这个实现，除去一些排除异常的条件，我理解的就几步，把对象复制过去，然后参数绑定过去，排除边界条件，整个咋一看并不是很难，但是很考验对整个操作符的掌握和熟悉程度。 new.target在构造方法调用中，new.target指向被new调用的构造函数，所以”new.”成为了一个虚拟上下文[2] 普通函数中 new.target的值是undefined,可以检测一个函数是否是作为构造函数通过new被调用的。function Foo() &#123; if (!new.target) throw "Foo() must be called with new"; console.log("Foo instantiated with new");&#125;Foo(); // throws "Foo() must be called with new"new Foo(); // logs "Foo instantiated with new"， 检测到由new调用 构造函数中稍微复杂点，这里暂时不讨论可以到MDN去看。今天暂时讨论到这啊！明天还得上线呢！有点晚，早点睡觉吧。--end 参考：[1]. 面试官问：能否模拟实现JS的new操作符[2]. new运算符]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第九天2019-01-09]]></title>
    <url>%2F2019%2F01%2F09%2F2019-01-09%2F</url>
    <content type="text"><![CDATA[这几天很忙啊！！早上都去的很晚！早点睡觉早点睡觉！ –end]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八天2019-01-08]]></title>
    <url>%2F2019%2F01%2F08%2F2019-01-08%2F</url>
    <content type="text"><![CDATA[碎碎念今天入职以来第一次迟到，作啊，8点43分有车，然后悠哉一会儿，52有车，悠哉穿个衣服，然后就9.20的车了。可能还有可能到公司，但是，出了隧道之后，公交每个红绿灯都停了，没有例外的巧合啊！期间还火车过道，这运气没谁了！最后10点10分才到公司。辛亏一个月可以迟到两次。 笔记-Object.assign()-下继承属性和不可枚举属性是不能拷贝的 原生情况下挂载在 Object 上的属性是不可枚举的，但是直接在 Object 上挂载属性 a 之后是可枚举的，所以这里必须使用 Object.defineProperty，并设置 enumerable: false 以及 writable: true, configurable: true。3 var obj = Object.create(&#123;foo: 1&#125;, &#123; // foo 是个继承属性。 bar: &#123; value: 2 // bar 是个不可枚举属性。 &#125;, baz: &#123; value: 3, enumerable: true // baz 是个自身可枚举属性。 &#125;&#125;);var copy = Object.assign(&#123;&#125;, obj);console.log(copy); // &#123; baz: 3 &#125; 检查是否可以枚举 查看Object.assign 是否可枚举，使用 Object.getOwnPropertyDescriptor 或者 Object.propertyIsEnumerable（会检查给定的属性名是否直接存在于对象中,而不是在原型链上,并且满足 enumerable: true）。 // 方法一：查看Object.assign()是否可以枚举Object.getOwnPropertyDescriptor(Object, &quot;assign&quot;);// 方法二Object.propertyIsEnumerable(&quot;assign&quot;); // false // 实现 Object.assign时要用Object.defineProperty(Object, &apos;assign&apos;,&#123;... writable: true, enumerable: false, configurable: true&#125;) 原始类型会被包装为对象有时候可以利用这一点包装为对象var v1 = &quot;abc&quot;;var v2 = true;var v3 = 10;var v4 = Symbol(&quot;foo&quot;)var obj = Object.assign(&#123;&#125;, v1, null, v2, undefined, v3, v4); // 原始类型会被包装，null 和 undefined 会被忽略。// 注意，只有字符串的包装对象才可能有自身可枚举属性。console.log(obj); // &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125; 异常会打断后续拷贝任务 在出现错误的情况下，例如，如果属性不可写，会引发TypeError，如果在引发错误之前添加了任何属性，则可以更改target对象2。 // 定义不能写var target = Object.defineProperty(&#123;&#125;, &quot;foo&quot;, &#123; value: 1, writable: false&#125;); // target 的 foo 属性是个只读属性。Object.assign(target, &#123;bar: 2&#125;, &#123;foo2: 3, foo: 3, foo3: 3&#125;, &#123;baz: 4&#125;);// TypeError: &quot;foo&quot; is read-only// 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。console.log(target.bar); // 2，说明第一个源对象拷贝成功了。console.log(target.foo2); // 3，说明第二个源对象的第一个属性也拷贝成功了。console.log(target.foo); // 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。这里异常console.log(target.foo3); // undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。console.log(target.baz); // undefined，第三个源对象更是不会被拷贝到的。 拷贝访问器var obj = &#123; foo: 1, // get 访问器 get bar() &#123; return 2; &#125;&#125;;var copy = Object.assign(&#123;&#125;, obj); console.log(copy); // &#123; foo: 1, bar: 2 &#125;// copy.bar的值来自obj.bar的getter函数的返回值 拷贝所有自有属性的属性描述符（难点）var obj = &#123; foo: 1, get bar() &#123; return 2; &#125;&#125;;function completeAssign(target, ...sources) &#123; sources.forEach(source =&gt; &#123; // reduce 可能是不太好理解，下期可能需要出一个笔记 let descriptors = Object.keys(source).reduce((descriptors, key) =&gt; &#123; // 获取属性描述符（可以分为数据描述符和存取描述符均，属性的信息可以查看：Object.defineProperty） descriptors[key] = Object.getOwnPropertyDescriptor(source, key); return descriptors; &#125;, &#123;&#125;); // Object.assign 默认也会拷贝可枚举的Symbols // Object.getOwnPropertySymbols() 方法返回一个给定对象自身的所有 Symbol 属性的数组。 Object.getOwnPropertySymbols(source).forEach(sym =&gt; &#123; let descriptor = Object.getOwnPropertyDescriptor(source, sym); if (descriptor.enumerable) &#123; descriptors[sym] = descriptor; &#125; &#125;); Object.defineProperties(target, descriptors); &#125;); return target;&#125;var copy = completeAssign(&#123;&#125;, obj);console.log(copy);// &#123; foo:1, get bar() &#123; return 2 &#125; &#125; MDN实现Obeject.assign()if (typeof Object.assign != &apos;function&apos;) &#123; // Must be writable: true, enumerable: false, configurable: true Object.defineProperty(Object, &quot;assign&quot;, &#123; value: function assign(target, varArgs) &#123; // .length of function is 2 &apos;use strict&apos;; if (target == null) &#123; // TypeError if undefined or null throw new TypeError(&apos;Cannot convert undefined or null to object&apos;); &#125; var to = Object(target); for (var index = 1; index &lt; arguments.length; index++) &#123; var nextSource = arguments[index]; if (nextSource != null) &#123; // Skip over if undefined or null for (var nextKey in nextSource) &#123; // Avoid bugs when hasOwnProperty is shadowed // 直接使用 myObject.hasOwnProperty(..) 是有问题的，因为有的对象可能没有连接到 Object.prototype 上所以这里用上call() if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) &#123; to[nextKey] = nextSource[nextKey]; &#125; &#125; &#125; &#125; return to; &#125;, writable: true, configurable: true &#125;);&#125; 今天就先很粗糙地写一下，明天再详细的谈一些细节部分吧。– end 参考[1]. Object.assign()–MDN[2]. JavaScript 中的对象拷贝[3]. 【进阶4-2期】Object.assign 原理及其实现]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第七天2019-01-07]]></title>
    <url>%2F2019%2F01%2F07%2F2019-01-07%2F</url>
    <content type="text"><![CDATA[碎碎念最近发现写代码的速度有提升，这说明写业务代码基础都差不多了，接下来就应该深究其内容了，该向代码底层的一些原理进行深入探究了，当然还是得夯实基础。之前看过一点Lodashjs的基础，但是有些关联性太强，没办法一下子联系起来，得慢慢的来看内容。今早上看了js中一个Object.assign()中的一些原理，发现其实并没有想象的那么难，但是手写起来可是非常考验功底，需要真正理解才能去写出浅拷贝的Objecr.assign()。下面来浅谈下。 笔记-Object.assign()–上 描述 如果目标对象中的属性具有相同的键，则属性将被源中的属性覆盖。后来的源的属性将类似地覆盖早先的属性。这里应该讲的是的**陷阱**。#### 拷贝问题```javascript?linenums// 1. 浅拷贝let obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;; // 源对象let obj2 = Object.assign(&#123;&#125;, obj1); // 目标对象console.log(JSON.stringify(obj2)); // &#123; a: 0, b: &#123; c: 0&#125;&#125;// 2. 改变源对象的属性值，拷贝的值并不会改变obj1.a = 1;console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125; ，console.log(JSON.stringify(obj2)); // &#123; a: 0, b: &#123; c: 0&#125;&#125;// 3. 修改目标对象的属性obj2.a = 2;console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125;console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 0&#125;&#125;// 4. 改变了目标对象的值，因为复制了对源对象的引用，对目标对象属性的修改也能改源对象，如何解决这种问题？obj2.b.c = 3;console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 3&#125;&#125;console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 3&#125;&#125;// 5. 常用的深拷贝JSON.parse(JSON.stringify()),这个方法也有缺点obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;;let obj3 = JSON.parse(JSON.stringify(obj1));obj1.a = 4;obj1.b.c = 4;console.log(JSON.stringify(obj3)); // &#123; a: 0, b: &#123; c: 0&#125;&#125; 合并对象（常用） 以下代码引自MDN var o1 = &#123; a: 1 &#125;;var o2 = &#123; b: 2 &#125;;var o3 = &#123; c: 3 &#125;;var obj = Object.assign(o1, o2, o3);console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;console.log(o1); // &#123; a: 1, b: 2, c: 3 &#125; 注意目标对象自身也会改变。 合并具有相同属性的对象 以下代码引自MDN var o1 = &#123; a: 1, b: 1, c: 1 &#125;;var o2 = &#123; b: 2, c: 2 &#125;;var o3 = &#123; c: 3 &#125;;var obj = Object.assign(&#123;&#125;, o1, o2, o3);console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125; 注意后续参数覆盖问题 拷贝 symbol 类型的属性 描述 Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。String类型和 Symbol 类型的属性都会被拷贝。 以下代码引自MDN var o1 = &#123; a: 1 &#125;;var o2 = &#123; [Symbol(&apos;foo&apos;)]: 2 &#125;;var obj = Object.assign(&#123;&#125;, o1, o2);console.log(obj); // &#123; a : 1, [Symbol(&quot;foo&quot;)]: 2 &#125; (cf. bug 1207182 on Firefox)Object.getOwnPropertySymbols(obj); // [Symbol(foo)] 先探究到这里吧针对深拷贝，需要使用其他方法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。常用的可能是JSON.parse(JSON.stringify()),这个方法也有缺点。 知识扩展-简单对比 Object.assign() JSON.parse(JSON.stringify()) 2，不适合复制循环引用对象,不适合复制对象方法 参考[1]. Object.assign()–MDN[2]. JavaScript 中的对象拷贝–end]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第六天2019-01-06]]></title>
    <url>%2F2019%2F01%2F06%2F2019-01-06%2F</url>
    <content type="text"><![CDATA[讲讲生活哈今天一天，早上起来之后就买了，汤骨和一些作料来做饭吃，真是很便宜，比在外面吃不知道要好多少啊。下面谈谈观影感受。 然后就开始在B站看电影，毕竟也是买了年度大会员的哈，总要找点专门属于会员的来看哈，因为最近上映的大黄蜂电影，于是就挑这个前传看，就在刚才结束的变形金刚前三部的观看，据说第四部和第五部分与原创相差太大。嗯，于是就不继续看下去吧。但是变形金刚的前三部是真的很帅！看完第一步，你完全想象不到这居然是零几年拍摄的电影CG效果简直不能再好。连看了三部之后真是觉得很热血啊。里面的人物价值观也设置的很合理，为了不同的追求，永远没有对和错，只有对事情角度的不同，影响。 这个周日也就一下子过去了。当然，上午还看了一大半的绣春刀，这部电影镜头什么的真的没话说，就是看到卢大哥被赏百户的时候，看不下去了，觉得，这是沈大人做的孽啊，为什么要为了一己私欲放走了魏忠贤，你觉得他会放过一个知道秘密的人？有时候真的是所有的错误，全在一瞬间决定。当我们遇到这种情况的时候，切记，一定要保持理智啊！因为摧毁你的不太可能是一个很明显的错误，是你最脆弱的时候犯的错误。今天谈感受就谈到这里吧！–end]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五2019-01-05]]></title>
    <url>%2F2019%2F01%2F05%2F2019-01-05%2F</url>
    <content type="text"><![CDATA[碎碎念今天加班啊！真是一件不太舒服的事情，加班都是为了一件事，让我一个人上线负责主要的内容。有点累。早上起得有点晚，出门下着小雨，在公交上都没法看点知识类的东西。晃晃悠悠到公司。结果发现我和产品来的最早啊。坑爹啊。不过，加班中午大家一起出去饭馆吃，老板请客这点倒是蛮不错，今天的才也都蛮合胃口！就是鼻子有鼻炎，总感觉人多的时候不太好，鼻子有失体面，下次一定把鼻子这事搞定吧。坚持用就行。下午顺利上线，真是ok。—end]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第四天 2019-01-04]]></title>
    <url>%2F2019%2F01%2F04%2F2019-01-04%2F</url>
    <content type="text"><![CDATA[一天以为项目会今天上线，结果，一天提了50-60个样式问题。虽然问题都很简单，但是真的是找的要命啊！下面讲讲今天这些问题的来源，讲八卦。 放图看到这奖状没？够专业了吧？ 你以为就只有奖状？！错，还有实在的礼品！第三名和第二名！如图： 真是非常辛苦产品小姐姐了！然而，我下班还当着产品的面，抱怨加需求。也是非常可以的了。第一名有两位！奖励手机壳！本来想聊一聊今天看的一篇，如何优化代码的文章！明天还要早起，算了吧。聊点八卦。–end]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三天2019-01-03]]></title>
    <url>%2F2019%2F01%2F03%2F2019-01-03%2F</url>
    <content type="text"><![CDATA[忙碌的一天啊！国际化终于要上线了。总是改文案改样式，我都快改死了。这个译文的调整真不是改的。细化到空格，逗号，括号。今天眼睛又是眯着回来的。不知道怎么了，是眼睛困了，会进行自我保护?所以眼睛会眯着？今天又看了原型和原型链的一片文章，发现真是永远也讲不完，```prototype```, 这种&quot;面向关联&quot;的模式真的是比较奇怪但是有中用。**列一下几个重要的等式吧。**&lt;!--more--&gt;```javascript// 函数的构造器是FunctionObject.__proto__ === Function.prototype // true// 函数字面量的__proto__ 指向Function(function () &#123;&#125;).__proto__ === Function.prototype // true// 对象字面量(&#123;&#125;).__proto__ === Object.prototype // true// Object函数原型的__proto__指向 nullObject.prototype.__proto__ === null// Function 函数的__proto__ 指向自身prototypeFunction.__proto__ === Function.prototype // true// Function的prototype是一个对象，所以Function.prototype.__proto__指向Object.prototypeFunction.prototype.__proto__ === Object.prototype // true 放图！ 图说明 小结 对象有属性__proto__(又可以称为隐式原型),指向该对象的构造函数的原型对象 方法(Function)除了有属性__proto__,还有属性prototype指向该方法的原型对象（包含所有实例共享的属性和方法叫做原型对象），原型对象也有属性constructor指回原构造函数。 先有Object.prototype（原型链顶端），Function.prototype继承Object.prototype而产生，最后，Function和Object和其它构造函数继承Function.prototype而产生 结束今天就到这吧，这是个很好的开端！！ 参考[1] js中proto和prototype的区别和关系？[2] JavaScript原型与继承的秘密]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二天2019-01-02]]></title>
    <url>%2F2019%2F01%2F02%2F2019-01-02%2F</url>
    <content type="text"><![CDATA[谈一天感受今天早上起来，发现这几天真的好冷啊。真是降温到极点了。扫兴的是，居然还牙疼，都怪假期三天吃的太多了，这智齿问题又出来了，哪天找个机会真的把它给拔了！今天转了一篇微信文章，要集赞然后获取《经济学人》98年到18年的文章。真是幸运，前几天还念叨着，要想办法拿下经济学人的文章合集就好。真是运气啊，今天就有机会获得了。新年开始，运气都这么好的吗？今天把推荐码和红包都写好了，不容易啊，断断续续一个星期，中间还惨杂这user-server的URL修改，实际工作时间真的就是三四天。剩下的还有后台管理的一小部分。其中掺杂着一些YiCAT的国际化，国际化你可快点上线吧，天天各种细节，译文修改，真是琐碎的很。还特别占时间。完全是体力活，原谅我再一次吐槽这个译文的修改。从第一次拿到译文，到现在为止，我已经数不清，改了多少次译文了。真想写个接口。让他们自己去修改。省得自己天天改译文文案。吐槽就到这里吧。这些天不知道眼睛怎么了，总是表现出很困的感觉，一直不自觉眯着眼睛。可能是没有早睡的原因。真是佩服公司同事，每天熬夜到一两点，精神气还十足。– end]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019--启程]]></title>
    <url>%2F2019%2F01%2F01%2F2019-%E5%90%AF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[即将告别2018年，这个对于我来说，多灾多难的一年。这一年发生了太多的事，每一年也都会发生很多事，但从来没有哪一年能够像2018年这样让人印象深刻。考研结束。毕业。工作。最悲痛的莫过于最亲的人去世。事业也刚刚起步，爱情失去了方向。真是让人印象深刻的一年。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新年第一天-2019-01-01]]></title>
    <url>%2F2019%2F01%2F01%2F2019-01-01%2F</url>
    <content type="text"><![CDATA[友情提示以下内容都是一些碎碎念，生活、读后感、今天生活内容。ps: 附上我的“专业插画师”提供的图片。 生活新年第一天，昨晚在群里抢红包，一直热闹到很晚才睡。今早10点才慵懒的起来，起的有点晚。中午炸鸡腿，惨不忍睹。后来玩游戏，庸庸碌碌的一天就过去了。这是假期最后一天。希望晚上的时候能收收心看点书。顺带一提昨天晚上看了组件详解。 读Vue 组件基础之组件通信 -《Vue js实战》组件基础组件的复用，复用离不开值得传递。父子组件，兄弟组件相互之间的传值。基本的有props，父组件传递给子组件，子组件通过$emit()、v-on: 来将值通知父组件。不太常用的有$parent(书中提到可以通过此通信访问父实例或组件），在组件中引用父组件，$child,父组件引用子组件。《Vue js实战》书中提到了，通过利用实例化一个空的BUS组件起到总线的作用，这种方法还挺新鲜。另外，组件通信时还有slot的内容分发，slot默认名称是可以和具名slot一起用的。相互之间并不影响。好吧，之前用的时候，总是会不自觉给slot取名字。理解的不够深刻。 高级组件 组件可以递归自己。 异步组件。 小结总感觉这种组件通信方式还有待于改善，应该多读一下开源的一些组件是怎么写出来的。因为上次研究element-UI的时候并没有看它运用这些（指的是通信手段，也可能是我忽略？）但是表现出了很强的可扩展性。很值得学习。包括其中CSS中的书写。 插播元旦放假头一天，买了100的零食，一个大箱子，有优惠。现在好像吃的牙有点疼。作啊。明明要减肥的人。 发现好的视频今天看B站排行榜的时候发现一个点评动漫的UP主，LexBurner?“艺名”：蕾丝。他的视频看动漫的角度还真是蛮特别，应该是有大量的漫画番剧的基础，能有空看这么多视频和漫画，这人真是不简单。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年最后一天]]></title>
    <url>%2F2018%2F12%2F31%2F2018-%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[2018年就要拜拜了。早上9点起来的也不算太晚。折腾了一会儿博客样式之（发现是又拍云开启浏览器缓存的锅）。今天打算看一些书度过。额，还是先玩会儿游戏放空下？不然感觉不太想看书。放张图片吧，可能就是需要这样来自嘲。– end]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fib]]></title>
    <url>%2F2018%2F04%2F17%2Ffib%2F</url>
    <content type="text"><![CDATA[斐波那契数列 打印斐波那契数列，递归法，迭代法，提升递归效率 [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]后一位数是前两位数之和(例如 fib(2) === 0 + 1) === 1; 提升递归效率，创建一个数据存储，或者一个小的缓存对象，缓存对象是数组 function memoize(fn) &#123; const cache = &#123;&#125;; return function(...args) &#123; // ...args ： 数组集 if (cache[args]) &#123; return cache[args]; &#125; const result = fn.apply(this, args); cache[args] = result; return result; &#125;;&#125;function slowFib(n) &#123; if (n &lt; 2) &#123; return n; &#125; return slowFib(n - 1) + slowFib(n - 2);&#125;const fib = memoize(slowFib); 递归法function fib(n) &#123; if (n &lt; 2) &#123; return n; &#125; return fib(n - 1) + fib(n - 2);&#125; 迭代法function fib(n) &#123; const result = [0, 1]; for (i = 2; i &lt;= n; i++) &#123; const a = result[i - 1]; const b = result[i - 2]; result.push(a + b); &#125; return result[n];&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>编程</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown-trick]]></title>
    <url>%2F2018%2F03%2F31%2Fmarkdown-trick%2F</url>
    <content type="text"><![CDATA[vscode snippets 以设置 markdown 代码片段为例 开启设置 文件 &gt; 首选项 &gt; 设置 "[markdown]": &#123; "editor.quickSuggestions": true &#125; 设置模板 文件 &gt; 首选项 &gt; 用户代码片段 &gt; markdown.json &#123; "markdown write template": &#123; "prefix": "mdrt", "body": [ "--- $1", "title: $TM_FILENAME_BASE", "tags:", "* xx", "categories:", "* xx", "date: $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE-$CURRENT_HOUR", "--- ", " \n ", "&lt;!--more--&gt; $2" ], "description": "Create template for markdown write" &#125;&#125; 输出---title: md-killtags:* xxcategories:* xxdate: 2018-03-31-20---&lt;!--more--&gt; 参考Markdown Snippet Prefix Does Not Trigger Snippet #28048Creating your own snippets]]></content>
      <categories>
        <category>日常操作</category>
      </categories>
      <tags>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matrix]]></title>
    <url>%2F2018%2F03%2F28%2Fmatrix%2F</url>
    <content type="text"><![CDATA[矩阵 写一个函数，输入数字 N,返会一个 N*N 的矩阵(环序)。 例如// matrix(2)// [[1, 2],// [3, 4]]// matrix(3)// [[1, 2, 3],// [8, 9, 4],// [7, 6, 5]] 代码function matrix(n) &#123; const results = []; for (let i = 0; i &lt; n; i++) &#123; results.push([]); &#125; let counter = 1; let startColumn = 0; let endColumn = n - 1; let startRow = 0; let endRow = n - 1; while (startColumn &lt;= endColumn &amp;&amp; startRow &lt;= endRow) &#123; //顶列开头到结尾 for (let i = startColumn; i &lt;= endColumn; i++) &#123; results[startRow][i] = counter; counter++; &#125; startRow++; //最右列 for (let i = startRow; i &lt;= endRow; i++) &#123; results[i][endColumn] = counter; counter++; &#125; endColumn--; // 底部行 for (let i = endColumn; i &gt;= startColumn; i--) &#123; results[endRow][i] = counter; counter++; &#125; endRow--; // start 列 for (let i = endRow; i &gt;= startRow; i--) &#123; results[i][startColumn] = counter; counter++; &#125; startColumn++; &#125; return results;&#125; 测试const matrix = require('./index');test('matrix 函数已定义', () =&gt; &#123; expect(typeof matrix).toEqual('function');&#125;);test('matrix produces a 2x2 array', () =&gt; &#123; const m = matrix(2); expect(m.length).toEqual(2); expect(m[0]).toEqual([1, 2]); expect(m[1]).toEqual([4, 3]);&#125;);test('matrix produces a 3x3 array', () =&gt; &#123; const m = matrix(3); expect(m.length).toEqual(3); expect(m[0]).toEqual([1, 2, 3]); expect(m[1]).toEqual([8, 9, 4]); expect(m[2]).toEqual([7, 6, 5]);&#125;);test('matrix produces a 4x4 array', () =&gt; &#123; const m = matrix(4); expect(m.length).toEqual(4); expect(m[0]).toEqual([1, 2, 3, 4]); expect(m[1]).toEqual([12, 13, 14, 5]); expect(m[2]).toEqual([11, 16, 15, 6]); expect(m[3]).toEqual([10, 9, 8, 7]);&#125;);]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>编程</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reversint]]></title>
    <url>%2F2018%2F03%2F19%2FreversInt%2F</url>
    <content type="text"><![CDATA[整数反转(reversint)问题 给你一个带符号的整数，返回这些数值的倒序 //例如 // reverseint(1243) === 3421 // reverseint(123) === 321 // reverseint(-12) === -21 // reverseint(-10) === -1 方法二function reverseint(n) &#123; const reversed = n .toString() .split('') .reverse() .join(''); return parseInt(reversed) * Math.sign(n);&#125; 方法一function reverseint(n) &#123; return (n = Math.abs(n) .toString() .split('') .reverse() .join('') * Math.sign(n));&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>编程</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 仓库合并（实例）]]></title>
    <url>%2F2018%2F03%2F05%2Fgit-progress%2F</url>
    <content type="text"><![CDATA[最近想着整理一下 github 上一些零散的代码到同一个库中，问题是如何合并两个仓库并且保留每个文件的提交记录？如果只是两个目录并为一个，不需保留每个库的提交的记录，你只要在本地 A 仓库中 clone B 再提交就行，而本文所做的就是实践这个过程，参考的博客在文末。 目的 合并两个库/提交记录 准备 本地环境 Windows os ,所有均在命令 git bash 中操作 远程仓库 A,如图左，远程仓库 B,如图右。 实践 clone 到本地git clone https://github.com/lmislm/Code_Repository.git 添加远程仓库 cd Code_Repository/ git remote add -f CSS_Ex git://github.com/lmislm/CSS_Ex.git 添加一个新的远程仓库，指定一个简单的名字，以便将来引用，运行 git remote add [shortname] [url]： git merge --strategy ours --no-commit CSS_Ex/master + 可能报错fatal: refusing to merge unrelated histories忽略就行。 + ours 选项强制冲突由‘our’版本自动解决，即：来自其他分支树不会影响到我们这边映射到合并的结果。 + &gt; 即忽略冲突只保留Code_Repository文件树并且把 CSS_Ex的历史记录合并进来。 git remote -v + 此命令将全部列出远程仓库。检查一下是否存在 git read-tree --prefix=css/ -u CSS_Ex/master + --prefix=css/：这里 Code_Repository/目录下有 css/子目录 + &gt; –prefix 用于指定文件树读取后保存的路径，相对于当前路径并且一定要追加 /–no-commit 的原因，该选项会在合并解析完成后中断，停留在最后的提交步骤之前。 git read-tree --prefix=css/ -u CSS_Ex/master + &gt; -u 是说在读取后更新 index，使得 working tree 与 index 保持同步 + git commit -m &quot;finish,迁移CSS_Ex到了Code_Repository/css/下&quot; + git add . + git commit -m &quot;迁移完成&quot; + git push -u origin master 结果 后记 在操作完成之后确实实现了合并到同一个仓库，但是并没有预期的结果，没有完美的合并提交记录。多次操作之后，将一些零散的东西合并到了同一个仓库。但是原来的仓库还是存在的。如果将原来零散的仓库删除。可以看到结果中，a year ago，历史提交记录确实存在，但是其他flex_Ex显示的却是在进行这个合并操作时提交的时间。 参考如何用 Git 合并两个库（合并历史记录，解决冲突／改写路径）Merging Git Repositories and Preserving History Git 基础 - 远程仓库的使用MERGE STRATEGIES​ - oursgit read-tree]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[undefined behavior in c]]></title>
    <url>%2F2018%2F01%2F06%2Fundefined%20behavior%20in%20c%2F</url>
    <content type="text"><![CDATA[undefined behavior（未定义行为） 思考一下下面这段代码的输出会是什么（答案在后面）？ 这段代码运行过程是怎样？ #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define SQ(y) (y*y) //define 1//#define SQ(y) ((y)*(y)) //define 2int main() &#123; int i = 1; while(i &lt;= 5)&#123; printf("%-2d",SQ(i++)); &#125; return 0;&#125;----------/*-只试了两种编译器 *所用编译器：gcc * 用define 1 : 结果1 9 15 * 用define 2 ：结果1 9 15 *其他编辑器： * 用define 1 : 结果2 12 30 * 用define 2: 结果1 9 15 * 。。。。。 问题：为什么得到的结果不一样？ 看上面的对比，是因为编辑器的原因导致的?? 一开始某本书上的答案是 2 12 30 ，我很纳闷，开头第一个数居然是 2，于是一番折腾查阅了一下别人的看法。 我认为的原因是：undefined behavior 什么是：undefined behavior（未定义行为）呢？如下。 在计算机程序设计中，未定义行为（英语：undefined behavior) 是指行为不可预测的计算机代码。这是一些编程语言的一个特点，最有名的是在 C 语言中。在这些语言中，为了简化标准，并给予实现一定的灵活性，标准特别地规定某些操作的结果是未定义的，这意味着程序员不能预测会发生什么事。……. 因此，这种未定义行为一般应被视为 bug。—来源：中文维基百科 还有哪些 undefined behavior（未定义行为） 偷懒：)。此处省略一些例子，因为 wiki 上都有一些典型例子。中文访问不了的话，英文在这，点我。 如何解释这段代码 输出 1 9 15++ 其计算过程可能为：第一次循环时，i=1，i++=2，1 _ 2 = 2， 再 i++=3第二次循环时，i=3，i++=4，3 _ 4 = 12，再 i++=5第三次循环时，i=5，i++=5, 5 * 6 = 30，再 i++=6//进入 i&lt;=5 判断,值为假，退出循环 输出 2 12 30++ 其计算过程可能为：第一次循环时，首先 i=1, 1 _ 1 = 1，i++=2，再 i++=3第二次循环时，首先 i=3, 3 _ 3 = 9，i++=4，再 i++=5第三次循环时，首先 i=5, 5 * 5 = 25, i++=6，再 i++=7// i=7，所以退出循环。 首先 i++是先运算，后加。对于 SQ(i++)来说，其实质是((i++)*(i++))。在后加运算符是在整个运算完成之后，才进行加 1 操作的。 多问和讨论总是有好处的，继续保持：）参考：[1]c语言的代参宏定义，#define sq(y) ((y)*(y))….输出应该是2 12 30才对啊？？[2]int i=5 ；printf(“%d”,i++,++i)；为什么输出 6? [3]c语言中define的用法进阶（可不看）：关于宏定义的 ppt]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell的正则表达式]]></title>
    <url>%2F2017%2F07%2F20%2Fshell%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[简介 正则表达式用于描述字符排列和匹配模式的一种语法规则。—-用来筛选数据 正则表达式与通配符的区别 1.正则表达式–匹配“文件”符合条件的字符串–&gt;&gt;包含匹配 2.通配符—–匹配符合条件的“文件”名——–&gt;&gt;完全匹配 3.为什么存在，通配符、正则表达式？ ls、find、cp（操作文件的一些命令）不支持正则表达式，只能用通配符。 grep、awk、sed（操作字符串的一些命令）支持正则表达式。 为什么所有的不都支持正则表达式？ 正则表达式 基础正则 元字符 作用 * 前一个字符匹配0 次或任意多次 . 前一个字符匹配0 次或任意多次 ^ 匹配行首，例：^he 匹配以 he 开头的行 $ 匹配行尾，例：he$匹配以 he 为结尾的字符串 [ ] 匹配括号中指定的任意一个字符，只匹配一个 例：[a-z]匹配 a-z 中的任意一个字符，[0-9][a-z]表示“连续匹配” [^] 匹配除中括号字符外任意一个字符，例：^[0-9]匹配任意一位非数字的字符 \ 转义符，取消特殊字符的含义 \ { n\ } 表示前面字符恰好出现 n 次 \ { n,\ } 表示前面字符出现不小于n 次 \ {n,m\ } 表示其前面字符至少出现 n 次 扩展正则 正则表达式（基础正则）“ * “ “*“星号——–不同于通配符中的匹配所有内容。 前一个字符匹配0 次，或者任意多次。 a* - - 匹配所有内容，包括空白行。 aa* - - 匹配至少包含有一个 a 的行。 aaa* - -匹配至少包含两个连续的 a 的字符串。 “ . “ “.“——–和通配符中”?”类似。 匹配除了换行符外任意字符 s..d - - 匹配之间两个字符的单词。 s.*d - - 匹配之间的任意字符。 .* - - 匹配所有内容。 “ ^ “、” $ “、” [] “、” [ ^ ] “ “^“、”$“、”[]“、”[^]“ ^ - - 匹配行首。 $ - - 匹配行尾。 [] - - 匹配括号中指定字符串中的任意字符，只匹配一个。 [^] - - 匹配除中括号的字符以外的任意一个字符。 {n\ }、{n,\ }、{n,m\ } “\{n\}”、”\{n,\}“、”\{n,m\}“ \{n\} - - 例：a\{3\} 匹配 a 字母连续出现三次的字符串（连续四次以上也会被匹配到，所以在该匹配首尾加定界符能精确匹配到） \{n,\} - - 例：\{n,\} 前面字符出现不少于 n 次 \{n,m\} - - 例：sa\{1,3}i 匹配在字母 s 和字母 i 之间最少一个 a，最多三个 a]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[question-check]]></title>
    <url>%2F2017%2F05%2F27%2Fcheck-question%2F</url>
    <content type="text"><![CDATA[质量反馈调查展示界面 编辑 管理 答题 统计数据 题库]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[acm基础--POJ No.1003 Hangover]]></title>
    <url>%2F2017%2F05%2F25%2Facm00%2F</url>
    <content type="text"><![CDATA[关于运算符号的思考（acm 热身）POJ No.1003 Hangover input：1.003.71output：3 card(s)61 card(s) c#include&lt;stdio.h&gt;main()&#123; int n; float a,b; while(scanf("%f",&amp;b)==1) &#123; if(b==0.0)break; a=0.0; for(n=1;a&lt;b;++n) a+=1.0/(float)(n+1); printf("%d" card(s) \n",n-1); &#125;&#125; 逗号运算符号 while(scanf(“%f”,&amp;b)==1)compare towhile(scanf(“%f”,&amp;b),b)结束条件等价于b!=0即使 b 的值为 0.000001f,0.00001f!=0 为真，也不会结束循环。所以写法(*，b）非常重要 强制类型转换 直接用(float)转换为 int 类型，简单点就写成for(n=1;al；) 减少变量 省略 int 类型将 n 写入 main（），但是有的编译器并不能通过。所以为了简单清晰，还是不要用的好。 尽量多用 for 循环直接缩成一行 其中包含n省略在mainmain(n)&#123;float b;for(;scanf(&quot;%f&quot;,&amp;b),b;printf(&quot;%d card(s)\n&quot;,n-1)) for(n=1;b&gt;0;)b-=1./++n;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度优先算法-部分和问题]]></title>
    <url>%2F2017%2F05%2F24%2FDFS-%E9%83%A8%E5%88%86%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目给定整数 a~1~,a~2~ ,…,a~n~，判断是否可以从中选出若干数，使他们的和恰好为 k。 限制条件 1≤ n ≤20 -10^8^ ≤ a~i~ ≤ 10^8^ -10^8^ ≤ k ≤ 10^8^输入 n=4 a={1,2,4,7} k=13输出yes （13 = 2 + 4 + 7） 分析利用最简单的递归，可以先画出深度优先的树代码c++#include&lt;iostream&gt;using namespace std;const int MAXNUM = 20;// 输入int arr[MAXNUM];int n, k;void input_data(int *n, int *k, int *arr)&#123; cout &lt;&lt; "n = "; cin &gt;&gt; *n; cout &lt;&lt; "a = &#123;"; for (int i = 0; i &lt; *n; i++)&#123; cin &gt;&gt; arr[i]; cin.get(); cin.get(); &#125; cout &lt;&lt; "k = "; cin &gt;&gt; *k;&#125; //已经从前n项得到了和sum，然后对于i项之后的分支bool dfs(int i, int sum)&#123;// 如果前n项都计算过了，则返回sum是否与k相等 if (i == n) return sum == k;// 不加上a[i]的情况 if (dfs(i+1, sum)) return true;// 加上a[i]的情况 if (dfs(i+1, sum+arr[i])) return true;// 无论是否加上a[i],都不能凑成k就返回false return false;&#125;void solve()&#123; if (dfs(0, 0)) cout &lt;&lt; "Yes" &lt;&lt; endl; else cout &lt;&lt; "No" &lt;&lt; endl;&#125;int main()&#123; input_data(&amp;n, &amp;k, arr); solve(); return 0;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Steps]]></title>
    <url>%2F2017%2F05%2F21%2Fpoj%20No.2590%2F</url>
    <content type="text"><![CDATA[POj No.2590 Steps题目在数轴上的两点之间，按照下面规则移动。 每一步的步幅都要是自然数，同时必须与前一步幅相同或者是差 1。 每一步和最后一步的步幅必须是 1。当给出两点位置的时候，请回答从第一个点移动到第二点需要的最小步数。 输入和输出测试数据个数 n、开始地点 x 以及终点 y（0&lt;=x&lt;=y&lt;2^31^),格式如下： nx~1~ y~1~x~2~ y~2~…x~n~ y~n~ 输入 345 4845 4945 50 输出 334 代码c#include&lt;stdio.h&gt;int main()&#123; int step, i,len; for(step=0;step&lt;20;++step)&#123; len=0; //求得一半为止的步数 // 步数是奇数就加1 int mid=step/2+step%2; //求出1+2+3+...到中间地点为止的合计 for(i=1;i&lt;=mid;++i) len+=i; //从中间地点开始计算...+3+2+1 for(i=step/2;i&gt;0;--i) len+=i; printf("%2d step(s)...%3d\n",step,len); &#125;&#125; 解决思路 画图找规律]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj No.3062 Celebrity jeopardy]]></title>
    <url>%2F2017%2F05%2F20%2Fpoj%20No.3062%2F</url>
    <content type="text"><![CDATA[Celebrity jeopardy直接输出的数字 c#include&lt;stdio.h&gt; char c;int main()&#123; for(;~c;) &#123; c = getchar(); putchar(c); &#125;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>acm</tag>
        <tag>编程</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codewars_Replace With Alphabet Position]]></title>
    <url>%2F2017%2F05%2F07%2Fcodewars_Replace%20With%20Alphabet%20Position%2F</url>
    <content type="text"><![CDATA[题目这是一道字符串操作的题。题目如下： Welcome.In this kata you are required to, given a string, replace every letter with its position in the alphabet. If anything in the text isn’t a letter, ignore it and don’t return it. a being 1, b being 2, etc.As an example: 例子alphabet_position(&quot;The sunset sets at twelve o&apos; clock.&quot;)Should return &quot;20 8 5 19 21 14 19 5 20 19 5 20 19 1 20 20 23 5 12 22 5 15 3 12 15 3 11&quot; (As a string.) 分析首先肯定利用方法charCodeAt来处理字符，其次得转化下大小写，因为每个字符都是空格隔开，那么肯定用到split等来“切割”。思路大概就是我代码里头描述的，但是看最佳答案的时候，有相对另外的思路，大概意思差不多但是把处理的顺序调一下，会有意想不到的作用，也是佩服那些大牛们啊，具体怎么调整才可以 →_→ 最优，聪明的你，可以想一想啊 :) 留个悬念。 解题function alphabetPosition(text) &#123; return text.replace(/[^a-zA-Z]+/g,&apos;&apos;).toUpperCase().split(&apos;&apos;).map( function (eachStr) &#123; return eachStr.charCodeAt()-64; &#125;).join(&apos; &apos;);&#125;console.log(alphabetPosition(&apos;The testT&apos;)) 那么我看到目前为止最机智中票数最高的代码下面这个，可惜这些对我来说还是很晦涩啊。但是我想大概思路是差不多的。另外看到很多用 for 循环的，感觉太麻烦，虽然代码容易读，但是我想对于一个想学习 JS 的人来说，尽量用方法应该是好的。 let alphabetPosition = (text) =&gt; text .toUpperCase() .replace(/[^A-Z]/g, &apos;&apos;) .split(&apos;&apos;) .map(ch =&gt; ch.charCodeAt(0) - 64).join(&apos; &apos;); 实际运用看到 js 字符串转换为数字基本就用转换函数的比较多， js 字符串转换成数字常用的几种方法转换函数、强制类型转换、利用 js 变量弱类型转换。 转换函数parseInt(&quot;1234blue&quot;); // returns 1234 强制类型转换Boolean(&quot;hi&quot;); //true – non-empty string js 变量弱类型转换var str = &#39;012.345 &#39;;var x = str - 0;x = x * 1; 查资料发现，关于类型转换的还是比较多，但是我并没有感觉其中的区别和用的地方，可能是实际运用接触不多。但是关于字符和数字之间的转换在 Nodejs 中也是有体现。因此，觉得 codewars 的题目质量还真的挺不错，至少对于我这种初学者来说。每一道题目后面可能都是作者精心挑选出来的。所以，加油吧。 参考 JavaScript 权威指南(第 6 版)(中文版) JavaScript 语言精粹(修订版) 中文版 MDN(Mozilla Developer Network) js 字符串转换成数字]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>js</tag>
        <tag>codewars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vowel Counts]]></title>
    <url>%2F2017%2F04%2F02%2Fvowel%20count%2F</url>
    <content type="text"><![CDATA[统计字符串中的特定字符的数量。主要是方法的优化: 1. 题目 Description: Return the number (count) of vowels in the given string. We will consider a, e, i, o, and u as vowels for this Kata. 2. 例子 测试数据 //Example test:describe(&quot;Case 1&quot;, function()&#123; it (&quot;should be defined&quot;, function()&#123; Test.assertEquals(getCount(&quot;abracadabra&quot;), 5) &#125;);&#125;); 3. 分析 第一眼就想到是可以从头依次查找的。能想到用 c，java 等都是利用 for 循环来处理。 其次，JS 中想到的是字符串匹配，利用正则表达式对特定字符串遍历。然后输出匹配字符的 length。 * 利用字符串的原型方法String.prototype.match(),语法str.match(regxp) 后面再总结一下，string 类方法 match(regex) 和 RegExp 类方法 exec(string) 4. 解题4.1 最优化：function getCount(str) &#123; return (str.match(/[aeiou]/ig)||[]).length;&#125; 4.2 “多语言”解非常的直白啊，感觉都没有一点艺术。。 function getCount(str) &#123; var vowelsCount = 0; var a = [&apos;a&apos;,&apos;e&apos;,&apos;i&apos;,&apos;o&apos;,&apos;u&apos;]; for(var i=0; i&lt;str.length; i++)&#123; for(var j=0;j&lt;a.length; j++)&#123; if(a[j]===str[i])&#123; vowelsCount ++; &#125; &#125; &#125; return vowelsCount;&#125; 4.3 优化用indexof来减少 for 循环。 function getCount(str) &#123; var vowelCount = 0; var a = [&apos;a&apos;,&apos;e&apos;,&apos;i&apos;,&apos;o&apos;,&apos;u&apos;]; for(var i=0;i&lt;str.length; i++)&#123; if((a.indexOf(str[i]))!==-1)&#123; vowelCount ++; &#125; &#125; return vowelCount;&#125; 总结match（regexp）和 exec() 关于这两个的讨论，感觉说破天也没有 MDN 上说得好啊。:&gt;]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>js</tag>
        <tag>codewars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Don't rely on luck.]]></title>
    <url>%2F2017%2F03%2F30%2FMath.random%2F</url>
    <content type="text"><![CDATA[题目在 codewars 上碰到一道奇怪的题目。猜随机数。难度 6kyu，题干比以往简单。这就让人捉急了。什么都看不出来。接下来看题 The test fixture I use for this kata is pre-populated.It will compare your guess to a random number generated in Ruby by: (Kernel::rand() * 100 + 1).floorIn Javascript/CoffeeScript by: Math.floor(Math.random() * 100 + 1)In Python by:randint(1,100)You can pass by relying on luck or skill but try not to rely on luck. “The power to define the situation is the ultimate power.” - Jerry Rubin Good luck! 例子这里，题目给出的测试是： Example Test:var lucky_number = Math.floor(Math.random() * 100 + 1);Test.assertEquals(guess, lucky_number, &quot;Sorry. Unlucky this time.&quot;); 分析看到题目的时候，- - 就这么点? 然后 0.0 ，睁大眼睛看，然后 = =，这什么鬼，+.+，直接Math.random()?, @.@ 那怎么相等呢。？.?搜了下 9.9 ，发现只有Ruby 的答案。 再查了下随机数。_ 随机数分为 伪随机数 和 真随机数 _ 正常电脑各种语言中使用的都是 伪随机数 ，是由可确定的函数，通过种子（常用时钟），产生伪随机数，这种数字理论上存在可预测性。 * _函数_ :计算机产生随机数的方法有：线性同余方法(大部分采用,，即 RandNumber = (Rand_Seed X + Y) mod Z 那个 RandSeed 就是「种子」一般取时钟周期，也就是 GetTickCount()。），平方取中法，M-sequence，梅森旋转算法，还有MT随机数算法。_ ps:这里不对 随机数的产生和随机数的计算理论做深究。具体可以看这里，各答案较完整讲了计算机产生的是伪随机数，还有产生 真随机数 的可行性。 那么 JavaScript 中的随机数是个什么样的存在？答案当然是伪随机数。= =_ JavaScript 中并没有类似上面底层语言提供的函数,根据 panxiwu 博客中的说法，c 和 Ruby 都有底层重置 seed 方法依据不同的方法来生成种子。而，JavaScript 应该是依靠引擎使用随机函数方法，所以在安全方面，不用 Math.random 最好，替代的可以使用window.crypto.getRandomValues(array); &gt; MDN：Math.random() does not provide cryptographically secure random numbers. Do not use them for anything related to security. Use the Web Crypto API instead, and more precisely the window.crypto.getRandomValues() method._ V8 引擎中实现 随机数：通过 Mathlmmul 来创造，并没有所谓的 seed 参数，所以只能重写。 // ECMA 262 - 15.8.2.14 var rngstate;// Initialized to a Uint32Array during genesis.function MathRandom() &#123;var r0 = (MathImul(18030, rngstate[0] &amp; 0xFFFF) + (rngstate[0] &gt;&gt;&gt; 16)) | 0; rngstate[0] = r0; var r1 = (MathImul(36969, rngstate[1] &amp; 0xFFFF) + (rngstate[1] &gt;&gt;&gt; 16)) | 0; rngstate[1] = r1; var x = ((r0 &lt;&lt; 16) + (r1 &amp; 0xFFFF)) | 0;// Division by 0x100000000 through multiplication by reciprocal.return (x &lt; 0 ? (x + 0x100000000) : x) * 2.3283064365386962890625e-10; &#125;// Non-standard extension.function MathImul(x, y) &#123; return %NumberImul(TO_NUMBER_INLINE(x), TO_NUMBER_INLINE(y));&#125; from v8 解题var guess = 10Math.floor = function(num) &#123;return guess;&#125; Accept!然后看到一堆不可描述的东西。lol 这个…….. var guess = 10;lucky_number = 10; 还有这个 Math.random=()=&gt;&quot;:D&quot;Math.floor=x=&gt;(x+&apos;&apos;).replace(/N/g,&apos;L&apos;).replace(/a/g,&quot;0&quot;)var guess = &quot;L0L&quot; 不少都是写死了 random 的值然后钻牛角尖的。。还有令人搞笑的，可以拿来当笑话集了，这题： var guess = &quot;What a stupid kata.&quot;;Math.floor = function() &#123; return &quot;What a stupid kata.&quot;;&#125; 还有这个，，厉害了。。。 实际运用 比如我们在开发京东的 H5 活动页面的小游戏时，可能需要随机产生一些背景、随机掉落道具、小怪物；当用户中途退出(微信不小心右滑，一定有不少人被这个恶心到[当然现在已经优化])，当用户重新打开小游戏时，用户整体进度、积分我们可以很容易记录到本地或者存储到微信 ID 建立的存储机制中从而得以恢复，但是随机产生的场景、随机掉落道具、小怪物等并不是那么容易存储恢复，重新获取场景、小怪物那未免用户体验太差！！！把画布上的所有物件、怪物属性全部存储下来更是没有必要。此时我们就可以利用我们重写的 Math.random()(此时可不重写内置方法，可另起别名)。只要我们保存下来一个随机数 seed 值，利用 seed 值来恢复所有的场景就好了。from 潘信伍 ,谢谢大神啊 参考悟道集JavaScript 中 Math.random 的种子设定方法]]></content>
      <categories>
        <category>工作</category>
        <category>codewars</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[holygrail（圣杯布局）]]></title>
    <url>%2F2017%2F03%2F25%2Fholygrail%2F</url>
    <content type="text"><![CDATA[圣杯布局(holygrail)起源 三列。两列固定在两边，中间是一个 流体 圣杯布局的原理是? 简述实现圣杯布局的步骤。双飞翼布局和圣杯布局有什么异同负 margin 的用法 例子 一个简单的仿照例子实现圣杯布局 步骤 1. 建立框架&lt;body&gt;&lt;!--第一步 建立框架--&gt;&lt;div id=&quot;header&quot;&gt;&lt;h1&gt;#header&lt;/h1&gt;&lt;/div&gt;&lt;div id=&quot;container&quot;&gt; &lt;h1&gt;#container&lt;/h1&gt;&lt;/div&gt;&lt;div id=&quot;footer&quot;&gt;&lt;h1&gt;#footer&lt;/h1&gt;&lt;/div&gt;&lt;/body&gt; 2. 加 column float 让其在 line。再清除 footer 让它在最下面。添加背景颜色和边界便于观察。中间栏要放在前面以优先渲染。 &lt;style&gt;#container &#123; padding-left: 200px; padding-right:150px; &#125; #container .column &#123; float: left; &#125; #center &#123; width:100%; &#125; #left &#123; width:200px; &#125; #right &#123; width: 150px; &#125; #footer &#123; clear: both; &#125; &lt;/style&gt; &lt;div id=&quot;container&quot;&gt; &lt;h1&gt;#container&lt;/h1&gt; &lt;div id=&quot;center&quot; class=&quot;column&quot;&gt;&lt;h1&gt;this is center&lt;/h1&gt;&lt;/div&gt; &lt;div id=&quot;left&quot; class=&quot;column&quot;&gt;&lt;h1&gt;this is left&lt;/h1&gt;&lt;/div&gt; &lt;div id=&quot;right&quot; class=&quot;column&quot;&gt;&lt;h1&gt;this is right&lt;/h1&gt;&lt;/div&gt;&lt;/div&gt; 效果图 2.1 3. 将左栏拉到相应位置 要让左栏和中间在一条直线上，先对左栏进行操作,分两步。margin-left:-100%跑到左上角（覆盖主栏目），再设置 position:relative,right:200px 或者 left:-200px（不覆盖主栏目） 第一步 #left &#123; width:200px; margin-left: -100%; background-color: #555555;&#125; 效果图 3.1 * 第二步用相对定位将左栏推开，加上相对定位标志之后，记得给左栏一个right:200px将左栏相对右边 200px,往左推 200px。 #left &#123; width:200px; margin-left: -100%; right:200px; background-color: #555555; &#125; 效果图 3.2. 4.将右栏加入 line注意： 原作者这里用的是margin-right:-150px，在演示时并不能起效果。 #right &#123; width: 150px margin-right: -100%; background-color: #8cacea;&#125; 效果图 4.1再处理一些小细节,固定的右边栏多出的字，撑开了 效果图 4.2 5.结果 总结实现步骤1. div 框架搭建出来， div- &gt;container，header，footer 2. 加 column， 设置float:left， 设置center宽度100% 清除footer浮动 3. 将左栏添到 center 左边， margin-left:-100%到左上（覆盖主栏目）， 再设置position:relative,right:200px或者left:-200px（不覆盖主栏目） 4. 将右栏添右 margin-right: -100%; 圣杯布局和双飞翼布局异同 两种布局方式都是把主列放在文档流最前面，使主列优先加载 两者在实现上的相同点在于都让三列浮动，然后通过负外边距形成三列布局； 两种布局方式的不同在于如何处理中间主列的位置：圣杯布局是利用父容器的左右内边距定位；双飞翼布局是把主列嵌套在 div 后利用主列的左右外边距定位。 浮动元素上的负 margin 给一个浮动元素加上相反方向的负 margin，则会使行间距为 0 且内容重叠。 bug 修复 * 当浮动元素使用负 margin 时，在一些旧的浏览器中可能会出现问题。用position:float,能解决很多问题。 具体可以参考 负 margin 用法权威指南 flex 实现的“标准”圣杯布局MDN 效果图 其他 圣杯布局基本就是（适：自适应，左：左栏，右：右栏）_ 左适右_ 左右适_ 左适、右适_ 等等 圣杯布局还有很多的实现方法_ 纯浮动实现_ flex 实现可以参考，圣杯布局小结，觉得这位作者对圣杯布局总结的挺好，各种小例子。其他的也可以搜一下。我这里主要是介绍下圣杯布局。 圣杯布局类似 * 双飞翼布局 1. left 和 right 覆盖了 center 的左右两边的内容。 2. center 的外部再加一个 div 标签来包裹中间区块， 3. 宽度为 100%。然后再设置 main 的左右外边距，使它回到对应的位置。 参考In Search of the Holy Grail by Matthew Levine关于「圣杯布局」 by DotHide圣杯布局小结 by 流云诸葛圣杯布局和双飞翼布局 by betterwlfCSS 之圣杯布局和双飞翼布局 by 宋菲负 margin 用法权威指南 by Airen 的博客]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法小记]]></title>
    <url>%2F2017%2F03%2F20%2Fmarkdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[插入表格：1.1. 表格的上下需要空行。空行的多少至关重要 表格中文字居中 在划线部分的划线两端加上”:“ 比如”:—–: | :—-: 代码块:2.1. 合理利用代码块有意想不到的效果。3.]]></content>
      <tags>
        <tag>markdown</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codewars-count_digits]]></title>
    <url>%2F2017%2F03%2F20%2Fcodewars%2F</url>
    <content type="text"><![CDATA[题目 Take an integer n (n &gt;= 0) and a digit d (0 &lt;= d &lt;= 9) as an integer. Square all numbers k (0 &lt;= k &lt;= n) between 0 and n. Count the numbers of digits d used in the writing of all the k* *2. Call nb_dig (or nbDig or …) the function taking n and d as parameters and returning this count. 例子 n = 10, d = 1,the k * k are 0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100 We are using the digit 1 in 1, 16, 81, 100. The total count is then 4.nb_dig(25, 1):the numbers of interest are 1, 4, 9, 10, 11, 12, 13, 14, 19, 21which squared are 1, 16, 81, 100, 121, 144, 169, 196, 361, 441 so there are 11 digits 1 for the squares of numbers between 0 and 25. 分析 给出n和d，求 0 到 n 中间的平方，再求这些平方的平方，问所得的这些数中包含多少个数字d。大概就是先算出这些数字的平方，然后挨个分解求出其中的值。 解题function nbDig(n,d) &#123; var s = &apos;&apos;; for(var i=0;i&lt;=n;i++)&#123; s += Math.pow(i,2); &#125; return s.split(d).length-1&#125; 牢骚篇今天，进了个群，挺多厉害的人，还私聊了一个有很多 offer 的同学。顿时觉得，自己就是渣渣啊，一点信心都没有。还是得加油吧，要学的东西还很多啊。]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>js</tag>
        <tag>codewars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codewars ooxx =>true]]></title>
    <url>%2F2017%2F03%2F17%2Fcodewars-ooxx%2F</url>
    <content type="text"><![CDATA[前言第二关 Yeah！目标 6kyu，坚持升级~ ：） 这一关，考察几个基本方法的使用，虽然单独拿出来可能难度不大，但是真正运用在工作中的时候，这些方法可能如大海捞针，不熟练是一时半会儿想不出来的。 话不多说，呀呀呀，提枪上阵， 题目描述Check to see if a string has the same amount of ‘x’s and ‘o’s. The method must return a boolean and be case insensitive. The string can contains any char.（0.0 看不懂？往下戳） 例子XO(&quot;ooxx&quot;) =&gt; trueXO(&quot;xooxx&quot;) =&gt; falseXO(&quot;ooxXm&quot;) =&gt; trueXO(&quot;zpzpzpp&quot;) =&gt; true // when no &apos;x&apos; and &apos;o&apos; is present should return trueXO(&quot;zzoo&quot;) =&gt; false 分析题目大概意思就是： 在有限任意字符串中字符 x 和 o 存在且数量相等时 值为 true,否则当x和o不存在时，值为flase。匹配的话，首先想到正则表达式来处理。 方法一利用 RegExp 来匹配正则，然后再判断数量为空和数量是否相等。 function xo(str) &#123; var numX = new RegExp(/x/gi); //g 全局搜索，i 忽略大小写 var numO = new RegExp(/o/gi); if(numX.test(str)&amp;&amp;numO.test(str))&#123; if(str.match(/x/gi).length == str.match(/o/gi).length)&#123; return true; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125;console.log(xo(&apos;xxoo&apos;))console.log(xo(&apos;glld&apos;)) 仔细一看，这种写法太麻烦。如何轻松取敌呢？ 方法二直接返回一个 return，并在 return 中判断。 function xo(str) &#123; var numX = str.match(/x/gi) || []; var numO = str.match(/x/gi) || []; return numO.length == numX.length;&#125; 解析方法一方法二 什么鬼！这不同的方法有什么区别呢？？我来试着剖析下这两种方法究竟是何利器。来看看MDN是怎么说的？贴心的MDN还在match这一篇中对两者进行了比较。 1. RegExp 构造函数创建了一个正则表达式对象，用于将文本与模式匹配。 2.当一个字符串与一个正则表达式匹配时， match()方法检索匹配项。 比较 如果正则表达式没有 g 标志，则 str.match() 会返回和 RegExp.exec() 相同的结果。而且返回的 Array 拥有一个额外的 input 属性，该属性包含被解析的原始字符串。另外，还拥有一个 index 属性，该属性表示匹配结果在原字符串中的索引（以 0 开始）。 用法 如果你需要知道一个字符串是否匹配一个正则表达式 RegExp ，可使用 search() 。如果你只是需要第一个匹配结果，你可能想要使用 RegExp.exec() 。如果你想要获得捕获组，并且设置了全局标志，你需要用 RegExp.exec() 。 综上：大概就是这么吧~不用鸟我了，直接看文档吧~ 方法三方法三是在解答完之后查看他人的方法，大神们就是大神。对于各种用法如数家珍，信手拈来。 let x = str.match(/x/gi);let o = str.match(/o/gi);return (x &amp;&amp; x.length) === (o &amp;&amp; o.length);&#125; 实际运用 这个keyword变量该如何转义呢？ function addHightLight(txt,keyword) &#123; return txt.replace(/+keyword+/g,&quot;&lt;mark class=keyword&gt;&quot;+keyword+&quot;&lt;/mark&gt;&quot;);&#125; 答案是： function addHightLight(txt,keyword) &#123; txt = &quot;咖啡&quot; ;keyword = &quot;机器&quot;; var va = new RegExp(keyword,&quot;g&quot;); va = /\/咖啡\/g/&#123;lastIndex:0&#125; return txt.replace(va,&quot;&lt;mark class=keyword&gt;&quot;+keyword+&quot;&lt;/mark&gt;&quot;);&#125; 就到这里了~]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>js</tag>
        <tag>codewars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codewars - - accm]]></title>
    <url>%2F2017%2F03%2F16%2Fcodewars-accm%2F</url>
    <content type="text"><![CDATA[前言 最近在找实习啊，希望暑假有份合适的工作来填充暑假。就刷 codewars。我比较懒所以更新的可能比较慢。。 题目描述This time no story, no theory. The examples below show you how to write function accum: 示例accum(&quot;abcd&quot;); // &quot;A-Bb-Ccc-Dddd&quot;accum(&quot;RqaEzty&quot;); // &quot;R-Qq-Aaa-Eeee-Zzzzz-Tttttt-Yyyyyyy&quot;accum(&quot;cwAt&quot;); // &quot;C-Ww-Aaa-Tttt&quot; 分析 大概意思就是递增的方式来重复每个字符再用依次拼接在一块儿，确定用join()来拼接，用 map 方法来迭代，再把首字母转为大写，其余为小写具体方法如下 解一 参考方法而之后发现这个并没有完全利用 js 中语法的特性，感觉在 js 学习中不可取 function accm(s) &#123; s = s.toUpperCase().split(''); for (var i = 0, l = s.length; i &lt; l; i++) &#123; var tmp = s[i].toLowerCase(); for (var j = 0; j &lt; i; j++) &#123; s[i] += tmp; &#125; &#125; return s.join('-');&#125; 解决二function accm(s)&#123;//分割。再map方法查询，再转换大小写 return s.split(&apos;&apos;).map( (x,index) =&gt; x.toUpperCase() + Array(index+1).join(x.toLowerCase())).join(&apos;-&apos;);&#125; 解决三 在方法一上，进行简化，但是没有方法二更简单 function accum(s)&#123; var letter = s.split(&apos;&apos;); var result = []; for(var i=0;i&lt;letter.length;i++)&#123; result.push(letter[i].toUpperCase()+Array(i+1).join(letter[i].toLowerCase())); &#125; return result.join(&apos;_&apos;);&#125;//输出accum(&apos;fds&apos;)F_Dd_Sss 总结在平时的学习中能多用到所学知识是最好的，如果混合方法写，不利于学习。]]></content>
      <categories>
        <category>工作</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>js</tag>
        <tag>codewars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 2.0 之 Vue-Router 路由挂载实例]]></title>
    <url>%2F2017%2F01%2F26%2Fvue-router%E6%8C%82%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[原因 在新出的 vue 2.0 中文档，挂载实例 问题 在构建路由时，vue1.0 中应用 map 方法，而在 2.0 中取消了 map 方法，而快速的启用 new router 便可以建立。在 vue1.0 到 vue2.0 的迁移时，也带来了很多麻烦。 问题点 render: h =&gt; h(App) 路由挂载的正确姿势 问题描述 vue1.0 中的实例很方便实现，而 2.0 中的实例模板并不是很好使用。 vue1.0 中 vue-router 写法、vue2.0 中 vue-router 写法 问题解决 vue2.0 官网中： // 0. 如果使用模块化机制编程，導入Vue和VueRouter，要调用Vue.use(VueRouter);// 1. 定义（路由）组件。// 可以从其他文件 import 进来const Foo = &#123; template: '&lt;div&gt;foo&lt;/div&gt;' &#125;;const Bar = &#123; template: '&lt;div&gt;bar&lt;/div&gt;' &#125;;// 2. 定义路由// 每个路由应该映射一个组件。 其中"component" 可以是// 通过 Vue.extend() 创建的组件构造器，// 或者，只是一个组件配置对象。// 我们晚点再讨论嵌套路由。const routes = [ &#123; path: '/foo', component: Foo &#125;, &#123; path: '/bar', component: Bar &#125;];// 3. 创建 router 实例，然后传 `routes` 配置// 你还可以传别的配置参数, 不过先这么简单着吧。const router = new VueRouter(&#123; routes // （缩写）相当于 routes: routes&#125;);// 4. 创建和挂载根实例。// 记得要通过 router 配置参数注入路由，// 从而让整个应用都有路由功能const app = new Vue(&#123; router&#125;).$mount('#app'); 实际案例写法 import Vue from 'vue';import VueRouter from 'vue-router';import App from './App';import goods from './components/goods/goods';Vue.use(VueRouter);//路由嵌套const router = new VueRouter(&#123; routes: [ &#123; path: '/goods', component: goods &#125; ]&#125;);new Vue(&#123; router, render: h =&gt; h(App) //关键点，官网中没加，这个相当于ES6的写法&#125;).$mount('#app');//默认去goodsrouter.push('goods');]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置hexo标签]]></title>
    <url>%2F2016%2F03%2F20%2Fhexo%E4%B8%AD%E7%9A%84tags%2F</url>
    <content type="text"><![CDATA[体会 hexo 写作要求的格式非常的严格，连空格都不能省略。 英语不好是硬伤，tags 标签在我配置的时候写成了 tages！害 得我找了很久。总算是搭建完了很多的功能。]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css和sass的比较]]></title>
    <url>%2F2016%2F01%2F18%2Fsass%E4%B8%8Ecss%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[css和sass的比较一个程序来说明sass和css3 这里配置sass不做介绍，请参考sass详细介绍和安装 对比 在这两个效果一样编译结果不一样的文件中你可以看到区别，sass对于程序化css起很大作用。 sass// n is number of stars required@function multiple-box-shadow ($n) $value: &apos;#&#123;random(2000)&#125;px #&#123;random(2000)&#125;px #FFF&apos; @for $i from 2 through $n $value: &apos;#&#123;$value&#125; , #&#123;random(2000)&#125;px #&#123;random(2000)&#125;px #FFF&apos; @return unquote($value)$shadows-small: multiple-box-shadow(700)$shadows-medium: multiple-box-shadow(200)$shadows-big: multiple-box-shadow(100)html height: 100% background: radial-gradient(ellipse at bottom, #1B2735 0%, #090A0F 100%) overflow: hidden #stars width: 1px height: 1px background: transparent box-shadow: $shadows-small animation : animStar 50s linear infinite &amp;:after content: &quot; &quot; position: absolute top: 2000px width: 1px height: 1px background: transparent box-shadow: $shadows-small #stars2 width: 2px height: 2px background: transparent box-shadow: $shadows-medium animation : animStar 100s linear infinite &amp;:after content: &quot; &quot; position: absolute top: 2000px width: 2px height: 2px background: transparent box-shadow: $shadows-medium #stars3 width: 3px height: 3px background: transparent box-shadow: $shadows-big animation : animStar 150s linear infinite &amp;:after content: &quot; &quot; position: absolute top: 2000px width: 3px height: 3px background: transparent box-shadow: $shadows-big#title position: absolute top: 50% left: 0 right: 0 color: #FFF text-align: center font-family: &apos;lato&apos;,sans-serif font-weight: 300 font-size: 50px letter-spacing: 10px margin-top: -60px padding-left: 10px span background: -webkit-linear-gradient(white, #38495a) -webkit-background-clip: text -webkit-text-fill-color: transparent @keyframes animStar from transform: translateY(0px) to transform: translateY(-2000px) csshtml &#123; height: 100%; background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%); overflow: hidden;&#125;#stars &#123; width: 1px; height: 1px; background: transparent; box-shadow: 1747px 1720px #FFF , 1693px 439px #FFF , 699px 1744px #FFF , 180px 479px #FFF , 379px 729px #FFF , 1294px 910px #FFF , 479px 1860px #FFF , 270px 1211px #FFF , 252px 1651px #FFF , 472px 1251px #FFF , 1650px 235px #FFF , 311px 1770px #FFF , 1469px 984px #FFF , 1349px 1839px #FFF , 525px 958px #FFF , 753px 1748px #FFF , 753px 1299px #FFF , 530px 489px #FFF , 1574px 311px #FFF , 760px 76px #FFF , 774px 837px #FFF , 1505px 1499px #FFF , 18px 512px #FFF , 1587px 1312px #FFF , 1072px 753px #FFF , 911px 866px #FFF , 1217px 1280px #FFF , 226px 958px #FFF , 1021px 149px #FFF , 1129px 1781px #FFF , 976px 1354px #FFF , 12px 1248px #FFF , 1816px 1631px #FFF , 178px 1185px #FFF , 628px 962px #FFF , 1806px 315px #FFF , 667px 1436px #FFF , 1133px 1304px #FFF , 1539px 661px #FFF , 342px 148px #FFF , 138px 332px #FFF , 1928px 612px #FFF , 434px 970px #FFF , 577px 456px #FFF , 1132px 892px #FFF , 1880px 1680px #FFF , 1524px 268px #FFF , 1406px 1375px #FFF , 747px 726px #FFF , 1016px 523px #FFF , 1996px 1063px #FFF , 1128px 595px #FFF , 177px 1792px #FFF , 1430px 477px #FFF , 949px 334px #FFF , 486px 1949px #FFF , 1958px 170px #FFF , 1899px 1870px #FFF , 1105px 208px #FFF , 271px 719px #FFF , 822px 598px #FFF , 409px 1398px #FFF , 345px 607px #FFF , 160px 156px #FFF , 946px 522px #FFF , 1796px 1680px #FFF , 1896px 1125px #FFF , 1731px 1802px #FFF , 1147px 503px #FFF , 525px 1562px #FFF , 1791px 1266px #FFF , 1650px 312px #FFF , 102px 1586px #FFF , 1885px 1314px #FFF , 781px 1403px #FFF , 901px 1566px #FFF , 1934px 1761px #FFF , 767px 646px #FFF , 797px 1990px #FFF , 486px 889px #FFF , 1165px 1607px #FFF , 940px 1092px #FFF , 821px 957px #FFF , 1563px 1793px #FFF , 83px 498px #FFF , 1246px 492px #FFF , 80px 956px #FFF , 1137px 1795px #FFF , 1365px 1816px #FFF , 549px 1650px #FFF , 1645px 1758px #FFF , 244px 1543px #FFF , 1941px 325px #FFF , 1347px 1608px #FFF , 409px 433px #FFF , 1364px 552px #FFF , 264px 1839px #FFF , 1610px 581px #FFF , 1225px 1386px #FFF , 763px 1077px #FFF , 1442px 1362px #FFF , 1152px 794px #FFF , 191px 1980px #FFF , 1537px 281px #FFF , 819px 749px #FFF , 1906px 1489px #FFF , 529px 1711px #FFF , 272px 910px #FFF , 26px 768px #FFF , 1702px 1887px #FFF , 531px 1236px #FFF , 1911px 11px #FFF , 875px 544px #FFF , 1340px 443px #FFF , 350px 343px #FFF , 368px 1663px #FFF , 1761px 671px #FFF , 1246px 1936px #FFF , 1927px 1611px #FFF , 1630px 1003px #FFF , 1602px 722px #FFF , 544px 178px #FFF , 1680px 994px #FFF , 1466px 296px #FFF , 1192px 1239px #FFF , 1864px 1361px #FFF , 503px 153px #FFF , 1778px 1652px #FFF , 1830px 513px #FFF , 360px 236px #FFF , 357px 1252px #FFF , 127px 847px #FFF , 1729px 1178px #FFF , 237px 1815px #FFF , 608px 108px #FFF , 1869px 1657px #FFF , 1864px 664px #FFF , 108px 175px #FFF , 807px 851px #FFF , 1031px 645px #FFF , 1322px 16px #FFF , 285px 154px #FFF , 414px 404px #FFF , 1750px 385px #FFF , 450px 579px #FFF , 1515px 546px #FFF , 915px 1198px #FFF , 921px 1940px #FFF , 234px 80px #FFF , 1790px 1079px #FFF , 1270px 1768px #FFF , 1680px 587px #FFF , 612px 400px #FFF , 1150px 1336px #FFF , 568px 776px #FFF , 839px 1939px #FFF , 1565px 267px #FFF , 294px 1855px #FFF , 524px 364px #FFF , 734px 789px #FFF , 1979px 1049px #FFF , 1353px 410px #FFF , 1016px 438px #FFF , 255px 1707px #FFF , 1699px 580px #FFF , 1812px 1261px #FFF , 84px 481px #FFF , 921px 863px #FFF , 113px 228px #FFF , 980px 806px #FFF , 920px 845px #FFF , 1933px 623px #FFF , 1744px 1304px #FFF , 148px 40px #FFF , 1732px 1292px #FFF , 1487px 1736px #FFF , 1123px 189px #FFF , 555px 1290px #FFF , 1293px 1629px #FFF , 1034px 521px #FFF , 1573px 1332px #FFF , 1679px 1906px #FFF , 1834px 1062px #FFF , 802px 1374px #FFF , 863px 66px #FFF , 660px 1260px #FFF , 1714px 1012px #FFF , 1698px 964px #FFF , 260px 626px #FFF , 402px 1064px #FFF , 621px 1517px #FFF , 989px 822px #FFF , 751px 29px #FFF , 1342px 1655px #FFF , 1314px 389px #FFF , 807px 1137px #FFF , 1820px 831px #FFF , 394px 658px #FFF , 1234px 562px #FFF , 612px 1674px #FFF , 180px 836px #FFF , 1291px 506px #FFF , 1936px 480px #FFF , 970px 1767px #FFF , 1066px 1142px #FFF , 351px 1465px #FFF , 1446px 1909px #FFF , 254px 306px #FFF , 1969px 1642px #FFF , 269px 404px #FFF , 838px 98px #FFF , 1794px 1243px #FFF , 1030px 1033px #FFF , 962px 1694px #FFF , 284px 497px #FFF , 109px 1796px #FFF , 1897px 592px #FFF , 1108px 1186px #FFF , 1464px 990px #FFF , 329px 1595px #FFF , 1524px 1046px #FFF , 454px 280px #FFF , 248px 493px #FFF , 1778px 1145px #FFF , 865px 1223px #FFF , 1045px 57px #FFF , 777px 128px #FFF , 1929px 565px #FFF , 880px 1923px #FFF , 1555px 20px #FFF , 140px 400px #FFF , 214px 26px #FFF , 1986px 182px #FFF , 588px 659px #FFF , 531px 1025px #FFF , 1503px 448px #FFF , 1437px 816px #FFF , 171px 1652px #FFF , 416px 1692px #FFF , 21px 1457px #FFF , 135px 1158px #FFF , 828px 499px #FFF , 1748px 666px #FFF , 749px 549px #FFF , 320px 1241px #FFF , 1718px 624px #FFF , 287px 935px #FFF , 739px 397px #FFF , 1319px 1371px #FFF , 1257px 1186px #FFF , 46px 1278px #FFF , 1826px 1073px #FFF , 1530px 1720px #FFF , 1302px 548px #FFF , 1411px 550px #FFF , 700px 615px #FFF , 404px 1006px #FFF , 1119px 1467px #FFF , 1154px 1330px #FFF , 1585px 248px #FFF , 1080px 671px #FFF , 219px 1195px #FFF , 903px 584px #FFF , 711px 1244px #FFF , 730px 1427px #FFF , 1891px 1491px #FFF , 1936px 1196px #FFF , 1605px 140px #FFF , 384px 194px #FFF , 148px 394px #FFF , 837px 1028px #FFF , 1949px 1981px #FFF , 159px 1530px #FFF , 1763px 1244px #FFF , 713px 1187px #FFF , 1356px 766px #FFF , 387px 280px #FFF , 18px 240px #FFF , 42px 840px #FFF , 1178px 253px #FFF , 1075px 1392px #FFF , 1944px 1639px #FFF , 748px 178px #FFF , 1952px 1310px #FFF , 1918px 1612px #FFF , 557px 755px #FFF , 993px 1080px #FFF , 192px 1863px #FFF , 489px 1175px #FFF , 647px 105px #FFF , 498px 1477px #FFF , 1398px 1548px #FFF , 821px 980px #FFF , 1412px 347px #FFF , 291px 755px #FFF , 953px 232px #FFF , 681px 20px #FFF , 261px 391px #FFF , 256px 1048px #FFF , 876px 1530px #FFF , 1003px 1213px #FFF , 1626px 940px #FFF , 1778px 1974px #FFF , 767px 1944px #FFF , 721px 673px #FFF , 714px 394px #FFF , 1284px 629px #FFF , 1813px 1464px #FFF , 222px 465px #FFF , 544px 1980px #FFF , 935px 542px #FFF , 331px 1468px #FFF , 1173px 1095px #FFF , 29px 1107px #FFF , 1810px 715px #FFF , 479px 1476px #FFF , 1801px 1739px #FFF , 1989px 599px #FFF , 1656px 1744px #FFF , 1117px 1377px #FFF , 1757px 800px #FFF , 373px 1151px #FFF , 1001px 64px #FFF , 1828px 1355px #FFF , 1493px 1243px #FFF , 176px 497px #FFF , 683px 1634px #FFF , 1120px 659px #FFF , 648px 1643px #FFF , 1281px 347px #FFF , 105px 1309px #FFF , 77px 1335px #FFF , 667px 1892px #FFF , 868px 1783px #FFF , 319px 1180px #FFF , 860px 1263px #FFF , 447px 916px #FFF , 723px 402px #FFF , 875px 283px #FFF , 1330px 1083px #FFF , 1175px 819px #FFF , 667px 1469px #FFF , 680px 371px #FFF , 1357px 1235px #FFF , 1223px 1701px #FFF , 1452px 1322px #FFF , 32px 882px #FFF , 1545px 407px #FFF , 1924px 1404px #FFF , 1846px 1390px #FFF , 216px 1421px #FFF , 1421px 1584px #FFF , 1167px 1901px #FFF , 276px 1756px #FFF , 714px 1856px #FFF , 359px 1199px #FFF , 1143px 1080px #FFF , 891px 635px #FFF , 579px 230px #FFF , 570px 676px #FFF , 1156px 1764px #FFF , 944px 1652px #FFF , 301px 666px #FFF , 209px 1005px #FFF , 460px 677px #FFF , 186px 1260px #FFF , 849px 284px #FFF , 240px 1059px #FFF , 953px 1959px #FFF , 783px 328px #FFF , 1794px 128px #FFF , 1884px 1051px #FFF , 842px 758px #FFF , 1848px 318px #FFF , 852px 348px #FFF , 1242px 1496px #FFF , 441px 712px #FFF , 1039px 113px #FFF , 1994px 749px #FFF , 1777px 1596px #FFF , 1471px 1817px #FFF , 1482px 1668px #FFF , 1837px 522px #FFF , 1272px 1285px #FFF , 751px 1669px #FFF , 104px 1968px #FFF , 1570px 400px #FFF , 1225px 1879px #FFF , 885px 1156px #FFF , 1392px 121px #FFF , 1754px 1477px #FFF , 251px 1060px #FFF , 1701px 547px #FFF , 1847px 114px #FFF , 1733px 1932px #FFF , 1178px 873px #FFF , 553px 191px #FFF , 1974px 1659px #FFF , 1155px 612px #FFF , 1509px 1533px #FFF , 1936px 1148px #FFF , 1708px 224px #FFF , 1358px 1235px #FFF , 293px 608px #FFF , 424px 639px #FFF , 347px 1944px #FFF , 1813px 243px #FFF , 150px 1042px #FFF , 36px 1533px #FFF , 1215px 64px #FFF , 1393px 730px #FFF , 567px 1509px #FFF , 1209px 1055px #FFF , 1969px 718px #FFF , 1458px 42px #FFF , 1494px 817px #FFF , 1863px 1290px #FFF , 1508px 1194px #FFF , 1607px 906px #FFF , 1371px 997px #FFF , 573px 871px #FFF , 1625px 1930px #FFF , 1422px 1835px #FFF , 1400px 1990px #FFF , 467px 1695px #FFF , 911px 1526px #FFF , 1745px 766px #FFF , 1016px 1602px #FFF , 1940px 1154px #FFF , 1468px 1035px #FFF , 1298px 992px #FFF , 874px 1589px #FFF , 1288px 721px #FFF , 1611px 905px #FFF , 569px 1548px #FFF , 1536px 1526px #FFF , 1668px 1903px #FFF , 267px 1053px #FFF , 1403px 4px #FFF , 1722px 91px #FFF , 863px 1904px #FFF , 120px 1878px #FFF , 21px 47px #FFF , 1384px 718px #FFF , 1000px 1523px #FFF , 1019px 1768px #FFF , 811px 209px #FFF , 950px 1763px #FFF , 504px 1011px #FFF , 420px 1424px #FFF , 1606px 747px #FFF , 1073px 9px #FFF , 860px 1731px #FFF , 473px 990px #FFF , 922px 1704px #FFF , 371px 15px #FFF , 821px 1243px #FFF , 423px 1259px #FFF , 1974px 1100px #FFF , 183px 615px #FFF , 1430px 6px #FFF , 909px 296px #FFF , 449px 251px #FFF , 953px 155px #FFF , 824px 706px #FFF , 1097px 429px #FFF , 1104px 260px #FFF , 271px 1851px #FFF , 1224px 1554px #FFF , 521px 1040px #FFF , 160px 1852px #FFF , 1564px 1782px #FFF , 320px 1490px #FFF , 1536px 741px #FFF , 236px 214px #FFF , 878px 1068px #FFF , 1698px 1752px #FFF , 1844px 799px #FFF , 55px 673px #FFF , 690px 1503px #FFF , 869px 1066px #FFF , 840px 204px #FFF , 214px 863px #FFF , 1315px 960px #FFF , 370px 1418px #FFF , 990px 1869px #FFF , 1560px 1981px #FFF , 66px 1315px #FFF , 834px 1874px #FFF , 1946px 1621px #FFF , 1062px 379px #FFF , 1688px 1972px #FFF , 526px 876px #FFF , 1121px 1353px #FFF , 1963px 1242px #FFF , 1456px 1033px #FFF , 486px 1617px #FFF , 582px 1325px #FFF , 312px 182px #FFF , 1815px 1006px #FFF , 513px 1826px #FFF , 173px 398px #FFF , 1892px 432px #FFF , 374px 432px #FFF , 645px 735px #FFF , 156px 1706px #FFF , 1596px 729px #FFF , 1661px 845px #FFF , 831px 561px #FFF , 966px 1432px #FFF , 227px 387px #FFF , 1088px 1804px #FFF , 972px 594px #FFF , 367px 1189px #FFF , 1527px 1909px #FFF , 1240px 290px #FFF , 676px 1729px #FFF , 1182px 1631px #FFF , 200px 423px #FFF , 1511px 1083px #FFF , 378px 1487px #FFF , 1876px 613px #FFF , 432px 696px #FFF , 1472px 32px #FFF , 691px 1422px #FFF , 666px 67px #FFF , 1280px 333px #FFF , 35px 843px #FFF , 803px 384px #FFF , 1272px 359px #FFF , 1074px 397px #FFF , 1757px 100px #FFF , 1391px 360px #FFF , 1601px 1885px #FFF , 1277px 1009px #FFF , 1025px 626px #FFF , 1262px 1473px #FFF , 1179px 941px #FFF , 1630px 722px #FFF , 1318px 234px #FFF , 235px 1211px #FFF , 637px 1605px #FFF , 648px 138px #FFF , 718px 391px #FFF , 893px 1863px #FFF , 993px 359px #FFF , 656px 1583px #FFF , 1285px 12px #FFF , 762px 1806px #FFF , 1164px 1280px #FFF , 1528px 170px #FFF , 67px 82px #FFF , 214px 1047px #FFF , 1926px 1683px #FFF , 1701px 609px #FFF , 862px 1939px #FFF , 175px 364px #FFF , 976px 1183px #FFF , 1011px 100px #FFF , 1967px 1252px #FFF , 327px 77px #FFF , 1044px 681px #FFF , 801px 1912px #FFF , 1633px 1110px #FFF , 1691px 925px #FFF , 342px 148px #FFF , 619px 119px #FFF , 1717px 1051px #FFF , 923px 1804px #FFF , 1504px 1465px #FFF , 1027px 1205px #FFF , 1086px 1662px #FFF , 605px 763px #FFF , 978px 624px #FFF , 551px 1242px #FFF , 1248px 297px #FFF , 676px 1534px #FFF , 1713px 1868px #FFF , 1684px 915px #FFF , 1657px 952px #FFF , 168px 556px #FFF , 1573px 481px #FFF , 213px 1525px #FFF , 203px 780px #FFF , 1718px 265px #FFF , 23px 676px #FFF , 1367px 394px #FFF , 651px 1047px #FFF , 445px 1194px #FFF , 1483px 1439px #FFF , 1669px 1499px #FFF , 1499px 1596px #FFF , 222px 1154px #FFF , 1044px 918px #FFF , 642px 1615px #FFF , 1158px 847px #FFF , 1553px 1546px #FFF , 1527px 486px #FFF , 355px 1464px #FFF , 1991px 494px #FFF , 271px 1958px #FFF , 601px 543px #FFF , 1217px 1684px #FFF , 1150px 1526px #FFF , 1875px 1843px #FFF , 1857px 1106px #FFF , 1957px 1456px #FFF , 698px 558px #FFF , 1700px 1333px #FFF , 808px 965px #FFF , 1654px 407px #FFF , 1649px 547px #FFF , 1862px 946px #FFF , 38px 808px #FFF , 1254px 578px #FFF , 1991px 243px #FFF , 363px 76px #FFF , 111px 1093px #FFF , 1096px 1390px #FFF , 1449px 1545px #FFF , 210px 576px #FFF , 321px 718px #FFF , 1434px 662px #FFF , 140px 895px #FFF , 510px 330px #FFF , 589px 1522px #FFF , 720px 1862px #FFF , 138px 1195px #FFF , 819px 319px #FFF , 814px 1434px #FFF , 1440px 274px #FFF , 795px 607px #FFF , 1860px 1988px #FFF , 1085px 204px #FFF , 394px 1151px #FFF , 1247px 870px #FFF , 189px 1638px #FFF , 384px 1430px #FFF , 1914px 895px #FFF , 48px 1777px #FFF , 242px 1378px #FFF , 343px 470px #FFF , 893px 1464px #FFF , 1818px 354px #FFF , 1260px 166px #FFF , 960px 1561px #FFF , 1072px 1416px #FFF , 835px 213px #FFF , 643px 1197px #FFF , 1257px 1319px #FFF , 508px 835px #FFF , 1568px 901px #FFF , 619px 233px #FFF , 495px 716px #FFF , 551px 1869px #FFF , 1275px 1694px #FFF , 1676px 302px #FFF , 524px 300px #FFF , 802px 1436px #FFF , 520px 1347px #FFF , 511px 1722px #FFF , 1640px 1315px #FFF , 825px 886px #FFF , 795px 1081px #FFF , 1297px 672px #FFF , 413px 1087px #FFF , 330px 168px #FFF , 745px 1783px #FFF , 275px 1856px #FFF , 1312px 1284px #FFF , 582px 1939px #FFF , 1647px 1252px #FFF , 1856px 794px #FFF , 663px 1882px #FFF , 949px 956px #FFF , 1422px 1791px #FFF , 233px 52px #FFF , 139px 1133px #FFF , 1057px 1972px #FFF , 1602px 861px #FFF , 1402px 713px #FFF , 974px 862px #FFF , 1341px 1705px #FFF , 1987px 1598px #FFF , 221px 482px #FFF , 1080px 1117px #FFF , 1589px 34px #FFF , 852px 960px #FFF , 1939px 253px #FFF , 1349px 566px #FFF , 1363px 1296px #FFF , 136px 1080px #FFF , 606px 1376px #FFF , 609px 522px #FFF , 939px 633px #FFF , 852px 1967px #FFF , 1340px 1519px #FFF , 141px 1061px #FFF , 123px 1427px #FFF , 1075px 573px #FFF; animation: animStar 50s linear infinite;&#125;#stars:after &#123; content: " "; position: absolute; top: 2000px; width: 1px; height: 1px; background: transparent; box-shadow: 1747px 1720px #FFF , 1693px 439px #FFF , 699px 1744px #FFF , 180px 479px #FFF , 379px 729px #FFF , 1294px 910px #FFF , 479px 1860px #FFF , 270px 1211px #FFF , 252px 1651px #FFF , 472px 1251px #FFF , 1650px 235px #FFF , 311px 1770px #FFF , 1469px 984px #FFF , 1349px 1839px #FFF , 525px 958px #FFF , 753px 1748px #FFF , 753px 1299px #FFF , 530px 489px #FFF , 1574px 311px #FFF , 760px 76px #FFF , 774px 837px #FFF , 1505px 1499px #FFF , 18px 512px #FFF , 1587px 1312px #FFF , 1072px 753px #FFF , 911px 866px #FFF , 1217px 1280px #FFF , 226px 958px #FFF , 1021px 149px #FFF , 1129px 1781px #FFF , 976px 1354px #FFF , 12px 1248px #FFF , 1816px 1631px #FFF , 178px 1185px #FFF , 628px 962px #FFF , 1806px 315px #FFF , 667px 1436px #FFF , 1133px 1304px #FFF , 1539px 661px #FFF , 342px 148px #FFF , 138px 332px #FFF , 1928px 612px #FFF , 434px 970px #FFF , 577px 456px #FFF , 1132px 892px #FFF , 1880px 1680px #FFF , 1524px 268px #FFF , 1406px 1375px #FFF , 747px 726px #FFF , 1016px 523px #FFF , 1996px 1063px #FFF , 1128px 595px #FFF , 177px 1792px #FFF , 1430px 477px #FFF , 949px 334px #FFF , 486px 1949px #FFF , 1958px 170px #FFF , 1899px 1870px #FFF , 1105px 208px #FFF , 271px 719px #FFF , 822px 598px #FFF , 409px 1398px #FFF , 345px 607px #FFF , 160px 156px #FFF , 946px 522px #FFF , 1796px 1680px #FFF , 1896px 1125px #FFF , 1731px 1802px #FFF , 1147px 503px #FFF , 525px 1562px #FFF , 1791px 1266px #FFF , 1650px 312px #FFF , 102px 1586px #FFF , 1885px 1314px #FFF , 781px 1403px #FFF , 901px 1566px #FFF , 1934px 1761px #FFF , 767px 646px #FFF , 797px 1990px #FFF , 486px 889px #FFF , 1165px 1607px #FFF , 940px 1092px #FFF , 821px 957px #FFF , 1563px 1793px #FFF , 83px 498px #FFF , 1246px 492px #FFF , 80px 956px #FFF , 1137px 1795px #FFF , 1365px 1816px #FFF , 549px 1650px #FFF , 1645px 1758px #FFF , 244px 1543px #FFF , 1941px 325px #FFF , 1347px 1608px #FFF , 409px 433px #FFF , 1364px 552px #FFF , 264px 1839px #FFF , 1610px 581px #FFF , 1225px 1386px #FFF , 763px 1077px #FFF , 1442px 1362px #FFF , 1152px 794px #FFF , 191px 1980px #FFF , 1537px 281px #FFF , 819px 749px #FFF , 1906px 1489px #FFF , 529px 1711px #FFF , 272px 910px #FFF , 26px 768px #FFF , 1702px 1887px #FFF , 531px 1236px #FFF , 1911px 11px #FFF , 875px 544px #FFF , 1340px 443px #FFF , 350px 343px #FFF , 368px 1663px #FFF , 1761px 671px #FFF , 1246px 1936px #FFF , 1927px 1611px #FFF , 1630px 1003px #FFF , 1602px 722px #FFF , 544px 178px #FFF , 1680px 994px #FFF , 1466px 296px #FFF , 1192px 1239px #FFF , 1864px 1361px #FFF , 503px 153px #FFF , 1778px 1652px #FFF , 1830px 513px #FFF , 360px 236px #FFF , 357px 1252px #FFF , 127px 847px #FFF , 1729px 1178px #FFF , 237px 1815px #FFF , 608px 108px #FFF , 1869px 1657px #FFF , 1864px 664px #FFF , 108px 175px #FFF , 807px 851px #FFF , 1031px 645px #FFF , 1322px 16px #FFF , 285px 154px #FFF , 414px 404px #FFF , 1750px 385px #FFF , 450px 579px #FFF , 1515px 546px #FFF , 915px 1198px #FFF , 921px 1940px #FFF , 234px 80px #FFF , 1790px 1079px #FFF , 1270px 1768px #FFF , 1680px 587px #FFF , 612px 400px #FFF , 1150px 1336px #FFF , 568px 776px #FFF , 839px 1939px #FFF , 1565px 267px #FFF , 294px 1855px #FFF , 524px 364px #FFF , 734px 789px #FFF , 1979px 1049px #FFF , 1353px 410px #FFF , 1016px 438px #FFF , 255px 1707px #FFF , 1699px 580px #FFF , 1812px 1261px #FFF , 84px 481px #FFF , 921px 863px #FFF , 113px 228px #FFF , 980px 806px #FFF , 920px 845px #FFF , 1933px 623px #FFF , 1744px 1304px #FFF , 148px 40px #FFF , 1732px 1292px #FFF , 1487px 1736px #FFF , 1123px 189px #FFF , 555px 1290px #FFF , 1293px 1629px #FFF , 1034px 521px #FFF , 1573px 1332px #FFF , 1679px 1906px #FFF , 1834px 1062px #FFF , 802px 1374px #FFF , 863px 66px #FFF , 660px 1260px #FFF , 1714px 1012px #FFF , 1698px 964px #FFF , 260px 626px #FFF , 402px 1064px #FFF , 621px 1517px #FFF , 989px 822px #FFF , 751px 29px #FFF , 1342px 1655px #FFF , 1314px 389px #FFF , 807px 1137px #FFF , 1820px 831px #FFF , 394px 658px #FFF , 1234px 562px #FFF , 612px 1674px #FFF , 180px 836px #FFF , 1291px 506px #FFF , 1936px 480px #FFF , 970px 1767px #FFF , 1066px 1142px #FFF , 351px 1465px #FFF , 1446px 1909px #FFF , 254px 306px #FFF , 1969px 1642px #FFF , 269px 404px #FFF , 838px 98px #FFF , 1794px 1243px #FFF , 1030px 1033px #FFF , 962px 1694px #FFF , 284px 497px #FFF , 109px 1796px #FFF , 1897px 592px #FFF , 1108px 1186px #FFF , 1464px 990px #FFF , 329px 1595px #FFF , 1524px 1046px #FFF , 454px 280px #FFF , 248px 493px #FFF , 1778px 1145px #FFF , 865px 1223px #FFF , 1045px 57px #FFF , 777px 128px #FFF , 1929px 565px #FFF , 880px 1923px #FFF , 1555px 20px #FFF , 140px 400px #FFF , 214px 26px #FFF , 1986px 182px #FFF , 588px 659px #FFF , 531px 1025px #FFF , 1503px 448px #FFF , 1437px 816px #FFF , 171px 1652px #FFF , 416px 1692px #FFF , 21px 1457px #FFF , 135px 1158px #FFF , 828px 499px #FFF , 1748px 666px #FFF , 749px 549px #FFF , 320px 1241px #FFF , 1718px 624px #FFF , 287px 935px #FFF , 739px 397px #FFF , 1319px 1371px #FFF , 1257px 1186px #FFF , 46px 1278px #FFF , 1826px 1073px #FFF , 1530px 1720px #FFF , 1302px 548px #FFF , 1411px 550px #FFF , 700px 615px #FFF , 404px 1006px #FFF , 1119px 1467px #FFF , 1154px 1330px #FFF , 1585px 248px #FFF , 1080px 671px #FFF , 219px 1195px #FFF , 903px 584px #FFF , 711px 1244px #FFF , 730px 1427px #FFF , 1891px 1491px #FFF , 1936px 1196px #FFF , 1605px 140px #FFF , 384px 194px #FFF , 148px 394px #FFF , 837px 1028px #FFF , 1949px 1981px #FFF , 159px 1530px #FFF , 1763px 1244px #FFF , 713px 1187px #FFF , 1356px 766px #FFF , 387px 280px #FFF , 18px 240px #FFF , 42px 840px #FFF , 1178px 253px #FFF , 1075px 1392px #FFF , 1944px 1639px #FFF , 748px 178px #FFF , 1952px 1310px #FFF , 1918px 1612px #FFF , 557px 755px #FFF , 993px 1080px #FFF , 192px 1863px #FFF , 489px 1175px #FFF , 647px 105px #FFF , 498px 1477px #FFF , 1398px 1548px #FFF , 821px 980px #FFF , 1412px 347px #FFF , 291px 755px #FFF , 953px 232px #FFF , 681px 20px #FFF , 261px 391px #FFF , 256px 1048px #FFF , 876px 1530px #FFF , 1003px 1213px #FFF , 1626px 940px #FFF , 1778px 1974px #FFF , 767px 1944px #FFF , 721px 673px #FFF , 714px 394px #FFF , 1284px 629px #FFF , 1813px 1464px #FFF , 222px 465px #FFF , 544px 1980px #FFF , 935px 542px #FFF , 331px 1468px #FFF , 1173px 1095px #FFF , 29px 1107px #FFF , 1810px 715px #FFF , 479px 1476px #FFF , 1801px 1739px #FFF , 1989px 599px #FFF , 1656px 1744px #FFF , 1117px 1377px #FFF , 1757px 800px #FFF , 373px 1151px #FFF , 1001px 64px #FFF , 1828px 1355px #FFF , 1493px 1243px #FFF , 176px 497px #FFF , 683px 1634px #FFF , 1120px 659px #FFF , 648px 1643px #FFF , 1281px 347px #FFF , 105px 1309px #FFF , 77px 1335px #FFF , 667px 1892px #FFF , 868px 1783px #FFF , 319px 1180px #FFF , 860px 1263px #FFF , 447px 916px #FFF , 723px 402px #FFF , 875px 283px #FFF , 1330px 1083px #FFF , 1175px 819px #FFF , 667px 1469px #FFF , 680px 371px #FFF , 1357px 1235px #FFF , 1223px 1701px #FFF , 1452px 1322px #FFF , 32px 882px #FFF , 1545px 407px #FFF , 1924px 1404px #FFF , 1846px 1390px #FFF , 216px 1421px #FFF , 1421px 1584px #FFF , 1167px 1901px #FFF , 276px 1756px #FFF , 714px 1856px #FFF , 359px 1199px #FFF , 1143px 1080px #FFF , 891px 635px #FFF , 579px 230px #FFF , 570px 676px #FFF , 1156px 1764px #FFF , 944px 1652px #FFF , 301px 666px #FFF , 209px 1005px #FFF , 460px 677px #FFF , 186px 1260px #FFF , 849px 284px #FFF , 240px 1059px #FFF , 953px 1959px #FFF , 783px 328px #FFF , 1794px 128px #FFF , 1884px 1051px #FFF , 842px 758px #FFF , 1848px 318px #FFF , 852px 348px #FFF , 1242px 1496px #FFF , 441px 712px #FFF , 1039px 113px #FFF , 1994px 749px #FFF , 1777px 1596px #FFF , 1471px 1817px #FFF , 1482px 1668px #FFF , 1837px 522px #FFF , 1272px 1285px #FFF , 751px 1669px #FFF , 104px 1968px #FFF , 1570px 400px #FFF , 1225px 1879px #FFF , 885px 1156px #FFF , 1392px 121px #FFF , 1754px 1477px #FFF , 251px 1060px #FFF , 1701px 547px #FFF , 1847px 114px #FFF , 1733px 1932px #FFF , 1178px 873px #FFF , 553px 191px #FFF , 1974px 1659px #FFF , 1155px 612px #FFF , 1509px 1533px #FFF , 1936px 1148px #FFF , 1708px 224px #FFF , 1358px 1235px #FFF , 293px 608px #FFF , 424px 639px #FFF , 347px 1944px #FFF , 1813px 243px #FFF , 150px 1042px #FFF , 36px 1533px #FFF , 1215px 64px #FFF , 1393px 730px #FFF , 567px 1509px #FFF , 1209px 1055px #FFF , 1969px 718px #FFF , 1458px 42px #FFF , 1494px 817px #FFF , 1863px 1290px #FFF , 1508px 1194px #FFF , 1607px 906px #FFF , 1371px 997px #FFF , 573px 871px #FFF , 1625px 1930px #FFF , 1422px 1835px #FFF , 1400px 1990px #FFF , 467px 1695px #FFF , 911px 1526px #FFF , 1745px 766px #FFF , 1016px 1602px #FFF , 1940px 1154px #FFF , 1468px 1035px #FFF , 1298px 992px #FFF , 874px 1589px #FFF , 1288px 721px #FFF , 1611px 905px #FFF , 569px 1548px #FFF , 1536px 1526px #FFF , 1668px 1903px #FFF , 267px 1053px #FFF , 1403px 4px #FFF , 1722px 91px #FFF , 863px 1904px #FFF , 120px 1878px #FFF , 21px 47px #FFF , 1384px 718px #FFF , 1000px 1523px #FFF , 1019px 1768px #FFF , 811px 209px #FFF , 950px 1763px #FFF , 504px 1011px #FFF , 420px 1424px #FFF , 1606px 747px #FFF , 1073px 9px #FFF , 860px 1731px #FFF , 473px 990px #FFF , 922px 1704px #FFF , 371px 15px #FFF , 821px 1243px #FFF , 423px 1259px #FFF , 1974px 1100px #FFF , 183px 615px #FFF , 1430px 6px #FFF , 909px 296px #FFF , 449px 251px #FFF , 953px 155px #FFF , 824px 706px #FFF , 1097px 429px #FFF , 1104px 260px #FFF , 271px 1851px #FFF , 1224px 1554px #FFF , 521px 1040px #FFF , 160px 1852px #FFF , 1564px 1782px #FFF , 320px 1490px #FFF , 1536px 741px #FFF , 236px 214px #FFF , 878px 1068px #FFF , 1698px 1752px #FFF , 1844px 799px #FFF , 55px 673px #FFF , 690px 1503px #FFF , 869px 1066px #FFF , 840px 204px #FFF , 214px 863px #FFF , 1315px 960px #FFF , 370px 1418px #FFF , 990px 1869px #FFF , 1560px 1981px #FFF , 66px 1315px #FFF , 834px 1874px #FFF , 1946px 1621px #FFF , 1062px 379px #FFF , 1688px 1972px #FFF , 526px 876px #FFF , 1121px 1353px #FFF , 1963px 1242px #FFF , 1456px 1033px #FFF , 486px 1617px #FFF , 582px 1325px #FFF , 312px 182px #FFF , 1815px 1006px #FFF , 513px 1826px #FFF , 173px 398px #FFF , 1892px 432px #FFF , 374px 432px #FFF , 645px 735px #FFF , 156px 1706px #FFF , 1596px 729px #FFF , 1661px 845px #FFF , 831px 561px #FFF , 966px 1432px #FFF , 227px 387px #FFF , 1088px 1804px #FFF , 972px 594px #FFF , 367px 1189px #FFF , 1527px 1909px #FFF , 1240px 290px #FFF , 676px 1729px #FFF , 1182px 1631px #FFF , 200px 423px #FFF , 1511px 1083px #FFF , 378px 1487px #FFF , 1876px 613px #FFF , 432px 696px #FFF , 1472px 32px #FFF , 691px 1422px #FFF , 666px 67px #FFF , 1280px 333px #FFF , 35px 843px #FFF , 803px 384px #FFF , 1272px 359px #FFF , 1074px 397px #FFF , 1757px 100px #FFF , 1391px 360px #FFF , 1601px 1885px #FFF , 1277px 1009px #FFF , 1025px 626px #FFF , 1262px 1473px #FFF , 1179px 941px #FFF , 1630px 722px #FFF , 1318px 234px #FFF , 235px 1211px #FFF , 637px 1605px #FFF , 648px 138px #FFF , 718px 391px #FFF , 893px 1863px #FFF , 993px 359px #FFF , 656px 1583px #FFF , 1285px 12px #FFF , 762px 1806px #FFF , 1164px 1280px #FFF , 1528px 170px #FFF , 67px 82px #FFF , 214px 1047px #FFF , 1926px 1683px #FFF , 1701px 609px #FFF , 862px 1939px #FFF , 175px 364px #FFF , 976px 1183px #FFF , 1011px 100px #FFF , 1967px 1252px #FFF , 327px 77px #FFF , 1044px 681px #FFF , 801px 1912px #FFF , 1633px 1110px #FFF , 1691px 925px #FFF , 342px 148px #FFF , 619px 119px #FFF , 1717px 1051px #FFF , 923px 1804px #FFF , 1504px 1465px #FFF , 1027px 1205px #FFF , 1086px 1662px #FFF , 605px 763px #FFF , 978px 624px #FFF , 551px 1242px #FFF , 1248px 297px #FFF , 676px 1534px #FFF , 1713px 1868px #FFF , 1684px 915px #FFF , 1657px 952px #FFF , 168px 556px #FFF , 1573px 481px #FFF , 213px 1525px #FFF , 203px 780px #FFF , 1718px 265px #FFF , 23px 676px #FFF , 1367px 394px #FFF , 651px 1047px #FFF , 445px 1194px #FFF , 1483px 1439px #FFF , 1669px 1499px #FFF , 1499px 1596px #FFF , 222px 1154px #FFF , 1044px 918px #FFF , 642px 1615px #FFF , 1158px 847px #FFF , 1553px 1546px #FFF , 1527px 486px #FFF , 355px 1464px #FFF , 1991px 494px #FFF , 271px 1958px #FFF , 601px 543px #FFF , 1217px 1684px #FFF , 1150px 1526px #FFF , 1875px 1843px #FFF , 1857px 1106px #FFF , 1957px 1456px #FFF , 698px 558px #FFF , 1700px 1333px #FFF , 808px 965px #FFF , 1654px 407px #FFF , 1649px 547px #FFF , 1862px 946px #FFF , 38px 808px #FFF , 1254px 578px #FFF , 1991px 243px #FFF , 363px 76px #FFF , 111px 1093px #FFF , 1096px 1390px #FFF , 1449px 1545px #FFF , 210px 576px #FFF , 321px 718px #FFF , 1434px 662px #FFF , 140px 895px #FFF , 510px 330px #FFF , 589px 1522px #FFF , 720px 1862px #FFF , 138px 1195px #FFF , 819px 319px #FFF , 814px 1434px #FFF , 1440px 274px #FFF , 795px 607px #FFF , 1860px 1988px #FFF , 1085px 204px #FFF , 394px 1151px #FFF , 1247px 870px #FFF , 189px 1638px #FFF , 384px 1430px #FFF , 1914px 895px #FFF , 48px 1777px #FFF , 242px 1378px #FFF , 343px 470px #FFF , 893px 1464px #FFF , 1818px 354px #FFF , 1260px 166px #FFF , 960px 1561px #FFF , 1072px 1416px #FFF , 835px 213px #FFF , 643px 1197px #FFF , 1257px 1319px #FFF , 508px 835px #FFF , 1568px 901px #FFF , 619px 233px #FFF , 495px 716px #FFF , 551px 1869px #FFF , 1275px 1694px #FFF , 1676px 302px #FFF , 524px 300px #FFF , 802px 1436px #FFF , 520px 1347px #FFF , 511px 1722px #FFF , 1640px 1315px #FFF , 825px 886px #FFF , 795px 1081px #FFF , 1297px 672px #FFF , 413px 1087px #FFF , 330px 168px #FFF , 745px 1783px #FFF , 275px 1856px #FFF , 1312px 1284px #FFF , 582px 1939px #FFF , 1647px 1252px #FFF , 1856px 794px #FFF , 663px 1882px #FFF , 949px 956px #FFF , 1422px 1791px #FFF , 233px 52px #FFF , 139px 1133px #FFF , 1057px 1972px #FFF , 1602px 861px #FFF , 1402px 713px #FFF , 974px 862px #FFF , 1341px 1705px #FFF , 1987px 1598px #FFF , 221px 482px #FFF , 1080px 1117px #FFF , 1589px 34px #FFF , 852px 960px #FFF , 1939px 253px #FFF , 1349px 566px #FFF , 1363px 1296px #FFF , 136px 1080px #FFF , 606px 1376px #FFF , 609px 522px #FFF , 939px 633px #FFF , 852px 1967px #FFF , 1340px 1519px #FFF , 141px 1061px #FFF , 123px 1427px #FFF , 1075px 573px #FFF;&#125;#stars2 &#123; width: 2px; height: 2px; background: transparent; box-shadow: 1211px 1949px #FFF , 222px 1526px #FFF , 499px 819px #FFF , 237px 1431px #FFF , 1794px 1914px #FFF , 461px 702px #FFF , 116px 1817px #FFF , 194px 695px #FFF , 1666px 172px #FFF , 1224px 1424px #FFF , 1823px 1249px #FFF , 1193px 1555px #FFF , 1922px 1440px #FFF , 1932px 58px #FFF , 1624px 1396px #FFF , 1179px 73px #FFF , 761px 189px #FFF , 1596px 703px #FFF , 1624px 290px #FFF , 1184px 837px #FFF , 752px 1347px #FFF , 1939px 1147px #FFF , 970px 887px #FFF , 37px 516px #FFF , 976px 172px #FFF , 801px 1813px #FFF , 216px 1615px #FFF , 12px 1764px #FFF , 549px 1914px #FFF , 958px 1200px #FFF , 70px 888px #FFF , 1856px 1524px #FFF , 1061px 1809px #FFF , 1101px 1084px #FFF , 1322px 87px #FFF , 344px 367px #FFF , 1821px 22px #FFF , 1923px 817px #FFF , 1520px 848px #FFF , 751px 1032px #FFF , 1089px 169px #FFF , 376px 381px #FFF , 692px 991px #FFF , 1569px 120px #FFF , 467px 429px #FFF , 1582px 778px #FFF , 785px 977px #FFF , 1744px 1519px #FFF , 874px 777px #FFF , 88px 1174px #FFF , 613px 1715px #FFF , 939px 1942px #FFF , 547px 1002px #FFF , 1244px 1453px #FFF , 1359px 1344px #FFF , 372px 421px #FFF , 612px 1736px #FFF , 1978px 1952px #FFF , 1154px 1256px #FFF , 1714px 1518px #FFF , 685px 361px #FFF , 1098px 1371px #FFF , 1916px 152px #FFF , 917px 700px #FFF , 191px 1498px #FFF , 811px 657px #FFF , 108px 1616px #FFF , 764px 619px #FFF , 844px 1480px #FFF , 1819px 626px #FFF , 743px 7px #FFF , 1718px 743px #FFF , 1437px 428px #FFF , 1935px 1865px #FFF , 1312px 1781px #FFF , 19px 636px #FFF , 271px 1445px #FFF , 1610px 1600px #FFF , 1148px 1897px #FFF , 1656px 673px #FFF , 814px 1143px #FFF , 422px 61px #FFF , 1624px 414px #FFF , 561px 245px #FFF , 1569px 417px #FFF , 1141px 223px #FFF , 971px 285px #FFF , 1680px 1586px #FFF , 1077px 421px #FFF , 1949px 1009px #FFF , 552px 561px #FFF , 1378px 264px #FFF , 181px 1355px #FFF , 700px 1680px #FFF , 896px 1650px #FFF , 194px 1369px #FFF , 1123px 619px #FFF , 788px 797px #FFF , 768px 1942px #FFF , 1957px 1718px #FFF , 817px 1013px #FFF , 1278px 1152px #FFF , 578px 1312px #FFF , 1730px 528px #FFF , 71px 1821px #FFF , 262px 1969px #FFF , 309px 452px #FFF , 621px 957px #FFF , 479px 1902px #FFF , 714px 67px #FFF , 1157px 1374px #FFF , 692px 366px #FFF , 1835px 763px #FFF , 393px 1990px #FFF , 1650px 121px #FFF , 1653px 208px #FFF , 700px 102px #FFF , 411px 1511px #FFF , 782px 1390px #FFF , 1032px 810px #FFF , 171px 1714px #FFF , 1943px 466px #FFF , 463px 463px #FFF , 881px 1706px #FFF , 1486px 1841px #FFF , 993px 433px #FFF , 1676px 1211px #FFF , 419px 1767px #FFF , 1998px 517px #FFF , 1013px 406px #FFF , 1207px 1036px #FFF , 449px 1399px #FFF , 902px 1484px #FFF , 1105px 1930px #FFF , 1063px 1932px #FFF , 88px 934px #FFF , 909px 614px #FFF , 1725px 384px #FFF , 1768px 1711px #FFF , 737px 387px #FFF , 222px 437px #FFF , 734px 907px #FFF , 263px 1000px #FFF , 361px 1216px #FFF , 541px 387px #FFF , 1136px 1045px #FFF , 1420px 1341px #FFF , 639px 1267px #FFF , 1750px 1572px #FFF , 1646px 1822px #FFF , 1849px 1298px #FFF , 1276px 780px #FFF , 902px 1207px #FFF , 297px 587px #FFF , 31px 633px #FFF , 554px 1471px #FFF , 1909px 729px #FFF , 679px 200px #FFF , 1095px 788px #FFF , 657px 600px #FFF , 1265px 1387px #FFF , 982px 707px #FFF , 881px 1664px #FFF , 618px 832px #FFF , 140px 1975px #FFF , 94px 1734px #FFF , 566px 1536px #FFF , 1183px 1180px #FFF , 20px 260px #FFF , 305px 1605px #FFF , 1835px 884px #FFF , 1591px 1415px #FFF , 1785px 1975px #FFF , 905px 229px #FFF , 1115px 273px #FFF , 1800px 1292px #FFF , 1787px 1928px #FFF , 895px 1561px #FFF , 1584px 104px #FFF , 1480px 1291px #FFF , 1714px 1681px #FFF , 1300px 1111px #FFF , 258px 72px #FFF , 1523px 1830px #FFF , 1313px 920px #FFF , 819px 1540px #FFF , 656px 260px #FFF , 1732px 1529px #FFF , 792px 1084px #FFF , 84px 803px #FFF , 1128px 224px #FFF , 1669px 1888px #FFF , 626px 129px #FFF , 1244px 1781px #FFF , 1107px 427px #FFF , 73px 759px #FFF , 336px 330px #FFF , 664px 338px #FFF , 977px 170px #FFF , 492px 1615px #FFF; animation: animStar 100s linear infinite;&#125;#stars2:after &#123; content: " "; position: absolute; top: 2000px; width: 2px; height: 2px; background: transparent; box-shadow: 1211px 1949px #FFF , 222px 1526px #FFF , 499px 819px #FFF , 237px 1431px #FFF , 1794px 1914px #FFF , 461px 702px #FFF , 116px 1817px #FFF , 194px 695px #FFF , 1666px 172px #FFF , 1224px 1424px #FFF , 1823px 1249px #FFF , 1193px 1555px #FFF , 1922px 1440px #FFF , 1932px 58px #FFF , 1624px 1396px #FFF , 1179px 73px #FFF , 761px 189px #FFF , 1596px 703px #FFF , 1624px 290px #FFF , 1184px 837px #FFF , 752px 1347px #FFF , 1939px 1147px #FFF , 970px 887px #FFF , 37px 516px #FFF , 976px 172px #FFF , 801px 1813px #FFF , 216px 1615px #FFF , 12px 1764px #FFF , 549px 1914px #FFF , 958px 1200px #FFF , 70px 888px #FFF , 1856px 1524px #FFF , 1061px 1809px #FFF , 1101px 1084px #FFF , 1322px 87px #FFF , 344px 367px #FFF , 1821px 22px #FFF , 1923px 817px #FFF , 1520px 848px #FFF , 751px 1032px #FFF , 1089px 169px #FFF , 376px 381px #FFF , 692px 991px #FFF , 1569px 120px #FFF , 467px 429px #FFF , 1582px 778px #FFF , 785px 977px #FFF , 1744px 1519px #FFF , 874px 777px #FFF , 88px 1174px #FFF , 613px 1715px #FFF , 939px 1942px #FFF , 547px 1002px #FFF , 1244px 1453px #FFF , 1359px 1344px #FFF , 372px 421px #FFF , 612px 1736px #FFF , 1978px 1952px #FFF , 1154px 1256px #FFF , 1714px 1518px #FFF , 685px 361px #FFF , 1098px 1371px #FFF , 1916px 152px #FFF , 917px 700px #FFF , 191px 1498px #FFF , 811px 657px #FFF , 108px 1616px #FFF , 764px 619px #FFF , 844px 1480px #FFF , 1819px 626px #FFF , 743px 7px #FFF , 1718px 743px #FFF , 1437px 428px #FFF , 1935px 1865px #FFF , 1312px 1781px #FFF , 19px 636px #FFF , 271px 1445px #FFF , 1610px 1600px #FFF , 1148px 1897px #FFF , 1656px 673px #FFF , 814px 1143px #FFF , 422px 61px #FFF , 1624px 414px #FFF , 561px 245px #FFF , 1569px 417px #FFF , 1141px 223px #FFF , 971px 285px #FFF , 1680px 1586px #FFF , 1077px 421px #FFF , 1949px 1009px #FFF , 552px 561px #FFF , 1378px 264px #FFF , 181px 1355px #FFF , 700px 1680px #FFF , 896px 1650px #FFF , 194px 1369px #FFF , 1123px 619px #FFF , 788px 797px #FFF , 768px 1942px #FFF , 1957px 1718px #FFF , 817px 1013px #FFF , 1278px 1152px #FFF , 578px 1312px #FFF , 1730px 528px #FFF , 71px 1821px #FFF , 262px 1969px #FFF , 309px 452px #FFF , 621px 957px #FFF , 479px 1902px #FFF , 714px 67px #FFF , 1157px 1374px #FFF , 692px 366px #FFF , 1835px 763px #FFF , 393px 1990px #FFF , 1650px 121px #FFF , 1653px 208px #FFF , 700px 102px #FFF , 411px 1511px #FFF , 782px 1390px #FFF , 1032px 810px #FFF , 171px 1714px #FFF , 1943px 466px #FFF , 463px 463px #FFF , 881px 1706px #FFF , 1486px 1841px #FFF , 993px 433px #FFF , 1676px 1211px #FFF , 419px 1767px #FFF , 1998px 517px #FFF , 1013px 406px #FFF , 1207px 1036px #FFF , 449px 1399px #FFF , 902px 1484px #FFF , 1105px 1930px #FFF , 1063px 1932px #FFF , 88px 934px #FFF , 909px 614px #FFF , 1725px 384px #FFF , 1768px 1711px #FFF , 737px 387px #FFF , 222px 437px #FFF , 734px 907px #FFF , 263px 1000px #FFF , 361px 1216px #FFF , 541px 387px #FFF , 1136px 1045px #FFF , 1420px 1341px #FFF , 639px 1267px #FFF , 1750px 1572px #FFF , 1646px 1822px #FFF , 1849px 1298px #FFF , 1276px 780px #FFF , 902px 1207px #FFF , 297px 587px #FFF , 31px 633px #FFF , 554px 1471px #FFF , 1909px 729px #FFF , 679px 200px #FFF , 1095px 788px #FFF , 657px 600px #FFF , 1265px 1387px #FFF , 982px 707px #FFF , 881px 1664px #FFF , 618px 832px #FFF , 140px 1975px #FFF , 94px 1734px #FFF , 566px 1536px #FFF , 1183px 1180px #FFF , 20px 260px #FFF , 305px 1605px #FFF , 1835px 884px #FFF , 1591px 1415px #FFF , 1785px 1975px #FFF , 905px 229px #FFF , 1115px 273px #FFF , 1800px 1292px #FFF , 1787px 1928px #FFF , 895px 1561px #FFF , 1584px 104px #FFF , 1480px 1291px #FFF , 1714px 1681px #FFF , 1300px 1111px #FFF , 258px 72px #FFF , 1523px 1830px #FFF , 1313px 920px #FFF , 819px 1540px #FFF , 656px 260px #FFF , 1732px 1529px #FFF , 792px 1084px #FFF , 84px 803px #FFF , 1128px 224px #FFF , 1669px 1888px #FFF , 626px 129px #FFF , 1244px 1781px #FFF , 1107px 427px #FFF , 73px 759px #FFF , 336px 330px #FFF , 664px 338px #FFF , 977px 170px #FFF , 492px 1615px #FFF;&#125;#stars3 &#123; width: 3px; height: 3px; background: transparent; box-shadow: 411px 162px #FFF , 1021px 667px #FFF , 904px 1844px #FFF , 581px 324px #FFF , 749px 1163px #FFF , 1091px 956px #FFF , 719px 1247px #FFF , 1030px 1103px #FFF , 290px 334px #FFF , 469px 1616px #FFF , 115px 875px #FFF , 758px 1198px #FFF , 535px 909px #FFF , 422px 334px #FFF , 820px 1579px #FFF , 1012px 867px #FFF , 1444px 1107px #FFF , 1447px 1351px #FFF , 636px 4px #FFF , 658px 1783px #FFF , 1655px 327px #FFF , 376px 1821px #FFF , 1618px 1076px #FFF , 40px 1501px #FFF , 313px 195px #FFF , 939px 1364px #FFF , 887px 1154px #FFF , 1422px 101px #FFF , 236px 1543px #FFF , 139px 864px #FFF , 756px 453px #FFF , 1525px 1430px #FFF , 1341px 1094px #FFF , 662px 251px #FFF , 544px 745px #FFF , 987px 251px #FFF , 382px 262px #FFF , 1055px 1641px #FFF , 1169px 1034px #FFF , 1095px 1022px #FFF , 1514px 526px #FFF , 1958px 1908px #FFF , 18px 1925px #FFF , 1912px 1250px #FFF , 1598px 513px #FFF , 335px 246px #FFF , 1358px 1347px #FFF , 1771px 1283px #FFF , 872px 692px #FFF , 71px 1426px #FFF , 1679px 1685px #FFF , 543px 141px #FFF , 923px 459px #FFF , 564px 1110px #FFF , 9px 622px #FFF , 423px 1583px #FFF , 1571px 555px #FFF , 1502px 879px #FFF , 1994px 944px #FFF , 608px 1837px #FFF , 1289px 1905px #FFF , 1885px 1332px #FFF , 1854px 1432px #FFF , 1453px 1115px #FFF , 461px 1883px #FFF , 619px 213px #FFF , 121px 1647px #FFF , 797px 1523px #FFF , 1885px 1534px #FFF , 183px 1660px #FFF , 1036px 227px #FFF , 1699px 1099px #FFF , 383px 1610px #FFF , 1109px 1542px #FFF , 1273px 582px #FFF , 1256px 1030px #FFF , 1897px 513px #FFF , 1737px 742px #FFF , 908px 1480px #FFF , 1119px 1237px #FFF , 1293px 1197px #FFF , 752px 1668px #FFF , 484px 1513px #FFF , 560px 378px #FFF , 1561px 373px #FFF , 952px 1450px #FFF , 273px 759px #FFF , 1655px 284px #FFF , 1536px 1987px #FFF , 833px 1900px #FFF , 1269px 660px #FFF , 858px 1708px #FFF , 1863px 1595px #FFF , 1984px 1053px #FFF , 1659px 771px #FFF , 1228px 1997px #FFF , 1707px 185px #FFF , 1634px 1153px #FFF , 1942px 664px #FFF , 841px 1967px #FFF; animation: animStar 150s linear infinite;&#125;#stars3:after &#123; content: " "; position: absolute; top: 2000px; width: 3px; height: 3px; background: transparent; box-shadow: 411px 162px #FFF , 1021px 667px #FFF , 904px 1844px #FFF , 581px 324px #FFF , 749px 1163px #FFF , 1091px 956px #FFF , 719px 1247px #FFF , 1030px 1103px #FFF , 290px 334px #FFF , 469px 1616px #FFF , 115px 875px #FFF , 758px 1198px #FFF , 535px 909px #FFF , 422px 334px #FFF , 820px 1579px #FFF , 1012px 867px #FFF , 1444px 1107px #FFF , 1447px 1351px #FFF , 636px 4px #FFF , 658px 1783px #FFF , 1655px 327px #FFF , 376px 1821px #FFF , 1618px 1076px #FFF , 40px 1501px #FFF , 313px 195px #FFF , 939px 1364px #FFF , 887px 1154px #FFF , 1422px 101px #FFF , 236px 1543px #FFF , 139px 864px #FFF , 756px 453px #FFF , 1525px 1430px #FFF , 1341px 1094px #FFF , 662px 251px #FFF , 544px 745px #FFF , 987px 251px #FFF , 382px 262px #FFF , 1055px 1641px #FFF , 1169px 1034px #FFF , 1095px 1022px #FFF , 1514px 526px #FFF , 1958px 1908px #FFF , 18px 1925px #FFF , 1912px 1250px #FFF , 1598px 513px #FFF , 335px 246px #FFF , 1358px 1347px #FFF , 1771px 1283px #FFF , 872px 692px #FFF , 71px 1426px #FFF , 1679px 1685px #FFF , 543px 141px #FFF , 923px 459px #FFF , 564px 1110px #FFF , 9px 622px #FFF , 423px 1583px #FFF , 1571px 555px #FFF , 1502px 879px #FFF , 1994px 944px #FFF , 608px 1837px #FFF , 1289px 1905px #FFF , 1885px 1332px #FFF , 1854px 1432px #FFF , 1453px 1115px #FFF , 461px 1883px #FFF , 619px 213px #FFF , 121px 1647px #FFF , 797px 1523px #FFF , 1885px 1534px #FFF , 183px 1660px #FFF , 1036px 227px #FFF , 1699px 1099px #FFF , 383px 1610px #FFF , 1109px 1542px #FFF , 1273px 582px #FFF , 1256px 1030px #FFF , 1897px 513px #FFF , 1737px 742px #FFF , 908px 1480px #FFF , 1119px 1237px #FFF , 1293px 1197px #FFF , 752px 1668px #FFF , 484px 1513px #FFF , 560px 378px #FFF , 1561px 373px #FFF , 952px 1450px #FFF , 273px 759px #FFF , 1655px 284px #FFF , 1536px 1987px #FFF , 833px 1900px #FFF , 1269px 660px #FFF , 858px 1708px #FFF , 1863px 1595px #FFF , 1984px 1053px #FFF , 1659px 771px #FFF , 1228px 1997px #FFF , 1707px 185px #FFF , 1634px 1153px #FFF , 1942px 664px #FFF , 841px 1967px #FFF;&#125;#title &#123; position: absolute; top: 50%; left: 0; right: 0; color: #FFF; text-align: center; font-family: "lato", sans-serif; font-weight: 300; font-size: 50px; letter-spacing: 10px; margin-top: -60px; padding-left: 10px;&#125;#title span &#123; background: -webkit-linear-gradient(white, #38495a); -webkit-background-clip: text; -webkit-text-fill-color: transparent;&#125;@keyframes animStar &#123; from &#123; transform: translateY(0px); &#125; to &#123; transform: translateY(-2000px); &#125;&#125;]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
</search>
