<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[day80-vuejs源码解析]]></title>
    <url>%2F2019%2F04%2F01%2F2019-04-01%2F</url>
    <content type="text"><![CDATA[碎碎念今天就是想简单的讲讲Vuejs源码中一些比较重要的部分。 愚人节快乐！！：）Vuejs源码解析正在研读中哈]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day79-理由-休息]]></title>
    <url>%2F2019%2F03%2F31%2F2019-03-31%2F</url>
    <content type="text"><![CDATA[碎碎念相信我，今天虽然是玩了一会儿游戏，但是我还是看书了的。红宝书还是看了一些的。所以今天主要还是玩了一天。我怎么这么能玩，立下的一些flag都要倒下了？]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day78-订阅发布者模式]]></title>
    <url>%2F2019%2F03%2F30%2F2019-03-30%2F</url>
    <content type="text"><![CDATA[订阅者-发布者模式前言，最近这个模式非常的火。刚好看书又看到这里。所以就跟着敲了一遍代码，把最基本的思想理了下。 小例子/** * * 订阅者-发布者模式（添加给所有对象） */let event = &#123; clientList: [], // 缓存对象，存放订阅者的回调函数 listen: function (key, fn) &#123; // 订阅消息 if (!this.clientList[key]) &#123; this.clientList = [] // 如果没有订阅过key类的消息，创建一个缓存列表 &#125; this.clientList[key].push(fn) // 订阅消息加入缓存列表 &#125;, trigger: function () &#123; // 发布消息 let key = Array.prototype.shift.call(arguments) let fns = this.clientList[key] if (!fns || fns.length === 0) &#123; return false &#125; for (let i = 0, fn; fn = fns[i++];) &#123; fn.apply(this, arguments) &#125; &#125;&#125;// 给所有对象动态安装发布-订阅功能let installEvent = function (obj) &#123; for (let i in event) &#123; obj[i] = event[i] &#125;&#125;// 实例-给对象salesOffices 动态增加发布-订阅功能let salesOffices = &#123;&#125;installEvent(salesOffices)salesOffices.listen('squareMeter88', function (price) &#123; console.log('price=' + price)&#125;)salesOffices.listen('squareMeter100', function (price) &#123; console.log('price=' + price)&#125;)salesOffices.trigger('squareMeter88', 200000)salesOffices.trigger('squareMeter100', 300000) end-]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day77-理由-休息]]></title>
    <url>%2F2019%2F03%2F29%2F2019-03-29%2F</url>
    <content type="text"><![CDATA[碎碎念明天有双休了！！yeah!]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day76-理由-修bug]]></title>
    <url>%2F2019%2F03%2F28%2F2019-03-28%2F</url>
    <content type="text"><![CDATA[碎碎念最近是真的比较忙啊。虽然比较忙，但是从平时的一些聊天中还是感觉到和别人的一些差距。这个还是要靠平时多做做题目来补全啊。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day75-理由-犯困]]></title>
    <url>%2F2019%2F03%2F27%2F2019-03-27%2F</url>
    <content type="text"><![CDATA[碎碎念这段时间果然记录下来是有点用处的！发现自己偷懒的轨迹了。自己一无所成啊。这些天都是以繁忙为借口，一直在逃避写一篇好的日志。这样是不行的啊。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day74-理由-提测]]></title>
    <url>%2F2019%2F03%2F26%2F2019-03-26%2F</url>
    <content type="text"><![CDATA[碎碎念最近项目终于开始提测了！这是比较好的事。然后就是最近阮一峰的ES6看了一遍了！现在开始准备看Vue技术揭秘，这是源码级别了吧！这是第二次想要阅读源码了！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day73-理由-心累]]></title>
    <url>%2F2019%2F03%2F25%2F2019-03-25%2F</url>
    <content type="text"><![CDATA[碎碎念今天又是一天，一直忙活项目的事情。暂时水到这里吧。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day72-理由-懈怠]]></title>
    <url>%2F2019%2F03%2F24%2F2019-03-24%2F</url>
    <content type="text"><![CDATA[碎碎念今天一口气喝了一罐红牛，突然感觉有点晕晕的啊。很久没有锻炼？看来是时候好好锻炼下！他们今天三个人，下楼打球，才打了半个小时就气喘嘘嘘上来了，我肯定也不例外啊，身体素质肯定又下去了！一定要锻炼啊！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day71-理由-紧张]]></title>
    <url>%2F2019%2F03%2F23%2F2019-03-23%2F</url>
    <content type="text"><![CDATA[碎碎念项目这几天就要提测了！有点期待全通过！希望不要出什么大的问题！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day70-理由-冲刺]]></title>
    <url>%2F2019%2F03%2F22%2F2019-03-22%2F</url>
    <content type="text"><![CDATA[碎碎念这几天最忙的就是项目了。这几天项目冲刺。可能要在4月份之前就要上线了。所以这个文章什么的，这个月看起来水的很。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day69-理由-项目]]></title>
    <url>%2F2019%2F03%2F21%2F2019-03-21%2F</url>
    <content type="text"><![CDATA[碎碎念啥也不说了！今天回来的真的很晚！早点睡觉吧！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day68-理由-划水]]></title>
    <url>%2F2019%2F03%2F20%2F2019-03-20%2F</url>
    <content type="text"><![CDATA[碎碎念今天是真的忘了提交了啊！又忘了push要写的日记内容。所以只能是这里划一下水。]]></content>
      <categories>
        <category>xx</category>
      </categories>
      <tags>
        <tag>xx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day67-数组对象去重]]></title>
    <url>%2F2019%2F03%2F19%2F2019-03-19%2F</url>
    <content type="text"><![CDATA[前言之前都是总结的数组去重，这次记录一个简单的例子，数组对象怎么利用reduce方法去重。 代码本节包含去重前的数组和去重数组方法和去重之后的结果。let a = [&#123;label: 'all', value: 0&#125;, &#123;label: 'all', value: 0&#125;, &#123;label: 'trans', value: 2&#125;, &#123;label: 'edit', value: 3&#125;]let obj = &#123;&#125;let res = a.reduce((item, next) =&gt; &#123; obj[next.value] ? '' : obj[next.value] = true &amp;&amp; item.push(next) return item&#125;, []) 输出： [ { label: ‘all’, value: 0 }, { label: ‘trans’, value: 2 }, { label: ‘edit’, value: 3 } ]]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day66-理由-挺忙]]></title>
    <url>%2F2019%2F03%2F18%2F2019-03-18%2F</url>
    <content type="text"><![CDATA[碎碎念最近有短短续续的看设计模式，但是进展还是非常的缓慢的。这几天习惯了早点下车，离家有一段距离的时候再下车。感觉这几天心情平静的很啊。end~]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day65-问题小结]]></title>
    <url>%2F2019%2F03%2F17%2F2019-003-17%2F</url>
    <content type="text"><![CDATA[前言最近一段时间在微信群里收藏了一些常见的问题。今天来列一下这些问题。以下问题有可能有点乱，随机收集的。 问题网络基础知识 - 腾讯懒函数 - 封装, 解决办法重写函数let foo = function () &#123; let t = new Date() foo = function () &#123; return t &#125; return foo()&#125; Vue技术内幕Vue.js 技术揭秘可视化理解JS事件循环机制观察者模式和发布订阅模式的区别怎么理解模块化 - 头条vdom diff排序、AST?二叉树非递归遍历，我写了一个前序遍历 - ？有没有手动搭建webpack工程mvvm的原理、mvc的缺点、vuex用来做什么有什么替代方案、小程序的坑、移动端适配、模块化组件化各自的优缺点、如何封装网络请求，要注意什么？递归实现数组内元素反转手写懒加载实现说到变量提升，class 声明一个类时，存在变量提升么？（不存在。因为要方便类的继承，先声明子类再声明父类；）问 事件循环为什么设计成微任务宏任务http2的多路复用，怎么实现的、Keep alive、缓存机制、cache control的一些值的区别setState发生了什么、react setState直接要diff整个component？手写json.stringifyDP算法题嵌套数组环形遍历数组里1-10 10个元素顺序排序，然后让随机打乱用几次for 怎么实现介绍原生datepicker技术细节element ui 中，在下拉菜单组件中，为什么下拉框里的内容要放在body标签里，而不是直接放在这个组件上？websocket面试加分项vuex和redux有什么区别Webpack的tree shakingString类型如何在不使用Number、parseInt、+、-、*、\/的情况下转换成Number？vue和react区别-&gt;vue2.0 3.0响应区别-&gt;set问题， 寄生组合继承中 将父类的原型赋值给了过渡函数的原型然后用过渡函数的实例再赋值给子类(中间修改了过渡函数的constructor指向到子类) 为什么不直接将父类的原型直接赋值给子类的原型呢？部署cdn - ？阻止冒泡使用 ECMAScript（JS）代码实现一个事件类Event，包含下面功能：绑定事件、解绑事件和派发事件。书《JavaScript设计模式》-张容铭，《设计模式之禅》-机械工业出版社 - 大宏如何调试node的 有没有远程调试过线上服务？]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day64-模板语法]]></title>
    <url>%2F2019%2F03%2F16%2F2019-03-16%2F</url>
    <content type="text"><![CDATA[背景vuejs项目中有个需求，在notification消息提示中某个部分需要有点击事件。UI用的element。想到用模板的方法来构造。 element-ui Notification onClick 触发方式组件中有两种触发的方式，但是都没有很好的满足需求。 点击时触发this.$notify.warning(&#123; dangerouslyUseHTMLString: true, duration: 0, message: `$&#123;this.createdFailedMember&#125;个成员创建失败！&lt;a id="message" style="color: #66b1ff;text-decoration: underline;cursor:pointer;" @click=aclick(event)"&gt;前往查看&lt;/a&gt;`, onClick: function () &#123; console.log(1) &#125;&#125;) 创建时触发this.$notify.warning(&#123; dangerouslyUseHTMLString: true, duration: 0, message: `$&#123;this.createdFailedMember&#125;个成员创建失败！&lt;a id="message" style="color: #66b1ff;text-decoration: underline;cursor:pointer;" @click=aclick(event)"&gt;前往查看&lt;/a&gt;`, onClick: (function () &#123; console.log(1) &#125;)()&#125;) 渲染函数比较灵活的render 函数。非常好用，但是没有模板语法那么简洁。this.$notify.warning(&#123;message: h( 'div', &#123; style: &#123;display: 'inline-block'&#125; &#125;, [ h('span', `$&#123;this.createdFailedMember&#125;个成员创建失败！`), h('a', &#123; style: &#123;color: '#409EFF', cursor: 'pointer', 'text-decoration': 'underline'&#125;, on: &#123; click: this.clickNotificationMsg &#125; &#125;, '前往查看') ])&#125;)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day64-模板语法]]></title>
    <url>%2F2019%2F03%2F16%2F2019-03-1111%2F</url>
    <content type="text"><![CDATA[背景vuejs项目中有个需求，在notification消息提示中某个部分需要有点击事件。UI用的element。想到用模板的方法来构造。 element-ui Notification onClick 触发方式组件中有两种触发的方式，但是都没有很好的满足需求。 点击时触发this.$notify.warning(&#123; dangerouslyUseHTMLString: true, duration: 0, message: `$&#123;this.createdFailedMember&#125;个成员创建失败！&lt;a id="message" style="color: #66b1ff;text-decoration: underline;cursor:pointer;" @click=aclick(event)"&gt;前往查看&lt;/a&gt;`, onClick: function () &#123; console.log(1) &#125;&#125;) 创建时触发this.$notify.warning(&#123; dangerouslyUseHTMLString: true, duration: 0, message: `$&#123;this.createdFailedMember&#125;个成员创建失败！&lt;a id="message" style="color: #66b1ff;text-decoration: underline;cursor:pointer;" @click=aclick(event)"&gt;前往查看&lt;/a&gt;`, onClick: (function () &#123; console.log(1) &#125;)()&#125;) 渲染函数比较灵活的render 函数。非常好用，但是没有模板语法那么简洁。this.$notify.warning(&#123;message: h( 'div', &#123; style: &#123;display: 'inline-block'&#125; &#125;, [ h('span', `$&#123;this.createdFailedMember&#125;个成员创建失败！`), h('a', &#123; style: &#123;color: '#409EFF', cursor: 'pointer', 'text-decoration': 'underline'&#125;, on: &#123; click: this.clickNotificationMsg &#125; &#125;, '前往查看') ])&#125;)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day63-理由-忘提交]]></title>
    <url>%2F2019%2F03%2F15%2F2019-03-15%2F</url>
    <content type="text"><![CDATA[碎碎念今天又写了一天的代码，还是抠细节，抠细节真的很没效率啊。本来写了一些小例子。忘了提交代码了啊。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day62-理由-感悟]]></title>
    <url>%2F2019%2F03%2F14%2F2019-03-14%2F</url>
    <content type="text"><![CDATA[碎碎念今天本来想优化代码的，看了很久的代码，最后还是没有优化，代码还是和原来一样。崩溃啊。实在是不愿意写下一些重复的代码，尤其是面条代码。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day61-理由-忙碌]]></title>
    <url>%2F2019%2F03%2F13%2F2019-03-13%2F</url>
    <content type="text"><![CDATA[碎碎念今天把昨天的问题解决了，业务上还有很多细节没有去处理。今天早点睡吧。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day60-理由-头疼]]></title>
    <url>%2F2019%2F03%2F12%2F2019-03-12%2F</url>
    <content type="text"><![CDATA[碎碎念今天下午居然碰到一个问题卡了一整个下午！关键是我现在都还没有解决。是有关vuejs中computed的getter、settter问题。头疼头疼。明天早上再去解决吧。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day59-理由-繁忙]]></title>
    <url>%2F2019%2F03%2F11%2F2019-03-11%2F</url>
    <content type="text"><![CDATA[碎碎念写了一整天的业务代码啊！！这种情况基本是腾不出时间来，写一些小累积。今天就到这吧。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day58-理由-吃撑]]></title>
    <url>%2F2019%2F03%2F10%2F2019-03-10%2F</url>
    <content type="text"><![CDATA[碎碎念今天真的是看书了！看的设计模式。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day57-理由-懒惰]]></title>
    <url>%2F2019%2F03%2F09%2F2019-03-09%2F</url>
    <content type="text"><![CDATA[碎碎念最近感觉有点累！还是早点睡觉吧！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day56-理由-拖延]]></title>
    <url>%2F2019%2F03%2F08%2F2019-03-08%2F</url>
    <content type="text"><![CDATA[碎碎念今天身边头号新闻，公司获得了1800万投资啊！嗯，有点兴奋！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day55-uncurrying]]></title>
    <url>%2F2019%2F03%2F07%2F2019-03-07%2F</url>
    <content type="text"><![CDATA[背景让对象借用原本不属于他的方法，我们可以用call,apply把任意对象当做this传入某个方法。有没有能够把this提取出来，并得到更广的适用性？ uncurrying 实现 实现方式之一 Function.prototype.uncurrying = function () &#123; let self = this return function () &#123; let obj = Array.prototype.shift.call(arguments) return self.apply(obj, arguments) &#125;&#125; 实现方法二 Function.prototype.uncurrying = function () &#123; let self = this return function () &#123; return Function.prototype.call.apply(self, arguments) &#125;&#125; uncurrying应用通过uncurrying方式，push 函数的作用和Array.prototype.push.call()一样 方法一的应用 let push = Array.prototype.push.uncurrying()let obj = &#123; 'length': 1, '0': 1&#125;push(obj, 2)console.log(obj) 发生了什么？ Function.prototype.uncurrying = function () &#123; let self = this // self 此时是Array.prototype.push() return function () &#123; let obj = Array.prototype.shift.call(arguments) /** * obj是&#123; * 'length': 1, * '0': 1 * &#125; * argument 对象的第一个元素被截去，剩下[2] */ return self.apply(obj, arguments) &#125;&#125; 参考[1].《JavaScript设计模式与开发实践》- 曾探]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day54-理由-ss挂了]]></title>
    <url>%2F2019%2F03%2F06%2F2019-03-06%2F</url>
    <content type="text"><![CDATA[碎碎念下午突然不能google了，Ping一下我服务器地址，是可以的，端口被封了！于是开始折腾了。可能是最近两会吧。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day53-两数组-集合运算]]></title>
    <url>%2F2019%2F03%2F05%2F2019-03-05%2F</url>
    <content type="text"><![CDATA[背景选择语言对的时候，源语言和目标语言选项要互斥。由此联想到交集、差集、补集、并集的JS如何实现。本文小结ES5和ES6的一些实现方法。 [Photo by Ant Rozetsky on Unsplash] ES5实现 数据let arrA = [‘a’, 3, 5, ‘d’, ‘o’]let arrB = [‘b’, 5, ‘o’, ‘x’, ‘g’, ‘b’]filter+indexOf+concat 交集 let intersection = arrA.filter(v =&gt; &#123; return arrB.indexOf(v) &gt; -1&#125;)console.log(intersection)// [ 5, 'o' ] 差集 arrA与arrB的差集 let r = arrA.filter(v =&gt; &#123; return arrB.indexOf(v) &gt; -1&#125;)console.log(r)// [ 'a', 3, 'd' ] 补集 let complementarySet = arrA.filter(v =&gt; !(arrB.indexOf(v) &gt; -1)).concat(arrB.filter(v =&gt; !(arrA.indexOf(v) &gt; -1)))console.log(complementarySet) // [ 'a', 3, 'd', 'b', 'x', 'g', 'b' ] 并集 let unionSet = arrA.concat(arrB.filter(v =&gt; !(arrA.indexOf(v) &gt; -1)))console.log(unionSet)// [ 'a', 3, 5, 'd', 'o', 'b', 'x', 'g', 'b' ] ES6实现 数据let arrA = [‘a’, 3, 5, ‘d’, ‘o’]let arrB = [‘b’, 5, ‘o’, ‘x’, ‘g’, ‘b’]filter+Set+has 交集 let intersection = arrA.filter(x =&gt; new Set(arrB).has(x))console.log(intersection)// [ 5, 'o' ] 差集 arrA与arrB的差集 let diffSet = arrA.filter(x =&gt; !new Set(arrB).has(x))console.log(diffSet)// [ 'a', 3, 'd' ] 补集 let complementarySet = [...arrA.filter(x =&gt; !new Set(arrB).has(x)), ...arrB.filter(x =&gt; !new Set(arrA).has(x))]console.log(complementarySet)// [ 'a', 3, 'd', 'b', 'x', 'g', 'b' ] 并集 let unionSet = Array.from(new Set([...arrA, ...arrB]))console.log(unionSet)// [ 'a', 3, 5, 'd', 'o', 'b', 'x', 'g' ]]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day52-理由-太忙]]></title>
    <url>%2F2019%2F03%2F04%2F2019-03-04%2F</url>
    <content type="text"><![CDATA[碎碎念今天有事，写了一整天的代码！这个就不能怪我忘了选博客内容了！理由是本来想提交代码的，结果忘了push代码，所以今天没有一个正经的博客内容。这是第六个理由！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day51-理由-懒惰]]></title>
    <url>%2F2019%2F03%2F03%2F2019-03-03%2F</url>
    <content type="text"><![CDATA[碎碎念今天忘了提交代码了，所以这里没有小总结！而且今天加班一天！写了一天的代码！至此，头一次，达成连续两天周末加班成就！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day50-清除浮动]]></title>
    <url>%2F2019%2F03%2F02%2F2019-03-02%2F</url>
    <content type="text"><![CDATA[背景慢慢的开始把一些最基础的知识点记下来。清除浮动的两种方法。overflow和伪类after。 css-float-hack 结构&lt;div class="float-container clearfix"&gt; &lt;div style="float:right;"&gt;&lt;/div&gt;&lt;/div&gt; 方法目前有两种方法清除浮动 方法一 overflow.clearfix &#123; overflow: auto;&#125; 控制不好margins 和padding 就会出现scrollbars 方法二 ::after.clearfix::after &#123; content: ""; clear: both; display: table;&#125; 这个方法比较常用。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day49-理由-没周末]]></title>
    <url>%2F2019%2F03%2F01%2F2019-03-01%2F</url>
    <content type="text"><![CDATA[碎碎念今天真的是不知道为啥，提不起一点劲。可能是最近事情比较多吧。这个月开始，一个月都没周末，唉！回到家就只想看点视频什么。看到了B站的《西游记之大圣归来》。真的是蛮精彩！强烈推荐。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day48-GitError]]></title>
    <url>%2F2019%2F02%2F28%2F2019-02-28%2F</url>
    <content type="text"><![CDATA[背景windows的电脑端ss开的局部代理，hosts经常有时会被莫名其妙的修改。这次就比较奇怪了，git连不上github.com显示connect error。以为密钥什么的错误，之后才意识到可能是hosts的问题。 问题 SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443 解决 进到.ssh目录 cd ~/.ssh/touch config 将下面内容添加到config(非注释部分) Host github.comUser gitHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443 就ok了！]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day48-理由4-忙碌]]></title>
    <url>%2F2019%2F02%2F27%2F2019-02-27%2F</url>
    <content type="text"><![CDATA[碎碎念今天又是一个死循环的一天。总结下今天，碰到一个问题，不去深究其中内因。不断地去尝试，试错。嗯，典型的不过脑子了。典型的不能很好地冷静下来。下次碰到问题一定把不能莽撞，一定要冷静下来，要冷静地好好想想，冷静地理一下，才不会浪费时间毫无头绪。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day47-多选过滤]]></title>
    <url>%2F2019%2F02%2F26%2F2019-02-26%2F</url>
    <content type="text"><![CDATA[背景今天有个需求，select下拉框中可以选中多个标签，并将这些标签作为过滤条件。以往都是单条件下拉框过滤，现在需要选择框中有多个选择条件，而且这个条件是动态变化。 代码let arr = ["1", "3"]// 数据源let data = [&#123; state: 1 &#125;, &#123; state: 2 &#125;, &#123; state: 3 &#125;]let d = data.filter(v =&gt; &#123; return arr.every(k =&gt; &#123; k = v.state return arr.indexOf(k.toString()) !== -1 &#125;)&#125;)// console.log(arr.every(v =&gt; v === 1))console.log(d) 参考[1]. Array.prototype.filter()[2]. JS 对象数组根据多个条件过滤[3]. JS中的数组过滤，从简单筛选到多条件筛选]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day46-理由-心累]]></title>
    <url>%2F2019%2F02%2F25%2F2019-02-25%2F</url>
    <content type="text"><![CDATA[碎碎念哇，最近移动端项目遇到了瓶颈，感觉有点心累啊！脑海里其他技术之外的事情又不停的在绕圈圈。哇咔咔~专心点吧！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day45-闭包的小例子]]></title>
    <url>%2F2019%2F02%2F24%2F2019-02-24%2F</url>
    <content type="text"><![CDATA[封装变量在平时运用中，闭包用的比较多的还是对于函数或者变量的封装。本文借鉴一个小例子，示范闭包的应用。 原函数let mult = function () &#123; let a = 1 for (let i = 0; i &lt; arguments.length; i++) &#123; a = a * arguments[i] &#125; return a&#125;console.log(mult(1, 2, 3)) // 6 封装变量let cache = &#123;&#125; // 注意是全局变量let mult = function () &#123; let args = Array.prototype.join.call(arguments, ',') if (cache[args]) &#123; return cache[args] &#125; console.log('==') let a = 1 for (let i = 0; i &lt; arguments.length; i++) &#123; a = a * arguments[i] &#125; return cache[args] = a&#125;console.log(mult(1,2,3))console.log(mult(1,2,3))// ==// 6// 6 优化全局变量 很错误的方法啊！ let mult = function () &#123; let cache = &#123;&#125; let args = Array.prototype.join.call(arguments, ',') if (cache[args]) &#123; return cache[args] &#125; console.log('==') let a = 1 for (let i = 0; i &lt; arguments.length; i++) &#123; a = a * arguments[i] &#125; return cache[args] = a&#125;console.log(mult(1, 2, 3))console.log(mult(1, 2, 3))// ==// 6// 6 正确方法之一 let mult = (function () &#123; let cache = &#123;&#125; return function () &#123; let args = Array.prototype.join.call(arguments, ',') if (cache[args]) &#123; return &#125; let a = 1 for (let i = 0; i &lt; arguments.length; i++) &#123; a = a * arguments[i] &#125; return cache[args] = a &#125;&#125;)()console.log(mult(1, 2 ,3))console.log(mult(1, 2 ,3))// ==// 6// 6 提炼函数let mult = (function () &#123; let cache = &#123;&#125; let calculate = function () &#123; let a = 1 for (let i = 0; i &lt; arguments.length; i++) &#123; a = a * arguments[i] &#125; return a &#125; return function () &#123; let args = Array.prototype.join.call(arguments, ',') if (args in cache) &#123; return cache[args] &#125; console.log('++') return cache[args] = calculate.apply(null, arguments) &#125;&#125;)()console.log(mult(1, 2, 3))// 6 以上就是我要说的话了，show code.–end]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day44-bind]]></title>
    <url>%2F2019%2F02%2F23%2F2019-02-23%2F</url>
    <content type="text"><![CDATA[bind的简单实现 最基本的Function.prototype.bind = function (context) &#123; let self = this return function () &#123; return self.apply(context, arguments) &#125;&#125;let obj = &#123; id: '1'&#125;let func = (function () &#123; console.log(this.id)&#125;).bind(obj)func()// 1 基本的PLUSFunction.prototype.bind = function () &#123; let self = this // 原函数 let context = [].shift.call(arguments) // this 上下文 let args = [].slice.call(arguments) // 剩余参数转化成数组 return function () &#123; return self.apply(context, [].concat.call(args, [].slice.call(arguments))) // 组合分别传入的参数 &#125;&#125;let obj = &#123; id: '1'&#125;let func = function (a, b, c, d) &#123; console.log(this.id) console.log([a, b, c, d])&#125;.bind(obj, 1, 2)func(3, 4)// 1// [ 1, 2, 3, 4 ] –end]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day43-理由-陪聊]]></title>
    <url>%2F2019%2F02%2F22%2F2019-02-22%2F</url>
    <content type="text"><![CDATA[碎碎念一个妹子突然找我，聊家事。聊了快一晚上了。感叹，不容易啊！家庭不容易啊！不容易啊！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day42-理由-评审]]></title>
    <url>%2F2019%2F02%2F21%2F2019-02-21%2F</url>
    <content type="text"><![CDATA[碎碎念居然说，3月份要没有周末，吓死我了！因为项目说是很急，我看项目量也不小啊！吓人吓人。今天评审时间就用了很久，5点到晚上7点半，之后8点到9点，吓人啊。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day41-“练字”-"debouncejs"]]></title>
    <url>%2F2019%2F02%2F20%2F2019-02-20%2F</url>
    <content type="text"><![CDATA[debounce本文主要是临摹Lodashjs中debouncejs源代码。对一部分细节进行了解，代码中会附上链接并写中文注释。分为两部分：loadsh-debounce是来自官方v4.17.5文档的解释。源代码是来自官方github上的代码，日期为2019-2-20之前。 lodash-debounce 背景_.debounce(func, [wait=0], [options={}]) 描述Creates a debounced function that delays invoking func until after wait milliseconds have elapsed since the last time the debounced function was invoked. The debounced function comes with a cancel method to cancel delayed func invocations and a flush method to immediately invoke them. Provide options to indicate whether func should be invoked on the leading and/or trailing edge of the wait timeout. The func is invoked with the last arguments provided to the debounced function. Subsequent calls to the debounced function return the result of the last func invocation. Note:If leading and trailing options are true, func is invoked on the trailing edge of the timeout only if the debounced function is invoked more than once during the wait timeout.If wait is 0 and leading is false, func invocation is deferred until to the next tick, similar to setTimeout with a timeout of 0. Argumentsfunc (Function): The function to debounce.[wait=0] (number): The number of milliseconds to delay.[options={}] (Object): The options object.[options.leading=false] (boolean): Specify invoking on the leading edge of the timeout.[options.maxWait] (number): The maximum time func is allowed to be delayed before it’s invoked.[options.trailing=true] (boolean): Specify invoking on the trailing edge of the timeout. Returns(Function): Returns the new debounced function. 源代码-加一些解析/** * lodash 中的debounce实现 *//** 常量 *//** lodash https://github.com/lodash/lodash/blob/master/.internal/freeGlobal.js *//** Detect free variable `global` from Node.js. */const freeGlobal = typeof global == 'object' &amp;&amp; global !== null &amp;&amp; global.Object === Object &amp;&amp; global/** lodash https://github.com/lodash/lodash/blob/master/.internal/root.js *//** Detect free variable `self`. */const freeSelf = typeof self == 'object' &amp;&amp; self !== null &amp;&amp; self.Object === Object &amp;&amp; self/** Used as a reference to the global object. */const root = freeGlobal || freeSelf || Function('return this')()/** 判断对象 */function isObject(value) &#123; const type = typeof value return value != null &amp;&amp; (type == 'object' || type == 'function')&#125;/** debounce */function debounce(func, wait, options) &#123; let lastArgs, lastThis, maxWait, result, timerId, lastCallTime let lastInvokeTime = 0 let leading = false let maxing = false let trailing = true // Bypass `requestAnimationFrame` by explicitly setting `wait=0`. // 注意(!wait &amp;&amp; wait)写法,通过``明确设置wait=0 // requestAnimationFrame接受一个动画执行函数作为参数，这个函数的作用是仅执行一帧动画的渲染。回调函数会在浏览器下一次重绘之前执行 // requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧 // 在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量。 // 调用requestAnimationFrame后，它会要求浏览器根据自己的频率进行一次重绘，它接收一个回调函数作为参数，在即将开始的浏览器重绘时，会调用这个函数，并会给这个函数传入调用回调函数时的时间作为参数。由于requestAnimationFrame的功效只是一次性的，所以若想达到动画效果，则必须连续不断的调用requestAnimationFrame // cancelAnimationFrame 取消requestAnimationFrame的回调 // https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame const useRAF = (!wait &amp;&amp; wait !== 0 &amp;&amp; typeof root.requestAnimationFrame === 'Function') if (typeof func !== 'function') &#123; throw new TypeError('Exception a function') &#125; // 一元正号将字符串转换成整数和浮点数形式，转换非字符串值 true，false 和 null,小数和十六进制格式字符串。 // 负数形式字符串也可以转换成数值（对于十六进制不适用）。如果它不能解析一个值，则计算结果为 NaN。 wait = +wait || 0 if (isObject(options)) &#123; leading = !!options.leading maxing = 'maxWait' in options maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait trailing = 'trailing' in options ? !!options.trailing : trailing &#125; function invokeFunc(time) &#123; const args = lastArgs const thisArg = lastThis lastArgs = lastThis = undefined lastInvokeTime = time result = func.apply(thisArg, args) return result &#125; // 定时器 function startTimer(pendingFunc, wait) &#123; if (useRAF) &#123; root.cancelAnimationFrame(pendingFunc) return root.requestAnimationFrame(pendingFunc) &#125; return setTimeout(pendingFunc, wait) &#125; // 取消定时器 function cancelTimer (id) &#123; if (useRAF) &#123; return root.cancelAnimationFrame(id) &#125; clearTimeout(id) &#125; // 函数在每个等待时延的开始被调用 function leadingEdge (time) &#123; // Reset any `maxWait` timer // 重置最长等待定时器 lastInvokeTime = time // Start the timer for the trailing edge. // 开启？？定时器 timerId = startTimer(timerExpired, wait) // Invoke the leading edge // 执行 return leading ? invokeFunc(time) : result &#125; function remainingWait(time) &#123; const timeSinceLastCall = time - lastCallTime const timeSinceLastInvoke = time - lastInvokeTime const timeWaiting = wait - timeSinceLastCall return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting &#125; function shouldInvoke(time) &#123; const timeSinceLastCall = time - lastCallTime const timeSinceLastInvoke = time - lastInvokeTime // Either this is the first call, activity has stopped and we're at the // trailing edge, the system time has gone backwards and we're treating // it as the trailing edge, or we've hit the `maxWait` limit. return (lastCallTime === undefined || (timeSinceLastCall &gt;= wait) || (timeSinceLastCall &lt; 0) || (maxing &amp;&amp; timeSinceLastInvoke &gt;= maxWait)) &#125; function timerExpired() &#123; const time = Date.now() if (shouldInvoke(time)) &#123; return trailingEdge(time) &#125; // Restart the timer. timerId = startTimer(timerExpired, remainingWait(time)) &#125; function trailingEdge(time) &#123; timerId = undefined // only invoke if we have `lastArgs` which means `func has been debounced at least once if (trailing &amp;&amp; lastArgs) &#123; return invokeFunc(time) &#125; lastArgs = lastThis = undefined return result &#125; function cancel () &#123; if (timerId !== undefined) &#123; cancelTimer(timerId) &#125; lastInvokeTime = 0 lastArgs = lastCallTime = lastThis = timerId = undefined &#125; // 立即执行 function flush () &#123; return timerId === undefined ? result : trailingEdge(Data.now()) &#125; function pending () &#123; return timerId !== undefined &#125; function debounce(...args) &#123; const time = Date.now() const isInvoking = shouldInvoke(time) lastArgs = args lastThis = this lastCallTime = time if (isInvoking) &#123; if (timerId === undefined) &#123; return leadingEdge(lastCallTime) &#125; if (maxing) &#123; // Handle invocations in a tight loop. // 多循环中处理调用 timerId = startTimer(timerExpired, wait) return invokeFunc(lastCallTime) &#125; &#125; if (timerId === undefined) &#123; timerId = startTimer(timerExpired, wait) &#125; return result &#125; debounced.cancel = cancel debounced.flush = flush debounced.pending = pending return debounced&#125; 资料附上Lodashjs文档中一篇资料来解释防抖和节流。debouncing-throttling-explained-examples https://css-tricks.com/debouncing-throttling-explained-examples/ 参考github源代码-lodash/debounce.js文档-_.debounce(func, [wait=0], [options={}])]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day40-“繁忙”]]></title>
    <url>%2F2019%2F02%2F19%2F2019-02-19%2F</url>
    <content type="text"><![CDATA[今天元宵节，“猿宵节”啊！节日快乐！其实今天是项目这边有点忙，没有写完编程日志，恰巧元宵节，所以这就是我不好好写日志的理由，哈哈。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day39-做题]]></title>
    <url>%2F2019%2F02%2F18%2F2019-02-18%2F</url>
    <content type="text"><![CDATA[题目console.log(['1', '2', '3'].map(parseInt))// 输出什么？ 答案[ 1, NaN, NaN ] 详解 这个应该是考map语法、进制转换和parseInt语法 易错点 parseInt(string, radix) - radix - 根 - （基数）范围：[2, 36] string 要被解析的值，无法被转化成数值类型，则返回NaN 代码扩展实际执行的代码是： ['1', '2', '3'].map((item, index) =&gt; &#123; return parseInt(item, index)&#125;) parseInt（string, radix) radix关于parseInt基数的处理(MDN)基数radix为 undefined，或者基数为 0 或者没有指定的情况下，JavaScript 作如下处理：如果 parseInt 遇到了不属于radix参数所指定的基数中的字符那么该字符和其后的字符都将被忽略。接着返回已经解析的整数部分。parseInt 将截取整数部分。开头和结尾的空白符允许存在，会被忽略 string 如果字符串 string 以”0x”或者”0X”开头, 则基数是16 (16进制). 如果字符串 string 以”0”开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。 如果字符串 string 以其它任何值开头，则基数是10 (十进制)。 解决（延伸）目前掌握的可能有两种方法： 方法一：利用函数柯里化来取map的数组index为0时的值，因为默认为10进制。 方法二：利用Number。方法一：let unary = fn =&gt; val =&gt; fn(val)let parse = unary(parseInt)let res_0 = ['1', '2', '3'].map(parse)console.log(res_0) 来自 30secondsofcode的unary方法。 let unary = fn =&gt; val =&gt; fn(val) 等价于下面function unary_1(fn) &#123; return function (val) &#123; return fn(val) &#125; &#125; 方法二：let res_1 = [‘10’,’10’,’10’,’8’,’10’].map(Number)console.log(res_1)来自[‘1’, ‘2’, ‘3’].map(parseInt) what &amp; why ? 练习 console.log(parseInt(1, 2)) console.log(parseInt(5, 4)) 参考[1]. 第二题：[‘1’, ‘2’, ‘3’].map(parseInt) 解析[2]. Array.prototype.map()[3]. parseInt]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day38-“摸鱼”]]></title>
    <url>%2F2019%2F02%2F17%2F2019-02-17%2F</url>
    <content type="text"><![CDATA[碎碎念摸了一天的鱼，昨天还是说要看书一天，结果今天中午才起来啊。然后一下午就是光玩儿了。到了晚上才看一会儿书。罪过罪过啊。看书看书！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day37-杂谈]]></title>
    <url>%2F2019%2F02%2F16%2F2019-02-16%2F</url>
    <content type="text"><![CDATA[碎碎念三天打鱼两天晒网，可能说的就是我写博客的状态没错了。今天是周末，待着一天，上午看电影，下午玩游戏，一点书都没看的人就是我了。明天看书！看书！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day36-杂谈]]></title>
    <url>%2F2019%2F02%2F15%2F2019-02-15%2F</url>
    <content type="text"><![CDATA[碎碎念今天是考研成绩出来的一天。恍恍惚惚，一年前的这个时候我还在过年，恍惚间一年已经过了。早上七点就醒了，不知道这有没有什么关系，但重要的是一年前的这个时候，我一晚上没睡着，结果第二天这个时候，消息并没有那么好。这都是一年前的事情了。谈一谈吧。这两天在做移动端的支付宝支付。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day35-杂谈]]></title>
    <url>%2F2019%2F02%2F14%2F2019-02-14%2F</url>
    <content type="text"><![CDATA[碎碎念发现要是女生和代码一样容易理解就好了，出错的几率也太大了。因为你费劲输入一大堆代码，最后错都不会报，根本不知道会不会运行。衰(′д｀ )…彡…彡有时候有些人你付出，更本就不会有任何反应。世事难料啊。情人节快乐！祝你们原地爆炸！ -end]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day34-deepClone]]></title>
    <url>%2F2019%2F02%2F13%2F2019-02-13%2F</url>
    <content type="text"><![CDATA[拷贝探究一下深拷贝，本文主要是浅拷贝、深拷贝的简单实现，并对循环引用就行一些了解。 准备let data = &#123; id: '1', segment: &#123; hitinfos: &#123; // 浅拷贝时rule为rule: [Object] rule: &#123; a: 'no-placeholder', b: 'no-tag' &#125;, level: 4 &#125;, atoms: [ &#123; tgt: 'you dont know', src: '你不知道' &#125;, &#123; id: 1, tgt: 'what', src: '什么' &#125; ] &#125;, arr: [&#123; id: 1, arr: 'arr1' &#125;], value_1: undefined, value_2: null, value_3: true&#125; 浅拷贝 简单的对象浅拷贝（只遍历一层）-拷贝引用 function cloneShadow(src) &#123; let tgt = &#123;&#125; // 为什么不直接用“=”赋值 for (let prop in src) &#123; // 或者用if (Object.hasOwnProperty(prop)) &#123; if (Object.prototype.hasOwnProperty.call(src, prop)) &#123; tgt[prop] = src[prop] &#125; &#125; return tgt&#125;let test = cloneShadow(data)data.id = 2console.log(test)console.log(data)console.log(test) 深拷贝 递归对象深拷贝（遍历多层）function deepClone(src) &#123; // 非对象 if (src &amp;&amp; typeof src !== 'object') &#123; return src // throw new TypeError('Except Object, got' + (typeof src)) &#125; // 初始化 let tgt = Array.isArray(src) ? [] : &#123;&#125; for (let prop in src) &#123; if (Object.prototype.hasOwnProperty.call(src, prop)) &#123; // value为null或者undefined则返回原值(typeof null === 'object') if (typeof src[prop] === 'object') &#123; tgt[prop] = deepClone(src[prop]) &#125; else &#123; tgt[prop] = src[prop] &#125; &#125; &#125; return tgt&#125;let test_1 = deepClone(data)console.log(test_1)console.log(data)console.log(test_1) 拷贝循环引用 拷贝循环引用（JSON方法抛异常）function deepCloneCircle(src) &#123; if (src &amp;&amp; src !== 'object') return src let tgt = Array.isArray(src) ? [] : &#123;&#125; for (let prop in src) &#123; if (Object.prototype.hasOwnProperty.call(src, tgt)) &#123; if (src[prop] &amp;&amp; src[prop] === 'object') &#123; tgt[prop] = deepCloneCircle(src[prop]) &#125; else &#123; tgt[prop] = src[prop] &#125; &#125; &#125; return tgt&#125;let test = deepCloneCircle(data)console.log(test) 参考：[1]. JavaScript中的浅拷贝和深拷贝[2]. 【进阶4-3期】面试题之如何实现一个深拷贝]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day33-css居中]]></title>
    <url>%2F2019%2F02%2F12%2F2019-02-12%2F</url>
    <content type="text"><![CDATA[居中总结经常会碰到一些居中的问题，这里尝试进行一些总结。分为垂直居中和水平居中。 水平居中 行内或类行内元素(inline/inline-block/inline-table/flex)：text-align: center; 块级元素： margin: 0 auto; 多个块级元素：display: inline-block; 垂直居中 行内或类行内元素: 单行：padding-top与padding-bottom 等值、或line-height与height 等值 多行：单行padding等值，或display: table-cell 用vertical-align：middle; 块级元素： – 待续]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三十二天2019-02-01]]></title>
    <url>%2F2019%2F02%2F01%2F2019-02-01%2F</url>
    <content type="text"><![CDATA[碎碎念最近又开始关注到Nodejs了，因为在探究js的一些原理的时候，不可避免的会注意到js的一些应用场景的不同，这两天看到了一篇很好的介绍Nodejs入门的文章，【全文】狼叔：如何正确的学习Node.js。看这篇文章还是比较有感触的，文章本身结合自身的体验从Nodejs诞生以来讲到近些年的趋势，当然我觉得最准的还是属于对于React.js和Vue.js的趋势的描述。这篇文章偏向于说教，也是说给初学Nodejs的人所听的，详细的地方在于介绍了一些该看的书本，和一些练习代码的方法，比如学会Nodejs要多看一些NPM包的源码，按作者来说就是一天5个NPM包阅读。这个对我来说感触是非常深的，本人觉得是，只有真正的上手，你才能说是真的开始去掌握这门东西。我觉得文章是真的比较详细，还提供一些资料，也提出了一些问题，比如，“在变化多端的大前端背景之下，该如何精进？”。文章本身可能探讨的比较多，也探讨了，Nodejs在各类编程语言中的比较，比如和java比较的优劣。总得来说，是一篇不可多得的好文。有幸看到这种文章。看来以后还是要多看专门的社区，去浏览一些文章，增长一些见识，拓宽一些视野。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三十一天2019-01-31]]></title>
    <url>%2F2019%2F01%2F31%2F2019-01-31%2F</url>
    <content type="text"><![CDATA[leetCode今天想到了Leetcode的题目，又捡起来做了一道题目。可能比较简单，就当是回忆的题目吧，以后捡起来题目都比较方便。慢慢来吧。坚持下去也好。也不是宁缺毋滥这种借口，是不存在的，还是得每天坚持写点日记，这样以后就能够进行阶段性总结，也可以看以前的东西，希望养成习惯。 Add Two Numbers** [2] Add Two Numbers** https://leetcode.com/problems/add-two-numbers/description/** algorithms* Medium (30.32%)* Total Accepted: 733.3K* Total Submissions: 2.4M* Testcase Example: '[2,4,3]\n[5,6,4]'** You are given two non-empty linked lists representing two non-negative* integers. The digits are stored in reverse order and each of their nodes* contain a single digit. Add the two numbers and return it as a linked list.* * You may assume the two numbers do not contain any leading zero, except the* number 0 itself.* * Example:* * * Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)* Output: 7 -&gt; 0 -&gt; 8* Explanation: 342 + 465 = 807.* * */ 题目框架** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var addTwoNumbers = function(l1, l2) &#123; 题解var addTwoNumbers = function(l1, l2) &#123; /** * 方法一 */ let List = new ListNode(0) let head = List let sum = 0 let carray = 0 while (l1 !== null || l2 !== null || sum &gt; 0) &#123; if (l1 !== null) &#123; sum = sum + l1.val l1 = l1.next &#125; if (l2 !== null) &#123; sum = sum + l2.val l2 = l2.next &#125; if (sum &gt;= 10) &#123; carray = 1 sum = sum - 10 &#125; head.next = new ListNode(sum) head = head.next sum = carray carray = 0 &#125; return List.next /** * 方法二 */ // let node = null // const carray = arguments[2] // if (l1 || l2) &#123; // // 加上进位 // const val1 = l1 ? l1.val1 : 0 // const val2 = l2 ? l2.val2 : 0 // const next1 = l1 ? l1.next : null // const next2 = l2 ? l2.next : null // const val = carry ? val1 + val2 + 1 : val1 + val2 // node = new ListNode(val % 10) // node.next = addTwoNumbers(next1, next2, val &gt;= 10) // &#125; else if (carray) &#123; // node = new ListNode(1) // node.next = null // &#125; // return node&#125;; –end–]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三十天2019-01-30]]></title>
    <url>%2F2019%2F01%2F30%2F2019-01-30%2F</url>
    <content type="text"><![CDATA[上线很晚啊，今天，有点困。还是早点睡吧，这些天。今天碰到个问题。vm.$attrs传入的不识别横线方式，爷组件传入的不会自动将驼峰转为横线模式。 –end–]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二十九天2019-01-29]]></title>
    <url>%2F2019%2F01%2F29%2F2019-01-29%2F</url>
    <content type="text"><![CDATA[碎碎念刚看了下，搁置了四天没写技术文章了，好几篇只有上文，没有下文。这个毛病从写日志体现出来了，说明得改，这还说明了，写日志的好处啊，能够从记录中发现问题。可能这就是今天鸽的理由吧。这几天快接近年末了，又期待，又不期待，真是很纠结。我发现，什么时候都有很多事，看你怎么去对待，永远不会说等到没事的时候。要调整好情绪再说。此处，鸽。 –end–]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二十八天2019-01-28]]></title>
    <url>%2F2019%2F01%2F28%2F2019-01-28%2F</url>
    <content type="text"><![CDATA[碎碎念今天回来的比较晚，可能事情比较多吧。又想起了以前的事。唉，洗洗早点睡吧。几天就这几句唠唠叨叨的话了。 –end–]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二十七天2019-01-27]]></title>
    <url>%2F2019%2F01%2F27%2F2019-01-27%2F</url>
    <content type="text"><![CDATA[今天上午看了一部动漫，B站Lex推荐的。看完之后感叹这两天动漫质量的提高，动漫三观简直不能再正，满满的正能量。这种动漫真是难怪不火。动漫名字叫《超能力少女》但是整个片并不是一部打斗片，而是一部以一位来自异世界超能力少女生活为主线另一位异世界超能力少女为辅，讲述了来到这个世界之后，两个少女面对不同的家庭之间各自的努力和奋斗故事，在女二号身上，看到了满满的正能量，与女一号富有的生活对比，个人感觉女二号的勤奋和人品更像是这部故事讲述的主题。同时，这个故事也对于日本的黑帮进行了一些美化。虽然故事剧情并没有像标题和开头一幕一样热血，但是剧情本身还是非常精彩！这里好像说了绕口令。但就是夸这部动漫吧。 –end–]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二十六天2019-01-26]]></title>
    <url>%2F2019%2F01%2F26%2F2019-01-26%2F</url>
    <content type="text"><![CDATA[碎碎念今天公司年会，这是个不写log的好理由，对吧？我也是这么觉得。回到家已经很晚了，晚上11点才到家，就真的不想再写日志了。就这样结束今天的日志环节吧。 –end–]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二十五天2019-01-25]]></title>
    <url>%2F2019%2F01%2F25%2F2019-01-25%2F</url>
    <content type="text"><![CDATA[js 常用数组方法小结 （2）碎碎念有些数组方法会经常用，这里今天就介绍一下reduce()方法和find()方法。 Array.protytype.reduce()背景看完一些方法，目前来说，reduce()方法，能实现的比较多，且我之前看到的文章中对其的推崇是比较多的。据说它能做很多事情。昨天看了下MDN上的介绍和几个例子，确实感觉其功能的强大。本文基于MDN上的代码以笔记的形式注释，先对功能做栗子，然后对方法进行一些描述。 举个栗子一些简单的例子 累加数组中的值？ let sum = [3, 9, 12, 34].reduce((accumulator, currentValue, currentIndex, array) =&gt; &#123; return accumulator + currentValue&#125;)console.log(sum) // 58 累加对象数组中的值？ let sum = [&#123;x: 1&#125;, &#123;x:2&#125;, &#123;x:3&#125;].reduce((accumulator, currentValue) =&gt; &#123; // 将键名为x的逐个累加到累加器中 return accumulator + currentValue.x&#125;, 0)console.log(sum) // 6 initialValue 为初始值，且初始值是必须提供的 二维数组转为一维数组？let flattened = [[0, 1], [2, 3], [4, 5]].reduce((acc, cval, cidx, arr) =&gt; &#123; // 初始值为空数组，取出当前下标数组中的值，放入累加器中的空数组，逐个累加 return acc.concat(cval)&#125;, [])console.log(flattened) 一些稍微复杂点的 计算数组中每个元素出现的次数？ let arr = [1, 3, 54, 21, 1]let count = arr.reduce((acc, cval) =&gt; &#123;// 这里要注意是在累加器中去寻找是否存在值 if (cval in acc) &#123; // 以对象形式赋值，真个reduce过程一次次去遍历 acc[cval]++ &#125; else &#123; acc[cval] = 1 &#125; return acc&#125;, &#123;&#125;)console.log(count) // &#123; '1': 2, '3': 1, '21': 1, '54': 1 &#125; 属性对object分类？ let people = [ &#123; name: 'Alice', age: 21 &#125;, &#123; name: 'Max', age: 20 &#125;, &#123; name: 'Jane', age: 20 &#125;]function groupBy (objArr, property) &#123; return objArr.reduce((acc, obj) =&gt; &#123; // 键名 let key = obj[property] // 判断累加器中是否有重复的元素 if(!acc[key]) &#123; acc[key] = [] &#125; acc[key].push(obj) return acc &#125;, &#123;&#125;)&#125;let groupedByPeople = groupBy(people, 'age')console.log(groupedByPeople) 使用扩展运算符和initialValue绑定包含在对象数组中的数组简单点说就是取出数组集合中对象中的数组 let friends = [&#123; name: 'Anna', books: ['Bible', 'Harry Potter'], age: 21&#125;, &#123; name: 'Bob', books: ['War and peace', 'Romeo and Juliet'], age: 26&#125;, &#123; name: 'Alice', books: ['The Lord of the Rings', 'The Shining'], age: 18&#125;]// 列出所有包含的书籍// 题目不容易理解，好好一想，就容易的多，还得对扩展符了解的比较多点就更容易上手let containerBook = friends.reduce((prev, curr) =&gt; &#123; return [...prev, ...curr.books]&#125;, [])console.log(containerBook) 然后，鸽了鸽了。先写到这里吧。时间又不够了。 参考[1]. Array.prototype.reduce()–end–]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二十四天2019-01-24]]></title>
    <url>%2F2019%2F01%2F24%2F2019-01-24%2F</url>
    <content type="text"><![CDATA[碎碎念今天一天写代码有点不在状态，可能是最近有点不太对，不是疲累也可能是心事又多了起来。原本计划今天继续上文或者上上文的。现在看来真的只能是搁了。最近图片可能会风格比较和以前不一样。这是问人要的哈。嘿嘿。 –end–]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二十三天2019-01-23]]></title>
    <url>%2F2019%2F01%2F23%2F2019-01-23%2F</url>
    <content type="text"><![CDATA[js 常用数组方法小结碎碎念今天这个数组对象操作写的有点多啊，特此来小结一下，一些常用的方法的基本操作。 Array.prototype.filter()表格过滤用的比较多大概用法就是过滤数组或者数组集合中一些不符合条件的数组元素和集合。也可以用来过滤数组中一些undefined和null。例子：[1]const fruits = [&apos;apple&apos;, &apos;banana&apos;, &apos;grapes&apos;, &apos;mango&apos;, &apos;orange&apos;];/** * Array filters items based on search criteria (query) */const filterItems = (query) =&gt; &#123; return fruits.filter((el) =&gt; // 过滤的条件 el.toLowerCase().indexOf(query.toLowerCase()) &gt; -1 );&#125;// 根据条件过滤之后的数组console.log(filterItems(&apos;ap&apos;)); // [&apos;apple&apos;, &apos;grapes&apos;]console.log(filterItems(&apos;an&apos;)); // [&apos;banana&apos;, &apos;mango&apos;, &apos;orange&apos;] 过滤数组中空值let newArray = oldArray.filter(s =&gt; s.value != null) filter() 的实现 利用for循环以及push构造数组[1]// Polyfill Array.prototype.filter()function newFilter() &#123; if (!Array.prototype.newFilter) &#123; // 可以带thisArg Array.prototype.newFilter = (fun /* , thisArg*/) =&gt; &#123; // void(0)（等同于void 0） 差不多等于 undefined if (this === void 0 || this === null) &#123; throw new TypeError() &#125; // Object构造函数为给定值创建一个对象包装器 let t = Object(this) // 所有非数值转换成0, 所有大于等于 0 等数取整数部分 // Shifts a in binary representation b (&lt; 32) bits to the right, discarding bits shifted off, and shifting in 0s from the left. let len = t.length &gt;&gt;&gt; 0 if (typeof fun !== &apos;function&apos;) &#123; throw new TypeError() &#125; let res = [] // arguments对象不是一个 Array 。它类似于Array，但除了length属性和索引元素之外没有任何Array属性 // 没有 pop 方法。但是它可以被转换为一个真正的Array：args = Array.from(arguments) // 所以这个地方用arguments可能有错？ let thisArg = arguments.length &gt;= 2 ? arguments[1] : void 0 // t = Object(this) for (let i = 0; i&lt; len; i++) &#123; // prop in object, 检查object（或其原型链）是否包含具有指定名称的属性的对象 if (i in t) &#123; let val = t[i] // NOTE: Technically this should Object.defineProperty at // the next index, as push can be affected by // properties on Object.prototype and Array.prototype. // But that method&apos;s new, and collisions should be // rare, so use the more-compatible alternative. // 满足filter中的条件的话就push进数组res,filter回调函数的三个参数：元素值，元素索引，原数组 // thisArg: 当前在数组中处理的元素 // val: 正在处理元素在数组中的索引 if (fun.call(thisArg, val, i, t)) res.push(val) &#125; &#125; &#125; &#125;&#125; Array.prototype.reduce()鸽到下期再讲吧，好像我已经鸽了很多东西了。额。–end–]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二十二天2019-01-22]]></title>
    <url>%2F2019%2F01%2F22%2F2019-01-22%2F</url>
    <content type="text"><![CDATA[组件通信-祖孙本文将结合例子，简单讲解下vuejs文档中的实例属性：vm.$attrs和vm.$listeners。 碎碎念因为项目中大多用Vuex来通信，但是用多了之后感觉简单的组件之间的通信再用构造vuex的mutation，写起来比较费，当然父子之间的通信肯定是用emit更实在。 写个“栗子” 三个组件：grandfather &gt; father &gt; son祖宗组件Vue.component(&apos;grandfather&apos;, &#123;props: [],template: `&lt;div&gt; &lt;father :getGrandsonData=&quot;grandfatherData&quot; // 传值 @getGrandsonEvent=&quot;grandfatherEvent&quot; // 事件 &gt;&lt;/father&gt; &lt;/div&gt; `data: function () &#123; return &#123; grandfatherData: &quot;hello, i&apos;m your grandfather&quot; &#125; &#125;,methods: &#123; grandfatherEvent (val) &#123; // 这里接到了“hello, i&apos;m your grandson” console.log(val) // hello, i&apos;m your grandson &#125;&#125;&#125;) 父亲组件Vue.component(&apos;father&apos;, &#123;props: [], // 注意这里props不需要再父组件声明template:\`&lt;div&gt; &lt;grandson v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot; &gt;&lt;/grandson&gt; \`&lt;/div&gt;&#125;) 孙子组件Vue.component(&apos;grandson&apos;, &#123;props: [],template:` &lt;input type=&quot;text&quot; v-model=&quot;grandsonMsgToGrandfather&quot; @input=&quot;sendToGrandfatherEvent&quot; &gt;&#123;&#123;$attrs.grandfatherData&#125;&#125;&lt;/div&gt; `data: function () &#123; return &#123; grandsonMsgToGrandfather: &quot;hello, i&apos;m your grandson&quot; &#125;&#125;,method: &#123; sendToGrandfatherEvent () &#123; this.$emit(&apos;getGrandsonEvent&apos;, sonMsgToGrandfather ) &#125;&#125;&#125;) 注意：这里的代码并没有验证过,只是大概写个简单的demo 上文档vm.$attrs vm.$attrs类型：{ [key: string]: string }只读详细：包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件——在创建高级别的组件时非常有用。 vm.$listeners vm.$listeners类型：{ [key: string]: Function | Array&lt;Function&gt; }只读详细：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件——在创建更高层次的组件时非常有用。 参考[1]. https://cn.vuejs.org/v2/api/#vm-attrs 、https://cn.vuejs.org/v2/api/#vm-listeners[2]. vue的通信方式（二）—祖父孙三个级别的之间的隔代通信 —end—]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二十一天2019-01-21]]></title>
    <url>%2F2019%2F01%2F21%2F2019-01-21%2F</url>
    <content type="text"><![CDATA[碎碎念今天又重温了一小下（事件循环）Event Loop，如何去区分MicroTask（微任务）,MacroTask（宏任务），说实话我还没有非常精确的去理解到位，做顺序题目，也会做错，理解的不充分不到位。去看了下MDN1,发现并没有解释的很详细，除了解释Nodejs中和浏览器中的EventLoop有点不同，其他简短的语言倒像是解释setTimeout()是“非等待一定时间之后执行”这一概念。 Event Loop - 上下面来稍微再温习下这个东西。承上启下，为Promise()的深入理解做更好的准备。 背景JavaScript这种并发模型基于“事件循环” ，是单线程的，不像是C语言任何位置被终止，它是异步而不阻塞主进程执行。Event Loop起到很重要的作用， JavaScript处理 I/O 通常通过事件和回调来执行。本文简单的入门一下Event Loop这个东西，大概有个映像就行。 任务js引擎的两种任务 MacroTask: setTimeout, setInterval, setImmediate,I/O, UI rendering MicroTask: Promise, process.nextTick, Object.observe, MutationObserver, MutaionObserver调度机制不同的任务行为并不一样，执行的先后顺序不一样。具体怎么个不一样，这里拿个例子2。setTimeout(function() &#123; console.log(4);&#125;, 0);var promise = new Promise(function executor(resolve) &#123; console.log(1); for (var i = 0; i &lt; 10000; i++) &#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(2);&#125;).then(function() &#123; console.log(5);&#125;);console.log(3); Nodejs输出： 1 2 3 5 4浏览器输出：1 2 3 5 undefined 4注：这里不讨论Nodejs和浏览器的异同 MicroTask 和 Macro Task的执行顺序 - 描述 Event Loop 开始 MicroTasks 队列开始执行至结束 检查MacroTask 队列是否有待执行，有则跳到4，无则跳到6 MacroTask队列“抽取”一个任务，执行至结束 检查MicroTasks 是否执行完毕，若有则跳到2，无则跳到3 结束Event Loop 以上整个过程就是Event Loop（事件循环）。 这里有个疑问，就是5为什么还要检查是否执行完毕，因为2已经检查过了，是什么事件遗留到了5？ MicroTask 和 Macro Task的执行顺序 - 图文一张图来解释下3（这张图是引用的，可能需要重画下，可能加上Event table会更好点）。 图怎么理解呢?宏任务作为入口的话，setTimeout不是第一个执行？是这么个解释的，拿调度机制中的代码说事。先把两种任务再放一遍。 MacroTask: setTimeout, setInterval, setImmediate,I/O, UI renderingMicroTask: Promise, process.nextTick, Object.observe, MutationObserver, MutaionObserver 整段代码作为宏任务进入主线程。 遇到setTimeout(), 回调函数注册后分发到宏任务Event Queue。// 回调函数注册？ 接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。// 立即执行？ 遇到console.log()，立即执行。 整段代码作为一次宏任务执行结束，进入微任务判断。Event Queue里有then函数，执行。 第二轮循环，开始新的宏任务。从宏任务Event Queue中去检查。发现setTimeout回调函数，立即执行。 到这里如果还不懂的话，可以到参考资料的3去看看，写的比较详细，我这里只是笔记形式简单总结下。 Promise 和 process.nextTick() 的先后顺序？- 后续这里就放到下一篇Event Loop再说吧。– end – 参考[1]. 并发模型与事件循环[2]. 理解event loop（浏览器环境与nodejs环境）[3]. 这一次，彻底弄懂 JavaScript 执行机制]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二十天2019-01-20]]></title>
    <url>%2F2019%2F01%2F20%2F2019-01-20%2F</url>
    <content type="text"><![CDATA[碎碎念今天下午就光玩游戏了~感觉需要放空自己啊，这是个玩游戏的好借口。但确实，今天下午看了一会儿电影，上午下午中间节点看完了《楚门的世界》（《The Truman Show》)。 这个电影，在高中的时候就很受它影响，我指的影响，大概是你看完一部电影之后，很长时间都会去回味这部电影的味道，这部电影的含义。九九八十一难，最后的一个“释然”的态度？ 再然后看了《天气预报员》？这是部慢热的剧情，感觉还是没有看下去的劲头，挖个坑吧，改天再看。然后尝试看了部石原里美日剧，嗯，看了一部分就看不下去了。然后接着就游戏了。本来想LOL的，结果愣是没有劲头，开了一局游戏都退了，看来游戏真的是没什么好玩的。然后，玩CSGO，感觉还是比较考验临场发挥的，碰到敌我实力不相上下的时候，整个人的荷尔蒙就都上来了，感觉还是对于放空自己比较有效果的。一直玩到了，晚上8点啊。你可是也有一堆事情要做的啊，怎么玩起游戏来了。说不玩游戏的，真香。 –end–]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十九天2019-01-19]]></title>
    <url>%2F2019%2F01%2F19%2F2019-01-19%2F</url>
    <content type="text"><![CDATA[碎碎念今天碰到一个需求，就是在element-ui表格中，列表操作这一列有下载和删除按钮，需要点击某一行的下载按钮，该行下载按钮显示正在下载的loading状态。这个看了下，应该只能是通过在scope.row对象中加属性，比如：isDownloading。这个就要求新属性isDownloading，能够具有响应式特性。 深入响应式原理 追踪变化下面这张图，是基于Object.defineProperty 实现响应式的关键。 不巧的是，受现代 JavaScript 的限制 (而且 Object.observe 也已经被废弃)，Vue 不能检测到对象属性的添加或删除。[1] Vue 不允许在已经创建的实例上动态添加新的根级响应式属性 (root-level reactive property)。然而它可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上：[1] 添加响应式属性使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象 一个已有对象添加多个属性// 代替 Object.assign(this.someObject, { a: 1, b: 2 })this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 }) vuejs 提供的Api Vue.set( target, key, value )参数： {Object | Array} target{string | number} key{any} value返回值： 设置的值。用法： 向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，因为 Vue 无法探测普通的新增属性 (比如 this.myObject.newProperty = ‘hi’)注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象。 注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象。 实践实践了一下，响应式的对象。在拉取list的forEach里新增一个响应式属性，this.$set(this.list, &#39;isDownloading&#39;, false)。然后就可以在操作前置true,操作后false。在列表的地方就可以用响应式的isDownloading属性了！ 参考[1]. https://cn.vuejs.org/v2/guide/reactivity.html#%E5%A6%82%E4%BD%95%E8%BF%BD%E8%B8%AA%E5%8F%98%E5%8C%96[2]. https://cn.vuejs.org/v2/api/#Vue-set——————————————————-end———————————————————–]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十八天2019-01-18]]></title>
    <url>%2F2019%2F01%2F18%2F2019-01-18%2F</url>
    <content type="text"><![CDATA[碎碎念今天写了一上午的技术，写后台管理，感觉时间过得好快啊。因为最近可能有需要部署一些应用在服务器上，所以最近又开始捡起Docker这个东西。今晚上复习了一下。具体的一些基本操作如下。 docker-ubuntu 准备Docker 要求 Ubuntu 系统的内核版本高于 3.10 uname -r 查看内核版本 安装 wget -qO- https://get.docker.com/ | sh 测试安装 docker run hello-world‘hello-world’ 是一个镜像，没有的话会默认pull 容器操作 docker ps -a // 列出所有创建的container docker ps -aq // 列出所有创建的container 的ID docker ps // 列出正在运行的容器container docker system df // 查看镜像、容器、数据卷所占用的空间 docker top // 查看容器的进程 docker stop // 停止容器（名字要全） docker rm // 删除指定名容器 镜像操作 docker image ls // 列出已经下载下来的镜像 docker images // 列出所有所有镜像 docker rmi &lt; image ID&gt; // (注：ID列出前几位就行了) 拉取ubuntu docker pull ubuntu:16.04 镜像操作 docker run -t -i ubuntu:16.04 /bin/bash // 运行容器 docker tag :&lt;新标签&gt; // ID只需要前几位就行 docker port // 查看端口的绑定 构建镜像 cat Dockerfile 参考[1]. http://www.runoob.com/docker/docker-container-usage.html[2]. https://yeasy.gitbooks.io/docker_practice/container/stop.html————————————————————————end———————————————————————-]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十七天2019-01-17]]></title>
    <url>%2F2019%2F01%2F17%2F2019-01-17%2F</url>
    <content type="text"><![CDATA[碎碎念今天眼睛好困啊好困啊！最近可能脑子里事情太多了！还是早点睡的好！乱七八糟的事情先放一边。今天看了Readability，准备用这个来做一些翻译相关的东西。感觉很厉害啊，这个东西。总之先粗略的console.log(),至于以后的什么并发什么的，这个等流量上去了之后再说，先把东西一个个做出来吧。总觉得Nodejs做的应该不会太差。明天记得预约体检！！ 就这样，又水了一天。早点睡吧。晚安。–end]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十六天2019-01-16]]></title>
    <url>%2F2019%2F01%2F16%2F2019-01-16%2F</url>
    <content type="text"><![CDATA[碎碎念恍恍惚惚，已经坚持写博客16天了，这是个“不小的成就”啊。回想过的这些天的博客，发现深度不够，停留在表面。博客写到表层的东西，肤浅的东西就浅尝辄止。这是个很大的问题。也是这些天博客记录下来之后发现的问题点。接下来就是对过去的整个东西进行一些梳理。自从博客开始记录生活以来。总共写了下面这几个事情： Object.assign（）// 上下已经完 new 操作符 // 简单地对原型和继承关系进行了复习 Vue源码解析 // 对于整个Vue源码的入口有了清晰的认识，意思就是，读源码开始上路 接下去 接下去可能还想开坑Vuex，这个坑，可能是因为在一些写法上，总觉得不够优雅，可能需要读一些开源的项目是怎么做的。可以的话，从很早就有的饿了么APP这个开始读一下，看他是怎么设计软件的。也可能继续开坑Loadshjs，研究如何实现deep clone或者是研究Promise,以及Even Loop其次，一直以来很重要的事，就是网络基础知识，比如HTTP里面的RTT这种知识，都必须熟练掌握。另外就是一直放了很久的Nodejs项目，改学会怎么写出好接口了。所以，这个地方也得去读Nodejs怎么学。再深入一点，可能需要读一些开源的项目了。这些在github上面关注的时候，有star，所以，这个不用太心急。偶尔逛逛github就出来了。这些都是很久的坑，暂时还不打算开。但是对于阅读源码是很有帮助的。毕竟是基础嘛。但是先开哪个坑，这个是有必要先想想，因为当务之急手下也还有一些bug没有解决。长久看，这种基础东西都是必须要懂的，不懂不行啊。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十五天2019-01-15]]></title>
    <url>%2F2019%2F01%2F15%2F2019-01-15%2F</url>
    <content type="text"><![CDATA[碎碎念 国际化今天对国际化进行了总结，作为第二个发表的人，我发现讲话水平有提高哦，讲的也有层次感了，思路也还算清晰。话说到国际化，确实啊，这个国际化怎么去做，怎么提取需要翻译的全部文本转为变量呢，这个前期工作很繁琐，实际翻译效率并不高。 手机端适配最近在做手机端适配，要写两套样式。发现还是蛮繁琐的，不过还好，如果原来的页面是自适应的话，那么样式就会简单很多。 关于最近一些技术上新的路子今早发现其实看Node.js一些源码解析片段可能会很快的就深入到js当中，比如Promise涉及到的SetTimeout()引出来的Even Loop等一些概念。其实可能没有想象中那么深奥，可能是不小心复杂化了。–end]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十四天2019-01-14]]></title>
    <url>%2F2019%2F01%2F14%2F2019-01-14%2F</url>
    <content type="text"><![CDATA[碎碎念今天写了一天的适配移动端样式，发现还好，并不是原来想象中的那么难。早上公交上，也看了Vue的源码分析，渐入佳境吧，慢慢的也看的越来越没有障碍了。 Vue源码-笔记Vue 构造函数function Vue (options) &#123; if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !(this instanceof Vue)) &#123; warn(&apos;Vue is a constructor and should be called with the `new` keyword&apos;) &#125; this._init(options)&#125; _init 方法 Vue.prototype._init = function (options?: Object) &#123; const vm: Component = this // a uid vm._uid = uid++ // a flag to avoid this being observed vm._isVue = true // merge options if (options &amp;&amp; options._isComponent) &#123; // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options) &#125; else &#123;// 走这一步分析 vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ) &#125; /* istanbul ignore else */ if (process.env.NODE_ENV !== &apos;production&apos;) &#123; initProxy(vm) &#125; else &#123; vm._renderProxy = vm &#125; // expose real self vm._self = vm initLifecycle(vm) initEvents(vm) callHook(vm, &apos;beforeCreate&apos;) initState(vm) callHook(vm, &apos;created&apos;) initRender(vm) &#125; Vue第一步 使用策略对象合并参数选项export function resolveConstructorOptions (Ctor: Class&lt;Component&gt;) &#123; let options = Ctor.options if (Ctor.super) &#123; const superOptions = Ctor.super.options const cachedSuperOptions = Ctor.superOptions const extendOptions = Ctor.extendOptions if (superOptions !== cachedSuperOptions) &#123; // super option changed Ctor.superOptions = superOptions extendOptions.render = options.render extendOptions.staticRenderFns = options.staticRenderFns extendOptions._scopeId = options._scopeId options = Ctor.options = mergeOptions(superOptions, extendOptions) if (options.name) &#123; options.components[options.name] = Ctor &#125; &#125; &#125; return options&#125; Vue.super 用来处理继承 mergeOptions// 1、引用依赖import Vue from &apos;../instance/index&apos;其他引用...// 2、合并父子选项值为最终值的策略对象，此时 strats 是一个空对象，因为 config.optionMergeStrategies = Object.create(null)const strats = config.optionMergeStrategies// 3、在 strats 对象上定义与参数选项名称相同的方法strats.el = strats.propsData = function (parent, child, vm, key)&#123;&#125;strats.data = function (parentVal, childVal, vm)config._lifecycleHooks.forEach(hook =&gt; &#123; strats[hook] = mergeHook&#125;)config._assetTypes.forEach(function (type) &#123; strats[type + &apos;s&apos;] = mergeAssets&#125;)strats.watch = function (parentVal, childVal)strats.props =strats.methods =strats.computed = function (parentVal: ?Object, childVal: ?Object)// 默认的合并策略，如果有 `childVal` 则返回 `childVal` 没有则返回 `parentVal`const defaultStrat = function (parentVal: any, childVal: any): any &#123; return childVal === undefined ? parentVal : childVal&#125;// 4、mergeOptions 中根据参数选项调用同名的策略方法进行合并处理export function mergeOptions ( parent: Object, child: Object, vm?: Component): Object &#123; // 其他代码 ... const options = &#123;&#125; let key for (key in parent) &#123; mergeField(key) &#125; for (key in child) &#123; if (!hasOwn(parent, key)) &#123; mergeField(key) &#125; &#125; function mergeField (key) &#123; const strat = strats[key] || defaultStrat options[key] = strat(parent[key], child[key], vm, key) &#125; return options&#125; 内容比较丰富，信息量有点大，慢慢来吧，暂时先到这，下次得加快进度看。–end]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十三天2019-01-13]]></title>
    <url>%2F2019%2F01%2F13%2F2019-01-13%2F</url>
    <content type="text"><![CDATA[碎碎念今天一天上午做饭，下午看电影，一天吧~做了个肉炒腐竹，看电影《雨果》、《美丽心灵》。 不得不说，电影《雨果》中的场景构建的是非常的漂亮，不知道是色彩的原因还是其他，其中包含了很多的机械，一些机械钟类转轴，非常的精美，整个故事的价值观，取向，也非常的完美！不可多得的好电影啊。看完这部电影，才知道什么叫做法国式的浪漫，看来法国式的浪漫不只是与常见的爱情，还在于法国的电影中所体现出的人物的绅士。 接下来的一部电影就是《美丽心灵》，这部电影183分钟，真的是看的人惊心动魄，不是各种悬疑故事，也不是各种打斗场面，而是来自内心的那种波澜起伏，主人公战胜精神病的坚强的意志，更赞的是电影标题所突出的人的心灵美。也是被片中的主人公的爱情喂饱了狗粮，甚至完全可以当做爱情片来看，“You are reason, you are all my reason”。但我更认为这部电影带给人的力量不仅限于此。不多说了，这电影一定推荐大家看。 –end]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十二天2019-01-12]]></title>
    <url>%2F2019%2F01%2F12%2F2019-01-12%2F</url>
    <content type="text"><![CDATA[今天一天还算是过的比较快，看了两三部电影，感觉还好，虽然都是些老电影。早上起来也做饭了，时间刚到中午就做好了，时间点掐的很完美嘛。就是今天没有看书这点，不是很好。睡觉之前还是看看书吧。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十一天2019-01-11]]></title>
    <url>%2F2019%2F01%2F11%2F2019-01-11%2F</url>
    <content type="text"><![CDATA[呦呦呦，上线了一个功能！所以今天回来的可能有点晚啊！今天临上线前又更新了一点需求，这个更新需求这个事情，对于有些场景来说，真的是不可避免啊，但是这个问题本身可能是在敲定最终需求的时候，需求不明确所导致的，但是整个过程怎么去优化，还是个很大的问题。所以，我觉得最后优化的空间还会很大的。好吧，好像说了很多的空话，但实际上是有点想吐槽下自己代码效率的，对于更新速度快的需求不能够很好的对代码进行解耦和快速的组装，这个说明在设计代码的时候还是很有必要加强训练！ – end]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十天2019-01-10]]></title>
    <url>%2F2019%2F01%2F10%2F2019-01-10%2F</url>
    <content type="text"><![CDATA[碎碎念最近都没有不同的图片可以贴了，还需要找点图片啊。今天早上看了下怎么实现new操作符，感觉又回到了，原型和原型链的理解，“new”一个函数的时候，到底发生了什么？兜兜转转看来还是这个理解的不到位。说起理解不到位，让我想起了，今天写业务代码的时候，写到Vue渲染先后顺序这个地方，愣是卡了很久。看来这是对于整个的Vue运行机制还掌握的不够。 笔记-new操作符-上“new” 发生了什么先来看看MDN上是怎么解释的？2 语法new constructor[([arguments])] // constructor：指定对象实例的类型的类或函数 描述 当代码 new Foo(…) 执行时，会发生以下事情： 一个继承自 Foo.prototype 的新对象被创建。 使用指定的参数调用构造函数 Foo ，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。 由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤） 网友总结的[1] 创建了一个全新的对象。 这个对象会被执行[[Prototype]]（也就是proto）链接。 生成的新对象会绑定到函数调用的this。 通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。 如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用会自动返回这个新的对象。 这个是总结出来的，总觉得有点不科学啊。但目前好像是最好的办法，通过new的功能反推new的实现。 补充使用 Function.prototype 属性将共享属性添加到以前定义的对象类型function Car() &#123;&#125;car1 = new Car()Car.prototype.color = nullconsole.log(car1.color) // null 怎么实现new/** * 模拟实现 new 操作符 * @param &#123;Function&#125; ctor [构造函数] * @return &#123;Object|Function|Regex|Date|Error&#125; [返回结果] */function newOperator(ctor)&#123; if(typeof ctor !== &apos;function&apos;)&#123; throw &apos;newOperator function the first param must be a function&apos;; &#125; // ES6 new.target 是指向构造函数 // new.target 后面会补充下 newOperator.target = ctor; // 1.创建一个全新的对象， // 2.并且执行[[Prototype]]链接 // 4.通过`new`创建的每个对象将最终被`[[Prototype]]`链接到这个函数的`prototype`对象上。 var newObj = Object.create(ctor.prototype); // ES5 arguments转成数组 当然也可以用ES6 [...arguments], Aarry.from(arguments); // 除去ctor构造函数的其余参数 var argsArr = [].slice.call(arguments, 1); // 3.生成的新对象会绑定到函数调用的`this`。 // 获取到ctor函数返回结果 var ctorReturnResult = ctor.apply(newObj, argsArr); // 小结4 中这些类型中合并起来只有Object和Function两种类型 typeof null 也是&apos;object&apos;所以要不等于null，排除null var isObject = typeof ctorReturnResult === &apos;object&apos; &amp;&amp; ctorReturnResult !== null; var isFunction = typeof ctorReturnResult === &apos;function&apos;; if(isObject || isFunction)&#123; return ctorReturnResult; &#125; // 5.如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)，那么`new`表达式中的函数调用会自动返回这个新的对象。 return newObj;&#125; 这个实现，除去一些排除异常的条件，我理解的就几步，把对象复制过去，然后参数绑定过去，排除边界条件，整个咋一看并不是很难，但是很考验对整个操作符的掌握和熟悉程度。 new.target在构造方法调用中，new.target指向被new调用的构造函数，所以”new.”成为了一个虚拟上下文[2] 普通函数中 new.target的值是undefined,可以检测一个函数是否是作为构造函数通过new被调用的。function Foo() &#123; if (!new.target) throw &quot;Foo() must be called with new&quot;; console.log(&quot;Foo instantiated with new&quot;);&#125;Foo(); // throws &quot;Foo() must be called with new&quot;new Foo(); // logs &quot;Foo instantiated with new&quot;， 检测到由new调用 构造函数中稍微复杂点，这里暂时不讨论可以到MDN去看。今天暂时讨论到这啊！明天还得上线呢！有点晚，早点睡觉吧。--end 参考：[1]. 面试官问：能否模拟实现JS的new操作符[2]. new运算符]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第九天2019-01-09]]></title>
    <url>%2F2019%2F01%2F09%2F2019-01-09%2F</url>
    <content type="text"><![CDATA[这几天很忙啊！！早上都去的很晚！早点睡觉早点睡觉！ –end]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八天2019-01-08]]></title>
    <url>%2F2019%2F01%2F08%2F2019-01-08%2F</url>
    <content type="text"><![CDATA[碎碎念今天入职以来第一次迟到，作啊，8点43分有车，然后悠哉一会儿，52有车，悠哉穿个衣服，然后就9.20的车了。可能还有可能到公司，但是，出了隧道之后，公交每个红绿灯都停了，没有例外的巧合啊！期间还火车过道，这运气没谁了！最后10点10分才到公司。辛亏一个月可以迟到两次。 笔记-Object.assign()-下继承属性和不可枚举属性是不能拷贝的 原生情况下挂载在 Object 上的属性是不可枚举的，但是直接在 Object 上挂载属性 a 之后是可枚举的，所以这里必须使用 Object.defineProperty，并设置 enumerable: false 以及 writable: true, configurable: true。3 var obj = Object.create(&#123;foo: 1&#125;, &#123; // foo 是个继承属性。 bar: &#123; value: 2 // bar 是个不可枚举属性。 &#125;, baz: &#123; value: 3, enumerable: true // baz 是个自身可枚举属性。 &#125;&#125;);var copy = Object.assign(&#123;&#125;, obj);console.log(copy); // &#123; baz: 3 &#125; 检查是否可以枚举 查看Object.assign 是否可枚举，使用 Object.getOwnPropertyDescriptor 或者 Object.propertyIsEnumerable（会检查给定的属性名是否直接存在于对象中,而不是在原型链上,并且满足 enumerable: true）。 // 方法一：查看Object.assign()是否可以枚举Object.getOwnPropertyDescriptor(Object, &quot;assign&quot;);// 方法二Object.propertyIsEnumerable(&quot;assign&quot;); // false // 实现 Object.assign时要用Object.defineProperty(Object, &apos;assign&apos;,&#123;... writable: true, enumerable: false, configurable: true&#125;) 原始类型会被包装为对象有时候可以利用这一点包装为对象var v1 = &quot;abc&quot;;var v2 = true;var v3 = 10;var v4 = Symbol(&quot;foo&quot;)var obj = Object.assign(&#123;&#125;, v1, null, v2, undefined, v3, v4); // 原始类型会被包装，null 和 undefined 会被忽略。// 注意，只有字符串的包装对象才可能有自身可枚举属性。console.log(obj); // &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125; 异常会打断后续拷贝任务 在出现错误的情况下，例如，如果属性不可写，会引发TypeError，如果在引发错误之前添加了任何属性，则可以更改target对象2。 // 定义不能写var target = Object.defineProperty(&#123;&#125;, &quot;foo&quot;, &#123; value: 1, writable: false&#125;); // target 的 foo 属性是个只读属性。Object.assign(target, &#123;bar: 2&#125;, &#123;foo2: 3, foo: 3, foo3: 3&#125;, &#123;baz: 4&#125;);// TypeError: &quot;foo&quot; is read-only// 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。console.log(target.bar); // 2，说明第一个源对象拷贝成功了。console.log(target.foo2); // 3，说明第二个源对象的第一个属性也拷贝成功了。console.log(target.foo); // 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。这里异常console.log(target.foo3); // undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。console.log(target.baz); // undefined，第三个源对象更是不会被拷贝到的。 拷贝访问器var obj = &#123; foo: 1, // get 访问器 get bar() &#123; return 2; &#125;&#125;;var copy = Object.assign(&#123;&#125;, obj); console.log(copy); // &#123; foo: 1, bar: 2 &#125;// copy.bar的值来自obj.bar的getter函数的返回值 拷贝所有自有属性的属性描述符（难点）var obj = &#123; foo: 1, get bar() &#123; return 2; &#125;&#125;;function completeAssign(target, ...sources) &#123; sources.forEach(source =&gt; &#123; // reduce 可能是不太好理解，下期可能需要出一个笔记 let descriptors = Object.keys(source).reduce((descriptors, key) =&gt; &#123; // 获取属性描述符（可以分为数据描述符和存取描述符均，属性的信息可以查看：Object.defineProperty） descriptors[key] = Object.getOwnPropertyDescriptor(source, key); return descriptors; &#125;, &#123;&#125;); // Object.assign 默认也会拷贝可枚举的Symbols // Object.getOwnPropertySymbols() 方法返回一个给定对象自身的所有 Symbol 属性的数组。 Object.getOwnPropertySymbols(source).forEach(sym =&gt; &#123; let descriptor = Object.getOwnPropertyDescriptor(source, sym); if (descriptor.enumerable) &#123; descriptors[sym] = descriptor; &#125; &#125;); Object.defineProperties(target, descriptors); &#125;); return target;&#125;var copy = completeAssign(&#123;&#125;, obj);console.log(copy);// &#123; foo:1, get bar() &#123; return 2 &#125; &#125; MDN实现Obeject.assign()if (typeof Object.assign != &apos;function&apos;) &#123; // Must be writable: true, enumerable: false, configurable: true Object.defineProperty(Object, &quot;assign&quot;, &#123; value: function assign(target, varArgs) &#123; // .length of function is 2 &apos;use strict&apos;; if (target == null) &#123; // TypeError if undefined or null throw new TypeError(&apos;Cannot convert undefined or null to object&apos;); &#125; var to = Object(target); for (var index = 1; index &lt; arguments.length; index++) &#123; var nextSource = arguments[index]; if (nextSource != null) &#123; // Skip over if undefined or null for (var nextKey in nextSource) &#123; // Avoid bugs when hasOwnProperty is shadowed // 直接使用 myObject.hasOwnProperty(..) 是有问题的，因为有的对象可能没有连接到 Object.prototype 上所以这里用上call() if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) &#123; to[nextKey] = nextSource[nextKey]; &#125; &#125; &#125; &#125; return to; &#125;, writable: true, configurable: true &#125;);&#125; 今天就先很粗糙地写一下，明天再详细的谈一些细节部分吧。– end 参考[1]. Object.assign()–MDN[2]. JavaScript 中的对象拷贝[3]. 【进阶4-2期】Object.assign 原理及其实现]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第七天2019-01-07]]></title>
    <url>%2F2019%2F01%2F07%2F2019-01-07%2F</url>
    <content type="text"><![CDATA[碎碎念最近发现写代码的速度有提升，这说明写业务代码基础都差不多了，接下来就应该深究其内容了，该向代码底层的一些原理进行深入探究了，当然还是得夯实基础。之前看过一点Lodashjs的基础，但是有些关联性太强，没办法一下子联系起来，得慢慢的来看内容。今早上看了js中一个Object.assign()中的一些原理，发现其实并没有想象的那么难，但是手写起来可是非常考验功底，需要真正理解才能去写出浅拷贝的Objecr.assign()。下面来浅谈下。 笔记-Object.assign()–上 描述 如果目标对象中的属性具有相同的键，则属性将被源中的属性覆盖。后来的源的属性将类似地覆盖早先的属性。这里应该讲的是的**陷阱**。#### 拷贝问题```javascript?linenums// 1. 浅拷贝let obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;; // 源对象let obj2 = Object.assign(&#123;&#125;, obj1); // 目标对象console.log(JSON.stringify(obj2)); // &#123; a: 0, b: &#123; c: 0&#125;&#125;// 2. 改变源对象的属性值，拷贝的值并不会改变obj1.a = 1;console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125; ，console.log(JSON.stringify(obj2)); // &#123; a: 0, b: &#123; c: 0&#125;&#125;// 3. 修改目标对象的属性obj2.a = 2;console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125;console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 0&#125;&#125;// 4. 改变了目标对象的值，因为复制了对源对象的引用，对目标对象属性的修改也能改源对象，如何解决这种问题？obj2.b.c = 3;console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 3&#125;&#125;console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 3&#125;&#125;// 5. 常用的深拷贝JSON.parse(JSON.stringify()),这个方法也有缺点obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;;let obj3 = JSON.parse(JSON.stringify(obj1));obj1.a = 4;obj1.b.c = 4;console.log(JSON.stringify(obj3)); // &#123; a: 0, b: &#123; c: 0&#125;&#125; 合并对象（常用） 以下代码引自MDN var o1 = &#123; a: 1 &#125;;var o2 = &#123; b: 2 &#125;;var o3 = &#123; c: 3 &#125;;var obj = Object.assign(o1, o2, o3);console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;console.log(o1); // &#123; a: 1, b: 2, c: 3 &#125; 注意目标对象自身也会改变。 合并具有相同属性的对象 以下代码引自MDN var o1 = &#123; a: 1, b: 1, c: 1 &#125;;var o2 = &#123; b: 2, c: 2 &#125;;var o3 = &#123; c: 3 &#125;;var obj = Object.assign(&#123;&#125;, o1, o2, o3);console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125; 注意后续参数覆盖问题 拷贝 symbol 类型的属性 描述 Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。String类型和 Symbol 类型的属性都会被拷贝。 以下代码引自MDN var o1 = &#123; a: 1 &#125;;var o2 = &#123; [Symbol(&apos;foo&apos;)]: 2 &#125;;var obj = Object.assign(&#123;&#125;, o1, o2);console.log(obj); // &#123; a : 1, [Symbol(&quot;foo&quot;)]: 2 &#125; (cf. bug 1207182 on Firefox)Object.getOwnPropertySymbols(obj); // [Symbol(foo)] 先探究到这里吧针对深拷贝，需要使用其他方法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。常用的可能是JSON.parse(JSON.stringify()),这个方法也有缺点。 知识扩展-简单对比 Object.assign() JSON.parse(JSON.stringify()) 2，不适合复制循环引用对象,不适合复制对象方法 参考[1]. Object.assign()–MDN[2]. JavaScript 中的对象拷贝–end]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第六天2019-01-06]]></title>
    <url>%2F2019%2F01%2F06%2F2019-01-06%2F</url>
    <content type="text"><![CDATA[讲讲生活哈今天一天，早上起来之后就买了，汤骨和一些作料来做饭吃，真是很便宜，比在外面吃不知道要好多少啊。下面谈谈观影感受。 然后就开始在B站看电影，毕竟也是买了年度大会员的哈，总要找点专门属于会员的来看哈，因为最近上映的大黄蜂电影，于是就挑这个前传看，就在刚才结束的变形金刚前三部的观看，据说第四部和第五部分与原创相差太大。嗯，于是就不继续看下去吧。但是变形金刚的前三部是真的很帅！看完第一步，你完全想象不到这居然是零几年拍摄的电影CG效果简直不能再好。连看了三部之后真是觉得很热血啊。里面的人物价值观也设置的很合理，为了不同的追求，永远没有对和错，只有对事情角度的不同，影响。 这个周日也就一下子过去了。当然，上午还看了一大半的绣春刀，这部电影镜头什么的真的没话说，就是看到卢大哥被赏百户的时候，看不下去了，觉得，这是沈大人做的孽啊，为什么要为了一己私欲放走了魏忠贤，你觉得他会放过一个知道秘密的人？有时候真的是所有的错误，全在一瞬间决定。当我们遇到这种情况的时候，切记，一定要保持理智啊！因为摧毁你的不太可能是一个很明显的错误，是你最脆弱的时候犯的错误。今天谈感受就谈到这里吧！–end]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五2019-01-05]]></title>
    <url>%2F2019%2F01%2F05%2F2019-01-05%2F</url>
    <content type="text"><![CDATA[碎碎念今天加班啊！真是一件不太舒服的事情，加班都是为了一件事，让我一个人上线负责主要的内容。有点累。早上起得有点晚，出门下着小雨，在公交上都没法看点知识类的东西。晃晃悠悠到公司。结果发现我和产品来的最早啊。坑爹啊。不过，加班中午大家一起出去饭馆吃，老板请客这点倒是蛮不错，今天的才也都蛮合胃口！就是鼻子有鼻炎，总感觉人多的时候不太好，鼻子有失体面，下次一定把鼻子这事搞定吧。坚持用就行。下午顺利上线，真是ok。—end]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第四天 2019-01-04]]></title>
    <url>%2F2019%2F01%2F04%2F2019-01-04%2F</url>
    <content type="text"><![CDATA[一天以为项目会今天上线，结果，一天提了50-60个样式问题。虽然问题都很简单，但是真的是找的要命啊！下面讲讲今天这些问题的来源，讲八卦。 放图看到这奖状没？够专业了吧？ 你以为就只有奖状？！错，还有实在的礼品！第三名和第二名！如图： 真是非常辛苦产品小姐姐了！然而，我下班还当着产品的面，抱怨加需求。也是非常可以的了。第一名有两位！奖励手机壳！本来想聊一聊今天看的一篇，如何优化代码的文章！明天还要早起，算了吧。聊点八卦。–end]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三天2019-01-03]]></title>
    <url>%2F2019%2F01%2F03%2F2019-01-03%2F</url>
    <content type="text"><![CDATA[忙碌的一天啊！国际化终于要上线了。总是改文案改样式，我都快改死了。这个译文的调整真不是改的。细化到空格，逗号，括号。今天眼睛又是眯着回来的。不知道怎么了，是眼睛困了，会进行自我保护?所以眼睛会眯着？今天又看了原型和原型链的一片文章，发现真是永远也讲不完，```prototype```, 这种&quot;面向关联&quot;的模式真的是比较奇怪但是有中用。**列一下几个重要的等式吧。**&lt;!--more--&gt;```javascript// 函数的构造器是FunctionObject.__proto__ === Function.prototype // true// 函数字面量的__proto__ 指向Function(function () &#123;&#125;).__proto__ === Function.prototype // true// 对象字面量(&#123;&#125;).__proto__ === Object.prototype // true// Object函数原型的__proto__指向 nullObject.prototype.__proto__ === null// Function 函数的__proto__ 指向自身prototypeFunction.__proto__ === Function.prototype // true// Function的prototype是一个对象，所以Function.prototype.__proto__指向Object.prototypeFunction.prototype.__proto__ === Object.prototype // true 放图！ 图说明 小结 对象有属性__proto__(又可以称为隐式原型),指向该对象的构造函数的原型对象 方法(Function)除了有属性__proto__,还有属性prototype指向该方法的原型对象（包含所有实例共享的属性和方法叫做原型对象），原型对象也有属性constructor指回原构造函数。 先有Object.prototype（原型链顶端），Function.prototype继承Object.prototype而产生，最后，Function和Object和其它构造函数继承Function.prototype而产生 结束今天就到这吧，这是个很好的开端！！ 参考[1] js中proto和prototype的区别和关系？[2] JavaScript原型与继承的秘密]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二天2019-01-02]]></title>
    <url>%2F2019%2F01%2F02%2F2019-01-02%2F</url>
    <content type="text"><![CDATA[谈一天感受今天早上起来，发现这几天真的好冷啊。真是降温到极点了。扫兴的是，居然还牙疼，都怪假期三天吃的太多了，这智齿问题又出来了，哪天找个机会真的把它给拔了！今天转了一篇微信文章，要集赞然后获取《经济学人》98年到18年的文章。真是幸运，前几天还念叨着，要想办法拿下经济学人的文章合集就好。真是运气啊，今天就有机会获得了。新年开始，运气都这么好的吗？今天把推荐码和红包都写好了，不容易啊，断断续续一个星期，中间还惨杂这user-server的URL修改，实际工作时间真的就是三四天。剩下的还有后台管理的一小部分。其中掺杂着一些YiCAT的国际化，国际化你可快点上线吧，天天各种细节，译文修改，真是琐碎的很。还特别占时间。完全是体力活，原谅我再一次吐槽这个译文的修改。从第一次拿到译文，到现在为止，我已经数不清，改了多少次译文了。真想写个接口。让他们自己去修改。省得自己天天改译文文案。吐槽就到这里吧。这些天不知道眼睛怎么了，总是表现出很困的感觉，一直不自觉眯着眼睛。可能是没有早睡的原因。真是佩服公司同事，每天熬夜到一两点，精神气还十足。– end]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新年第一天-2019-01-01]]></title>
    <url>%2F2019%2F01%2F01%2F2019-01-01%2F</url>
    <content type="text"><![CDATA[友情提示以下内容都是一些碎碎念，生活、读后感、今天生活内容。ps: 附上我的“专业插画师”提供的图片。 生活新年第一天，昨晚在群里抢红包，一直热闹到很晚才睡。今早10点才慵懒的起来，起的有点晚。中午炸鸡腿，惨不忍睹。后来玩游戏，庸庸碌碌的一天就过去了。这是假期最后一天。希望晚上的时候能收收心看点书。顺带一提昨天晚上看了组件详解。 读Vue 组件基础之组件通信 -《Vue js实战》组件基础组件的复用，复用离不开值得传递。父子组件，兄弟组件相互之间的传值。基本的有props，父组件传递给子组件，子组件通过$emit()、v-on: 来将值通知父组件。不太常用的有$parent(书中提到可以通过此通信访问父实例或组件），在组件中引用父组件，$child,父组件引用子组件。《Vue js实战》书中提到了，通过利用实例化一个空的BUS组件起到总线的作用，这种方法还挺新鲜。另外，组件通信时还有slot的内容分发，slot默认名称是可以和具名slot一起用的。相互之间并不影响。好吧，之前用的时候，总是会不自觉给slot取名字。理解的不够深刻。 高级组件 组件可以递归自己。 异步组件。 小结总感觉这种组件通信方式还有待于改善，应该多读一下开源的一些组件是怎么写出来的。因为上次研究element-UI的时候并没有看它运用这些（指的是通信手段，也可能是我忽略？）但是表现出了很强的可扩展性。很值得学习。包括其中CSS中的书写。 插播元旦放假头一天，买了100的零食，一个大箱子，有优惠。现在好像吃的牙有点疼。作啊。明明要减肥的人。 发现好的视频今天看B站排行榜的时候发现一个点评动漫的UP主，LexBurner?“艺名”：蕾丝。他的视频看动漫的角度还真是蛮特别，应该是有大量的漫画番剧的基础，能有空看这么多视频和漫画，这人真是不简单。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年最后一天]]></title>
    <url>%2F2018%2F12%2F31%2F2018-%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[2018年就要拜拜了。早上9点起来的也不算太晚。折腾了一会儿博客样式之（发现是又拍云开启浏览器缓存的锅）。今天打算看一些书度过。额，还是先玩会儿游戏放空下？不然感觉不太想看书。放张图片吧，可能就是需要这样来自嘲。– end]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown-trick]]></title>
    <url>%2F2018%2F12%2F30%2Fmarkdown-trick%2F</url>
    <content type="text"><![CDATA[vscode snippets 以设置 markdown 代码片段为例 开启设置 文件 &gt; 首选项 &gt; 设置 "[markdown]": &#123; "editor.quickSuggestions": true &#125; 设置模板 文件 &gt; 首选项 &gt; 用户代码片段 &gt; markdown.json &#123; "markdown write template": &#123; "prefix": "mdrt", "body": [ "--- $1", "title: $TM_FILENAME_BASE", "tags:", "* xx", "categories:", "* xx", "date: $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE-$CURRENT_HOUR", "--- ", " \n ", "&lt;!--more--&gt; $2" ], "description": "Create template for markdown write" &#125;&#125; 输出---title: md-killtags:* xxcategories:* xxdate: 2018-03-31-20---&lt;!--more--&gt; 参考Markdown Snippet Prefix Does Not Trigger Snippet #28048Creating your own snippets]]></content>
      <categories>
        <category>日常操作</category>
      </categories>
      <tags>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fib]]></title>
    <url>%2F2018%2F12%2F30%2Ffib%2F</url>
    <content type="text"><![CDATA[斐波那契数列 打印斐波那契数列，递归法，迭代法，提升递归效率 [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]后一位数是前两位数之和(例如 fib(2) === 0 + 1) === 1; 提升递归效率，创建一个数据存储，或者一个小的缓存对象，缓存对象是数组 function memoize(fn) &#123; const cache = &#123;&#125;; return function(...args) &#123; // ...args ： 数组集 if (cache[args]) &#123; return cache[args]; &#125; const result = fn.apply(this, args); cache[args] = result; return result; &#125;;&#125;function slowFib(n) &#123; if (n &lt; 2) &#123; return n; &#125; return slowFib(n - 1) + slowFib(n - 2);&#125;const fib = memoize(slowFib); 递归法function fib(n) &#123; if (n &lt; 2) &#123; return n; &#125; return fib(n - 1) + fib(n - 2);&#125; 迭代法function fib(n) &#123; const result = [0, 1]; for (i = 2; i &lt;= n; i++) &#123; const a = result[i - 1]; const b = result[i - 2]; result.push(a + b); &#125; return result[n];&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>编程</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019--启程]]></title>
    <url>%2F2018%2F12%2F30%2F2019-%E5%90%AF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[即将告别2018年，这个对于我来说，多灾多难的一年。这一年发生了太多的事，每一年也都会发生很多事，但从来没有哪一年能够像2018年这样让人印象深刻。考研结束。毕业。工作。最悲痛的莫过于最亲的人去世。事业也刚刚起步，爱情失去了方向。真是让人印象深刻的一年。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matrix]]></title>
    <url>%2F2018%2F03%2F28%2Fmatrix%2F</url>
    <content type="text"><![CDATA[矩阵 写一个函数，输入数字 N,返会一个 N*N 的矩阵(环序)。 例如// matrix(2)// [[1, 2],// [3, 4]]// matrix(3)// [[1, 2, 3],// [8, 9, 4],// [7, 6, 5]] 代码function matrix(n) &#123; const results = []; for (let i = 0; i &lt; n; i++) &#123; results.push([]); &#125; let counter = 1; let startColumn = 0; let endColumn = n - 1; let startRow = 0; let endRow = n - 1; while (startColumn &lt;= endColumn &amp;&amp; startRow &lt;= endRow) &#123; //顶列开头到结尾 for (let i = startColumn; i &lt;= endColumn; i++) &#123; results[startRow][i] = counter; counter++; &#125; startRow++; //最右列 for (let i = startRow; i &lt;= endRow; i++) &#123; results[i][endColumn] = counter; counter++; &#125; endColumn--; // 底部行 for (let i = endColumn; i &gt;= startColumn; i--) &#123; results[endRow][i] = counter; counter++; &#125; endRow--; // start 列 for (let i = endRow; i &gt;= startRow; i--) &#123; results[i][startColumn] = counter; counter++; &#125; startColumn++; &#125; return results;&#125; 测试const matrix = require('./index');test('matrix 函数已定义', () =&gt; &#123; expect(typeof matrix).toEqual('function');&#125;);test('matrix produces a 2x2 array', () =&gt; &#123; const m = matrix(2); expect(m.length).toEqual(2); expect(m[0]).toEqual([1, 2]); expect(m[1]).toEqual([4, 3]);&#125;);test('matrix produces a 3x3 array', () =&gt; &#123; const m = matrix(3); expect(m.length).toEqual(3); expect(m[0]).toEqual([1, 2, 3]); expect(m[1]).toEqual([8, 9, 4]); expect(m[2]).toEqual([7, 6, 5]);&#125;);test('matrix produces a 4x4 array', () =&gt; &#123; const m = matrix(4); expect(m.length).toEqual(4); expect(m[0]).toEqual([1, 2, 3, 4]); expect(m[1]).toEqual([12, 13, 14, 5]); expect(m[2]).toEqual([11, 16, 15, 6]); expect(m[3]).toEqual([10, 9, 8, 7]);&#125;);]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>编程</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reversint]]></title>
    <url>%2F2018%2F03%2F19%2FreversInt%2F</url>
    <content type="text"><![CDATA[整数反转(reversint)问题 给你一个带符号的整数，返回这些数值的倒序 //例如 // reverseint(1243) === 3421 // reverseint(123) === 321 // reverseint(-12) === -21 // reverseint(-10) === -1 方法二function reverseint(n) &#123; const reversed = n .toString() .split('') .reverse() .join(''); return parseInt(reversed) * Math.sign(n);&#125; 方法一function reverseint(n) &#123; return (n = Math.abs(n) .toString() .split('') .reverse() .join('') * Math.sign(n));&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>编程</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 仓库合并（实例）]]></title>
    <url>%2F2018%2F03%2F05%2Fgit-progress%2F</url>
    <content type="text"><![CDATA[最近想着整理一下 github 上一些零散的代码到同一个库中，问题是如何合并两个仓库并且保留每个文件的提交记录？如果只是两个目录并为一个，不需保留每个库的提交的记录，你只要在本地 A 仓库中 clone B 再提交就行，而本文所做的就是实践这个过程，参考的博客在文末。 目的 合并两个库/提交记录 准备 本地环境 Windows os ,所有均在命令 git bash 中操作 远程仓库 A,如图左，远程仓库 B,如图右。 实践 clone 到本地git clone https://github.com/lmislm/Code_Repository.git 添加远程仓库 cd Code_Repository/ git remote add -f CSS_Ex git://github.com/lmislm/CSS_Ex.git 添加一个新的远程仓库，指定一个简单的名字，以便将来引用，运行 git remote add [shortname] [url]： git merge --strategy ours --no-commit CSS_Ex/master + 可能报错fatal: refusing to merge unrelated histories忽略就行。 + ours 选项强制冲突由‘our’版本自动解决，即：来自其他分支树不会影响到我们这边映射到合并的结果。 + &gt; 即忽略冲突只保留Code_Repository文件树并且把 CSS_Ex的历史记录合并进来。 git remote -v + 此命令将全部列出远程仓库。检查一下是否存在 git read-tree --prefix=css/ -u CSS_Ex/master + --prefix=css/：这里 Code_Repository/目录下有 css/子目录 + &gt; –prefix 用于指定文件树读取后保存的路径，相对于当前路径并且一定要追加 /–no-commit 的原因，该选项会在合并解析完成后中断，停留在最后的提交步骤之前。 git read-tree --prefix=css/ -u CSS_Ex/master + &gt; -u 是说在读取后更新 index，使得 working tree 与 index 保持同步 + git commit -m &quot;finish,迁移CSS_Ex到了Code_Repository/css/下&quot; + git add . + git commit -m &quot;迁移完成&quot; + git push -u origin master 结果 后记 在操作完成之后确实实现了合并到同一个仓库，但是并没有预期的结果，没有完美的合并提交记录。多次操作之后，将一些零散的东西合并到了同一个仓库。但是原来的仓库还是存在的。如果将原来零散的仓库删除。可以看到结果中，a year ago，历史提交记录确实存在，但是其他flex_Ex显示的却是在进行这个合并操作时提交的时间。 参考如何用 Git 合并两个库（合并历史记录，解决冲突／改写路径）Merging Git Repositories and Preserving History Git 基础 - 远程仓库的使用MERGE STRATEGIES​ - oursgit read-tree]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[undefined behavior in c]]></title>
    <url>%2F2018%2F01%2F06%2Fundefined%20behavior%20in%20c%2F</url>
    <content type="text"><![CDATA[undefined behavior（未定义行为） 思考一下下面这段代码的输出会是什么（答案在后面）？ 这段代码运行过程是怎样？ #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define SQ(y) (y*y) //define 1//#define SQ(y) ((y)*(y)) //define 2int main() &#123; int i = 1; while(i &lt;= 5)&#123; printf("%-2d",SQ(i++)); &#125; return 0;&#125;----------/*-只试了两种编译器 *所用编译器：gcc * 用define 1 : 结果1 9 15 * 用define 2 ：结果1 9 15 *其他编辑器： * 用define 1 : 结果2 12 30 * 用define 2: 结果1 9 15 * 。。。。。 问题：为什么得到的结果不一样？ 看上面的对比，是因为编辑器的原因导致的?? 一开始某本书上的答案是 2 12 30 ，我很纳闷，开头第一个数居然是 2，于是一番折腾查阅了一下别人的看法。 我认为的原因是：undefined behavior 什么是：undefined behavior（未定义行为）呢？如下。 在计算机程序设计中，未定义行为（英语：undefined behavior) 是指行为不可预测的计算机代码。这是一些编程语言的一个特点，最有名的是在 C 语言中。在这些语言中，为了简化标准，并给予实现一定的灵活性，标准特别地规定某些操作的结果是未定义的，这意味着程序员不能预测会发生什么事。……. 因此，这种未定义行为一般应被视为 bug。—来源：中文维基百科 还有哪些 undefined behavior（未定义行为） 偷懒：)。此处省略一些例子，因为 wiki 上都有一些典型例子。中文访问不了的话，英文在这，点我。 如何解释这段代码 输出 1 9 15++ 其计算过程可能为：第一次循环时，i=1，i++=2，1 _ 2 = 2， 再 i++=3第二次循环时，i=3，i++=4，3 _ 4 = 12，再 i++=5第三次循环时，i=5，i++=5, 5 * 6 = 30，再 i++=6//进入 i&lt;=5 判断,值为假，退出循环 输出 2 12 30++ 其计算过程可能为：第一次循环时，首先 i=1, 1 _ 1 = 1，i++=2，再 i++=3第二次循环时，首先 i=3, 3 _ 3 = 9，i++=4，再 i++=5第三次循环时，首先 i=5, 5 * 5 = 25, i++=6，再 i++=7// i=7，所以退出循环。 首先 i++是先运算，后加。对于 SQ(i++)来说，其实质是((i++)*(i++))。在后加运算符是在整个运算完成之后，才进行加 1 操作的。 多问和讨论总是有好处的，继续保持：）参考：[1]c语言的代参宏定义，#define sq(y) ((y)*(y))….输出应该是2 12 30才对啊？？[2]int i=5 ；printf(“%d”,i++,++i)；为什么输出 6? [3]c语言中define的用法进阶（可不看）：关于宏定义的 ppt]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell的正则表达式]]></title>
    <url>%2F2017%2F07%2F20%2Fshell%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[简介 正则表达式用于描述字符排列和匹配模式的一种语法规则。—-用来筛选数据 正则表达式与通配符的区别 1.正则表达式–匹配“文件”符合条件的字符串–&gt;&gt;包含匹配 2.通配符—–匹配符合条件的“文件”名——–&gt;&gt;完全匹配 3.为什么存在，通配符、正则表达式？ ls、find、cp（操作文件的一些命令）不支持正则表达式，只能用通配符。 grep、awk、sed（操作字符串的一些命令）支持正则表达式。 为什么所有的不都支持正则表达式？ 正则表达式 基础正则 元字符 作用 * 前一个字符匹配0 次或任意多次 . 前一个字符匹配0 次或任意多次 ^ 匹配行首，例：^he 匹配以 he 开头的行 $ 匹配行尾，例：he$匹配以 he 为结尾的字符串 [ ] 匹配括号中指定的任意一个字符，只匹配一个 例：[a-z]匹配 a-z 中的任意一个字符，[0-9][a-z]表示“连续匹配” [^] 匹配除中括号字符外任意一个字符，例：^[0-9]匹配任意一位非数字的字符 \ 转义符，取消特殊字符的含义 \ { n\ } 表示前面字符恰好出现 n 次 \ { n,\ } 表示前面字符出现不小于n 次 \ {n,m\ } 表示其前面字符至少出现 n 次 扩展正则 正则表达式（基础正则）“ * “ “*“星号——–不同于通配符中的匹配所有内容。 前一个字符匹配0 次，或者任意多次。 a* - - 匹配所有内容，包括空白行。 aa* - - 匹配至少包含有一个 a 的行。 aaa* - -匹配至少包含两个连续的 a 的字符串。 “ . “ “.“——–和通配符中”?”类似。 匹配除了换行符外任意字符 s..d - - 匹配之间两个字符的单词。 s.*d - - 匹配之间的任意字符。 .* - - 匹配所有内容。 “ ^ “、” $ “、” [] “、” [ ^ ] “ “^“、”$“、”[]“、”[^]“ ^ - - 匹配行首。 $ - - 匹配行尾。 [] - - 匹配括号中指定字符串中的任意字符，只匹配一个。 [^] - - 匹配除中括号的字符以外的任意一个字符。 {n\ }、{n,\ }、{n,m\ } “\{n\}”、”\{n,\}“、”\{n,m\}“ \{n\} - - 例：a\{3\} 匹配 a 字母连续出现三次的字符串（连续四次以上也会被匹配到，所以在该匹配首尾加定界符能精确匹配到） \{n,\} - - 例：\{n,\} 前面字符出现不少于 n 次 \{n,m\} - - 例：sa\{1,3}i 匹配在字母 s 和字母 i 之间最少一个 a，最多三个 a]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[question-check]]></title>
    <url>%2F2017%2F05%2F27%2Fcheck-question%2F</url>
    <content type="text"><![CDATA[质量反馈调查展示界面 编辑 管理 答题 统计数据 题库]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>展示</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[acm基础--POJ No.1003 Hangover]]></title>
    <url>%2F2017%2F05%2F25%2Facm00%2F</url>
    <content type="text"><![CDATA[关于运算符号的思考（acm 热身）POJ No.1003 Hangover input：1.003.71output：3 card(s)61 card(s) c#include&lt;stdio.h&gt;main()&#123; int n; float a,b; while(scanf("%f",&amp;b)==1) &#123; if(b==0.0)break; a=0.0; for(n=1;a&lt;b;++n) a+=1.0/(float)(n+1); printf("%d" card(s) \n",n-1); &#125;&#125; 逗号运算符号 while(scanf(“%f”,&amp;b)==1)compare towhile(scanf(“%f”,&amp;b),b)结束条件等价于b!=0即使 b 的值为 0.000001f,0.00001f!=0 为真，也不会结束循环。所以写法(*，b）非常重要 强制类型转换 直接用(float)转换为 int 类型，简单点就写成for(n=1;al；) 减少变量 省略 int 类型将 n 写入 main（），但是有的编译器并不能通过。所以为了简单清晰，还是不要用的好。 尽量多用 for 循环直接缩成一行 其中包含n省略在mainmain(n)&#123;float b;for(;scanf(&quot;%f&quot;,&amp;b),b;printf(&quot;%d card(s)\n&quot;,n-1)) for(n=1;b&gt;0;)b-=1./++n;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度优先算法-部分和问题]]></title>
    <url>%2F2017%2F05%2F24%2FDFS-%E9%83%A8%E5%88%86%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目给定整数 a~1~,a~2~ ,…,a~n~，判断是否可以从中选出若干数，使他们的和恰好为 k。 限制条件 1≤ n ≤20 -10^8^ ≤ a~i~ ≤ 10^8^ -10^8^ ≤ k ≤ 10^8^输入 n=4 a={1,2,4,7} k=13输出yes （13 = 2 + 4 + 7） 分析利用最简单的递归，可以先画出深度优先的树代码c++#include&lt;iostream&gt;using namespace std;const int MAXNUM = 20;// 输入int arr[MAXNUM];int n, k;void input_data(int *n, int *k, int *arr)&#123; cout &lt;&lt; "n = "; cin &gt;&gt; *n; cout &lt;&lt; "a = &#123;"; for (int i = 0; i &lt; *n; i++)&#123; cin &gt;&gt; arr[i]; cin.get(); cin.get(); &#125; cout &lt;&lt; "k = "; cin &gt;&gt; *k;&#125; //已经从前n项得到了和sum，然后对于i项之后的分支bool dfs(int i, int sum)&#123;// 如果前n项都计算过了，则返回sum是否与k相等 if (i == n) return sum == k;// 不加上a[i]的情况 if (dfs(i+1, sum)) return true;// 加上a[i]的情况 if (dfs(i+1, sum+arr[i])) return true;// 无论是否加上a[i],都不能凑成k就返回false return false;&#125;void solve()&#123; if (dfs(0, 0)) cout &lt;&lt; "Yes" &lt;&lt; endl; else cout &lt;&lt; "No" &lt;&lt; endl;&#125;int main()&#123; input_data(&amp;n, &amp;k, arr); solve(); return 0;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Steps]]></title>
    <url>%2F2017%2F05%2F21%2Fpoj%20No.2590%2F</url>
    <content type="text"><![CDATA[POj No.2590 Steps题目在数轴上的两点之间，按照下面规则移动。 每一步的步幅都要是自然数，同时必须与前一步幅相同或者是差 1。 每一步和最后一步的步幅必须是 1。当给出两点位置的时候，请回答从第一个点移动到第二点需要的最小步数。 输入和输出测试数据个数 n、开始地点 x 以及终点 y（0&lt;=x&lt;=y&lt;2^31^),格式如下： nx~1~ y~1~x~2~ y~2~…x~n~ y~n~ 输入 345 4845 4945 50 输出 334 代码c#include&lt;stdio.h&gt;int main()&#123; int step, i,len; for(step=0;step&lt;20;++step)&#123; len=0; //求得一半为止的步数 // 步数是奇数就加1 int mid=step/2+step%2; //求出1+2+3+...到中间地点为止的合计 for(i=1;i&lt;=mid;++i) len+=i; //从中间地点开始计算...+3+2+1 for(i=step/2;i&gt;0;--i) len+=i; printf("%2d step(s)...%3d\n",step,len); &#125;&#125; 解决思路 画图找规律]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj No.3062 Celebrity jeopardy]]></title>
    <url>%2F2017%2F05%2F20%2Fpoj%20No.3062%2F</url>
    <content type="text"><![CDATA[Celebrity jeopardy直接输出的数字 c#include&lt;stdio.h&gt; char c;int main()&#123; for(;~c;) &#123; c = getchar(); putchar(c); &#125;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>acm</tag>
        <tag>poj</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codewars_Replace With Alphabet Position]]></title>
    <url>%2F2017%2F05%2F07%2Fcodewars_Replace%20With%20Alphabet%20Position%2F</url>
    <content type="text"><![CDATA[题目这是一道字符串操作的题。题目如下： Welcome.In this kata you are required to, given a string, replace every letter with its position in the alphabet. If anything in the text isn’t a letter, ignore it and don’t return it. a being 1, b being 2, etc.As an example: 例子alphabet_position(&quot;The sunset sets at twelve o&apos; clock.&quot;)Should return &quot;20 8 5 19 21 14 19 5 20 19 5 20 19 1 20 20 23 5 12 22 5 15 3 12 15 3 11&quot; (As a string.) 分析首先肯定利用方法charCodeAt来处理字符，其次得转化下大小写，因为每个字符都是空格隔开，那么肯定用到split等来“切割”。思路大概就是我代码里头描述的，但是看最佳答案的时候，有相对另外的思路，大概意思差不多但是把处理的顺序调一下，会有意想不到的作用，也是佩服那些大牛们啊，具体怎么调整才可以 →_→ 最优，聪明的你，可以想一想啊 :) 留个悬念。 解题function alphabetPosition(text) &#123; return text.replace(/[^a-zA-Z]+/g,&apos;&apos;).toUpperCase().split(&apos;&apos;).map( function (eachStr) &#123; return eachStr.charCodeAt()-64; &#125;).join(&apos; &apos;);&#125;console.log(alphabetPosition(&apos;The testT&apos;)) 那么我看到目前为止最机智中票数最高的代码下面这个，可惜这些对我来说还是很晦涩啊。但是我想大概思路是差不多的。另外看到很多用 for 循环的，感觉太麻烦，虽然代码容易读，但是我想对于一个想学习 JS 的人来说，尽量用方法应该是好的。 let alphabetPosition = (text) =&gt; text .toUpperCase() .replace(/[^A-Z]/g, &apos;&apos;) .split(&apos;&apos;) .map(ch =&gt; ch.charCodeAt(0) - 64).join(&apos; &apos;); 实际运用看到 js 字符串转换为数字基本就用转换函数的比较多， js 字符串转换成数字常用的几种方法转换函数、强制类型转换、利用 js 变量弱类型转换。 转换函数parseInt(&quot;1234blue&quot;); // returns 1234 强制类型转换Boolean(&quot;hi&quot;); //true – non-empty string js 变量弱类型转换var str = &#39;012.345 &#39;;var x = str - 0;x = x * 1; 查资料发现，关于类型转换的还是比较多，但是我并没有感觉其中的区别和用的地方，可能是实际运用接触不多。但是关于字符和数字之间的转换在 Nodejs 中也是有体现。因此，觉得 codewars 的题目质量还真的挺不错，至少对于我这种初学者来说。每一道题目后面可能都是作者精心挑选出来的。所以，加油吧。 参考 JavaScript 权威指南(第 6 版)(中文版) JavaScript 语言精粹(修订版) 中文版 MDN(Mozilla Developer Network) js 字符串转换成数字]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>js</tag>
        <tag>codewars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vowel Counts]]></title>
    <url>%2F2017%2F04%2F02%2Fvowel%20count%2F</url>
    <content type="text"><![CDATA[统计字符串中的特定字符的数量。主要是方法的优化: 1. 题目 Description: Return the number (count) of vowels in the given string. We will consider a, e, i, o, and u as vowels for this Kata. 2. 例子 测试数据 //Example test:describe(&quot;Case 1&quot;, function()&#123; it (&quot;should be defined&quot;, function()&#123; Test.assertEquals(getCount(&quot;abracadabra&quot;), 5) &#125;);&#125;); 3. 分析 第一眼就想到是可以从头依次查找的。能想到用 c，java 等都是利用 for 循环来处理。 其次，JS 中想到的是字符串匹配，利用正则表达式对特定字符串遍历。然后输出匹配字符的 length。 * 利用字符串的原型方法String.prototype.match(),语法str.match(regxp) 后面再总结一下，string 类方法 match(regex) 和 RegExp 类方法 exec(string) 4. 解题4.1 最优化：function getCount(str) &#123; return (str.match(/[aeiou]/ig)||[]).length;&#125; 4.2 “多语言”解非常的直白啊，感觉都没有一点艺术。。 function getCount(str) &#123; var vowelsCount = 0; var a = [&apos;a&apos;,&apos;e&apos;,&apos;i&apos;,&apos;o&apos;,&apos;u&apos;]; for(var i=0; i&lt;str.length; i++)&#123; for(var j=0;j&lt;a.length; j++)&#123; if(a[j]===str[i])&#123; vowelsCount ++; &#125; &#125; &#125; return vowelsCount;&#125; 4.3 优化用indexof来减少 for 循环。 function getCount(str) &#123; var vowelCount = 0; var a = [&apos;a&apos;,&apos;e&apos;,&apos;i&apos;,&apos;o&apos;,&apos;u&apos;]; for(var i=0;i&lt;str.length; i++)&#123; if((a.indexOf(str[i]))!==-1)&#123; vowelCount ++; &#125; &#125; return vowelCount;&#125; 总结match（regexp）和 exec() 关于这两个的讨论，感觉说破天也没有 MDN 上说得好啊。:&gt;]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>js</tag>
        <tag>codewars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Don't rely on luck.]]></title>
    <url>%2F2017%2F03%2F30%2FMath.random%2F</url>
    <content type="text"><![CDATA[题目在 codewars 上碰到一道奇怪的题目。猜随机数。难度 6kyu，题干比以往简单。这就让人捉急了。什么都看不出来。接下来看题 The test fixture I use for this kata is pre-populated.It will compare your guess to a random number generated in Ruby by: (Kernel::rand() * 100 + 1).floorIn Javascript/CoffeeScript by: Math.floor(Math.random() * 100 + 1)In Python by:randint(1,100)You can pass by relying on luck or skill but try not to rely on luck. “The power to define the situation is the ultimate power.” - Jerry Rubin Good luck! 例子这里，题目给出的测试是： Example Test:var lucky_number = Math.floor(Math.random() * 100 + 1);Test.assertEquals(guess, lucky_number, &quot;Sorry. Unlucky this time.&quot;); 分析看到题目的时候，- - 就这么点? 然后 0.0 ，睁大眼睛看，然后 = =，这什么鬼，+.+，直接Math.random()?, @.@ 那怎么相等呢。？.?搜了下 9.9 ，发现只有Ruby 的答案。 再查了下随机数。_ 随机数分为 伪随机数 和 真随机数 _ 正常电脑各种语言中使用的都是 伪随机数 ，是由可确定的函数，通过种子（常用时钟），产生伪随机数，这种数字理论上存在可预测性。 * _函数_ :计算机产生随机数的方法有：线性同余方法(大部分采用,，即 RandNumber = (Rand_Seed X + Y) mod Z 那个 RandSeed 就是「种子」一般取时钟周期，也就是 GetTickCount()。），平方取中法，M-sequence，梅森旋转算法，还有MT随机数算法。_ ps:这里不对 随机数的产生和随机数的计算理论做深究。具体可以看这里，各答案较完整讲了计算机产生的是伪随机数，还有产生 真随机数 的可行性。 那么 JavaScript 中的随机数是个什么样的存在？答案当然是伪随机数。= =_ JavaScript 中并没有类似上面底层语言提供的函数,根据 panxiwu 博客中的说法，c 和 Ruby 都有底层重置 seed 方法依据不同的方法来生成种子。而，JavaScript 应该是依靠引擎使用随机函数方法，所以在安全方面，不用 Math.random 最好，替代的可以使用window.crypto.getRandomValues(array); &gt; MDN：Math.random() does not provide cryptographically secure random numbers. Do not use them for anything related to security. Use the Web Crypto API instead, and more precisely the window.crypto.getRandomValues() method._ V8 引擎中实现 随机数：通过 Mathlmmul 来创造，并没有所谓的 seed 参数，所以只能重写。 // ECMA 262 - 15.8.2.14 var rngstate;// Initialized to a Uint32Array during genesis.function MathRandom() &#123;var r0 = (MathImul(18030, rngstate[0] &amp; 0xFFFF) + (rngstate[0] &gt;&gt;&gt; 16)) | 0; rngstate[0] = r0; var r1 = (MathImul(36969, rngstate[1] &amp; 0xFFFF) + (rngstate[1] &gt;&gt;&gt; 16)) | 0; rngstate[1] = r1; var x = ((r0 &lt;&lt; 16) + (r1 &amp; 0xFFFF)) | 0;// Division by 0x100000000 through multiplication by reciprocal.return (x &lt; 0 ? (x + 0x100000000) : x) * 2.3283064365386962890625e-10; &#125;// Non-standard extension.function MathImul(x, y) &#123; return %NumberImul(TO_NUMBER_INLINE(x), TO_NUMBER_INLINE(y));&#125; from v8 解题var guess = 10Math.floor = function(num) &#123;return guess;&#125; Accept!然后看到一堆不可描述的东西。lol 这个…….. var guess = 10;lucky_number = 10; 还有这个 Math.random=()=&gt;&quot;:D&quot;Math.floor=x=&gt;(x+&apos;&apos;).replace(/N/g,&apos;L&apos;).replace(/a/g,&quot;0&quot;)var guess = &quot;L0L&quot; 不少都是写死了 random 的值然后钻牛角尖的。。还有令人搞笑的，可以拿来当笑话集了，这题： var guess = &quot;What a stupid kata.&quot;;Math.floor = function() &#123; return &quot;What a stupid kata.&quot;;&#125; 还有这个，，厉害了。。。 实际运用 比如我们在开发京东的 H5 活动页面的小游戏时，可能需要随机产生一些背景、随机掉落道具、小怪物；当用户中途退出(微信不小心右滑，一定有不少人被这个恶心到[当然现在已经优化])，当用户重新打开小游戏时，用户整体进度、积分我们可以很容易记录到本地或者存储到微信 ID 建立的存储机制中从而得以恢复，但是随机产生的场景、随机掉落道具、小怪物等并不是那么容易存储恢复，重新获取场景、小怪物那未免用户体验太差！！！把画布上的所有物件、怪物属性全部存储下来更是没有必要。此时我们就可以利用我们重写的 Math.random()(此时可不重写内置方法，可另起别名)。只要我们保存下来一个随机数 seed 值，利用 seed 值来恢复所有的场景就好了。from 潘信伍 ,谢谢大神啊 参考悟道集JavaScript 中 Math.random 的种子设定方法]]></content>
      <categories>
        <category>工作</category>
        <category>codewars</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[holygrail（圣杯布局）]]></title>
    <url>%2F2017%2F03%2F25%2Fholygrail%2F</url>
    <content type="text"><![CDATA[圣杯布局(holygrail)起源 三列。两列固定在两边，中间是一个 流体 圣杯布局的原理是? 简述实现圣杯布局的步骤。双飞翼布局和圣杯布局有什么异同负 margin 的用法 例子 一个简单的仿照例子实现圣杯布局 步骤 1. 建立框架&lt;body&gt;&lt;!--第一步 建立框架--&gt;&lt;div id=&quot;header&quot;&gt;&lt;h1&gt;#header&lt;/h1&gt;&lt;/div&gt;&lt;div id=&quot;container&quot;&gt; &lt;h1&gt;#container&lt;/h1&gt;&lt;/div&gt;&lt;div id=&quot;footer&quot;&gt;&lt;h1&gt;#footer&lt;/h1&gt;&lt;/div&gt;&lt;/body&gt; 2. 加 column float 让其在 line。再清除 footer 让它在最下面。添加背景颜色和边界便于观察。中间栏要放在前面以优先渲染。 &lt;style&gt;#container &#123; padding-left: 200px; padding-right:150px; &#125; #container .column &#123; float: left; &#125; #center &#123; width:100%; &#125; #left &#123; width:200px; &#125; #right &#123; width: 150px; &#125; #footer &#123; clear: both; &#125; &lt;/style&gt; &lt;div id=&quot;container&quot;&gt; &lt;h1&gt;#container&lt;/h1&gt; &lt;div id=&quot;center&quot; class=&quot;column&quot;&gt;&lt;h1&gt;this is center&lt;/h1&gt;&lt;/div&gt; &lt;div id=&quot;left&quot; class=&quot;column&quot;&gt;&lt;h1&gt;this is left&lt;/h1&gt;&lt;/div&gt; &lt;div id=&quot;right&quot; class=&quot;column&quot;&gt;&lt;h1&gt;this is right&lt;/h1&gt;&lt;/div&gt;&lt;/div&gt; 效果图 2.1 3. 将左栏拉到相应位置 要让左栏和中间在一条直线上，先对左栏进行操作,分两步。margin-left:-100%跑到左上角（覆盖主栏目），再设置 position:relative,right:200px 或者 left:-200px（不覆盖主栏目） 第一步 #left &#123; width:200px; margin-left: -100%; background-color: #555555;&#125; 效果图 3.1 * 第二步用相对定位将左栏推开，加上相对定位标志之后，记得给左栏一个right:200px将左栏相对右边 200px,往左推 200px。 #left &#123; width:200px; margin-left: -100%; right:200px; background-color: #555555; &#125; 效果图 3.2. 4.将右栏加入 line注意： 原作者这里用的是margin-right:-150px，在演示时并不能起效果。 #right &#123; width: 150px margin-right: -100%; background-color: #8cacea;&#125; 效果图 4.1再处理一些小细节,固定的右边栏多出的字，撑开了 效果图 4.2 5.结果 总结实现步骤1. div 框架搭建出来， div- &gt;container，header，footer 2. 加 column， 设置float:left， 设置center宽度100% 清除footer浮动 3. 将左栏添到 center 左边， margin-left:-100%到左上（覆盖主栏目）， 再设置position:relative,right:200px或者left:-200px（不覆盖主栏目） 4. 将右栏添右 margin-right: -100%; 圣杯布局和双飞翼布局异同 两种布局方式都是把主列放在文档流最前面，使主列优先加载 两者在实现上的相同点在于都让三列浮动，然后通过负外边距形成三列布局； 两种布局方式的不同在于如何处理中间主列的位置：圣杯布局是利用父容器的左右内边距定位；双飞翼布局是把主列嵌套在 div 后利用主列的左右外边距定位。 浮动元素上的负 margin 给一个浮动元素加上相反方向的负 margin，则会使行间距为 0 且内容重叠。 bug 修复 * 当浮动元素使用负 margin 时，在一些旧的浏览器中可能会出现问题。用position:float,能解决很多问题。 具体可以参考 负 margin 用法权威指南 flex 实现的“标准”圣杯布局MDN 效果图 其他 圣杯布局基本就是（适：自适应，左：左栏，右：右栏）_ 左适右_ 左右适_ 左适、右适_ 等等 圣杯布局还有很多的实现方法_ 纯浮动实现_ flex 实现可以参考，圣杯布局小结，觉得这位作者对圣杯布局总结的挺好，各种小例子。其他的也可以搜一下。我这里主要是介绍下圣杯布局。 圣杯布局类似 * 双飞翼布局 1. left 和 right 覆盖了 center 的左右两边的内容。 2. center 的外部再加一个 div 标签来包裹中间区块， 3. 宽度为 100%。然后再设置 main 的左右外边距，使它回到对应的位置。 参考In Search of the Holy Grail by Matthew Levine关于「圣杯布局」 by DotHide圣杯布局小结 by 流云诸葛圣杯布局和双飞翼布局 by betterwlfCSS 之圣杯布局和双飞翼布局 by 宋菲负 margin 用法权威指南 by Airen 的博客]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codewars-count_digits]]></title>
    <url>%2F2017%2F03%2F20%2Fcodewars%2F</url>
    <content type="text"><![CDATA[题目 Take an integer n (n &gt;= 0) and a digit d (0 &lt;= d &lt;= 9) as an integer. Square all numbers k (0 &lt;= k &lt;= n) between 0 and n. Count the numbers of digits d used in the writing of all the k* *2. Call nb_dig (or nbDig or …) the function taking n and d as parameters and returning this count. 例子 n = 10, d = 1,the k * k are 0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100 We are using the digit 1 in 1, 16, 81, 100. The total count is then 4.nb_dig(25, 1):the numbers of interest are 1, 4, 9, 10, 11, 12, 13, 14, 19, 21which squared are 1, 16, 81, 100, 121, 144, 169, 196, 361, 441 so there are 11 digits 1 for the squares of numbers between 0 and 25. 分析 给出n和d，求 0 到 n 中间的平方，再求这些平方的平方，问所得的这些数中包含多少个数字d。大概就是先算出这些数字的平方，然后挨个分解求出其中的值。 解题function nbDig(n,d) &#123; var s = &apos;&apos;; for(var i=0;i&lt;=n;i++)&#123; s += Math.pow(i,2); &#125; return s.split(d).length-1&#125; 牢骚篇今天，进了个群，挺多厉害的人，还私聊了一个有很多 offer 的同学。顿时觉得，自己就是渣渣啊，一点信心都没有。还是得加油吧，要学的东西还很多啊。]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>js</tag>
        <tag>codewars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法小记]]></title>
    <url>%2F2017%2F03%2F20%2Fmarkdown%E8%AF%AD%E6%B3%95%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[插入表格：1.1. 表格的上下需要空行。空行的多少至关重要 表格中文字居中 在划线部分的划线两端加上”:“ 比如”:—–: | :—-: 代码块:2.1. 合理利用代码块有意想不到的效果。3.]]></content>
      <tags>
        <tag>工具</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codewars ooxx =>true]]></title>
    <url>%2F2017%2F03%2F17%2Fcodewars-ooxx%2F</url>
    <content type="text"><![CDATA[前言第二关 Yeah！目标 6kyu，坚持升级~ ：） 这一关，考察几个基本方法的使用，虽然单独拿出来可能难度不大，但是真正运用在工作中的时候，这些方法可能如大海捞针，不熟练是一时半会儿想不出来的。 话不多说，呀呀呀，提枪上阵， 题目描述Check to see if a string has the same amount of ‘x’s and ‘o’s. The method must return a boolean and be case insensitive. The string can contains any char.（0.0 看不懂？往下戳） 例子XO(&quot;ooxx&quot;) =&gt; trueXO(&quot;xooxx&quot;) =&gt; falseXO(&quot;ooxXm&quot;) =&gt; trueXO(&quot;zpzpzpp&quot;) =&gt; true // when no &apos;x&apos; and &apos;o&apos; is present should return trueXO(&quot;zzoo&quot;) =&gt; false 分析题目大概意思就是： 在有限任意字符串中字符 x 和 o 存在且数量相等时 值为 true,否则当x和o不存在时，值为flase。匹配的话，首先想到正则表达式来处理。 方法一利用 RegExp 来匹配正则，然后再判断数量为空和数量是否相等。 function xo(str) &#123; var numX = new RegExp(/x/gi); //g 全局搜索，i 忽略大小写 var numO = new RegExp(/o/gi); if(numX.test(str)&amp;&amp;numO.test(str))&#123; if(str.match(/x/gi).length == str.match(/o/gi).length)&#123; return true; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125;console.log(xo(&apos;xxoo&apos;))console.log(xo(&apos;glld&apos;)) 仔细一看，这种写法太麻烦。如何轻松取敌呢？ 方法二直接返回一个 return，并在 return 中判断。 function xo(str) &#123; var numX = str.match(/x/gi) || []; var numO = str.match(/x/gi) || []; return numO.length == numX.length;&#125; 解析方法一方法二 什么鬼！这不同的方法有什么区别呢？？我来试着剖析下这两种方法究竟是何利器。来看看MDN是怎么说的？贴心的MDN还在match这一篇中对两者进行了比较。 1. RegExp 构造函数创建了一个正则表达式对象，用于将文本与模式匹配。 2.当一个字符串与一个正则表达式匹配时， match()方法检索匹配项。 比较 如果正则表达式没有 g 标志，则 str.match() 会返回和 RegExp.exec() 相同的结果。而且返回的 Array 拥有一个额外的 input 属性，该属性包含被解析的原始字符串。另外，还拥有一个 index 属性，该属性表示匹配结果在原字符串中的索引（以 0 开始）。 用法 如果你需要知道一个字符串是否匹配一个正则表达式 RegExp ，可使用 search() 。如果你只是需要第一个匹配结果，你可能想要使用 RegExp.exec() 。如果你想要获得捕获组，并且设置了全局标志，你需要用 RegExp.exec() 。 综上：大概就是这么吧~不用鸟我了，直接看文档吧~ 方法三方法三是在解答完之后查看他人的方法，大神们就是大神。对于各种用法如数家珍，信手拈来。 let x = str.match(/x/gi);let o = str.match(/o/gi);return (x &amp;&amp; x.length) === (o &amp;&amp; o.length);&#125; 实际运用 这个keyword变量该如何转义呢？ function addHightLight(txt,keyword) &#123; return txt.replace(/+keyword+/g,&quot;&lt;mark class=keyword&gt;&quot;+keyword+&quot;&lt;/mark&gt;&quot;);&#125; 答案是： function addHightLight(txt,keyword) &#123; txt = &quot;咖啡&quot; ;keyword = &quot;机器&quot;; var va = new RegExp(keyword,&quot;g&quot;); va = /\/咖啡\/g/&#123;lastIndex:0&#125; return txt.replace(va,&quot;&lt;mark class=keyword&gt;&quot;+keyword+&quot;&lt;/mark&gt;&quot;);&#125; 就到这里了~]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>js</tag>
        <tag>codewars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[codewars - - accm]]></title>
    <url>%2F2017%2F03%2F16%2Fcodewars-accm%2F</url>
    <content type="text"><![CDATA[前言 最近在找实习啊，希望暑假有份合适的工作来填充暑假。就刷 codewars。我比较懒所以更新的可能比较慢。。 题目描述This time no story, no theory. The examples below show you how to write function accum: 示例accum(&quot;abcd&quot;); // &quot;A-Bb-Ccc-Dddd&quot;accum(&quot;RqaEzty&quot;); // &quot;R-Qq-Aaa-Eeee-Zzzzz-Tttttt-Yyyyyyy&quot;accum(&quot;cwAt&quot;); // &quot;C-Ww-Aaa-Tttt&quot; 分析 大概意思就是递增的方式来重复每个字符再用依次拼接在一块儿，确定用join()来拼接，用 map 方法来迭代，再把首字母转为大写，其余为小写具体方法如下 解一 参考方法而之后发现这个并没有完全利用 js 中语法的特性，感觉在 js 学习中不可取 function accm(s) &#123; s = s.toUpperCase().split(''); for (var i = 0, l = s.length; i &lt; l; i++) &#123; var tmp = s[i].toLowerCase(); for (var j = 0; j &lt; i; j++) &#123; s[i] += tmp; &#125; &#125; return s.join('-');&#125; 解决二function accm(s)&#123;//分割。再map方法查询，再转换大小写 return s.split(&apos;&apos;).map( (x,index) =&gt; x.toUpperCase() + Array(index+1).join(x.toLowerCase())).join(&apos;-&apos;);&#125; 解决三 在方法一上，进行简化，但是没有方法二更简单 function accum(s)&#123; var letter = s.split(&apos;&apos;); var result = []; for(var i=0;i&lt;letter.length;i++)&#123; result.push(letter[i].toUpperCase()+Array(i+1).join(letter[i].toLowerCase())); &#125; return result.join(&apos;_&apos;);&#125;//输出accum(&apos;fds&apos;)F_Dd_Sss 总结在平时的学习中能多用到所学知识是最好的，如果混合方法写，不利于学习。]]></content>
      <categories>
        <category>工作</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>js</tag>
        <tag>codewars</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 2.0 之 Vue-Router 路由挂载实例]]></title>
    <url>%2F2017%2F01%2F26%2Fvue-router%E6%8C%82%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[原因 在新出的 vue 2.0 中文档，挂载实例 问题 在构建路由时，vue1.0 中应用 map 方法，而在 2.0 中取消了 map 方法，而快速的启用 new router 便可以建立。在 vue1.0 到 vue2.0 的迁移时，也带来了很多麻烦。 问题点 render: h =&gt; h(App) 路由挂载的正确姿势 问题描述 vue1.0 中的实例很方便实现，而 2.0 中的实例模板并不是很好使用。 vue1.0 中 vue-router 写法、vue2.0 中 vue-router 写法 问题解决 vue2.0 官网中： // 0. 如果使用模块化机制编程，導入Vue和VueRouter，要调用Vue.use(VueRouter);// 1. 定义（路由）组件。// 可以从其他文件 import 进来const Foo = &#123; template: '&lt;div&gt;foo&lt;/div&gt;' &#125;;const Bar = &#123; template: '&lt;div&gt;bar&lt;/div&gt;' &#125;;// 2. 定义路由// 每个路由应该映射一个组件。 其中"component" 可以是// 通过 Vue.extend() 创建的组件构造器，// 或者，只是一个组件配置对象。// 我们晚点再讨论嵌套路由。const routes = [ &#123; path: '/foo', component: Foo &#125;, &#123; path: '/bar', component: Bar &#125;];// 3. 创建 router 实例，然后传 `routes` 配置// 你还可以传别的配置参数, 不过先这么简单着吧。const router = new VueRouter(&#123; routes // （缩写）相当于 routes: routes&#125;);// 4. 创建和挂载根实例。// 记得要通过 router 配置参数注入路由，// 从而让整个应用都有路由功能const app = new Vue(&#123; router&#125;).$mount('#app'); 实际案例写法 import Vue from 'vue';import VueRouter from 'vue-router';import App from './App';import goods from './components/goods/goods';Vue.use(VueRouter);//路由嵌套const router = new VueRouter(&#123; routes: [ &#123; path: '/goods', component: goods &#125; ]&#125;);new Vue(&#123; router, render: h =&gt; h(App) //关键点，官网中没加，这个相当于ES6的写法&#125;).$mount('#app');//默认去goodsrouter.push('goods');]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置hexo标签]]></title>
    <url>%2F2016%2F03%2F20%2Fhexo%E4%B8%AD%E7%9A%84tags%2F</url>
    <content type="text"><![CDATA[体会 hexo 写作要求的格式非常的严格，连空格都不能省略。 英语不好是硬伤，tags 标签在我配置的时候写成了 tages！害 得我找了很久。总算是搭建完了很多的功能。]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css和sass的比较]]></title>
    <url>%2F2016%2F01%2F18%2Fsass%E4%B8%8Ecss%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[css和sass的比较一个程序来说明sass和css3 这里配置sass不做介绍，请参考sass详细介绍和安装 对比 在这两个效果一样编译结果不一样的文件中你可以看到区别，sass对于程序化css起很大作用。 sass// n is number of stars required@function multiple-box-shadow ($n) $value: &apos;#&#123;random(2000)&#125;px #&#123;random(2000)&#125;px #FFF&apos; @for $i from 2 through $n $value: &apos;#&#123;$value&#125; , #&#123;random(2000)&#125;px #&#123;random(2000)&#125;px #FFF&apos; @return unquote($value)$shadows-small: multiple-box-shadow(700)$shadows-medium: multiple-box-shadow(200)$shadows-big: multiple-box-shadow(100)html height: 100% background: radial-gradient(ellipse at bottom, #1B2735 0%, #090A0F 100%) overflow: hidden #stars width: 1px height: 1px background: transparent box-shadow: $shadows-small animation : animStar 50s linear infinite &amp;:after content: &quot; &quot; position: absolute top: 2000px width: 1px height: 1px background: transparent box-shadow: $shadows-small #stars2 width: 2px height: 2px background: transparent box-shadow: $shadows-medium animation : animStar 100s linear infinite &amp;:after content: &quot; &quot; position: absolute top: 2000px width: 2px height: 2px background: transparent box-shadow: $shadows-medium #stars3 width: 3px height: 3px background: transparent box-shadow: $shadows-big animation : animStar 150s linear infinite &amp;:after content: &quot; &quot; position: absolute top: 2000px width: 3px height: 3px background: transparent box-shadow: $shadows-big#title position: absolute top: 50% left: 0 right: 0 color: #FFF text-align: center font-family: &apos;lato&apos;,sans-serif font-weight: 300 font-size: 50px letter-spacing: 10px margin-top: -60px padding-left: 10px span background: -webkit-linear-gradient(white, #38495a) -webkit-background-clip: text -webkit-text-fill-color: transparent @keyframes animStar from transform: translateY(0px) to transform: translateY(-2000px) csshtml &#123; height: 100%; background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%); overflow: hidden;&#125;#stars &#123; width: 1px; height: 1px; background: transparent; box-shadow: 1747px 1720px #FFF , 1693px 439px #FFF , 699px 1744px #FFF , 180px 479px #FFF , 379px 729px #FFF , 1294px 910px #FFF , 479px 1860px #FFF , 270px 1211px #FFF , 252px 1651px #FFF , 472px 1251px #FFF , 1650px 235px #FFF , 311px 1770px #FFF , 1469px 984px #FFF , 1349px 1839px #FFF , 525px 958px #FFF , 753px 1748px #FFF , 753px 1299px #FFF , 530px 489px #FFF , 1574px 311px #FFF , 760px 76px #FFF , 774px 837px #FFF , 1505px 1499px #FFF , 18px 512px #FFF , 1587px 1312px #FFF , 1072px 753px #FFF , 911px 866px #FFF , 1217px 1280px #FFF , 226px 958px #FFF , 1021px 149px #FFF , 1129px 1781px #FFF , 976px 1354px #FFF , 12px 1248px #FFF , 1816px 1631px #FFF , 178px 1185px #FFF , 628px 962px #FFF , 1806px 315px #FFF , 667px 1436px #FFF , 1133px 1304px #FFF , 1539px 661px #FFF , 342px 148px #FFF , 138px 332px #FFF , 1928px 612px #FFF , 434px 970px #FFF , 577px 456px #FFF , 1132px 892px #FFF , 1880px 1680px #FFF , 1524px 268px #FFF , 1406px 1375px #FFF , 747px 726px #FFF , 1016px 523px #FFF , 1996px 1063px #FFF , 1128px 595px #FFF , 177px 1792px #FFF , 1430px 477px #FFF , 949px 334px #FFF , 486px 1949px #FFF , 1958px 170px #FFF , 1899px 1870px #FFF , 1105px 208px #FFF , 271px 719px #FFF , 822px 598px #FFF , 409px 1398px #FFF , 345px 607px #FFF , 160px 156px #FFF , 946px 522px #FFF , 1796px 1680px #FFF , 1896px 1125px #FFF , 1731px 1802px #FFF , 1147px 503px #FFF , 525px 1562px #FFF , 1791px 1266px #FFF , 1650px 312px #FFF , 102px 1586px #FFF , 1885px 1314px #FFF , 781px 1403px #FFF , 901px 1566px #FFF , 1934px 1761px #FFF , 767px 646px #FFF , 797px 1990px #FFF , 486px 889px #FFF , 1165px 1607px #FFF , 940px 1092px #FFF , 821px 957px #FFF , 1563px 1793px #FFF , 83px 498px #FFF , 1246px 492px #FFF , 80px 956px #FFF , 1137px 1795px #FFF , 1365px 1816px #FFF , 549px 1650px #FFF , 1645px 1758px #FFF , 244px 1543px #FFF , 1941px 325px #FFF , 1347px 1608px #FFF , 409px 433px #FFF , 1364px 552px #FFF , 264px 1839px #FFF , 1610px 581px #FFF , 1225px 1386px #FFF , 763px 1077px #FFF , 1442px 1362px #FFF , 1152px 794px #FFF , 191px 1980px #FFF , 1537px 281px #FFF , 819px 749px #FFF , 1906px 1489px #FFF , 529px 1711px #FFF , 272px 910px #FFF , 26px 768px #FFF , 1702px 1887px #FFF , 531px 1236px #FFF , 1911px 11px #FFF , 875px 544px #FFF , 1340px 443px #FFF , 350px 343px #FFF , 368px 1663px #FFF , 1761px 671px #FFF , 1246px 1936px #FFF , 1927px 1611px #FFF , 1630px 1003px #FFF , 1602px 722px #FFF , 544px 178px #FFF , 1680px 994px #FFF , 1466px 296px #FFF , 1192px 1239px #FFF , 1864px 1361px #FFF , 503px 153px #FFF , 1778px 1652px #FFF , 1830px 513px #FFF , 360px 236px #FFF , 357px 1252px #FFF , 127px 847px #FFF , 1729px 1178px #FFF , 237px 1815px #FFF , 608px 108px #FFF , 1869px 1657px #FFF , 1864px 664px #FFF , 108px 175px #FFF , 807px 851px #FFF , 1031px 645px #FFF , 1322px 16px #FFF , 285px 154px #FFF , 414px 404px #FFF , 1750px 385px #FFF , 450px 579px #FFF , 1515px 546px #FFF , 915px 1198px #FFF , 921px 1940px #FFF , 234px 80px #FFF , 1790px 1079px #FFF , 1270px 1768px #FFF , 1680px 587px #FFF , 612px 400px #FFF , 1150px 1336px #FFF , 568px 776px #FFF , 839px 1939px #FFF , 1565px 267px #FFF , 294px 1855px #FFF , 524px 364px #FFF , 734px 789px #FFF , 1979px 1049px #FFF , 1353px 410px #FFF , 1016px 438px #FFF , 255px 1707px #FFF , 1699px 580px #FFF , 1812px 1261px #FFF , 84px 481px #FFF , 921px 863px #FFF , 113px 228px #FFF , 980px 806px #FFF , 920px 845px #FFF , 1933px 623px #FFF , 1744px 1304px #FFF , 148px 40px #FFF , 1732px 1292px #FFF , 1487px 1736px #FFF , 1123px 189px #FFF , 555px 1290px #FFF , 1293px 1629px #FFF , 1034px 521px #FFF , 1573px 1332px #FFF , 1679px 1906px #FFF , 1834px 1062px #FFF , 802px 1374px #FFF , 863px 66px #FFF , 660px 1260px #FFF , 1714px 1012px #FFF , 1698px 964px #FFF , 260px 626px #FFF , 402px 1064px #FFF , 621px 1517px #FFF , 989px 822px #FFF , 751px 29px #FFF , 1342px 1655px #FFF , 1314px 389px #FFF , 807px 1137px #FFF , 1820px 831px #FFF , 394px 658px #FFF , 1234px 562px #FFF , 612px 1674px #FFF , 180px 836px #FFF , 1291px 506px #FFF , 1936px 480px #FFF , 970px 1767px #FFF , 1066px 1142px #FFF , 351px 1465px #FFF , 1446px 1909px #FFF , 254px 306px #FFF , 1969px 1642px #FFF , 269px 404px #FFF , 838px 98px #FFF , 1794px 1243px #FFF , 1030px 1033px #FFF , 962px 1694px #FFF , 284px 497px #FFF , 109px 1796px #FFF , 1897px 592px #FFF , 1108px 1186px #FFF , 1464px 990px #FFF , 329px 1595px #FFF , 1524px 1046px #FFF , 454px 280px #FFF , 248px 493px #FFF , 1778px 1145px #FFF , 865px 1223px #FFF , 1045px 57px #FFF , 777px 128px #FFF , 1929px 565px #FFF , 880px 1923px #FFF , 1555px 20px #FFF , 140px 400px #FFF , 214px 26px #FFF , 1986px 182px #FFF , 588px 659px #FFF , 531px 1025px #FFF , 1503px 448px #FFF , 1437px 816px #FFF , 171px 1652px #FFF , 416px 1692px #FFF , 21px 1457px #FFF , 135px 1158px #FFF , 828px 499px #FFF , 1748px 666px #FFF , 749px 549px #FFF , 320px 1241px #FFF , 1718px 624px #FFF , 287px 935px #FFF , 739px 397px #FFF , 1319px 1371px #FFF , 1257px 1186px #FFF , 46px 1278px #FFF , 1826px 1073px #FFF , 1530px 1720px #FFF , 1302px 548px #FFF , 1411px 550px #FFF , 700px 615px #FFF , 404px 1006px #FFF , 1119px 1467px #FFF , 1154px 1330px #FFF , 1585px 248px #FFF , 1080px 671px #FFF , 219px 1195px #FFF , 903px 584px #FFF , 711px 1244px #FFF , 730px 1427px #FFF , 1891px 1491px #FFF , 1936px 1196px #FFF , 1605px 140px #FFF , 384px 194px #FFF , 148px 394px #FFF , 837px 1028px #FFF , 1949px 1981px #FFF , 159px 1530px #FFF , 1763px 1244px #FFF , 713px 1187px #FFF , 1356px 766px #FFF , 387px 280px #FFF , 18px 240px #FFF , 42px 840px #FFF , 1178px 253px #FFF , 1075px 1392px #FFF , 1944px 1639px #FFF , 748px 178px #FFF , 1952px 1310px #FFF , 1918px 1612px #FFF , 557px 755px #FFF , 993px 1080px #FFF , 192px 1863px #FFF , 489px 1175px #FFF , 647px 105px #FFF , 498px 1477px #FFF , 1398px 1548px #FFF , 821px 980px #FFF , 1412px 347px #FFF , 291px 755px #FFF , 953px 232px #FFF , 681px 20px #FFF , 261px 391px #FFF , 256px 1048px #FFF , 876px 1530px #FFF , 1003px 1213px #FFF , 1626px 940px #FFF , 1778px 1974px #FFF , 767px 1944px #FFF , 721px 673px #FFF , 714px 394px #FFF , 1284px 629px #FFF , 1813px 1464px #FFF , 222px 465px #FFF , 544px 1980px #FFF , 935px 542px #FFF , 331px 1468px #FFF , 1173px 1095px #FFF , 29px 1107px #FFF , 1810px 715px #FFF , 479px 1476px #FFF , 1801px 1739px #FFF , 1989px 599px #FFF , 1656px 1744px #FFF , 1117px 1377px #FFF , 1757px 800px #FFF , 373px 1151px #FFF , 1001px 64px #FFF , 1828px 1355px #FFF , 1493px 1243px #FFF , 176px 497px #FFF , 683px 1634px #FFF , 1120px 659px #FFF , 648px 1643px #FFF , 1281px 347px #FFF , 105px 1309px #FFF , 77px 1335px #FFF , 667px 1892px #FFF , 868px 1783px #FFF , 319px 1180px #FFF , 860px 1263px #FFF , 447px 916px #FFF , 723px 402px #FFF , 875px 283px #FFF , 1330px 1083px #FFF , 1175px 819px #FFF , 667px 1469px #FFF , 680px 371px #FFF , 1357px 1235px #FFF , 1223px 1701px #FFF , 1452px 1322px #FFF , 32px 882px #FFF , 1545px 407px #FFF , 1924px 1404px #FFF , 1846px 1390px #FFF , 216px 1421px #FFF , 1421px 1584px #FFF , 1167px 1901px #FFF , 276px 1756px #FFF , 714px 1856px #FFF , 359px 1199px #FFF , 1143px 1080px #FFF , 891px 635px #FFF , 579px 230px #FFF , 570px 676px #FFF , 1156px 1764px #FFF , 944px 1652px #FFF , 301px 666px #FFF , 209px 1005px #FFF , 460px 677px #FFF , 186px 1260px #FFF , 849px 284px #FFF , 240px 1059px #FFF , 953px 1959px #FFF , 783px 328px #FFF , 1794px 128px #FFF , 1884px 1051px #FFF , 842px 758px #FFF , 1848px 318px #FFF , 852px 348px #FFF , 1242px 1496px #FFF , 441px 712px #FFF , 1039px 113px #FFF , 1994px 749px #FFF , 1777px 1596px #FFF , 1471px 1817px #FFF , 1482px 1668px #FFF , 1837px 522px #FFF , 1272px 1285px #FFF , 751px 1669px #FFF , 104px 1968px #FFF , 1570px 400px #FFF , 1225px 1879px #FFF , 885px 1156px #FFF , 1392px 121px #FFF , 1754px 1477px #FFF , 251px 1060px #FFF , 1701px 547px #FFF , 1847px 114px #FFF , 1733px 1932px #FFF , 1178px 873px #FFF , 553px 191px #FFF , 1974px 1659px #FFF , 1155px 612px #FFF , 1509px 1533px #FFF , 1936px 1148px #FFF , 1708px 224px #FFF , 1358px 1235px #FFF , 293px 608px #FFF , 424px 639px #FFF , 347px 1944px #FFF , 1813px 243px #FFF , 150px 1042px #FFF , 36px 1533px #FFF , 1215px 64px #FFF , 1393px 730px #FFF , 567px 1509px #FFF , 1209px 1055px #FFF , 1969px 718px #FFF , 1458px 42px #FFF , 1494px 817px #FFF , 1863px 1290px #FFF , 1508px 1194px #FFF , 1607px 906px #FFF , 1371px 997px #FFF , 573px 871px #FFF , 1625px 1930px #FFF , 1422px 1835px #FFF , 1400px 1990px #FFF , 467px 1695px #FFF , 911px 1526px #FFF , 1745px 766px #FFF , 1016px 1602px #FFF , 1940px 1154px #FFF , 1468px 1035px #FFF , 1298px 992px #FFF , 874px 1589px #FFF , 1288px 721px #FFF , 1611px 905px #FFF , 569px 1548px #FFF , 1536px 1526px #FFF , 1668px 1903px #FFF , 267px 1053px #FFF , 1403px 4px #FFF , 1722px 91px #FFF , 863px 1904px #FFF , 120px 1878px #FFF , 21px 47px #FFF , 1384px 718px #FFF , 1000px 1523px #FFF , 1019px 1768px #FFF , 811px 209px #FFF , 950px 1763px #FFF , 504px 1011px #FFF , 420px 1424px #FFF , 1606px 747px #FFF , 1073px 9px #FFF , 860px 1731px #FFF , 473px 990px #FFF , 922px 1704px #FFF , 371px 15px #FFF , 821px 1243px #FFF , 423px 1259px #FFF , 1974px 1100px #FFF , 183px 615px #FFF , 1430px 6px #FFF , 909px 296px #FFF , 449px 251px #FFF , 953px 155px #FFF , 824px 706px #FFF , 1097px 429px #FFF , 1104px 260px #FFF , 271px 1851px #FFF , 1224px 1554px #FFF , 521px 1040px #FFF , 160px 1852px #FFF , 1564px 1782px #FFF , 320px 1490px #FFF , 1536px 741px #FFF , 236px 214px #FFF , 878px 1068px #FFF , 1698px 1752px #FFF , 1844px 799px #FFF , 55px 673px #FFF , 690px 1503px #FFF , 869px 1066px #FFF , 840px 204px #FFF , 214px 863px #FFF , 1315px 960px #FFF , 370px 1418px #FFF , 990px 1869px #FFF , 1560px 1981px #FFF , 66px 1315px #FFF , 834px 1874px #FFF , 1946px 1621px #FFF , 1062px 379px #FFF , 1688px 1972px #FFF , 526px 876px #FFF , 1121px 1353px #FFF , 1963px 1242px #FFF , 1456px 1033px #FFF , 486px 1617px #FFF , 582px 1325px #FFF , 312px 182px #FFF , 1815px 1006px #FFF , 513px 1826px #FFF , 173px 398px #FFF , 1892px 432px #FFF , 374px 432px #FFF , 645px 735px #FFF , 156px 1706px #FFF , 1596px 729px #FFF , 1661px 845px #FFF , 831px 561px #FFF , 966px 1432px #FFF , 227px 387px #FFF , 1088px 1804px #FFF , 972px 594px #FFF , 367px 1189px #FFF , 1527px 1909px #FFF , 1240px 290px #FFF , 676px 1729px #FFF , 1182px 1631px #FFF , 200px 423px #FFF , 1511px 1083px #FFF , 378px 1487px #FFF , 1876px 613px #FFF , 432px 696px #FFF , 1472px 32px #FFF , 691px 1422px #FFF , 666px 67px #FFF , 1280px 333px #FFF , 35px 843px #FFF , 803px 384px #FFF , 1272px 359px #FFF , 1074px 397px #FFF , 1757px 100px #FFF , 1391px 360px #FFF , 1601px 1885px #FFF , 1277px 1009px #FFF , 1025px 626px #FFF , 1262px 1473px #FFF , 1179px 941px #FFF , 1630px 722px #FFF , 1318px 234px #FFF , 235px 1211px #FFF , 637px 1605px #FFF , 648px 138px #FFF , 718px 391px #FFF , 893px 1863px #FFF , 993px 359px #FFF , 656px 1583px #FFF , 1285px 12px #FFF , 762px 1806px #FFF , 1164px 1280px #FFF , 1528px 170px #FFF , 67px 82px #FFF , 214px 1047px #FFF , 1926px 1683px #FFF , 1701px 609px #FFF , 862px 1939px #FFF , 175px 364px #FFF , 976px 1183px #FFF , 1011px 100px #FFF , 1967px 1252px #FFF , 327px 77px #FFF , 1044px 681px #FFF , 801px 1912px #FFF , 1633px 1110px #FFF , 1691px 925px #FFF , 342px 148px #FFF , 619px 119px #FFF , 1717px 1051px #FFF , 923px 1804px #FFF , 1504px 1465px #FFF , 1027px 1205px #FFF , 1086px 1662px #FFF , 605px 763px #FFF , 978px 624px #FFF , 551px 1242px #FFF , 1248px 297px #FFF , 676px 1534px #FFF , 1713px 1868px #FFF , 1684px 915px #FFF , 1657px 952px #FFF , 168px 556px #FFF , 1573px 481px #FFF , 213px 1525px #FFF , 203px 780px #FFF , 1718px 265px #FFF , 23px 676px #FFF , 1367px 394px #FFF , 651px 1047px #FFF , 445px 1194px #FFF , 1483px 1439px #FFF , 1669px 1499px #FFF , 1499px 1596px #FFF , 222px 1154px #FFF , 1044px 918px #FFF , 642px 1615px #FFF , 1158px 847px #FFF , 1553px 1546px #FFF , 1527px 486px #FFF , 355px 1464px #FFF , 1991px 494px #FFF , 271px 1958px #FFF , 601px 543px #FFF , 1217px 1684px #FFF , 1150px 1526px #FFF , 1875px 1843px #FFF , 1857px 1106px #FFF , 1957px 1456px #FFF , 698px 558px #FFF , 1700px 1333px #FFF , 808px 965px #FFF , 1654px 407px #FFF , 1649px 547px #FFF , 1862px 946px #FFF , 38px 808px #FFF , 1254px 578px #FFF , 1991px 243px #FFF , 363px 76px #FFF , 111px 1093px #FFF , 1096px 1390px #FFF , 1449px 1545px #FFF , 210px 576px #FFF , 321px 718px #FFF , 1434px 662px #FFF , 140px 895px #FFF , 510px 330px #FFF , 589px 1522px #FFF , 720px 1862px #FFF , 138px 1195px #FFF , 819px 319px #FFF , 814px 1434px #FFF , 1440px 274px #FFF , 795px 607px #FFF , 1860px 1988px #FFF , 1085px 204px #FFF , 394px 1151px #FFF , 1247px 870px #FFF , 189px 1638px #FFF , 384px 1430px #FFF , 1914px 895px #FFF , 48px 1777px #FFF , 242px 1378px #FFF , 343px 470px #FFF , 893px 1464px #FFF , 1818px 354px #FFF , 1260px 166px #FFF , 960px 1561px #FFF , 1072px 1416px #FFF , 835px 213px #FFF , 643px 1197px #FFF , 1257px 1319px #FFF , 508px 835px #FFF , 1568px 901px #FFF , 619px 233px #FFF , 495px 716px #FFF , 551px 1869px #FFF , 1275px 1694px #FFF , 1676px 302px #FFF , 524px 300px #FFF , 802px 1436px #FFF , 520px 1347px #FFF , 511px 1722px #FFF , 1640px 1315px #FFF , 825px 886px #FFF , 795px 1081px #FFF , 1297px 672px #FFF , 413px 1087px #FFF , 330px 168px #FFF , 745px 1783px #FFF , 275px 1856px #FFF , 1312px 1284px #FFF , 582px 1939px #FFF , 1647px 1252px #FFF , 1856px 794px #FFF , 663px 1882px #FFF , 949px 956px #FFF , 1422px 1791px #FFF , 233px 52px #FFF , 139px 1133px #FFF , 1057px 1972px #FFF , 1602px 861px #FFF , 1402px 713px #FFF , 974px 862px #FFF , 1341px 1705px #FFF , 1987px 1598px #FFF , 221px 482px #FFF , 1080px 1117px #FFF , 1589px 34px #FFF , 852px 960px #FFF , 1939px 253px #FFF , 1349px 566px #FFF , 1363px 1296px #FFF , 136px 1080px #FFF , 606px 1376px #FFF , 609px 522px #FFF , 939px 633px #FFF , 852px 1967px #FFF , 1340px 1519px #FFF , 141px 1061px #FFF , 123px 1427px #FFF , 1075px 573px #FFF; animation: animStar 50s linear infinite;&#125;#stars:after &#123; content: " "; position: absolute; top: 2000px; width: 1px; height: 1px; background: transparent; box-shadow: 1747px 1720px #FFF , 1693px 439px #FFF , 699px 1744px #FFF , 180px 479px #FFF , 379px 729px #FFF , 1294px 910px #FFF , 479px 1860px #FFF , 270px 1211px #FFF , 252px 1651px #FFF , 472px 1251px #FFF , 1650px 235px #FFF , 311px 1770px #FFF , 1469px 984px #FFF , 1349px 1839px #FFF , 525px 958px #FFF , 753px 1748px #FFF , 753px 1299px #FFF , 530px 489px #FFF , 1574px 311px #FFF , 760px 76px #FFF , 774px 837px #FFF , 1505px 1499px #FFF , 18px 512px #FFF , 1587px 1312px #FFF , 1072px 753px #FFF , 911px 866px #FFF , 1217px 1280px #FFF , 226px 958px #FFF , 1021px 149px #FFF , 1129px 1781px #FFF , 976px 1354px #FFF , 12px 1248px #FFF , 1816px 1631px #FFF , 178px 1185px #FFF , 628px 962px #FFF , 1806px 315px #FFF , 667px 1436px #FFF , 1133px 1304px #FFF , 1539px 661px #FFF , 342px 148px #FFF , 138px 332px #FFF , 1928px 612px #FFF , 434px 970px #FFF , 577px 456px #FFF , 1132px 892px #FFF , 1880px 1680px #FFF , 1524px 268px #FFF , 1406px 1375px #FFF , 747px 726px #FFF , 1016px 523px #FFF , 1996px 1063px #FFF , 1128px 595px #FFF , 177px 1792px #FFF , 1430px 477px #FFF , 949px 334px #FFF , 486px 1949px #FFF , 1958px 170px #FFF , 1899px 1870px #FFF , 1105px 208px #FFF , 271px 719px #FFF , 822px 598px #FFF , 409px 1398px #FFF , 345px 607px #FFF , 160px 156px #FFF , 946px 522px #FFF , 1796px 1680px #FFF , 1896px 1125px #FFF , 1731px 1802px #FFF , 1147px 503px #FFF , 525px 1562px #FFF , 1791px 1266px #FFF , 1650px 312px #FFF , 102px 1586px #FFF , 1885px 1314px #FFF , 781px 1403px #FFF , 901px 1566px #FFF , 1934px 1761px #FFF , 767px 646px #FFF , 797px 1990px #FFF , 486px 889px #FFF , 1165px 1607px #FFF , 940px 1092px #FFF , 821px 957px #FFF , 1563px 1793px #FFF , 83px 498px #FFF , 1246px 492px #FFF , 80px 956px #FFF , 1137px 1795px #FFF , 1365px 1816px #FFF , 549px 1650px #FFF , 1645px 1758px #FFF , 244px 1543px #FFF , 1941px 325px #FFF , 1347px 1608px #FFF , 409px 433px #FFF , 1364px 552px #FFF , 264px 1839px #FFF , 1610px 581px #FFF , 1225px 1386px #FFF , 763px 1077px #FFF , 1442px 1362px #FFF , 1152px 794px #FFF , 191px 1980px #FFF , 1537px 281px #FFF , 819px 749px #FFF , 1906px 1489px #FFF , 529px 1711px #FFF , 272px 910px #FFF , 26px 768px #FFF , 1702px 1887px #FFF , 531px 1236px #FFF , 1911px 11px #FFF , 875px 544px #FFF , 1340px 443px #FFF , 350px 343px #FFF , 368px 1663px #FFF , 1761px 671px #FFF , 1246px 1936px #FFF , 1927px 1611px #FFF , 1630px 1003px #FFF , 1602px 722px #FFF , 544px 178px #FFF , 1680px 994px #FFF , 1466px 296px #FFF , 1192px 1239px #FFF , 1864px 1361px #FFF , 503px 153px #FFF , 1778px 1652px #FFF , 1830px 513px #FFF , 360px 236px #FFF , 357px 1252px #FFF , 127px 847px #FFF , 1729px 1178px #FFF , 237px 1815px #FFF , 608px 108px #FFF , 1869px 1657px #FFF , 1864px 664px #FFF , 108px 175px #FFF , 807px 851px #FFF , 1031px 645px #FFF , 1322px 16px #FFF , 285px 154px #FFF , 414px 404px #FFF , 1750px 385px #FFF , 450px 579px #FFF , 1515px 546px #FFF , 915px 1198px #FFF , 921px 1940px #FFF , 234px 80px #FFF , 1790px 1079px #FFF , 1270px 1768px #FFF , 1680px 587px #FFF , 612px 400px #FFF , 1150px 1336px #FFF , 568px 776px #FFF , 839px 1939px #FFF , 1565px 267px #FFF , 294px 1855px #FFF , 524px 364px #FFF , 734px 789px #FFF , 1979px 1049px #FFF , 1353px 410px #FFF , 1016px 438px #FFF , 255px 1707px #FFF , 1699px 580px #FFF , 1812px 1261px #FFF , 84px 481px #FFF , 921px 863px #FFF , 113px 228px #FFF , 980px 806px #FFF , 920px 845px #FFF , 1933px 623px #FFF , 1744px 1304px #FFF , 148px 40px #FFF , 1732px 1292px #FFF , 1487px 1736px #FFF , 1123px 189px #FFF , 555px 1290px #FFF , 1293px 1629px #FFF , 1034px 521px #FFF , 1573px 1332px #FFF , 1679px 1906px #FFF , 1834px 1062px #FFF , 802px 1374px #FFF , 863px 66px #FFF , 660px 1260px #FFF , 1714px 1012px #FFF , 1698px 964px #FFF , 260px 626px #FFF , 402px 1064px #FFF , 621px 1517px #FFF , 989px 822px #FFF , 751px 29px #FFF , 1342px 1655px #FFF , 1314px 389px #FFF , 807px 1137px #FFF , 1820px 831px #FFF , 394px 658px #FFF , 1234px 562px #FFF , 612px 1674px #FFF , 180px 836px #FFF , 1291px 506px #FFF , 1936px 480px #FFF , 970px 1767px #FFF , 1066px 1142px #FFF , 351px 1465px #FFF , 1446px 1909px #FFF , 254px 306px #FFF , 1969px 1642px #FFF , 269px 404px #FFF , 838px 98px #FFF , 1794px 1243px #FFF , 1030px 1033px #FFF , 962px 1694px #FFF , 284px 497px #FFF , 109px 1796px #FFF , 1897px 592px #FFF , 1108px 1186px #FFF , 1464px 990px #FFF , 329px 1595px #FFF , 1524px 1046px #FFF , 454px 280px #FFF , 248px 493px #FFF , 1778px 1145px #FFF , 865px 1223px #FFF , 1045px 57px #FFF , 777px 128px #FFF , 1929px 565px #FFF , 880px 1923px #FFF , 1555px 20px #FFF , 140px 400px #FFF , 214px 26px #FFF , 1986px 182px #FFF , 588px 659px #FFF , 531px 1025px #FFF , 1503px 448px #FFF , 1437px 816px #FFF , 171px 1652px #FFF , 416px 1692px #FFF , 21px 1457px #FFF , 135px 1158px #FFF , 828px 499px #FFF , 1748px 666px #FFF , 749px 549px #FFF , 320px 1241px #FFF , 1718px 624px #FFF , 287px 935px #FFF , 739px 397px #FFF , 1319px 1371px #FFF , 1257px 1186px #FFF , 46px 1278px #FFF , 1826px 1073px #FFF , 1530px 1720px #FFF , 1302px 548px #FFF , 1411px 550px #FFF , 700px 615px #FFF , 404px 1006px #FFF , 1119px 1467px #FFF , 1154px 1330px #FFF , 1585px 248px #FFF , 1080px 671px #FFF , 219px 1195px #FFF , 903px 584px #FFF , 711px 1244px #FFF , 730px 1427px #FFF , 1891px 1491px #FFF , 1936px 1196px #FFF , 1605px 140px #FFF , 384px 194px #FFF , 148px 394px #FFF , 837px 1028px #FFF , 1949px 1981px #FFF , 159px 1530px #FFF , 1763px 1244px #FFF , 713px 1187px #FFF , 1356px 766px #FFF , 387px 280px #FFF , 18px 240px #FFF , 42px 840px #FFF , 1178px 253px #FFF , 1075px 1392px #FFF , 1944px 1639px #FFF , 748px 178px #FFF , 1952px 1310px #FFF , 1918px 1612px #FFF , 557px 755px #FFF , 993px 1080px #FFF , 192px 1863px #FFF , 489px 1175px #FFF , 647px 105px #FFF , 498px 1477px #FFF , 1398px 1548px #FFF , 821px 980px #FFF , 1412px 347px #FFF , 291px 755px #FFF , 953px 232px #FFF , 681px 20px #FFF , 261px 391px #FFF , 256px 1048px #FFF , 876px 1530px #FFF , 1003px 1213px #FFF , 1626px 940px #FFF , 1778px 1974px #FFF , 767px 1944px #FFF , 721px 673px #FFF , 714px 394px #FFF , 1284px 629px #FFF , 1813px 1464px #FFF , 222px 465px #FFF , 544px 1980px #FFF , 935px 542px #FFF , 331px 1468px #FFF , 1173px 1095px #FFF , 29px 1107px #FFF , 1810px 715px #FFF , 479px 1476px #FFF , 1801px 1739px #FFF , 1989px 599px #FFF , 1656px 1744px #FFF , 1117px 1377px #FFF , 1757px 800px #FFF , 373px 1151px #FFF , 1001px 64px #FFF , 1828px 1355px #FFF , 1493px 1243px #FFF , 176px 497px #FFF , 683px 1634px #FFF , 1120px 659px #FFF , 648px 1643px #FFF , 1281px 347px #FFF , 105px 1309px #FFF , 77px 1335px #FFF , 667px 1892px #FFF , 868px 1783px #FFF , 319px 1180px #FFF , 860px 1263px #FFF , 447px 916px #FFF , 723px 402px #FFF , 875px 283px #FFF , 1330px 1083px #FFF , 1175px 819px #FFF , 667px 1469px #FFF , 680px 371px #FFF , 1357px 1235px #FFF , 1223px 1701px #FFF , 1452px 1322px #FFF , 32px 882px #FFF , 1545px 407px #FFF , 1924px 1404px #FFF , 1846px 1390px #FFF , 216px 1421px #FFF , 1421px 1584px #FFF , 1167px 1901px #FFF , 276px 1756px #FFF , 714px 1856px #FFF , 359px 1199px #FFF , 1143px 1080px #FFF , 891px 635px #FFF , 579px 230px #FFF , 570px 676px #FFF , 1156px 1764px #FFF , 944px 1652px #FFF , 301px 666px #FFF , 209px 1005px #FFF , 460px 677px #FFF , 186px 1260px #FFF , 849px 284px #FFF , 240px 1059px #FFF , 953px 1959px #FFF , 783px 328px #FFF , 1794px 128px #FFF , 1884px 1051px #FFF , 842px 758px #FFF , 1848px 318px #FFF , 852px 348px #FFF , 1242px 1496px #FFF , 441px 712px #FFF , 1039px 113px #FFF , 1994px 749px #FFF , 1777px 1596px #FFF , 1471px 1817px #FFF , 1482px 1668px #FFF , 1837px 522px #FFF , 1272px 1285px #FFF , 751px 1669px #FFF , 104px 1968px #FFF , 1570px 400px #FFF , 1225px 1879px #FFF , 885px 1156px #FFF , 1392px 121px #FFF , 1754px 1477px #FFF , 251px 1060px #FFF , 1701px 547px #FFF , 1847px 114px #FFF , 1733px 1932px #FFF , 1178px 873px #FFF , 553px 191px #FFF , 1974px 1659px #FFF , 1155px 612px #FFF , 1509px 1533px #FFF , 1936px 1148px #FFF , 1708px 224px #FFF , 1358px 1235px #FFF , 293px 608px #FFF , 424px 639px #FFF , 347px 1944px #FFF , 1813px 243px #FFF , 150px 1042px #FFF , 36px 1533px #FFF , 1215px 64px #FFF , 1393px 730px #FFF , 567px 1509px #FFF , 1209px 1055px #FFF , 1969px 718px #FFF , 1458px 42px #FFF , 1494px 817px #FFF , 1863px 1290px #FFF , 1508px 1194px #FFF , 1607px 906px #FFF , 1371px 997px #FFF , 573px 871px #FFF , 1625px 1930px #FFF , 1422px 1835px #FFF , 1400px 1990px #FFF , 467px 1695px #FFF , 911px 1526px #FFF , 1745px 766px #FFF , 1016px 1602px #FFF , 1940px 1154px #FFF , 1468px 1035px #FFF , 1298px 992px #FFF , 874px 1589px #FFF , 1288px 721px #FFF , 1611px 905px #FFF , 569px 1548px #FFF , 1536px 1526px #FFF , 1668px 1903px #FFF , 267px 1053px #FFF , 1403px 4px #FFF , 1722px 91px #FFF , 863px 1904px #FFF , 120px 1878px #FFF , 21px 47px #FFF , 1384px 718px #FFF , 1000px 1523px #FFF , 1019px 1768px #FFF , 811px 209px #FFF , 950px 1763px #FFF , 504px 1011px #FFF , 420px 1424px #FFF , 1606px 747px #FFF , 1073px 9px #FFF , 860px 1731px #FFF , 473px 990px #FFF , 922px 1704px #FFF , 371px 15px #FFF , 821px 1243px #FFF , 423px 1259px #FFF , 1974px 1100px #FFF , 183px 615px #FFF , 1430px 6px #FFF , 909px 296px #FFF , 449px 251px #FFF , 953px 155px #FFF , 824px 706px #FFF , 1097px 429px #FFF , 1104px 260px #FFF , 271px 1851px #FFF , 1224px 1554px #FFF , 521px 1040px #FFF , 160px 1852px #FFF , 1564px 1782px #FFF , 320px 1490px #FFF , 1536px 741px #FFF , 236px 214px #FFF , 878px 1068px #FFF , 1698px 1752px #FFF , 1844px 799px #FFF , 55px 673px #FFF , 690px 1503px #FFF , 869px 1066px #FFF , 840px 204px #FFF , 214px 863px #FFF , 1315px 960px #FFF , 370px 1418px #FFF , 990px 1869px #FFF , 1560px 1981px #FFF , 66px 1315px #FFF , 834px 1874px #FFF , 1946px 1621px #FFF , 1062px 379px #FFF , 1688px 1972px #FFF , 526px 876px #FFF , 1121px 1353px #FFF , 1963px 1242px #FFF , 1456px 1033px #FFF , 486px 1617px #FFF , 582px 1325px #FFF , 312px 182px #FFF , 1815px 1006px #FFF , 513px 1826px #FFF , 173px 398px #FFF , 1892px 432px #FFF , 374px 432px #FFF , 645px 735px #FFF , 156px 1706px #FFF , 1596px 729px #FFF , 1661px 845px #FFF , 831px 561px #FFF , 966px 1432px #FFF , 227px 387px #FFF , 1088px 1804px #FFF , 972px 594px #FFF , 367px 1189px #FFF , 1527px 1909px #FFF , 1240px 290px #FFF , 676px 1729px #FFF , 1182px 1631px #FFF , 200px 423px #FFF , 1511px 1083px #FFF , 378px 1487px #FFF , 1876px 613px #FFF , 432px 696px #FFF , 1472px 32px #FFF , 691px 1422px #FFF , 666px 67px #FFF , 1280px 333px #FFF , 35px 843px #FFF , 803px 384px #FFF , 1272px 359px #FFF , 1074px 397px #FFF , 1757px 100px #FFF , 1391px 360px #FFF , 1601px 1885px #FFF , 1277px 1009px #FFF , 1025px 626px #FFF , 1262px 1473px #FFF , 1179px 941px #FFF , 1630px 722px #FFF , 1318px 234px #FFF , 235px 1211px #FFF , 637px 1605px #FFF , 648px 138px #FFF , 718px 391px #FFF , 893px 1863px #FFF , 993px 359px #FFF , 656px 1583px #FFF , 1285px 12px #FFF , 762px 1806px #FFF , 1164px 1280px #FFF , 1528px 170px #FFF , 67px 82px #FFF , 214px 1047px #FFF , 1926px 1683px #FFF , 1701px 609px #FFF , 862px 1939px #FFF , 175px 364px #FFF , 976px 1183px #FFF , 1011px 100px #FFF , 1967px 1252px #FFF , 327px 77px #FFF , 1044px 681px #FFF , 801px 1912px #FFF , 1633px 1110px #FFF , 1691px 925px #FFF , 342px 148px #FFF , 619px 119px #FFF , 1717px 1051px #FFF , 923px 1804px #FFF , 1504px 1465px #FFF , 1027px 1205px #FFF , 1086px 1662px #FFF , 605px 763px #FFF , 978px 624px #FFF , 551px 1242px #FFF , 1248px 297px #FFF , 676px 1534px #FFF , 1713px 1868px #FFF , 1684px 915px #FFF , 1657px 952px #FFF , 168px 556px #FFF , 1573px 481px #FFF , 213px 1525px #FFF , 203px 780px #FFF , 1718px 265px #FFF , 23px 676px #FFF , 1367px 394px #FFF , 651px 1047px #FFF , 445px 1194px #FFF , 1483px 1439px #FFF , 1669px 1499px #FFF , 1499px 1596px #FFF , 222px 1154px #FFF , 1044px 918px #FFF , 642px 1615px #FFF , 1158px 847px #FFF , 1553px 1546px #FFF , 1527px 486px #FFF , 355px 1464px #FFF , 1991px 494px #FFF , 271px 1958px #FFF , 601px 543px #FFF , 1217px 1684px #FFF , 1150px 1526px #FFF , 1875px 1843px #FFF , 1857px 1106px #FFF , 1957px 1456px #FFF , 698px 558px #FFF , 1700px 1333px #FFF , 808px 965px #FFF , 1654px 407px #FFF , 1649px 547px #FFF , 1862px 946px #FFF , 38px 808px #FFF , 1254px 578px #FFF , 1991px 243px #FFF , 363px 76px #FFF , 111px 1093px #FFF , 1096px 1390px #FFF , 1449px 1545px #FFF , 210px 576px #FFF , 321px 718px #FFF , 1434px 662px #FFF , 140px 895px #FFF , 510px 330px #FFF , 589px 1522px #FFF , 720px 1862px #FFF , 138px 1195px #FFF , 819px 319px #FFF , 814px 1434px #FFF , 1440px 274px #FFF , 795px 607px #FFF , 1860px 1988px #FFF , 1085px 204px #FFF , 394px 1151px #FFF , 1247px 870px #FFF , 189px 1638px #FFF , 384px 1430px #FFF , 1914px 895px #FFF , 48px 1777px #FFF , 242px 1378px #FFF , 343px 470px #FFF , 893px 1464px #FFF , 1818px 354px #FFF , 1260px 166px #FFF , 960px 1561px #FFF , 1072px 1416px #FFF , 835px 213px #FFF , 643px 1197px #FFF , 1257px 1319px #FFF , 508px 835px #FFF , 1568px 901px #FFF , 619px 233px #FFF , 495px 716px #FFF , 551px 1869px #FFF , 1275px 1694px #FFF , 1676px 302px #FFF , 524px 300px #FFF , 802px 1436px #FFF , 520px 1347px #FFF , 511px 1722px #FFF , 1640px 1315px #FFF , 825px 886px #FFF , 795px 1081px #FFF , 1297px 672px #FFF , 413px 1087px #FFF , 330px 168px #FFF , 745px 1783px #FFF , 275px 1856px #FFF , 1312px 1284px #FFF , 582px 1939px #FFF , 1647px 1252px #FFF , 1856px 794px #FFF , 663px 1882px #FFF , 949px 956px #FFF , 1422px 1791px #FFF , 233px 52px #FFF , 139px 1133px #FFF , 1057px 1972px #FFF , 1602px 861px #FFF , 1402px 713px #FFF , 974px 862px #FFF , 1341px 1705px #FFF , 1987px 1598px #FFF , 221px 482px #FFF , 1080px 1117px #FFF , 1589px 34px #FFF , 852px 960px #FFF , 1939px 253px #FFF , 1349px 566px #FFF , 1363px 1296px #FFF , 136px 1080px #FFF , 606px 1376px #FFF , 609px 522px #FFF , 939px 633px #FFF , 852px 1967px #FFF , 1340px 1519px #FFF , 141px 1061px #FFF , 123px 1427px #FFF , 1075px 573px #FFF;&#125;#stars2 &#123; width: 2px; height: 2px; background: transparent; box-shadow: 1211px 1949px #FFF , 222px 1526px #FFF , 499px 819px #FFF , 237px 1431px #FFF , 1794px 1914px #FFF , 461px 702px #FFF , 116px 1817px #FFF , 194px 695px #FFF , 1666px 172px #FFF , 1224px 1424px #FFF , 1823px 1249px #FFF , 1193px 1555px #FFF , 1922px 1440px #FFF , 1932px 58px #FFF , 1624px 1396px #FFF , 1179px 73px #FFF , 761px 189px #FFF , 1596px 703px #FFF , 1624px 290px #FFF , 1184px 837px #FFF , 752px 1347px #FFF , 1939px 1147px #FFF , 970px 887px #FFF , 37px 516px #FFF , 976px 172px #FFF , 801px 1813px #FFF , 216px 1615px #FFF , 12px 1764px #FFF , 549px 1914px #FFF , 958px 1200px #FFF , 70px 888px #FFF , 1856px 1524px #FFF , 1061px 1809px #FFF , 1101px 1084px #FFF , 1322px 87px #FFF , 344px 367px #FFF , 1821px 22px #FFF , 1923px 817px #FFF , 1520px 848px #FFF , 751px 1032px #FFF , 1089px 169px #FFF , 376px 381px #FFF , 692px 991px #FFF , 1569px 120px #FFF , 467px 429px #FFF , 1582px 778px #FFF , 785px 977px #FFF , 1744px 1519px #FFF , 874px 777px #FFF , 88px 1174px #FFF , 613px 1715px #FFF , 939px 1942px #FFF , 547px 1002px #FFF , 1244px 1453px #FFF , 1359px 1344px #FFF , 372px 421px #FFF , 612px 1736px #FFF , 1978px 1952px #FFF , 1154px 1256px #FFF , 1714px 1518px #FFF , 685px 361px #FFF , 1098px 1371px #FFF , 1916px 152px #FFF , 917px 700px #FFF , 191px 1498px #FFF , 811px 657px #FFF , 108px 1616px #FFF , 764px 619px #FFF , 844px 1480px #FFF , 1819px 626px #FFF , 743px 7px #FFF , 1718px 743px #FFF , 1437px 428px #FFF , 1935px 1865px #FFF , 1312px 1781px #FFF , 19px 636px #FFF , 271px 1445px #FFF , 1610px 1600px #FFF , 1148px 1897px #FFF , 1656px 673px #FFF , 814px 1143px #FFF , 422px 61px #FFF , 1624px 414px #FFF , 561px 245px #FFF , 1569px 417px #FFF , 1141px 223px #FFF , 971px 285px #FFF , 1680px 1586px #FFF , 1077px 421px #FFF , 1949px 1009px #FFF , 552px 561px #FFF , 1378px 264px #FFF , 181px 1355px #FFF , 700px 1680px #FFF , 896px 1650px #FFF , 194px 1369px #FFF , 1123px 619px #FFF , 788px 797px #FFF , 768px 1942px #FFF , 1957px 1718px #FFF , 817px 1013px #FFF , 1278px 1152px #FFF , 578px 1312px #FFF , 1730px 528px #FFF , 71px 1821px #FFF , 262px 1969px #FFF , 309px 452px #FFF , 621px 957px #FFF , 479px 1902px #FFF , 714px 67px #FFF , 1157px 1374px #FFF , 692px 366px #FFF , 1835px 763px #FFF , 393px 1990px #FFF , 1650px 121px #FFF , 1653px 208px #FFF , 700px 102px #FFF , 411px 1511px #FFF , 782px 1390px #FFF , 1032px 810px #FFF , 171px 1714px #FFF , 1943px 466px #FFF , 463px 463px #FFF , 881px 1706px #FFF , 1486px 1841px #FFF , 993px 433px #FFF , 1676px 1211px #FFF , 419px 1767px #FFF , 1998px 517px #FFF , 1013px 406px #FFF , 1207px 1036px #FFF , 449px 1399px #FFF , 902px 1484px #FFF , 1105px 1930px #FFF , 1063px 1932px #FFF , 88px 934px #FFF , 909px 614px #FFF , 1725px 384px #FFF , 1768px 1711px #FFF , 737px 387px #FFF , 222px 437px #FFF , 734px 907px #FFF , 263px 1000px #FFF , 361px 1216px #FFF , 541px 387px #FFF , 1136px 1045px #FFF , 1420px 1341px #FFF , 639px 1267px #FFF , 1750px 1572px #FFF , 1646px 1822px #FFF , 1849px 1298px #FFF , 1276px 780px #FFF , 902px 1207px #FFF , 297px 587px #FFF , 31px 633px #FFF , 554px 1471px #FFF , 1909px 729px #FFF , 679px 200px #FFF , 1095px 788px #FFF , 657px 600px #FFF , 1265px 1387px #FFF , 982px 707px #FFF , 881px 1664px #FFF , 618px 832px #FFF , 140px 1975px #FFF , 94px 1734px #FFF , 566px 1536px #FFF , 1183px 1180px #FFF , 20px 260px #FFF , 305px 1605px #FFF , 1835px 884px #FFF , 1591px 1415px #FFF , 1785px 1975px #FFF , 905px 229px #FFF , 1115px 273px #FFF , 1800px 1292px #FFF , 1787px 1928px #FFF , 895px 1561px #FFF , 1584px 104px #FFF , 1480px 1291px #FFF , 1714px 1681px #FFF , 1300px 1111px #FFF , 258px 72px #FFF , 1523px 1830px #FFF , 1313px 920px #FFF , 819px 1540px #FFF , 656px 260px #FFF , 1732px 1529px #FFF , 792px 1084px #FFF , 84px 803px #FFF , 1128px 224px #FFF , 1669px 1888px #FFF , 626px 129px #FFF , 1244px 1781px #FFF , 1107px 427px #FFF , 73px 759px #FFF , 336px 330px #FFF , 664px 338px #FFF , 977px 170px #FFF , 492px 1615px #FFF; animation: animStar 100s linear infinite;&#125;#stars2:after &#123; content: " "; position: absolute; top: 2000px; width: 2px; height: 2px; background: transparent; box-shadow: 1211px 1949px #FFF , 222px 1526px #FFF , 499px 819px #FFF , 237px 1431px #FFF , 1794px 1914px #FFF , 461px 702px #FFF , 116px 1817px #FFF , 194px 695px #FFF , 1666px 172px #FFF , 1224px 1424px #FFF , 1823px 1249px #FFF , 1193px 1555px #FFF , 1922px 1440px #FFF , 1932px 58px #FFF , 1624px 1396px #FFF , 1179px 73px #FFF , 761px 189px #FFF , 1596px 703px #FFF , 1624px 290px #FFF , 1184px 837px #FFF , 752px 1347px #FFF , 1939px 1147px #FFF , 970px 887px #FFF , 37px 516px #FFF , 976px 172px #FFF , 801px 1813px #FFF , 216px 1615px #FFF , 12px 1764px #FFF , 549px 1914px #FFF , 958px 1200px #FFF , 70px 888px #FFF , 1856px 1524px #FFF , 1061px 1809px #FFF , 1101px 1084px #FFF , 1322px 87px #FFF , 344px 367px #FFF , 1821px 22px #FFF , 1923px 817px #FFF , 1520px 848px #FFF , 751px 1032px #FFF , 1089px 169px #FFF , 376px 381px #FFF , 692px 991px #FFF , 1569px 120px #FFF , 467px 429px #FFF , 1582px 778px #FFF , 785px 977px #FFF , 1744px 1519px #FFF , 874px 777px #FFF , 88px 1174px #FFF , 613px 1715px #FFF , 939px 1942px #FFF , 547px 1002px #FFF , 1244px 1453px #FFF , 1359px 1344px #FFF , 372px 421px #FFF , 612px 1736px #FFF , 1978px 1952px #FFF , 1154px 1256px #FFF , 1714px 1518px #FFF , 685px 361px #FFF , 1098px 1371px #FFF , 1916px 152px #FFF , 917px 700px #FFF , 191px 1498px #FFF , 811px 657px #FFF , 108px 1616px #FFF , 764px 619px #FFF , 844px 1480px #FFF , 1819px 626px #FFF , 743px 7px #FFF , 1718px 743px #FFF , 1437px 428px #FFF , 1935px 1865px #FFF , 1312px 1781px #FFF , 19px 636px #FFF , 271px 1445px #FFF , 1610px 1600px #FFF , 1148px 1897px #FFF , 1656px 673px #FFF , 814px 1143px #FFF , 422px 61px #FFF , 1624px 414px #FFF , 561px 245px #FFF , 1569px 417px #FFF , 1141px 223px #FFF , 971px 285px #FFF , 1680px 1586px #FFF , 1077px 421px #FFF , 1949px 1009px #FFF , 552px 561px #FFF , 1378px 264px #FFF , 181px 1355px #FFF , 700px 1680px #FFF , 896px 1650px #FFF , 194px 1369px #FFF , 1123px 619px #FFF , 788px 797px #FFF , 768px 1942px #FFF , 1957px 1718px #FFF , 817px 1013px #FFF , 1278px 1152px #FFF , 578px 1312px #FFF , 1730px 528px #FFF , 71px 1821px #FFF , 262px 1969px #FFF , 309px 452px #FFF , 621px 957px #FFF , 479px 1902px #FFF , 714px 67px #FFF , 1157px 1374px #FFF , 692px 366px #FFF , 1835px 763px #FFF , 393px 1990px #FFF , 1650px 121px #FFF , 1653px 208px #FFF , 700px 102px #FFF , 411px 1511px #FFF , 782px 1390px #FFF , 1032px 810px #FFF , 171px 1714px #FFF , 1943px 466px #FFF , 463px 463px #FFF , 881px 1706px #FFF , 1486px 1841px #FFF , 993px 433px #FFF , 1676px 1211px #FFF , 419px 1767px #FFF , 1998px 517px #FFF , 1013px 406px #FFF , 1207px 1036px #FFF , 449px 1399px #FFF , 902px 1484px #FFF , 1105px 1930px #FFF , 1063px 1932px #FFF , 88px 934px #FFF , 909px 614px #FFF , 1725px 384px #FFF , 1768px 1711px #FFF , 737px 387px #FFF , 222px 437px #FFF , 734px 907px #FFF , 263px 1000px #FFF , 361px 1216px #FFF , 541px 387px #FFF , 1136px 1045px #FFF , 1420px 1341px #FFF , 639px 1267px #FFF , 1750px 1572px #FFF , 1646px 1822px #FFF , 1849px 1298px #FFF , 1276px 780px #FFF , 902px 1207px #FFF , 297px 587px #FFF , 31px 633px #FFF , 554px 1471px #FFF , 1909px 729px #FFF , 679px 200px #FFF , 1095px 788px #FFF , 657px 600px #FFF , 1265px 1387px #FFF , 982px 707px #FFF , 881px 1664px #FFF , 618px 832px #FFF , 140px 1975px #FFF , 94px 1734px #FFF , 566px 1536px #FFF , 1183px 1180px #FFF , 20px 260px #FFF , 305px 1605px #FFF , 1835px 884px #FFF , 1591px 1415px #FFF , 1785px 1975px #FFF , 905px 229px #FFF , 1115px 273px #FFF , 1800px 1292px #FFF , 1787px 1928px #FFF , 895px 1561px #FFF , 1584px 104px #FFF , 1480px 1291px #FFF , 1714px 1681px #FFF , 1300px 1111px #FFF , 258px 72px #FFF , 1523px 1830px #FFF , 1313px 920px #FFF , 819px 1540px #FFF , 656px 260px #FFF , 1732px 1529px #FFF , 792px 1084px #FFF , 84px 803px #FFF , 1128px 224px #FFF , 1669px 1888px #FFF , 626px 129px #FFF , 1244px 1781px #FFF , 1107px 427px #FFF , 73px 759px #FFF , 336px 330px #FFF , 664px 338px #FFF , 977px 170px #FFF , 492px 1615px #FFF;&#125;#stars3 &#123; width: 3px; height: 3px; background: transparent; box-shadow: 411px 162px #FFF , 1021px 667px #FFF , 904px 1844px #FFF , 581px 324px #FFF , 749px 1163px #FFF , 1091px 956px #FFF , 719px 1247px #FFF , 1030px 1103px #FFF , 290px 334px #FFF , 469px 1616px #FFF , 115px 875px #FFF , 758px 1198px #FFF , 535px 909px #FFF , 422px 334px #FFF , 820px 1579px #FFF , 1012px 867px #FFF , 1444px 1107px #FFF , 1447px 1351px #FFF , 636px 4px #FFF , 658px 1783px #FFF , 1655px 327px #FFF , 376px 1821px #FFF , 1618px 1076px #FFF , 40px 1501px #FFF , 313px 195px #FFF , 939px 1364px #FFF , 887px 1154px #FFF , 1422px 101px #FFF , 236px 1543px #FFF , 139px 864px #FFF , 756px 453px #FFF , 1525px 1430px #FFF , 1341px 1094px #FFF , 662px 251px #FFF , 544px 745px #FFF , 987px 251px #FFF , 382px 262px #FFF , 1055px 1641px #FFF , 1169px 1034px #FFF , 1095px 1022px #FFF , 1514px 526px #FFF , 1958px 1908px #FFF , 18px 1925px #FFF , 1912px 1250px #FFF , 1598px 513px #FFF , 335px 246px #FFF , 1358px 1347px #FFF , 1771px 1283px #FFF , 872px 692px #FFF , 71px 1426px #FFF , 1679px 1685px #FFF , 543px 141px #FFF , 923px 459px #FFF , 564px 1110px #FFF , 9px 622px #FFF , 423px 1583px #FFF , 1571px 555px #FFF , 1502px 879px #FFF , 1994px 944px #FFF , 608px 1837px #FFF , 1289px 1905px #FFF , 1885px 1332px #FFF , 1854px 1432px #FFF , 1453px 1115px #FFF , 461px 1883px #FFF , 619px 213px #FFF , 121px 1647px #FFF , 797px 1523px #FFF , 1885px 1534px #FFF , 183px 1660px #FFF , 1036px 227px #FFF , 1699px 1099px #FFF , 383px 1610px #FFF , 1109px 1542px #FFF , 1273px 582px #FFF , 1256px 1030px #FFF , 1897px 513px #FFF , 1737px 742px #FFF , 908px 1480px #FFF , 1119px 1237px #FFF , 1293px 1197px #FFF , 752px 1668px #FFF , 484px 1513px #FFF , 560px 378px #FFF , 1561px 373px #FFF , 952px 1450px #FFF , 273px 759px #FFF , 1655px 284px #FFF , 1536px 1987px #FFF , 833px 1900px #FFF , 1269px 660px #FFF , 858px 1708px #FFF , 1863px 1595px #FFF , 1984px 1053px #FFF , 1659px 771px #FFF , 1228px 1997px #FFF , 1707px 185px #FFF , 1634px 1153px #FFF , 1942px 664px #FFF , 841px 1967px #FFF; animation: animStar 150s linear infinite;&#125;#stars3:after &#123; content: " "; position: absolute; top: 2000px; width: 3px; height: 3px; background: transparent; box-shadow: 411px 162px #FFF , 1021px 667px #FFF , 904px 1844px #FFF , 581px 324px #FFF , 749px 1163px #FFF , 1091px 956px #FFF , 719px 1247px #FFF , 1030px 1103px #FFF , 290px 334px #FFF , 469px 1616px #FFF , 115px 875px #FFF , 758px 1198px #FFF , 535px 909px #FFF , 422px 334px #FFF , 820px 1579px #FFF , 1012px 867px #FFF , 1444px 1107px #FFF , 1447px 1351px #FFF , 636px 4px #FFF , 658px 1783px #FFF , 1655px 327px #FFF , 376px 1821px #FFF , 1618px 1076px #FFF , 40px 1501px #FFF , 313px 195px #FFF , 939px 1364px #FFF , 887px 1154px #FFF , 1422px 101px #FFF , 236px 1543px #FFF , 139px 864px #FFF , 756px 453px #FFF , 1525px 1430px #FFF , 1341px 1094px #FFF , 662px 251px #FFF , 544px 745px #FFF , 987px 251px #FFF , 382px 262px #FFF , 1055px 1641px #FFF , 1169px 1034px #FFF , 1095px 1022px #FFF , 1514px 526px #FFF , 1958px 1908px #FFF , 18px 1925px #FFF , 1912px 1250px #FFF , 1598px 513px #FFF , 335px 246px #FFF , 1358px 1347px #FFF , 1771px 1283px #FFF , 872px 692px #FFF , 71px 1426px #FFF , 1679px 1685px #FFF , 543px 141px #FFF , 923px 459px #FFF , 564px 1110px #FFF , 9px 622px #FFF , 423px 1583px #FFF , 1571px 555px #FFF , 1502px 879px #FFF , 1994px 944px #FFF , 608px 1837px #FFF , 1289px 1905px #FFF , 1885px 1332px #FFF , 1854px 1432px #FFF , 1453px 1115px #FFF , 461px 1883px #FFF , 619px 213px #FFF , 121px 1647px #FFF , 797px 1523px #FFF , 1885px 1534px #FFF , 183px 1660px #FFF , 1036px 227px #FFF , 1699px 1099px #FFF , 383px 1610px #FFF , 1109px 1542px #FFF , 1273px 582px #FFF , 1256px 1030px #FFF , 1897px 513px #FFF , 1737px 742px #FFF , 908px 1480px #FFF , 1119px 1237px #FFF , 1293px 1197px #FFF , 752px 1668px #FFF , 484px 1513px #FFF , 560px 378px #FFF , 1561px 373px #FFF , 952px 1450px #FFF , 273px 759px #FFF , 1655px 284px #FFF , 1536px 1987px #FFF , 833px 1900px #FFF , 1269px 660px #FFF , 858px 1708px #FFF , 1863px 1595px #FFF , 1984px 1053px #FFF , 1659px 771px #FFF , 1228px 1997px #FFF , 1707px 185px #FFF , 1634px 1153px #FFF , 1942px 664px #FFF , 841px 1967px #FFF;&#125;#title &#123; position: absolute; top: 50%; left: 0; right: 0; color: #FFF; text-align: center; font-family: "lato", sans-serif; font-weight: 300; font-size: 50px; letter-spacing: 10px; margin-top: -60px; padding-left: 10px;&#125;#title span &#123; background: -webkit-linear-gradient(white, #38495a); -webkit-background-clip: text; -webkit-text-fill-color: transparent;&#125;@keyframes animStar &#123; from &#123; transform: translateY(0px); &#125; to &#123; transform: translateY(-2000px); &#125;&#125;]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
      </tags>
  </entry>
</search>
