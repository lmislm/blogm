<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LMISLMのBlog</title>
  
  <subtitle>不积小流，无以成江海。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lmislm.com/"/>
  <updated>2019-08-15T14:22:25.348Z</updated>
  <id>http://lmislm.com/</id>
  
  <author>
    <name>lmislm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>day214-HTTP四次挥手</title>
    <link href="http://lmislm.com/2019/08/15/2019-08-15/"/>
    <id>http://lmislm.com/2019/08/15/2019-08-15/</id>
    <published>2019-08-14T16:00:00.000Z</published>
    <updated>2019-08-15T14:22:25.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>目的</li><li>过程<a id="more"></a></li></ol><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭，客户端或服务器均可主动发起挥手动作。</p><p>这个原则是当一方完成它的数据发送任务后就能发送标志位FIN来终止这个方向的连接。收到FIN=1只意味着这一方向上没有数据流动，一个TCP连接在收到FIN=1后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p><strong>第一次握手</strong> (FIN=1，seq=x)</p><p>假设客户端想要关闭连接，客户端发送标志位FIN为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p><p>发送完毕后，客户端进入<code>FIN_WAIT_1</code>状态。</p><p><strong>第二次握手</strong> (ACK=1，ACKnum=x+1)</p><p>服务器端确认客户端的 FIN 包，发送一个确认序号（ACKnum，又写做ack），表明已接收客户端关闭连接的请求，但还没有准备好关闭连接。</p><p>发送完毕后，服务器端进入<code>CLOSE_WAIT</code>状态。<br>客户端接收到这个确认序号后，进入<code>FIN_WAIT_2</code>状态，等待服务器端关闭连接。</p><p><strong>第三次握手</strong> (FIN=1，seq=y)</p><p>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。</p><p>发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。</p><p><strong>第四次挥手</strong> (ACK=1，ACKnum=y+1)</p><p>客户端接收到来自服务器端的关闭请求，发送一个确认序号，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。</p><p>服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</p><p><strong>最后</strong></p><p>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html" target="_blank" rel="noopener">三次握手</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;目的&lt;/li&gt;
&lt;li&gt;过程
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day214-HTTP三次握手</title>
    <link href="http://lmislm.com/2019/08/14/2019-08-14/"/>
    <id>http://lmislm.com/2019/08/14/2019-08-14/</id>
    <published>2019-08-13T16:00:00.000Z</published>
    <updated>2019-08-15T14:18:51.452Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>目的</li><li>名词</li><li>过程</li><li>疑问<a id="more"></a></li></ol><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>客户端连接服务端，建立TCP连接，交换窗口大小信息</p><h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><p><code>ISN(Initial Sequence Number)：</code>操作系统动态随机选取一个32位长的序列号，即初始序列号ISN。</p><p><code>SYN(SYNchronization)：</code>同步信号SYN，占用一个字节的编号。</p><p>在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。</p><p>对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。</p><p><code>ACKnum：</code>确认序号。Inform the sending host that the transmitted data was received successfully.</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p><strong>第一次握手</strong>（SYN=1, seq=x)</p><p>客户端发送，TCP的SYN标志位初始值为1的包，表明客户端向服务端发起连接。同时seq（ sequence numbers 序列号）包含ISN序列号x，保存在发送包序列号字段里。</p><p>发送完毕后，客户端进入<code>SYN_SEND</code>状态。</p><p><strong>第二次握手</strong>（SYN=1, seq=y, ACK=1, ACKnum=x+1）（注意ACKnum又写作ack）</p><p>服务器返回，SYN标志位和ACK标志位为1。服务端将ISN序列号放入Seq域，同时将ACKnum（Acknowledgement Number：确认序号）设置为客户端ISN序列号加1，即x+1。</p><p>发送完毕后，服务端进入<code>SYN_RCVD</code>状态。</p><p><strong>第三次握手</strong>（ACK=1，seq=x + 1，ACKnum=y+1）</p><p>客户端发送，SYN标志位为0，ACK标志位为1，将服务端的seq序号值加1，放入确认序号中，发送给服务端。</p><p>发送完毕后，客户端进入<code>ESTABLISHED</code>状态，服务端接收后，也进入ESTABLISHED状态。TCP三次握手结束</p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ol><li>为什么是三次握手不是两次握手？</li></ol><p>TCP 需要 seq 序列号来做可靠重传或接收，而避免连接复用时无法分辨出 seq 是延迟或者是旧链接的 seq。</p><blockquote><p>谢希仁版《计算机网络》：“已失效的连接请求报文段” 的产生在这样一种情况下：client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。”</p><ol start="2"><li>TCP 怎么样识别之前旧链接重发的包？</li></ol></blockquote><p>ISN（初始序列号）机制。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/24853633" target="_blank" rel="noopener">TCP 为什么是三次握手，而不是两次或四次？</a></p><p><a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html" target="_blank" rel="noopener">三次握手</a></p><p><a href="https://packetlife.net/blog/2010/jun/7/understanding-tcp-sequence-acknowledgment-numbers/" target="_blank" rel="noopener">Understanding TCP Sequence and Acknowledgment Numbers</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;目的&lt;/li&gt;
&lt;li&gt;名词&lt;/li&gt;
&lt;li&gt;过程&lt;/li&gt;
&lt;li&gt;疑问
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day213-DNS解析</title>
    <link href="http://lmislm.com/2019/08/13/2019-08-13/"/>
    <id>http://lmislm.com/2019/08/13/2019-08-13/</id>
    <published>2019-08-12T16:00:00.000Z</published>
    <updated>2019-08-13T15:24:04.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>DNS解析过程</li><li>DNS优化<a id="more"></a></li></ol><h2 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h2><p>DNS解析查IP过程：（以<a href="http://www.xxx.com为例）" target="_blank" rel="noopener">www.xxx.com为例）</a><br>过程：. -&gt; .com -&gt; xxx.com. -&gt; <a href="http://www.xxx.com" target="_blank" rel="noopener">www.xxx.com</a>.</p><ol><li>读取DNS缓存（缓存分为：浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存）</li><li>查找LDNS（本地区域名服务器，如果你在学校接入互联网，则 LDNS 服务器就在学校）。LDNS查询自己的DNS缓存，失败则进行DNS解析请求。</li><li>LDNS查找根域名服务器（<a href="http://www.xxx.com.，注意com后的“.”对应根域名服务器，默认都有，通常省略，但浏览器请求DNS时会自动加上" target="_blank" rel="noopener">www.xxx.com.，注意com后的“.”对应根域名服务器，默认都有，通常省略，但浏览器请求DNS时会自动加上</a>)</li><li>LDNS查找顶级域名服务器（COM域名服务器）</li><li>LDNS查找主域名服务器（xxx.com域名服务器），得到IP地址</li><li>LDNS将得到的IP地址，返回给操作系统，自己也存一份。</li></ol><h2 id="DNS优化"><a href="#DNS优化" class="headerlink" title="DNS优化"></a>DNS优化</h2><ol><li><p>缓存<br>主要有：浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存<br>浏览器缓存查看（Chrome版本75.0.3770.100为例）：<code>chrome://net-internals/#dns</code>。注：可以从<code>chrome://chrome-urls/</code>进去<br>系统缓存查看：（<code>/etc/hosts</code>，Linux系统）（<code>hosts</code>，Windows系统）</p></li><li><p>负载均衡<br>根据每台被请求的机器（含有请求资源）的负载量，该机器离用户地理位置的距离等等，来决定哪个机器处理，即负载均衡，又叫DNS重定向。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">前端经典面试题: 从输入URL到页面加载发生了什么？</a></p><p><a href="https://github.com/kaola-fed/blog/issues" target="_blank" rel="noopener">从输入页面地址到展示页面信息都发生了些什么？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;DNS解析过程&lt;/li&gt;
&lt;li&gt;DNS优化
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day212-localStorage、sessionStorage、Cookie</title>
    <link href="http://lmislm.com/2019/08/12/2019-08-12/"/>
    <id>http://lmislm.com/2019/08/12/2019-08-12/</id>
    <published>2019-08-11T16:00:00.000Z</published>
    <updated>2019-08-12T15:45:12.351Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>三者异同</li><li>三者的基本概念<a id="more"></a></li></ol><h2 id="三者异同"><a href="#三者异同" class="headerlink" title="三者异同"></a>三者异同</h2><table><thead><tr><th>特性</th><th>Cookie</th><th>localStorage</th><th>sessionStorage</th></tr></thead><tbody><tr><td>生命周期</td><td>可由服务器生成，可设置过期时间。如果在浏览器端生成Cookie，默认是关闭浏览器后清除</td><td>除非被清除，否则永久保存</td><td>仅在当前会话下有效，关闭页面或浏览器后被清除</td></tr><tr><td>可存放数据大小</td><td>4K左右</td><td>5MB左右</td><td>5MB左右</td></tr><tr><td>与服务器端通信</td><td>携带在HTTP头中</td><td>不与服务器端通信，仅仅在浏览器中保存</td><td>不与服务器端通信，仅仅在浏览器中保存</td></tr><tr><td>易用性</td><td>接口不友好</td><td>相对较容易封装</td><td>相对较容易封装</td></tr></tbody></table><h2 id="三者的基本概念"><a href="#三者的基本概念" class="headerlink" title="三者的基本概念"></a>三者的基本概念</h2><p><strong>localStorage</strong></p><p>HTML5新特性，支持IE8+、 IE6+的polyfill可以用userData。localStorage在浏览器的隐私模式下面是不可读取的。</p><p><strong>sessionStorage</strong></p><p>仅在当前会话下有效，关闭页面或浏览器后被清除。<br><strong>作用域</strong> 如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的。</p><p><strong>Cookie</strong><br>生命周期在设置的cookie过期时间之前一直有效。长度和数量的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB。属于旧方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;三者异同&lt;/li&gt;
&lt;li&gt;三者的基本概念
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day211-Content-Type</title>
    <link href="http://lmislm.com/2019/08/11/2019-08-11/"/>
    <id>http://lmislm.com/2019/08/11/2019-08-11/</id>
    <published>2019-08-10T16:00:00.000Z</published>
    <updated>2019-08-11T14:43:56.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>是什么？</li><li>句法</li><li>指令，及其注释<a id="more"></a></li></ol><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>Content-Type 实体头部用于指示资源的MIME类型 media type 。</p><h2 id="句法"><a href="#句法" class="headerlink" title="句法"></a>句法</h2><p>就是经常在header中看到的东西，如，<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Content-Type: text/html; charset=utf<span class="number">-8</span></span><br></pre></td></tr></table></figure></p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><ol><li>media-type</li></ol><p>资源或数据的 MIME type（媒体类型—通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型 ，是一种标准，用来表示文档、文件或字节流的性质和格式，如：text/html<br>、text/plain）。</p><ul><li>常见的：<br><code>multipart/form-data</code>，用以支持向服务器发送二进制数据</li></ul><p><code>application/x-www-urlencoded</code>，消息内容会经过 URL 格式编码，可用get方法和post方法，但不写enctype，无法实现文件上传</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.runoob.com/http/http-content-type.html" target="_blank" rel="noopener">HTTP content-type 对照表</a></p><p><a href="https://segmentfault.com/a/1190000003002851#articleHeader2" target="_blank" rel="noopener">理解HTTP之Content-Type</a></p><p><a href="https://juejin.im/post/5c9f4885f265da308868dad1" target="_blank" rel="noopener">上传文件multipart/form-data深入解析</a></p><p><a href="https://www.jianshu.com/p/29e38bcc8a1d" target="_blank" rel="noopener">深入解析 multipart/form-data</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;是什么？&lt;/li&gt;
&lt;li&gt;句法&lt;/li&gt;
&lt;li&gt;指令，及其注释
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day210-repaint和reflow扫盲</title>
    <link href="http://lmislm.com/2019/08/10/2019-08-10/"/>
    <id>http://lmislm.com/2019/08/10/2019-08-10/</id>
    <published>2019-08-09T16:00:00.000Z</published>
    <updated>2019-08-10T14:01:16.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>介绍</li><li>引起XX的常见操作</li><li>优化<a id="more"></a></li></ol><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>浏览器重新渲染，就需要重新生成布局和重新绘制。前者叫做”回流”（reflow，又叫重排，英文也叫Layout），后者叫做”重绘”（repaint）。</p><p>元素样式的改变不影响布局， UI 层面的重新像素绘制，重绘对元素进行更新 —— 重绘(repaint)<br>重新渲染页面 —— 回流(reflow)</p><h2 id="常见原因"><a href="#常见原因" class="headerlink" title="常见原因"></a>常见原因</h2><p><strong>常见的reflow操作：</strong></p><ol><li>页面初次渲染，浏览器窗口大小改变</li><li>元素尺寸/位置/内容发生改变</li><li>css伪类<blockquote><p>offsetTop/offsetLeft/offsetWidth/offsetHeight/offsetParent</p></blockquote></li></ol><blockquote><p>clientTop/clientLeft/clientWidth/clientHeight</p></blockquote><blockquote><p>scrollTop/scrollLeft/scrollWidth/scrollHeight</p></blockquote><blockquote><p>getComputedStyle()/getClientRects()/getBoundingClientRect()</p></blockquote><p><strong>常见的repaint操作：</strong></p><p>css属性的改变。</p><p>具体见CSS Triggers <a href="https://csstriggers.com/" target="_blank" rel="noopener">https://csstriggers.com/</a> 这里列出了哪些属性会引起reflow(即Layout)或repaint。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ul><li><p>rAF等<br>使用 window.requestAnimationFrame()、window.requestIdleCallback() 这两个方法调节重新渲染</p></li><li><p><a href="https://github.com/wilsonpage/fastdom" target="_blank" rel="noopener">FASTDOM</a> (Eliminates layout thrashing by batching DOM measurement and mutation tasks<br>)</p><blockquote><p>自动完成读写操作的批处理</p></blockquote></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/30078937" target="_blank" rel="noopener">如何不择手段提升scroll事件的性能—知乎</a></p><p><a href="https://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html" target="_blank" rel="noopener">网页性能管理详解—阮一峰</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;介绍&lt;/li&gt;
&lt;li&gt;引起XX的常见操作&lt;/li&gt;
&lt;li&gt;优化
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day208-requestAnimationFrame-了解</title>
    <link href="http://lmislm.com/2019/08/09/2019-08-09/"/>
    <id>http://lmislm.com/2019/08/09/2019-08-09/</id>
    <published>2019-08-08T16:00:00.000Z</published>
    <updated>2019-08-09T15:16:37.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>作用</li><li>应用</li><li>实例<a id="more"></a></li></ol><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><blockquote><p>要求浏览器在下次重绘之前调用指定的回调函数更新动画<sup>[1]</sup></p></blockquote><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li>减少<code>重绘</code>或<code>回流</code>。</li><li>替代通过时间管理队列的高频发事件，通过<code>requestAnimationFrame</code>来管理队列，保证 <code>requestAnimationFrame</code>的队列里，同样的回调函数只有一个。因为通常显示器16.7ms（16.7 = 1000 / 60, 即每秒60帧）的刷新间隔中，如果发生了其他绘制请求(setTimeout)，可能导致帧丢失。这里帧丢失通常就包含有，滚动、触摸这类高触发频率事件的回调可能会在同一帧内触发多次所导致，<code>requestAnimationFrame</code>就是跟着浏览器的绘制走，绘制间隔时间内绘制完毕。</li></ol><h2 id="实例-进度条"><a href="#实例-进度条" class="headerlink" title="实例-进度条"></a>实例-进度条</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span> <span class="attr">style</span>=<span class="string">"background-color: lightblue;width: 0;height: 20px;line-height: 20px;"</span>&gt;</span>0%<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span>run<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="javascript"><span class="keyword">var</span> timer; btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; myDiv.style.width = <span class="string">'0'</span>;</span></span><br><span class="line">  cancelAnimationFrame(timer);</span><br><span class="line"><span class="javascript">  timer = requestAnimationFrame(<span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span>(<span class="built_in">parseInt</span>(myDiv.style.width) &lt; <span class="number">500</span>)&#123; </span></span><br><span class="line"><span class="javascript">      myDiv.style.width = <span class="built_in">parseInt</span>(myDiv.style.width) + <span class="number">5</span> + <span class="string">'px'</span>; </span></span><br><span class="line"><span class="javascript">      myDiv.innerHTML = <span class="built_in">parseInt</span>(myDiv.style.width)/<span class="number">5</span> + <span class="string">'%'</span>; </span></span><br><span class="line">      timer = requestAnimationFrame(fn); </span><br><span class="line"><span class="javascript">    &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line">      cancelAnimationFrame(timer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>进度条例子来自：<a href="https://www.w3cplus.com/javascript/requestAnimationFrame.html" target="_blank" rel="noopener">W3Plus-被誉为神器的requestAnimationFrame</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1]. <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noopener">window.requestAnimationFrame-MDN</a></p><p><a href="https://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-%E5%8A%A8%E7%94%BB%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">CSS3动画那么强，requestAnimationFrame还有毛线用？</a></p><p><a href="https://segmentfault.com/a/1190000010229232" target="_blank" rel="noopener">requestAnimationFrame 方法你真的用对了吗？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;作用&lt;/li&gt;
&lt;li&gt;应用&lt;/li&gt;
&lt;li&gt;实例
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day207-Vue-nextTick()</title>
    <link href="http://lmislm.com/2019/08/08/2019-08-08/"/>
    <id>http://lmislm.com/2019/08/08/2019-08-08/</id>
    <published>2019-08-07T16:00:00.000Z</published>
    <updated>2019-08-08T15:12:28.727Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li><code>nextTick</code>用法</li><li><code>nextTick</code>源码相关</li><li>事件循环</li><li>源码中的降级策略<a id="more"></a></li></ol><h2 id="nextTick作用"><a href="#nextTick作用" class="headerlink" title="nextTick作用"></a><code>nextTick</code>作用</h2><blockquote><p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。<a href="https://cn.vuejs.org/v2/api/#Vue-nextTick" target="_blank" rel="noopener">来源</a></p></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 850555d on 20 Dec 2018</span></span><br><span class="line"><span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> MutationObserver !== <span class="string">'undefined'</span> &amp;&amp; (</span><br><span class="line">  isNative(MutationObserver) ||</span><br><span class="line">  <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">  MutationObserver.toString() === <span class="string">'[object MutationObserverConstructor]'</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="comment">// Use MutationObserver where native Promise is not available,</span></span><br><span class="line">  <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">  <span class="comment">// (#6466 MutationObserver is unreliable in IE11)</span></span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter)) <span class="comment">// 创建一个文本</span></span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    characterData: <span class="literal">true</span> <span class="comment">// 初始化监听文本节点</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.data = <span class="built_in">String</span>(counter) <span class="comment">// 文本节点变化监听</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上主要作用就是：监听文本变动是否完毕。</p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><ul><li><p>常见的<strong>microtask</strong>有：<br><code>Promise</code>、<code>MutationObserve</code>r、<code>Object.observe(废弃)</code>，以及nodejs中的<code>process.nextTick</code></p></li><li><p>常见的<strong>macrotask</strong> 有<code>setTimeout</code>、<code>MessageChannel</code>、<code>postMessage</code>、<code>setImmediate</code></p></li></ul><h2 id="降级策略"><a href="#降级策略" class="headerlink" title="降级策略"></a>降级策略</h2><p>在vue2.x版本的源码文件next-tick.js中，你还可以看到有其他的一些兼容性方法。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/Ma63d/vue-analysis/issues/6" target="_blank" rel="noopener">Vue源码详解之nextTick：MutationObserver只是浮云，microtask才是核心！</a></p><p><a href="https://juejin.im/entry/5aced80b518825482e39441e" target="_blank" rel="noopener">全面解析Vue.nextTick实现原理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;nextTick&lt;/code&gt;用法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nextTick&lt;/code&gt;源码相关&lt;/li&gt;
&lt;li&gt;事件循环&lt;/li&gt;
&lt;li&gt;源码中的降级策略
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day206-初识MutationObserver</title>
    <link href="http://lmislm.com/2019/08/07/2019-08-07/"/>
    <id>http://lmislm.com/2019/08/07/2019-08-07/</id>
    <published>2019-08-06T16:00:00.000Z</published>
    <updated>2019-08-07T15:29:09.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li><code>MutationObserver</code> 使用方法</li><li><code>MutationObserver</code> 的方法<code>observe()</code>(具体)和<code>takeRecords()</code>以及<code>disconnect()</code></li><li><code>MutationRecord</code><a id="more"></a></li></ol><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mObserver = <span class="keyword">new</span> MutationObserver(callback) <span class="comment">// 新建实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> word = <span class="built_in">document</span>.querySelector(<span class="string">'words'</span>);</span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  <span class="string">'childList'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'arrtibutes'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'characterData'</span>: <span class="literal">true</span>, <span class="comment">// 节点内容或节点文本的变动</span></span><br><span class="line">  <span class="string">'subtree'</span>: <span class="literal">true</span>, <span class="comment">// 所有子节点，不能单独观察，必须同时指定以上三个为`true`</span></span><br><span class="line">  <span class="string">'attributeOldValue'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'characterDataOldValue'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'attributesFilter'</span>: [<span class="string">'class'</span>, <span class="string">'str'</span>] <span class="comment">// 值为数组，表示观察的特定属性</span></span><br><span class="line">&#125;</span><br><span class="line">mObserver.observer(word, options)</span><br></pre></td></tr></table></figure><h2 id="disconnect、takeRecord"><a href="#disconnect、takeRecord" class="headerlink" title="disconnect、takeRecord"></a>disconnect、takeRecord</h2><ul><li>disconnect 表示停止观察，无参数，用法：mObserver.disconnect()</li><li>takeRecord 用来清除变动记录，无参数，用法：mObserver.takeRecords()</li></ul><h2 id="MutationRecord"><a href="#MutationRecord" class="headerlink" title="MutationRecord"></a>MutationRecord</h2><blockquote><p>每个 MutationRecord 代表一个独立的 DOM 变化，其作为参数传递给 MutationObserver 的回调函数。</p></blockquote><ol><li>参数的含义</li></ol><ul><li>type: 观察的变动类型（attribute、characterData或者childList）</li><li>target: 发生变动的DOM对象</li><li>addedNodes: 新增的DOM对象</li><li>removeNodes: 删除的DOM对象</li><li>previousSibling: 前一个同级的DOM对象，无则返回null</li><li>nextSibling: 下个同级的DOM对象，无则返回null</li><li>attributeName: 发生变动的属性，如果设置了attributeFilter，则只返回预先指定的属性</li><li>oldValue：变动前的值。只对attribute和characterData变动有效</li></ul><p>详细的属性表，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationRecord" target="_blank" rel="noopener">点击这里</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver/observe" target="_blank" rel="noopener">MDN-MutationObserver</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationRecord" target="_blank" rel="noopener">MDN-MutationRecord</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;MutationObserver&lt;/code&gt; 使用方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MutationObserver&lt;/code&gt; 的方法&lt;code&gt;observe()&lt;/code&gt;(具体)和&lt;code&gt;takeRecords()&lt;/code&gt;以及&lt;code&gt;disconnect()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MutationRecord&lt;/code&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day205-instanceOf</title>
    <link href="http://lmislm.com/2019/08/06/2019-08-06/"/>
    <id>http://lmislm.com/2019/08/06/2019-08-06/</id>
    <published>2019-08-05T16:00:00.000Z</published>
    <updated>2019-08-06T14:59:38.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>instanceOf 简单实现</p><blockquote><p>原理：检查是否在left（左边的值）的原型链上<br><a id="more"></a></p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceOf</span> (<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rightProto = right.prototype</span><br><span class="line">  left = left.__proto__</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!left) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left === rightProto) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 继续找下去</span></span><br><span class="line">    &#125;</span><br><span class="line">    left = left.__proto__ <span class="comment">// 继续遍历</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;p&gt;instanceOf 简单实现&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原理：检查是否在left（左边的值）的原型链上&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day204-es6-笔记-Class-this</title>
    <link href="http://lmislm.com/2019/08/05/2019-08-05/"/>
    <id>http://lmislm.com/2019/08/05/2019-08-05/</id>
    <published>2019-08-04T16:00:00.000Z</published>
    <updated>2019-08-05T14:20:36.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><blockquote><p>class 构造函数<code>constructor</code>中<code>this</code>的指向<br>类的方法内部如果含有<code>this</code>,默认指向类的实例。单独使用方法时，可能报错。</p></blockquote><ul><li>解决方法：</li></ul><ol><li>构造方法中绑定`this</li><li>使用箭头函数</li><li>使用<code>Proxy</code>，获取方法的时候，自动绑定<code>this</code><a id="more"></a><h2 id="具体解决方法-3rd"><a href="#具体解决方法-3rd" class="headerlink" title="具体解决方法-3rd"></a>具体解决方法-3rd</h2></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selfish</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">WeakMap</span>() <span class="comment">// 弱引用</span></span><br><span class="line">  <span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span> (target, key) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="built_in">Reflect</span>.get(target, key)</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!cache.has(value)) &#123;</span><br><span class="line">        cache.set(value, value.bind(target)) <span class="comment">// 还是用到了bind</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> cache.get(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line">  <span class="keyword">return</span> proxy</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 示例 */</span></span><br><span class="line"><span class="keyword">const</span> logger = selfish(<span class="keyword">new</span> logger())</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;class 构造函数&lt;code&gt;constructor&lt;/code&gt;中&lt;code&gt;this&lt;/code&gt;的指向&lt;br&gt;类的方法内部如果含有&lt;code&gt;this&lt;/code&gt;,默认指向类的实例。单独使用方法时，可能报错。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;解决方法：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;构造方法中绑定`this&lt;/li&gt;
&lt;li&gt;使用箭头函数&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;Proxy&lt;/code&gt;，获取方法的时候，自动绑定&lt;code&gt;this&lt;/code&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day203-reduce题目</title>
    <link href="http://lmislm.com/2019/08/04/2019-08-04/"/>
    <id>http://lmislm.com/2019/08/04/2019-08-04/</id>
    <published>2019-08-03T16:00:00.000Z</published>
    <updated>2019-08-04T14:19:44.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol><li>求<code>[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ]</code></li></ol><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>第一个<code>[3,2,1].reduce(Math.pow)</code>结果是：<code>Math.pow(3, 2) =&gt; 9; Math.pow(9, 1) =&gt;9</code>。<br>第二个<code>[].reduce(Math.pow)</code>结果是<code>TypeError: Reduce of empty array with no initial value</code>,即：没有初始值。</p><p>输出<code>error</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;求&lt;code&gt;[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day202-简单实现Promise(4)</title>
    <link href="http://lmislm.com/2019/08/03/2019-08-03/"/>
    <id>http://lmislm.com/2019/08/03/2019-08-03/</id>
    <published>2019-08-02T16:00:00.000Z</published>
    <updated>2019-08-03T14:21:13.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li><code>resolved</code>,<code>rejected</code>和<code>pending</code>三种情况的相应处理</li></ol><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** promise */</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据标准，如果then的参数不是function，则我们需要忽略它</span></span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123; <span class="keyword">return</span> v&#125;</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123; <span class="keyword">return</span> r &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'resolved'</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里promise的状态已经确定是resolved，所以调用onResolved</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ret是onFulfilled的返回值</span></span><br><span class="line">        <span class="keyword">var</span> ret = onFulfilled(self.data)</span><br><span class="line">        <span class="keyword">if</span> (ret <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">          <span class="comment">// 如果ret是一个promise，则取其值作为新的promise的结果</span></span><br><span class="line">          ret.then(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 否则，以它的返回值作为新的promise的结果</span></span><br><span class="line">          resolve(ret)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">// 如果出错，以捕获到的错误作为promise2的结果</span></span><br><span class="line">        reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里的逻辑跟前面一样，不再赘述</span></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> ret = onRejected(self.data)</span><br><span class="line">        <span class="keyword">if</span> (ret <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">          ret.then(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject(ret)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果当前的Promise还处于pending状态，则不能确定调用</span></span><br><span class="line">    <span class="comment">// onResolved还是onRejecte，只能等到Promise状态确定后，</span></span><br><span class="line">    <span class="comment">// 才能确定如何处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      self.onFulfilledCallback.push(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> ret = onFulfilled(self.data)</span><br><span class="line">          <span class="keyword">if</span> (ret <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            ret.then(resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(ret)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      self.onRejectedCallback.push(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> ret = onRejected(self.data)</span><br><span class="line">          <span class="keyword">if</span> (ret <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            ret.then(resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reject(ret)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺便实现一下catch方法</span></span><br><span class="line">MyPromise.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;resolved&lt;/code&gt;,&lt;code&gt;rejected&lt;/code&gt;和&lt;code&gt;pending&lt;/code&gt;三种情况的相应处理&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day201-简单实现Promise(3)</title>
    <link href="http://lmislm.com/2019/08/02/2019-08-02/"/>
    <id>http://lmislm.com/2019/08/02/2019-08-02/</id>
    <published>2019-08-01T16:00:00.000Z</published>
    <updated>2019-08-03T14:17:52.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>promise的<code>then</code>方法框架</li></ol><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** promise-then方法 */</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// 标准2.2.1.1. If onFulfilled is not a function, it must be ignored.</span></span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123; <span class="keyword">return</span> v &#125;</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123; <span class="keyword">return</span> r &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Promise对象存在以下三种状态，对三种状态采用不同处理</span></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'resolved'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// todo</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// todo</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// todo</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;promise的&lt;code&gt;then&lt;/code&gt;方法框架&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day200-简单实现Promise(2)</title>
    <link href="http://lmislm.com/2019/08/01/2019-08-01/"/>
    <id>http://lmislm.com/2019/08/01/2019-08-01/</id>
    <published>2019-07-31T16:00:00.000Z</published>
    <updated>2019-08-03T14:17:54.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>修改promise状态</li></ol><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 构造函数 - 雏形 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span></span><br><span class="line">  self.status = <span class="string">'pending'</span></span><br><span class="line">  self.data = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">  self.onFulfilledCallback = [] <span class="comment">// resolve 回调函数集合</span></span><br><span class="line">  self.onRejectedCallback = [] <span class="comment">// reject 回调函数集合</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      self.status = <span class="string">'resolved'</span></span><br><span class="line">      self.data = value</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; self.onFulfilledCallback.length; i++) &#123;</span><br><span class="line">        self.onFulfilledCallback[i](value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      self.status = <span class="string">'rejected'</span></span><br><span class="line">      self.data = reason</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; self.onRejectedCallback.length; i++) &#123;</span><br><span class="line">        self.onRejectedCallback[i](reason)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fn (resolve, reject) <span class="comment">// 执行传入的函数，传入</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;修改promise状态&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day199-简单实现Promise(1)</title>
    <link href="http://lmislm.com/2019/07/31/2019-07-31/"/>
    <id>http://lmislm.com/2019/07/31/2019-07-31/</id>
    <published>2019-07-30T16:00:00.000Z</published>
    <updated>2019-07-31T14:56:05.441Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>构造函数</li><li>回调函数集合</li></ol><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 构造函数 - 雏形 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span></span><br><span class="line">  self.status = <span class="string">'pending'</span></span><br><span class="line">  self.data = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">  self.onFulfilledCallback = [] <span class="comment">// resolve 回调函数集合</span></span><br><span class="line">  self.onRejectedCallback = [] <span class="comment">// reject 回调函数集合</span></span><br><span class="line"></span><br><span class="line">  fn(resolve, reject) <span class="comment">// 执行传入函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;构造函数&lt;/li&gt;
&lt;li&gt;回调函数集合&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day198-字符串连续出现最多的字符</title>
    <link href="http://lmislm.com/2019/07/30/2019-07-30/"/>
    <id>http://lmislm.com/2019/07/30/2019-07-30/</id>
    <published>2019-07-29T16:00:00.000Z</published>
    <updated>2019-07-30T16:09:48.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>统计出现次数。</li><li><strong>连续</strong>出现次数。</li><li>时间复杂度尽量最小。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'abcaakjbb'</span> =&gt; &#123;<span class="string">'a'</span>:<span class="number">2</span>,<span class="string">'b'</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="string">'abbkejsbcccwqaa'</span> =&gt; &#123;<span class="string">'c'</span>:<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'abcaakjbb'</span></span><br><span class="line"><span class="comment">// 过程</span></span><br><span class="line"><span class="keyword">let</span> result = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> flag = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> strArr = str.split(<span class="string">''</span>)</span><br><span class="line"><span class="keyword">let</span> letterTimes = strArr.reduce(<span class="function">(<span class="params">acc, cur, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!acc[cur]) &#123;</span><br><span class="line">    acc[cur] = <span class="number">1</span> <span class="comment">// 不存在，就创建键值对，初始值1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (strArr[index + <span class="number">1</span>] === cur) &#123;</span><br><span class="line">    acc[cur] += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 比较次数大小</span></span><br><span class="line">  <span class="keyword">if</span> (acc[cur] &gt; flag) &#123;</span><br><span class="line">    flag = acc[cur]</span><br><span class="line">  &#125;</span><br><span class="line">  acc[]</span><br><span class="line">  <span class="keyword">return</span> acc</span><br><span class="line">&#125;, &#123;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(letterTimes)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;统计出现次数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;连续&lt;/strong&gt;出现次数。&lt;/li&gt;
&lt;li&gt;时间复杂度尽量最小。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;abcaakjbb&#39;&lt;/span&gt; =&amp;gt; &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;abbkejsbcccwqaa&#39;&lt;/span&gt; =&amp;gt; &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;c&#39;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day197-DOM Range操作</title>
    <link href="http://lmislm.com/2019/07/29/2019-07-29/"/>
    <id>http://lmislm.com/2019/07/29/2019-07-29/</id>
    <published>2019-07-28T16:00:00.000Z</published>
    <updated>2019-07-29T14:47:06.957Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>Range是？</li><li>createRange？<a id="more"></a><h2 id="Range是？"><a href="#Range是？" class="headerlink" title="Range是？"></a>Range是？</h2>Range是一种fragment（HTML片断），包含了节点或文本节点的一部分，通过document.createRange()或selection象的getRangeAt()方法获得。<blockquote><p>IE没有。需要检查兼容性。</p></blockquote></li></ol><h2 id="createRange？"><a href="#createRange？" class="headerlink" title="createRange？"></a>createRange？</h2><blockquote><p><code>Document.createRange()</code>常用来设置光标定位。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'editable'</span>)</span><br><span class="line"><span class="keyword">let</span> range = <span class="built_in">document</span>.createRange()</span><br><span class="line"><span class="keyword">let</span> sel = <span class="built_in">window</span>.getSelection()</span><br><span class="line">range.setStart(el.childNodes[<span class="number">2</span>], <span class="number">5</span>) <span class="comment">// childNodes来源于NodeList</span></span><br><span class="line">range.collapse(<span class="literal">true</span>) <span class="comment">// collapse(toStart) 折叠该范围，使它的“起点”和“结束点”重合。</span></span><br><span class="line">sel.removeAllRanges()</span><br><span class="line">sel.addRange(range)</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/rainman/archive/2011/02/28/1967488.html" target="_blank" rel="noopener">Javascript标准DOM Range操作</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/createRange" target="_blank" rel="noopener">Document.createRange()</a></p><p><a href="https://stackoverflow.com/questions/6249095/how-to-set-caretcursor-position-in-contenteditable-element-div" target="_blank" rel="noopener">How to set caret(cursor) position in contenteditable element (div)?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Range是？&lt;/li&gt;
&lt;li&gt;createRange？
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day196-事件循环的常见问题和错误观点</title>
    <link href="http://lmislm.com/2019/07/28/2019-07-28/"/>
    <id>http://lmislm.com/2019/07/28/2019-07-28/</id>
    <published>2019-07-27T16:00:00.000Z</published>
    <updated>2019-07-28T15:00:28.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>Node.js 是完全单线程？</li><li>其他线程？</li><li>事件循环是种栈结构？<a id="more"></a><h2 id="Node-js-是完全单线程"><a href="#Node-js-是完全单线程" class="headerlink" title="Node.js 是完全单线程?"></a>Node.js 是完全单线程?</h2>Node 单线程运行，但是Nodejs中一些标准库函数为了保证程序速度和性能并不是运行在同一个线程上（例如：fs函数）。</li></ol><h2 id="其他线程运行在什么地方？"><a href="#其他线程运行在什么地方？" class="headerlink" title="其他线程运行在什么地方？"></a>其他线程运行在什么地方？</h2><p>既然NOdejs不是单线程，那么其他线程运行在什么地方呢？Nodejs使用名为<code>libuv</code>的特殊库模块来执行异步操作。此库还和Node的后台逻辑一起使用，用来管理被称为<code>libuv线程池</code>的特殊线程池。</p><p>该特殊线程池由四个线程组成，用于委派对于事件循环来说太重（长时间运行，过于昂贵）的操作。</p><h2 id="事件循环是种栈结构"><a href="#事件循环是种栈结构" class="headerlink" title="事件循环是种栈结构"></a>事件循环是种栈结构</h2><p>在线程中可能涉及一些类似栈的结构，但其实是事件循环由一系列的阶段所组成，每个阶段都有自己的特定任务，所有阶段都以循环重复的方式去处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Node.js 是完全单线程？&lt;/li&gt;
&lt;li&gt;其他线程？&lt;/li&gt;
&lt;li&gt;事件循环是种栈结构？
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day195-Vue-style Hooks</title>
    <link href="http://lmislm.com/2019/07/27/2019-07-27/"/>
    <id>http://lmislm.com/2019/07/27/2019-07-27/</id>
    <published>2019-07-26T16:00:00.000Z</published>
    <updated>2019-07-27T14:22:25.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>在vue3中，将更多的采用hook。个人觉得，如果能保留之前的东西再加上hook，将会更加的灵活。</p><ol><li>API that maps Vue’s existing API.</li><li>Usage in Normal Vue Components<a id="more"></a><h2 id="API-that-maps-Vue’s-existing-API"><a href="#API-that-maps-Vue’s-existing-API" class="headerlink" title="API that maps Vue’s existing API."></a>API that maps Vue’s existing API.</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  withHooks,</span><br><span class="line">  useData,</span><br><span class="line">  useComputed,</span><br><span class="line">  useWatch,</span><br><span class="line">  useMounted,</span><br><span class="line">  useUpdated,</span><br><span class="line">  useDestroyed</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"vue-hooks"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Foo = withHooks(<span class="function"><span class="params">h</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> data = useData(&#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> double = useComputed(<span class="function"><span class="params">()</span> =&gt;</span> data.count * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  useWatch(<span class="function"><span class="params">()</span> =&gt;</span> data.count, (val, prevVal) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`count is: <span class="subst">$&#123;val&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  useMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'mounted!'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  useUpdated(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'updated!'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  useDestroyed(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'destroyed!'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> h(<span class="string">'div'</span>, [</span><br><span class="line">    h(<span class="string">'div'</span>, <span class="string">`count is <span class="subst">$&#123;data.count&#125;</span>`</span>),</span><br><span class="line">    h(<span class="string">'div'</span>, <span class="string">`double count is <span class="subst">$&#123;double&#125;</span>`</span>),</span><br><span class="line">    h(<span class="string">'button'</span>, &#123; <span class="attr">on</span>: &#123; <span class="attr">click</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// still got that direct mutation!</span></span><br><span class="line">      data.count++</span><br><span class="line">    &#125;&#125;&#125;, <span class="string">'count++'</span>)</span><br><span class="line">  ])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h2 id="Usage-in-Normal-Vue-Components"><a href="#Usage-in-Normal-Vue-Components" class="headerlink" title="Usage in Normal Vue Components"></a>Usage in Normal Vue Components</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; hooks, useData, useComputed &#125; <span class="keyword">from</span> <span class="string">'vue-hooks'</span></span><br><span class="line"></span><br><span class="line">Vue.use(hooks)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div @click="data.count++"&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123; data.count &#125;&#125; &#123;&#123; double &#125;&#125;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  hooks() &#123;</span><br><span class="line">    <span class="keyword">const</span> data = useData(&#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> double = useComputed(<span class="function"><span class="params">()</span> =&gt;</span> data.count * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      data,</span><br><span class="line">      double</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;p&gt;在vue3中，将更多的采用hook。个人觉得，如果能保留之前的东西再加上hook，将会更加的灵活。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;API that maps Vue’s existing API.&lt;/li&gt;
&lt;li&gt;Usage in Normal Vue Components
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
