<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LMISLMのBlog</title>
  
  <subtitle>不积小流，无以成江海。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lmislm.com/"/>
  <updated>2019-08-12T15:35:43.446Z</updated>
  <id>http://lmislm.com/</id>
  
  <author>
    <name>lmislm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>day212-localStorage、sessionStorage、Cookie</title>
    <link href="http://lmislm.com/2019/08/12/2019-08-12/"/>
    <id>http://lmislm.com/2019/08/12/2019-08-12/</id>
    <published>2019-08-11T16:00:00.000Z</published>
    <updated>2019-08-12T15:35:43.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>三者异同</li><li>三者的基本概念<a id="more"></a></li></ol><h2 id="三者异同"><a href="#三者异同" class="headerlink" title="三者异同"></a>三者异同</h2><table><thead><tr><th>特性</th><th>Cookie</th><th>localStorage</th><th>sessionStorage</th></tr></thead><tbody><tr><td>生命周期</td><td>可由服务器生成，可设置过期时间。如果在浏览器端生成Cookie，默认是关闭浏览器后清除</td><td>除非被清除，否则永久保存</td><td>仅在当前会话下有效，关闭页面或浏览器后被清除</td></tr><tr><td>可存放数据大小</td><td>4K左右</td><td>5MB左右</td></tr><tr><td>与服务器端通信</td><td>携带在HTTP头中</td><td>不与服务器端通信，仅仅在浏览器中保存</td></tr><tr><td>易用性</td><td>接口不友好</td><td>相对较容易封装</td></tr></tbody></table><h2 id="三者的基本概念"><a href="#三者的基本概念" class="headerlink" title="三者的基本概念"></a>三者的基本概念</h2><p><strong>localStorage</strong></p><p>HTML5新特性，支持IE8+、 IE6+的polyfill可以用userData。localStorage在浏览器的隐私模式下面是不可读取的。</p><p><strong>sessionStorage</strong></p><p>仅在当前会话下有效，关闭页面或浏览器后被清除。<br><strong>作用域</strong> 如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的。</p><p><strong>Cookie</strong><br>生命周期在设置的cookie过期时间之前一直有效。长度和数量的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB。属于旧方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;三者异同&lt;/li&gt;
&lt;li&gt;三者的基本概念
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day211-Content-Type</title>
    <link href="http://lmislm.com/2019/08/11/2019-08-11/"/>
    <id>http://lmislm.com/2019/08/11/2019-08-11/</id>
    <published>2019-08-10T16:00:00.000Z</published>
    <updated>2019-08-11T14:43:56.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>是什么？</li><li>句法</li><li>指令，及其注释<a id="more"></a></li></ol><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>Content-Type 实体头部用于指示资源的MIME类型 media type 。</p><h2 id="句法"><a href="#句法" class="headerlink" title="句法"></a>句法</h2><p>就是经常在header中看到的东西，如，<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Content-Type: text/html; charset=utf<span class="number">-8</span></span><br></pre></td></tr></table></figure></p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><ol><li>media-type</li></ol><p>资源或数据的 MIME type（媒体类型—通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型 ，是一种标准，用来表示文档、文件或字节流的性质和格式，如：text/html<br>、text/plain）。</p><ul><li>常见的：<br><code>multipart/form-data</code>，用以支持向服务器发送二进制数据</li></ul><p><code>application/x-www-urlencoded</code>，消息内容会经过 URL 格式编码，可用get方法和post方法，但不写enctype，无法实现文件上传</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.runoob.com/http/http-content-type.html" target="_blank" rel="noopener">HTTP content-type 对照表</a></p><p><a href="https://segmentfault.com/a/1190000003002851#articleHeader2" target="_blank" rel="noopener">理解HTTP之Content-Type</a></p><p><a href="https://juejin.im/post/5c9f4885f265da308868dad1" target="_blank" rel="noopener">上传文件multipart/form-data深入解析</a></p><p><a href="https://www.jianshu.com/p/29e38bcc8a1d" target="_blank" rel="noopener">深入解析 multipart/form-data</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;是什么？&lt;/li&gt;
&lt;li&gt;句法&lt;/li&gt;
&lt;li&gt;指令，及其注释
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day210-repaint和reflow扫盲</title>
    <link href="http://lmislm.com/2019/08/10/2019-08-10/"/>
    <id>http://lmislm.com/2019/08/10/2019-08-10/</id>
    <published>2019-08-09T16:00:00.000Z</published>
    <updated>2019-08-10T14:01:16.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>介绍</li><li>引起XX的常见操作</li><li>优化<a id="more"></a></li></ol><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>浏览器重新渲染，就需要重新生成布局和重新绘制。前者叫做”回流”（reflow，又叫重排，英文也叫Layout），后者叫做”重绘”（repaint）。</p><p>元素样式的改变不影响布局， UI 层面的重新像素绘制，重绘对元素进行更新 —— 重绘(repaint)<br>重新渲染页面 —— 回流(reflow)</p><h2 id="常见原因"><a href="#常见原因" class="headerlink" title="常见原因"></a>常见原因</h2><p><strong>常见的reflow操作：</strong></p><ol><li>页面初次渲染，浏览器窗口大小改变</li><li>元素尺寸/位置/内容发生改变</li><li>css伪类<blockquote><p>offsetTop/offsetLeft/offsetWidth/offsetHeight/offsetParent</p></blockquote></li></ol><blockquote><p>clientTop/clientLeft/clientWidth/clientHeight</p></blockquote><blockquote><p>scrollTop/scrollLeft/scrollWidth/scrollHeight</p></blockquote><blockquote><p>getComputedStyle()/getClientRects()/getBoundingClientRect()</p></blockquote><p><strong>常见的repaint操作：</strong></p><p>css属性的改变。</p><p>具体见CSS Triggers <a href="https://csstriggers.com/" target="_blank" rel="noopener">https://csstriggers.com/</a> 这里列出了哪些属性会引起reflow(即Layout)或repaint。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ul><li><p>rAF等<br>使用 window.requestAnimationFrame()、window.requestIdleCallback() 这两个方法调节重新渲染</p></li><li><p><a href="https://github.com/wilsonpage/fastdom" target="_blank" rel="noopener">FASTDOM</a> (Eliminates layout thrashing by batching DOM measurement and mutation tasks<br>)</p><blockquote><p>自动完成读写操作的批处理</p></blockquote></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/30078937" target="_blank" rel="noopener">如何不择手段提升scroll事件的性能—知乎</a></p><p><a href="https://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html" target="_blank" rel="noopener">网页性能管理详解—阮一峰</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;介绍&lt;/li&gt;
&lt;li&gt;引起XX的常见操作&lt;/li&gt;
&lt;li&gt;优化
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day208-requestAnimationFrame-了解</title>
    <link href="http://lmislm.com/2019/08/09/2019-08-09/"/>
    <id>http://lmislm.com/2019/08/09/2019-08-09/</id>
    <published>2019-08-08T16:00:00.000Z</published>
    <updated>2019-08-09T15:16:37.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>作用</li><li>应用</li><li>实例<a id="more"></a></li></ol><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><blockquote><p>要求浏览器在下次重绘之前调用指定的回调函数更新动画<sup>[1]</sup></p></blockquote><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li>减少<code>重绘</code>或<code>回流</code>。</li><li>替代通过时间管理队列的高频发事件，通过<code>requestAnimationFrame</code>来管理队列，保证 <code>requestAnimationFrame</code>的队列里，同样的回调函数只有一个。因为通常显示器16.7ms（16.7 = 1000 / 60, 即每秒60帧）的刷新间隔中，如果发生了其他绘制请求(setTimeout)，可能导致帧丢失。这里帧丢失通常就包含有，滚动、触摸这类高触发频率事件的回调可能会在同一帧内触发多次所导致，<code>requestAnimationFrame</code>就是跟着浏览器的绘制走，绘制间隔时间内绘制完毕。</li></ol><h2 id="实例-进度条"><a href="#实例-进度条" class="headerlink" title="实例-进度条"></a>实例-进度条</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span> <span class="attr">style</span>=<span class="string">"background-color: lightblue;width: 0;height: 20px;line-height: 20px;"</span>&gt;</span>0%<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span>run<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="javascript"><span class="keyword">var</span> timer; btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; myDiv.style.width = <span class="string">'0'</span>;</span></span><br><span class="line">  cancelAnimationFrame(timer);</span><br><span class="line"><span class="javascript">  timer = requestAnimationFrame(<span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span>(<span class="built_in">parseInt</span>(myDiv.style.width) &lt; <span class="number">500</span>)&#123; </span></span><br><span class="line"><span class="javascript">      myDiv.style.width = <span class="built_in">parseInt</span>(myDiv.style.width) + <span class="number">5</span> + <span class="string">'px'</span>; </span></span><br><span class="line"><span class="javascript">      myDiv.innerHTML = <span class="built_in">parseInt</span>(myDiv.style.width)/<span class="number">5</span> + <span class="string">'%'</span>; </span></span><br><span class="line">      timer = requestAnimationFrame(fn); </span><br><span class="line"><span class="javascript">    &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line">      cancelAnimationFrame(timer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>进度条例子来自：<a href="https://www.w3cplus.com/javascript/requestAnimationFrame.html" target="_blank" rel="noopener">W3Plus-被誉为神器的requestAnimationFrame</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1]. <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noopener">window.requestAnimationFrame-MDN</a></p><p><a href="https://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-%E5%8A%A8%E7%94%BB%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">CSS3动画那么强，requestAnimationFrame还有毛线用？</a></p><p><a href="https://segmentfault.com/a/1190000010229232" target="_blank" rel="noopener">requestAnimationFrame 方法你真的用对了吗？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;作用&lt;/li&gt;
&lt;li&gt;应用&lt;/li&gt;
&lt;li&gt;实例
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day207-Vue-nextTick()</title>
    <link href="http://lmislm.com/2019/08/08/2019-08-08/"/>
    <id>http://lmislm.com/2019/08/08/2019-08-08/</id>
    <published>2019-08-07T16:00:00.000Z</published>
    <updated>2019-08-08T15:12:28.727Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li><code>nextTick</code>用法</li><li><code>nextTick</code>源码相关</li><li>事件循环</li><li>源码中的降级策略<a id="more"></a></li></ol><h2 id="nextTick作用"><a href="#nextTick作用" class="headerlink" title="nextTick作用"></a><code>nextTick</code>作用</h2><blockquote><p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。<a href="https://cn.vuejs.org/v2/api/#Vue-nextTick" target="_blank" rel="noopener">来源</a></p></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 850555d on 20 Dec 2018</span></span><br><span class="line"><span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> MutationObserver !== <span class="string">'undefined'</span> &amp;&amp; (</span><br><span class="line">  isNative(MutationObserver) ||</span><br><span class="line">  <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">  MutationObserver.toString() === <span class="string">'[object MutationObserverConstructor]'</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="comment">// Use MutationObserver where native Promise is not available,</span></span><br><span class="line">  <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">  <span class="comment">// (#6466 MutationObserver is unreliable in IE11)</span></span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter)) <span class="comment">// 创建一个文本</span></span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    characterData: <span class="literal">true</span> <span class="comment">// 初始化监听文本节点</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.data = <span class="built_in">String</span>(counter) <span class="comment">// 文本节点变化监听</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上主要作用就是：监听文本变动是否完毕。</p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><ul><li><p>常见的<strong>microtask</strong>有：<br><code>Promise</code>、<code>MutationObserve</code>r、<code>Object.observe(废弃)</code>，以及nodejs中的<code>process.nextTick</code></p></li><li><p>常见的<strong>macrotask</strong> 有<code>setTimeout</code>、<code>MessageChannel</code>、<code>postMessage</code>、<code>setImmediate</code></p></li></ul><h2 id="降级策略"><a href="#降级策略" class="headerlink" title="降级策略"></a>降级策略</h2><p>在vue2.x版本的源码文件next-tick.js中，你还可以看到有其他的一些兼容性方法。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/Ma63d/vue-analysis/issues/6" target="_blank" rel="noopener">Vue源码详解之nextTick：MutationObserver只是浮云，microtask才是核心！</a></p><p><a href="https://juejin.im/entry/5aced80b518825482e39441e" target="_blank" rel="noopener">全面解析Vue.nextTick实现原理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;nextTick&lt;/code&gt;用法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nextTick&lt;/code&gt;源码相关&lt;/li&gt;
&lt;li&gt;事件循环&lt;/li&gt;
&lt;li&gt;源码中的降级策略
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day206-初识MutationObserver</title>
    <link href="http://lmislm.com/2019/08/07/2019-08-07/"/>
    <id>http://lmislm.com/2019/08/07/2019-08-07/</id>
    <published>2019-08-06T16:00:00.000Z</published>
    <updated>2019-08-07T15:29:09.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li><code>MutationObserver</code> 使用方法</li><li><code>MutationObserver</code> 的方法<code>observe()</code>(具体)和<code>takeRecords()</code>以及<code>disconnect()</code></li><li><code>MutationRecord</code><a id="more"></a></li></ol><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mObserver = <span class="keyword">new</span> MutationObserver(callback) <span class="comment">// 新建实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> word = <span class="built_in">document</span>.querySelector(<span class="string">'words'</span>);</span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  <span class="string">'childList'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'arrtibutes'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'characterData'</span>: <span class="literal">true</span>, <span class="comment">// 节点内容或节点文本的变动</span></span><br><span class="line">  <span class="string">'subtree'</span>: <span class="literal">true</span>, <span class="comment">// 所有子节点，不能单独观察，必须同时指定以上三个为`true`</span></span><br><span class="line">  <span class="string">'attributeOldValue'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'characterDataOldValue'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'attributesFilter'</span>: [<span class="string">'class'</span>, <span class="string">'str'</span>] <span class="comment">// 值为数组，表示观察的特定属性</span></span><br><span class="line">&#125;</span><br><span class="line">mObserver.observer(word, options)</span><br></pre></td></tr></table></figure><h2 id="disconnect、takeRecord"><a href="#disconnect、takeRecord" class="headerlink" title="disconnect、takeRecord"></a>disconnect、takeRecord</h2><ul><li>disconnect 表示停止观察，无参数，用法：mObserver.disconnect()</li><li>takeRecord 用来清除变动记录，无参数，用法：mObserver.takeRecords()</li></ul><h2 id="MutationRecord"><a href="#MutationRecord" class="headerlink" title="MutationRecord"></a>MutationRecord</h2><blockquote><p>每个 MutationRecord 代表一个独立的 DOM 变化，其作为参数传递给 MutationObserver 的回调函数。</p></blockquote><ol><li>参数的含义</li></ol><ul><li>type: 观察的变动类型（attribute、characterData或者childList）</li><li>target: 发生变动的DOM对象</li><li>addedNodes: 新增的DOM对象</li><li>removeNodes: 删除的DOM对象</li><li>previousSibling: 前一个同级的DOM对象，无则返回null</li><li>nextSibling: 下个同级的DOM对象，无则返回null</li><li>attributeName: 发生变动的属性，如果设置了attributeFilter，则只返回预先指定的属性</li><li>oldValue：变动前的值。只对attribute和characterData变动有效</li></ul><p>详细的属性表，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationRecord" target="_blank" rel="noopener">点击这里</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver/observe" target="_blank" rel="noopener">MDN-MutationObserver</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationRecord" target="_blank" rel="noopener">MDN-MutationRecord</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;MutationObserver&lt;/code&gt; 使用方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MutationObserver&lt;/code&gt; 的方法&lt;code&gt;observe()&lt;/code&gt;(具体)和&lt;code&gt;takeRecords()&lt;/code&gt;以及&lt;code&gt;disconnect()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MutationRecord&lt;/code&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day205-instanceOf</title>
    <link href="http://lmislm.com/2019/08/06/2019-08-06/"/>
    <id>http://lmislm.com/2019/08/06/2019-08-06/</id>
    <published>2019-08-05T16:00:00.000Z</published>
    <updated>2019-08-06T14:59:38.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>instanceOf 简单实现</p><blockquote><p>原理：检查是否在left（左边的值）的原型链上<br><a id="more"></a></p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceOf</span> (<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rightProto = right.prototype</span><br><span class="line">  left = left.__proto__</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!left) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left === rightProto) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 继续找下去</span></span><br><span class="line">    &#125;</span><br><span class="line">    left = left.__proto__ <span class="comment">// 继续遍历</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;p&gt;instanceOf 简单实现&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原理：检查是否在left（左边的值）的原型链上&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day204-es6-笔记-Class-this</title>
    <link href="http://lmislm.com/2019/08/05/2019-08-05/"/>
    <id>http://lmislm.com/2019/08/05/2019-08-05/</id>
    <published>2019-08-04T16:00:00.000Z</published>
    <updated>2019-08-05T14:20:36.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><blockquote><p>class 构造函数<code>constructor</code>中<code>this</code>的指向<br>类的方法内部如果含有<code>this</code>,默认指向类的实例。单独使用方法时，可能报错。</p></blockquote><ul><li>解决方法：</li></ul><ol><li>构造方法中绑定`this</li><li>使用箭头函数</li><li>使用<code>Proxy</code>，获取方法的时候，自动绑定<code>this</code><a id="more"></a><h2 id="具体解决方法-3rd"><a href="#具体解决方法-3rd" class="headerlink" title="具体解决方法-3rd"></a>具体解决方法-3rd</h2></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selfish</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">WeakMap</span>() <span class="comment">// 弱引用</span></span><br><span class="line">  <span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span> (target, key) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="built_in">Reflect</span>.get(target, key)</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!cache.has(value)) &#123;</span><br><span class="line">        cache.set(value, value.bind(target)) <span class="comment">// 还是用到了bind</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> cache.get(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line">  <span class="keyword">return</span> proxy</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 示例 */</span></span><br><span class="line"><span class="keyword">const</span> logger = selfish(<span class="keyword">new</span> logger())</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;class 构造函数&lt;code&gt;constructor&lt;/code&gt;中&lt;code&gt;this&lt;/code&gt;的指向&lt;br&gt;类的方法内部如果含有&lt;code&gt;this&lt;/code&gt;,默认指向类的实例。单独使用方法时，可能报错。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;解决方法：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;构造方法中绑定`this&lt;/li&gt;
&lt;li&gt;使用箭头函数&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;Proxy&lt;/code&gt;，获取方法的时候，自动绑定&lt;code&gt;this&lt;/code&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day203-reduce题目</title>
    <link href="http://lmislm.com/2019/08/04/2019-08-04/"/>
    <id>http://lmislm.com/2019/08/04/2019-08-04/</id>
    <published>2019-08-03T16:00:00.000Z</published>
    <updated>2019-08-04T14:19:44.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol><li>求<code>[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ]</code></li></ol><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>第一个<code>[3,2,1].reduce(Math.pow)</code>结果是：<code>Math.pow(3, 2) =&gt; 9; Math.pow(9, 1) =&gt;9</code>。<br>第二个<code>[].reduce(Math.pow)</code>结果是<code>TypeError: Reduce of empty array with no initial value</code>,即：没有初始值。</p><p>输出<code>error</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;求&lt;code&gt;[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day202-简单实现Promise(4)</title>
    <link href="http://lmislm.com/2019/08/03/2019-08-03/"/>
    <id>http://lmislm.com/2019/08/03/2019-08-03/</id>
    <published>2019-08-02T16:00:00.000Z</published>
    <updated>2019-08-03T14:21:13.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li><code>resolved</code>,<code>rejected</code>和<code>pending</code>三种情况的相应处理</li></ol><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** promise */</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据标准，如果then的参数不是function，则我们需要忽略它</span></span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123; <span class="keyword">return</span> v&#125;</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123; <span class="keyword">return</span> r &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'resolved'</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里promise的状态已经确定是resolved，所以调用onResolved</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ret是onFulfilled的返回值</span></span><br><span class="line">        <span class="keyword">var</span> ret = onFulfilled(self.data)</span><br><span class="line">        <span class="keyword">if</span> (ret <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">          <span class="comment">// 如果ret是一个promise，则取其值作为新的promise的结果</span></span><br><span class="line">          ret.then(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 否则，以它的返回值作为新的promise的结果</span></span><br><span class="line">          resolve(ret)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">// 如果出错，以捕获到的错误作为promise2的结果</span></span><br><span class="line">        reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里的逻辑跟前面一样，不再赘述</span></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> ret = onRejected(self.data)</span><br><span class="line">        <span class="keyword">if</span> (ret <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">          ret.then(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject(ret)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果当前的Promise还处于pending状态，则不能确定调用</span></span><br><span class="line">    <span class="comment">// onResolved还是onRejecte，只能等到Promise状态确定后，</span></span><br><span class="line">    <span class="comment">// 才能确定如何处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      self.onFulfilledCallback.push(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> ret = onFulfilled(self.data)</span><br><span class="line">          <span class="keyword">if</span> (ret <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            ret.then(resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(ret)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      self.onRejectedCallback.push(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> ret = onRejected(self.data)</span><br><span class="line">          <span class="keyword">if</span> (ret <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            ret.then(resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reject(ret)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺便实现一下catch方法</span></span><br><span class="line">MyPromise.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;resolved&lt;/code&gt;,&lt;code&gt;rejected&lt;/code&gt;和&lt;code&gt;pending&lt;/code&gt;三种情况的相应处理&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day201-简单实现Promise(3)</title>
    <link href="http://lmislm.com/2019/08/02/2019-08-02/"/>
    <id>http://lmislm.com/2019/08/02/2019-08-02/</id>
    <published>2019-08-01T16:00:00.000Z</published>
    <updated>2019-08-03T14:17:52.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>promise的<code>then</code>方法框架</li></ol><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** promise-then方法 */</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// 标准2.2.1.1. If onFulfilled is not a function, it must be ignored.</span></span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123; <span class="keyword">return</span> v &#125;</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123; <span class="keyword">return</span> r &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Promise对象存在以下三种状态，对三种状态采用不同处理</span></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'resolved'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// todo</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// todo</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// todo</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;promise的&lt;code&gt;then&lt;/code&gt;方法框架&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day200-简单实现Promise(2)</title>
    <link href="http://lmislm.com/2019/08/01/2019-08-01/"/>
    <id>http://lmislm.com/2019/08/01/2019-08-01/</id>
    <published>2019-07-31T16:00:00.000Z</published>
    <updated>2019-08-03T14:17:54.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>修改promise状态</li></ol><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 构造函数 - 雏形 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span></span><br><span class="line">  self.status = <span class="string">'pending'</span></span><br><span class="line">  self.data = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">  self.onFulfilledCallback = [] <span class="comment">// resolve 回调函数集合</span></span><br><span class="line">  self.onRejectedCallback = [] <span class="comment">// reject 回调函数集合</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      self.status = <span class="string">'resolved'</span></span><br><span class="line">      self.data = value</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; self.onFulfilledCallback.length; i++) &#123;</span><br><span class="line">        self.onFulfilledCallback[i](value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      self.status = <span class="string">'rejected'</span></span><br><span class="line">      self.data = reason</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; self.onRejectedCallback.length; i++) &#123;</span><br><span class="line">        self.onRejectedCallback[i](reason)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fn (resolve, reject) <span class="comment">// 执行传入的函数，传入</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;修改promise状态&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day199-简单实现Promise(1)</title>
    <link href="http://lmislm.com/2019/07/31/2019-07-31/"/>
    <id>http://lmislm.com/2019/07/31/2019-07-31/</id>
    <published>2019-07-30T16:00:00.000Z</published>
    <updated>2019-07-31T14:56:05.441Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>构造函数</li><li>回调函数集合</li></ol><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 构造函数 - 雏形 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span></span><br><span class="line">  self.status = <span class="string">'pending'</span></span><br><span class="line">  self.data = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">  self.onFulfilledCallback = [] <span class="comment">// resolve 回调函数集合</span></span><br><span class="line">  self.onRejectedCallback = [] <span class="comment">// reject 回调函数集合</span></span><br><span class="line"></span><br><span class="line">  fn(resolve, reject) <span class="comment">// 执行传入函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;构造函数&lt;/li&gt;
&lt;li&gt;回调函数集合&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day198-字符串连续出现最多的字符</title>
    <link href="http://lmislm.com/2019/07/30/2019-07-30/"/>
    <id>http://lmislm.com/2019/07/30/2019-07-30/</id>
    <published>2019-07-29T16:00:00.000Z</published>
    <updated>2019-07-30T16:09:48.241Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>统计出现次数。</li><li><strong>连续</strong>出现次数。</li><li>时间复杂度尽量最小。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'abcaakjbb'</span> =&gt; &#123;<span class="string">'a'</span>:<span class="number">2</span>,<span class="string">'b'</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="string">'abbkejsbcccwqaa'</span> =&gt; &#123;<span class="string">'c'</span>:<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'abcaakjbb'</span></span><br><span class="line"><span class="comment">// 过程</span></span><br><span class="line"><span class="keyword">let</span> result = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> flag = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> strArr = str.split(<span class="string">''</span>)</span><br><span class="line"><span class="keyword">let</span> letterTimes = strArr.reduce(<span class="function">(<span class="params">acc, cur, index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!acc[cur]) &#123;</span><br><span class="line">    acc[cur] = <span class="number">1</span> <span class="comment">// 不存在，就创建键值对，初始值1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (strArr[index + <span class="number">1</span>] === cur) &#123;</span><br><span class="line">    acc[cur] += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 比较次数大小</span></span><br><span class="line">  <span class="keyword">if</span> (acc[cur] &gt; flag) &#123;</span><br><span class="line">    flag = acc[cur]</span><br><span class="line">  &#125;</span><br><span class="line">  acc[]</span><br><span class="line">  <span class="keyword">return</span> acc</span><br><span class="line">&#125;, &#123;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(letterTimes)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;统计出现次数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;连续&lt;/strong&gt;出现次数。&lt;/li&gt;
&lt;li&gt;时间复杂度尽量最小。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;abcaakjbb&#39;&lt;/span&gt; =&amp;gt; &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;abbkejsbcccwqaa&#39;&lt;/span&gt; =&amp;gt; &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;c&#39;&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day197-DOM Range操作</title>
    <link href="http://lmislm.com/2019/07/29/2019-07-29/"/>
    <id>http://lmislm.com/2019/07/29/2019-07-29/</id>
    <published>2019-07-28T16:00:00.000Z</published>
    <updated>2019-07-29T14:47:06.957Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>Range是？</li><li>createRange？<a id="more"></a><h2 id="Range是？"><a href="#Range是？" class="headerlink" title="Range是？"></a>Range是？</h2>Range是一种fragment（HTML片断），包含了节点或文本节点的一部分，通过document.createRange()或selection象的getRangeAt()方法获得。<blockquote><p>IE没有。需要检查兼容性。</p></blockquote></li></ol><h2 id="createRange？"><a href="#createRange？" class="headerlink" title="createRange？"></a>createRange？</h2><blockquote><p><code>Document.createRange()</code>常用来设置光标定位。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'editable'</span>)</span><br><span class="line"><span class="keyword">let</span> range = <span class="built_in">document</span>.createRange()</span><br><span class="line"><span class="keyword">let</span> sel = <span class="built_in">window</span>.getSelection()</span><br><span class="line">range.setStart(el.childNodes[<span class="number">2</span>], <span class="number">5</span>) <span class="comment">// childNodes来源于NodeList</span></span><br><span class="line">range.collapse(<span class="literal">true</span>) <span class="comment">// collapse(toStart) 折叠该范围，使它的“起点”和“结束点”重合。</span></span><br><span class="line">sel.removeAllRanges()</span><br><span class="line">sel.addRange(range)</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/rainman/archive/2011/02/28/1967488.html" target="_blank" rel="noopener">Javascript标准DOM Range操作</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/createRange" target="_blank" rel="noopener">Document.createRange()</a></p><p><a href="https://stackoverflow.com/questions/6249095/how-to-set-caretcursor-position-in-contenteditable-element-div" target="_blank" rel="noopener">How to set caret(cursor) position in contenteditable element (div)?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Range是？&lt;/li&gt;
&lt;li&gt;createRange？
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day196-事件循环的常见问题和错误观点</title>
    <link href="http://lmislm.com/2019/07/28/2019-07-28/"/>
    <id>http://lmislm.com/2019/07/28/2019-07-28/</id>
    <published>2019-07-27T16:00:00.000Z</published>
    <updated>2019-07-28T15:00:28.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>Node.js 是完全单线程？</li><li>其他线程？</li><li>事件循环是种栈结构？<a id="more"></a><h2 id="Node-js-是完全单线程"><a href="#Node-js-是完全单线程" class="headerlink" title="Node.js 是完全单线程?"></a>Node.js 是完全单线程?</h2>Node 单线程运行，但是Nodejs中一些标准库函数为了保证程序速度和性能并不是运行在同一个线程上（例如：fs函数）。</li></ol><h2 id="其他线程运行在什么地方？"><a href="#其他线程运行在什么地方？" class="headerlink" title="其他线程运行在什么地方？"></a>其他线程运行在什么地方？</h2><p>既然NOdejs不是单线程，那么其他线程运行在什么地方呢？Nodejs使用名为<code>libuv</code>的特殊库模块来执行异步操作。此库还和Node的后台逻辑一起使用，用来管理被称为<code>libuv线程池</code>的特殊线程池。</p><p>该特殊线程池由四个线程组成，用于委派对于事件循环来说太重（长时间运行，过于昂贵）的操作。</p><h2 id="事件循环是种栈结构"><a href="#事件循环是种栈结构" class="headerlink" title="事件循环是种栈结构"></a>事件循环是种栈结构</h2><p>在线程中可能涉及一些类似栈的结构，但其实是事件循环由一系列的阶段所组成，每个阶段都有自己的特定任务，所有阶段都以循环重复的方式去处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Node.js 是完全单线程？&lt;/li&gt;
&lt;li&gt;其他线程？&lt;/li&gt;
&lt;li&gt;事件循环是种栈结构？
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day195-Vue-style Hooks</title>
    <link href="http://lmislm.com/2019/07/27/2019-07-27/"/>
    <id>http://lmislm.com/2019/07/27/2019-07-27/</id>
    <published>2019-07-26T16:00:00.000Z</published>
    <updated>2019-07-27T14:22:25.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>在vue3中，将更多的采用hook。个人觉得，如果能保留之前的东西再加上hook，将会更加的灵活。</p><ol><li>API that maps Vue’s existing API.</li><li>Usage in Normal Vue Components<a id="more"></a><h2 id="API-that-maps-Vue’s-existing-API"><a href="#API-that-maps-Vue’s-existing-API" class="headerlink" title="API that maps Vue’s existing API."></a>API that maps Vue’s existing API.</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  withHooks,</span><br><span class="line">  useData,</span><br><span class="line">  useComputed,</span><br><span class="line">  useWatch,</span><br><span class="line">  useMounted,</span><br><span class="line">  useUpdated,</span><br><span class="line">  useDestroyed</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"vue-hooks"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Foo = withHooks(<span class="function"><span class="params">h</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> data = useData(&#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> double = useComputed(<span class="function"><span class="params">()</span> =&gt;</span> data.count * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  useWatch(<span class="function"><span class="params">()</span> =&gt;</span> data.count, (val, prevVal) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`count is: <span class="subst">$&#123;val&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  useMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'mounted!'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  useUpdated(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'updated!'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  useDestroyed(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'destroyed!'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> h(<span class="string">'div'</span>, [</span><br><span class="line">    h(<span class="string">'div'</span>, <span class="string">`count is <span class="subst">$&#123;data.count&#125;</span>`</span>),</span><br><span class="line">    h(<span class="string">'div'</span>, <span class="string">`double count is <span class="subst">$&#123;double&#125;</span>`</span>),</span><br><span class="line">    h(<span class="string">'button'</span>, &#123; <span class="attr">on</span>: &#123; <span class="attr">click</span>: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// still got that direct mutation!</span></span><br><span class="line">      data.count++</span><br><span class="line">    &#125;&#125;&#125;, <span class="string">'count++'</span>)</span><br><span class="line">  ])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h2 id="Usage-in-Normal-Vue-Components"><a href="#Usage-in-Normal-Vue-Components" class="headerlink" title="Usage in Normal Vue Components"></a>Usage in Normal Vue Components</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; hooks, useData, useComputed &#125; <span class="keyword">from</span> <span class="string">'vue-hooks'</span></span><br><span class="line"></span><br><span class="line">Vue.use(hooks)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div @click="data.count++"&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123; data.count &#125;&#125; &#123;&#123; double &#125;&#125;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span>,</span><br><span class="line">  hooks() &#123;</span><br><span class="line">    <span class="keyword">const</span> data = useData(&#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> double = useComputed(<span class="function"><span class="params">()</span> =&gt;</span> data.count * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      data,</span><br><span class="line">      double</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;p&gt;在vue3中，将更多的采用hook。个人觉得，如果能保留之前的东西再加上hook，将会更加的灵活。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;API that maps Vue’s existing API.&lt;/li&gt;
&lt;li&gt;Usage in Normal Vue Components
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day194-控制contenteditable的光标</title>
    <link href="http://lmislm.com/2019/07/26/2019-07-26/"/>
    <id>http://lmislm.com/2019/07/26/2019-07-26/</id>
    <published>2019-07-25T16:00:00.000Z</published>
    <updated>2019-07-26T15:09:49.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>元素为<code>contenteditable</code>时控制光标在尾部，方法适用于粘贴纯文本时，光标的定位。<br><a id="more"></a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">placeCaretAtEnd</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">  el.focus();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span>.getSelection != <span class="string">"undefined"</span></span><br><span class="line">      &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">document</span>.createRange != <span class="string">"undefined"</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> range = <span class="built_in">document</span>.createRange();</span><br><span class="line">    range.selectNodeContents(el);</span><br><span class="line">    range.collapse(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">var</span> sel = <span class="built_in">window</span>.getSelection();</span><br><span class="line">    sel.removeAllRanges();</span><br><span class="line">    sel.addRange(range);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">document</span>.body.createTextRange != <span class="string">"undefined"</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> textRange = <span class="built_in">document</span>.body.createTextRange();</span><br><span class="line">    textRange.moveToElementText(el);</span><br><span class="line">    textRange.collapse(<span class="literal">false</span>);</span><br><span class="line">    textRange.select();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">placeCaretAtEnd( <span class="built_in">document</span>.querySelector(<span class="string">'p'</span>) );</span><br></pre></td></tr></table></figure><h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://stackoverflow.com/questions/4233265/contenteditable-set-caret-at-the-end-of-the-text-cross-browser/4238971#4238971" target="_blank" rel="noopener">stackoverflow—contenteditable, set caret at the end of the text (cross-browser)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;p&gt;元素为&lt;code&gt;contenteditable&lt;/code&gt;时控制光标在尾部，方法适用于粘贴纯文本时，光标的定位。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day193-模拟new</title>
    <link href="http://lmislm.com/2019/07/25/2019-07-25/"/>
    <id>http://lmislm.com/2019/07/25/2019-07-25/</id>
    <published>2019-07-24T16:00:00.000Z</published>
    <updated>2019-07-25T14:09:49.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>模拟new<br>直接上代码,之前有写过两次，但是一个过于毛糙，一个过于复杂不便于理解。这里根据记忆，再手写一遍。<a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟new</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newFactory</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  Constructor = [].shift.call(<span class="built_in">arguments</span>)</span><br><span class="line">  <span class="comment">// __proto__不建议使用了，建议用Object.create()代替</span></span><br><span class="line">  <span class="comment">// var newObj = Object.create(null)</span></span><br><span class="line">  <span class="comment">// newObj.__proto__ = Constructor.prototype</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> newObj = <span class="built_in">Object</span>.create(Constructor.prototype)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> r = Constructor.apply(newObj, <span class="built_in">arguments</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> newObj === <span class="string">'object'</span> ? r || newObj : newObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newTes</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(newFactory(newTes, <span class="string">'ceshi'</span>))</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;模拟new&lt;br&gt;直接上代码,之前有写过两次，但是一个过于毛糙，一个过于复杂不便于理解。这里根据记忆，再手写一遍。
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day192-event loop-处理过程</title>
    <link href="http://lmislm.com/2019/07/24/2019-07-24/"/>
    <id>http://lmislm.com/2019/07/24/2019-07-24/</id>
    <published>2019-07-23T16:00:00.000Z</published>
    <updated>2019-07-24T14:57:24.790Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>event loop的处理过程（Processing model）<a id="more"></a><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2></li></ol><blockquote><p><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model" target="_blank" rel="noopener">event-loop-processing-model</a></p></blockquote><p>只要<code>event loop</code>存在，就会不断执行下面的步骤：</p><ol><li>让task queue成为事件循环的任务队列之一，以用户代理定义的方式选择，约束条件是所选任务队列必须至少包含一个可运行的任务。如果没有这样的任务队列，那么跳到下一个微任务步骤。</li><li>让oldesttask成为taskqueue中的第一个可运行任务，并将其从taskqueue中删除。</li><li>通过执行以下步骤报告用户代理不执行此循环的持续时间： ….</li><li>将事件循环当前正在运行的任务设置为OldestTask。</li><li>执行旧任务的步骤。</li><li>从其任务队列中删除OldestTask。</li><li>Microtasks: 执行microtasks任务检查点（microtasks队列里的任务）。<blockquote><p>…</p></blockquote></li><li>更新渲染<blockquote><p>…</p></blockquote></li><li>如果这是一个worker event loop，但是没有任务在task队列中，并且WorkerGlobalScope对象的closing标识为true，则销毁event loop，中止这些步骤，然后进行定义在Web workers章节的run a worker。</li><li>返回到第一步。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;event loop的处理过程（Processing model）
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
