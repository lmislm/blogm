<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LMISLMのBlog</title>
  
  <subtitle>不积小流，无以成江海。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lmislm.com/"/>
  <updated>2019-05-13T15:27:18.495Z</updated>
  <id>http://lmislm.com/</id>
  
  <author>
    <name>lmislm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>day121-数组扁平化-去重-升序</title>
    <link href="http://lmislm.com/2019/05/13/2019-05-13/"/>
    <id>http://lmislm.com/2019/05/13/2019-05-13/</id>
    <published>2019-05-12T16:00:00.000Z</published>
    <updated>2019-05-13T15:27:18.495Z</updated>
    
    <content type="html"><![CDATA[<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr.flat(<span class="literal">Infinity</span>))).sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123; <span class="keyword">return</span> a-b&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;sp
      
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day120-js深拷贝</title>
    <link href="http://lmislm.com/2019/05/12/2019-05-12/"/>
    <id>http://lmislm.com/2019/05/12/2019-05-12/</id>
    <published>2019-05-11T16:00:00.000Z</published>
    <updated>2019-05-12T15:29:12.172Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>来一个js的深拷贝，和JSON.stringify实现的还是有点区别的。</p><a id="more"></a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//判断是否是简单数据类型，</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj == <span class="string">"object"</span>)&#123;</span><br><span class="line">        <span class="comment">//复杂数据类型</span></span><br><span class="line">        <span class="keyword">var</span> result = obj.constructor == <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> obj)&#123;</span><br><span class="line">            result[i] = <span class="keyword">typeof</span> obj[i] == <span class="string">"object"</span> ? deepCopy(obj[i]) : obj[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//简单数据类型 直接 == 赋值</span></span><br><span class="line">        <span class="keyword">var</span> result = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;来一个js的深拷贝，和JSON.stringify实现的还是有点区别的。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day118-手写简单的函数柯里化-笔记</title>
    <link href="http://lmislm.com/2019/05/10/2019-05-10/"/>
    <id>http://lmislm.com/2019/05/10/2019-05-10/</id>
    <published>2019-05-09T16:00:00.000Z</published>
    <updated>2019-05-10T15:37:09.628Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>函数柯里化是属于高阶函数中一种常见的技术。特点就是<code>参数复用</code>、<code>提前返回</code>和<code>延迟执行</code>。</p><a id="more"></a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span> (<span class="params">fn, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> length = fn.length</span><br><span class="line">  <span class="keyword">var</span> args = args || []</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    newArgs = args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>))</span><br><span class="line">    <span class="keyword">if</span> (newArgs.length &lt; length) &#123;</span><br><span class="line">      <span class="keyword">return</span> curry.call(<span class="keyword">this</span>, fn, newArgs)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, newArgs)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiFn</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b * c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> multi = curry(multiFn)</span><br><span class="line"></span><br><span class="line">multi(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br><span class="line">multi(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">multi(<span class="number">1</span>)(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">multi(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;函数柯里化是属于高阶函数中一种常见的技术。特点就是&lt;code&gt;参数复用&lt;/code&gt;、&lt;code&gt;提前返回&lt;/code&gt;和&lt;code&gt;延迟执行&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day119-实现一个instanceOf笔记</title>
    <link href="http://lmislm.com/2019/05/10/2019-05-11/"/>
    <id>http://lmislm.com/2019/05/10/2019-05-11/</id>
    <published>2019-05-09T16:00:00.000Z</published>
    <updated>2019-05-10T16:14:39.163Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>话不多说，这篇是水篇。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现一个instanceOf</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceOf</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> proto = left.__proto__</span><br><span class="line">  <span class="keyword">let</span> prototype = right.prototype</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!proto) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proto === prototype) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    proto === proto.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;话不多说，这篇是水篇。&lt;/p&gt;
&lt;h3 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 实现一个instanceOf&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;myInstanceOf&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;left, right&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; proto = left.__proto__&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; prototype = right.prototype&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!proto) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (proto === prototype) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    proto === proto.__proto__&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day117-手写简单防抖</title>
    <link href="http://lmislm.com/2019/05/09/2019-05-09/"/>
    <id>http://lmislm.com/2019/05/09/2019-05-09/</id>
    <published>2019-05-08T16:00:00.000Z</published>
    <updated>2019-05-09T15:44:43.901Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>其实就是一个apply调用。非常简单。重点是理解防抖和节流这两个概念吧。<br>首次事件发生之后，需要<strong>延迟(wait)时间</strong>处理。<br>延迟时间段内有第二次事件，则以第二次事件为准<strong>延迟处理</strong>。<br>知道最后一次时间段内没有事件，则执行最后一次。</p><a id="more"></a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li><p>debounce</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">fn, wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 注意arguments是当前函数内的参数</span></span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123; fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>) &#125;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123; clearTimeout(timer) &#125;</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>throttle</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prev = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    <span class="comment">// 在wait时间内只执行一次</span></span><br><span class="line">    <span class="keyword">if</span> (now - prev &gt; wait) &#123;</span><br><span class="line">      <span class="comment">// 注意arguments是当前函数内的参数</span></span><br><span class="line">      fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">      prev = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>总结就是：<strong>throttle限制函数调用频率，debounce则限制函数调用速率</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;其实就是一个apply调用。非常简单。重点是理解防抖和节流这两个概念吧。&lt;br&gt;首次事件发生之后，需要&lt;strong&gt;延迟(wait)时间&lt;/strong&gt;处理。&lt;br&gt;延迟时间段内有第二次事件，则以第二次事件为准&lt;strong&gt;延迟处理&lt;/strong&gt;。&lt;br&gt;知道最后一次时间段内没有事件，则执行最后一次。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day116-手写JSON.stringify</title>
    <link href="http://lmislm.com/2019/05/08/2019-05-08/"/>
    <id>http://lmislm.com/2019/05/08/2019-05-08/</id>
    <published>2019-05-07T16:00:00.000Z</published>
    <updated>2019-05-09T15:25:34.205Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>没啥可说的，这篇比较水。<br><code>JSON.stringify(value[, replacer [, space]])</code></p><a id="more"></a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonStringify</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> type = <span class="keyword">typeof</span> obj</span><br><span class="line">  <span class="keyword">if</span> (type !== <span class="string">"object"</span>) &#123;</span><br><span class="line">    <span class="comment">// undefined 什么的会被忽略，循环引用也会被忽略</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/string|undefined|function/</span>.test(type)) &#123;</span><br><span class="line">      obj = <span class="string">'"'</span> + obj + <span class="string">'"'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(obj)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> json = []</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="built_in">Array</span>.isArray(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">let</span> v = obj[k]</span><br><span class="line">      <span class="keyword">let</span> type = <span class="keyword">typeof</span> v</span><br><span class="line">      <span class="keyword">if</span> (<span class="regexp">/string|undefined|function/</span>.test(type)) &#123;</span><br><span class="line">        v = <span class="string">'"'</span> + v + <span class="string">'"'</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">"object"</span>) &#123;</span><br><span class="line">        v = jsonStringify(v)</span><br><span class="line">      &#125;</span><br><span class="line">      json.push((arr ? <span class="string">""</span> : <span class="string">'"'</span> + k + <span class="string">'":'</span>) + <span class="built_in">String</span>(v))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (arr ? <span class="string">"["</span> : <span class="string">"&#123;"</span>) + <span class="built_in">String</span>(json) + (arr ? <span class="string">"]"</span> : <span class="string">"&#125;"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://juejin.im/post/5c9c3989e51d454e3a3902b6#heading-1" target="_blank" rel="noopener">JavaScript手写代码无敌秘籍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;没啥可说的，这篇比较水。&lt;br&gt;&lt;code&gt;JSON.stringify(value[, replacer [, space]])&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day115-实现事件类Event</title>
    <link href="http://lmislm.com/2019/05/07/2019-05-07/"/>
    <id>http://lmislm.com/2019/05/07/2019-05-07/</id>
    <published>2019-05-06T16:00:00.000Z</published>
    <updated>2019-05-08T14:40:37.316Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong>源起：</strong><br>同页面组件间通信使用事件监听和派发的方式，而不是直接相互调用组件方法。用[订阅发布模式]，保证组件的独立性和降低组件间耦合度。</p><p><img src="https://i.loli.net/2019/05/07/5cd1a8d874919.jpg" alt="">·</p><a id="more"></a><p><strong>核心：</strong><br>核心是一个<em>事件类型</em>对应回调函数的数据设计。</p><h3 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h3><p>本质上是一个观察者模式的实现。且Node.js原生自带<strong>EventEmitter</strong>模块，所以这部分是比较重要的。<br>实现一个事件类Event ，包含下面功能：</p><ol><li>绑定事件</li><li>解绑事件</li><li>派发事件</li></ol><ul><li><p><strong>on(eventName, func)</strong>：<br>  监听 eventName事件， 事件触发的时候调用 func函数</p></li><li><p><strong>emit(eventName, arg1, arg2, arg3,arg4…)</strong>：<br> 触发eventName 事件, 并且把参数 arg1, arg2, arg3,arg4…传给事件处理函数</p></li><li><strong>off(eventName, func)</strong>：<br>  停止监听某个事件</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/60324936" target="_blank" rel="noopener">实现一个Event类（发布订阅模式）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;源起：&lt;/strong&gt;&lt;br&gt;同页面组件间通信使用事件监听和派发的方式，而不是直接相互调用组件方法。用[订阅发布模式]，保证组件的独立性和降低组件间耦合度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/05/07/5cd1a8d874919.jpg&quot; alt=&quot;&quot;&gt;·&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day114-实现new运算符（2）</title>
    <link href="http://lmislm.com/2019/05/06/2019-05-06/"/>
    <id>http://lmislm.com/2019/05/06/2019-05-06/</id>
    <published>2019-05-05T16:00:00.000Z</published>
    <updated>2019-05-08T14:40:14.398Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>new 模拟实现大致思路：</p><ol><li>建立一个新对象</li><li>通过<code>new</code>创建的每个对象将最终被<code>[[Prototype]]</code>链接到这个函数的<code>prototype</code>对象上</li><li>实例可以访问原型上的属性</li></ol><h4 id="原型的知识复习"><a href="#原型的知识复习" class="headerlink" title="原型的知识复习"></a>原型的知识复习</h4><p><strong>[[prototype]] 是什么？</strong><br>JavaScript中的对象，都有一个特殊的[[prototype]]内置属性，其实就是对于其他对象的引用。（你不知道的JavaScript-上卷-第五章）<br><a id="more"></a><br><strong>__proto__ 是什么？</strong><br>__proto__ ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。<br><strong>new.target 是什么？</strong><br>new.target属性允许你检测函数或构造方法是否是通过new运算符被调用的。在通过new运算符被初始化的函数或构造方法中，new.target返回一个指向构造方法或函数的引用。在普通的函数调用中，new.target 的值是undefined。</p><p>原型关系图：</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1fytrxmsbzsj20eg0gbq6u.jpg" alt=""></p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myObjectFactory</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Constructor = [].shift.call(<span class="built_in">arguments</span>) <span class="comment">// 取外部传入的构造器</span></span><br><span class="line">  <span class="keyword">var</span> newObj = <span class="built_in">Object</span>.create(Constructor.prototype)</span><br><span class="line">  <span class="comment">// newObj也可以这么写</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * var obj = new Object()</span></span><br><span class="line"><span class="comment">   * obj.__proto__ = Constructor.prototype</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">var</span> ctorResult = Constructor.apply(newObj, <span class="built_in">arguments</span>)</span><br><span class="line">  <span class="comment">// 判断返回的值是不是一个对象，如果是一个对象，则返回对象</span></span><br><span class="line">  <span class="comment">// 注意：判ctorResult是否空</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> ctorResult === <span class="string">'object'</span> ? ctorResult||newObj : newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一种实现<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">unction New(func) &#123;</span><br><span class="line">    <span class="keyword">var</span> res = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (func.prototype !== <span class="literal">null</span>) &#123;</span><br><span class="line">        res.__proto__ = func.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> ret = func.apply(res, <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">typeof</span> ret === <span class="string">"object"</span> || <span class="keyword">typeof</span> ret === <span class="string">"function"</span>) &amp;&amp; ret !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = New(A, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// equals to</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> A(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><p>引自：<a href="https://juejin.im/post/5c9c3989e51d454e3a3902b6#heading-1" target="_blank" rel="noopener">实现一个new操作符</a></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 测试用例-1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.habit = <span class="string">'Games'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test.prototype.age = <span class="number">22</span></span><br><span class="line"></span><br><span class="line">Test.prototype.sayYourName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'I am '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = myObjectFactory(Test, <span class="string">'zhangsan'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// zhangsan</span></span><br><span class="line"><span class="built_in">console</span>.log(person.habit) <span class="comment">// Games</span></span><br><span class="line"><span class="built_in">console</span>.log(person.age) <span class="comment">// 22</span></span><br><span class="line"></span><br><span class="line">person.sayYourName() <span class="comment">// I am zhangsan</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例-2 虚实__proto__(Object.create(null))</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Otaku</span> (<span class="params">age</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Otaku.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = myObjectFactory(Otaku, <span class="string">'Kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person) <span class="comment">// Otaku &#123;&#125;</span></span><br><span class="line">person.sayHello() <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="noopener">JavaScript深入之new的模拟实现</a><br><a href="https://www.zhihu.com/question/34183746" target="_blank" rel="noopener">js中_proto_和prototype的区别和关系？</a><br><a href="https://lmislm.com//2019/01/10/2019-01-10/#%E8%A1%A5%E5%85%85">怎么实现new</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new.target" target="_blank" rel="noopener">new​.target</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;new 模拟实现大致思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立一个新对象&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;new&lt;/code&gt;创建的每个对象将最终被&lt;code&gt;[[Prototype]]&lt;/code&gt;链接到这个函数的&lt;code&gt;prototype&lt;/code&gt;对象上&lt;/li&gt;
&lt;li&gt;实例可以访问原型上的属性&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;原型的知识复习&quot;&gt;&lt;a href=&quot;#原型的知识复习&quot; class=&quot;headerlink&quot; title=&quot;原型的知识复习&quot;&gt;&lt;/a&gt;原型的知识复习&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;[[prototype]] 是什么？&lt;/strong&gt;&lt;br&gt;JavaScript中的对象，都有一个特殊的[[prototype]]内置属性，其实就是对于其他对象的引用。（你不知道的JavaScript-上卷-第五章）&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day113-实现new运算符（1）</title>
    <link href="http://lmislm.com/2019/05/05/2019-05-05/"/>
    <id>http://lmislm.com/2019/05/05/2019-05-05/</id>
    <published>2019-05-04T16:00:00.000Z</published>
    <updated>2019-05-06T15:44:39.093Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一些实现new运算符的思路整理。</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g2qtkmlyotj20e709g75f.jpg" alt=""><br><a id="more"></a><br>new 运算符，new关键字的操作（MDN）：</p><ol><li><p>Creates a blank, plain JavaScript object;</p><blockquote><p>创建一个空的简单JavaScript对象（即{}）；</p></blockquote></li><li><p>Links (sets the constructor of) this object to another object;</p><blockquote><p>链接该对象（即设置该对象的构造函数）到另一个对象 ；</p></blockquote></li><li><p>Passes the newly created object from Step 1 as the this context;</p><blockquote><p>将步骤1新创建的对象作为this的上下文 ；</p></blockquote></li><li><p>Returns this if the function doesn’t return its own object.</p><blockquote><p>如果该函数没有返回对象，则返回this。</p></blockquote></li></ol><p>new Foo() 发生了什么？<br>当代码 new Foo(…) 执行时，会发生以下事情：</p><ol><li>一个继承自 Foo.prototype 的新对象被创建。</li><li>使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象。new Foo 等同于 Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。</li><li>由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;一些实现new运算符的思路整理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g2qtkmlyotj20e709g75f.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day112-手写原生bind()-2</title>
    <link href="http://lmislm.com/2019/05/04/2019-05-04/"/>
    <id>http://lmislm.com/2019/05/04/2019-05-04/</id>
    <published>2019-05-03T16:00:00.000Z</published>
    <updated>2019-05-06T14:23:25.560Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前实现的bind()，能返回新函数，也能参数传递，实际原生的bind()还能实现<strong>构造函数</strong>的效果。这个用法也是很常用的。其中还涉及到绑定函数时，需要了解<strong>new 的模拟实现</strong>。</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g2qtkma14uj20cl09gjrq.jpg" alt=""><br><a id="more"></a></p><blockquote><p>MDN上作为构造函数的绑定函数，如下。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bind() 作为构造函数的绑定函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x</span><br><span class="line">  <span class="keyword">this</span>.y = y</span><br><span class="line">&#125;</span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.x + <span class="string">','</span> + <span class="keyword">this</span>.y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> YAxisPoint = Point.bind(<span class="literal">null</span>, <span class="number">0</span><span class="comment">/*x*/</span>)</span><br><span class="line"><span class="keyword">var</span> axisPoint = <span class="keyword">new</span> YAxisPoint(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">var</span> result = axisPoint.toString()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// 0,5</span></span><br></pre></td></tr></table></figure><p>做一些改动。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 改动</span></span><br><span class="line"><span class="keyword">var</span> contextObj = &#123;</span><br><span class="line">  x: <span class="string">'1'</span>,</span><br><span class="line">  y: <span class="string">'2'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> YAxisPoint2 = Point.bind(contextObj)</span><br><span class="line"><span class="keyword">var</span> result2 = <span class="keyword">new</span> YAxisPoint(<span class="string">'1'</span>, <span class="string">'9'</span>)</span><br><span class="line"><span class="comment">// 绑定的 this 失效</span></span><br><span class="line"><span class="built_in">console</span>.log(YAxisPoint2.x) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p>代码里有些要注意的点。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">ct</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _self = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 原型变量</span></span><br><span class="line">  <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 注意：arguments是当前函数的参数</span></span><br><span class="line">    <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="comment">// fBound做构造函数时，将绑定函数的this指向该实例，让实例获得来自绑定函数的值</span></span><br><span class="line">    <span class="keyword">return</span> _self.apply(fNOP.prototype.isPrototype(<span class="keyword">this</span>) ? <span class="keyword">this</span> : ct, args.concat(bindArgs))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实例继承绑定函数原型</span></span><br><span class="line">  <span class="comment">// fBound.prototype = this.prototype</span></span><br><span class="line">  <span class="comment">// 这里args长度会变化？？？</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.prototype) &#123;</span><br><span class="line">    <span class="comment">// 维护原型关系，空函数中转</span></span><br><span class="line">    fNOP.protytype = <span class="keyword">this</span>.prototype</span><br><span class="line">  &#125;</span><br><span class="line">  fBound.prototype = <span class="keyword">new</span> fNOP()</span><br><span class="line">  <span class="keyword">return</span> fBound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一些细节：<br>    这部分实现创建的绑定函数所有的 length 属性并不是同ECMA-262标准一致的：它创建的函数的 length 是0，而在实际的实现中根据目标函数的 length 和预先指定的参数个数可能会返回非零的 length。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/mqyqingfeng/Blog/issues/12" target="_blank" rel="noopener">JavaScript深入之bind的模拟实现</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">MDN(中文版)Function​.prototype​.bind()</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">MDN(英文版)Function​.prototype​.bind()</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;之前实现的bind()，能返回新函数，也能参数传递，实际原生的bind()还能实现&lt;strong&gt;构造函数&lt;/strong&gt;的效果。这个用法也是很常用的。其中还涉及到绑定函数时，需要了解&lt;strong&gt;new 的模拟实现&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g2qtkma14uj20cl09gjrq.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day111-手写原生bind()-1</title>
    <link href="http://lmislm.com/2019/05/03/2019-05-03/"/>
    <id>http://lmislm.com/2019/05/03/2019-05-03/</id>
    <published>2019-05-02T16:00:00.000Z</published>
    <updated>2019-05-05T14:40:18.482Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一般bind()用的比较多的就是<strong>创建绑定函数</strong>，还有就是<strong>偏函数</strong>。所以这里可能就是从bind函数的一般用法来考虑实现。MDN上的Polyfill借用slice()，concat()，call()方法。这里也是差不多的实现方法。</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g2ofiscpy6j20gs09ggnu.jpg" alt=""><br><a id="more"></a></p><ul><li><p>MDN上的例子</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.x = <span class="number">9</span>;    <span class="comment">// 在浏览器中，this指向全局的 "window" 对象</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">  x: <span class="number">81</span>,</span><br><span class="line">  getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.x &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.getX() <span class="comment">// 81</span></span><br><span class="line"><span class="comment">//注意：新手容易错的地方-将一个方法从对象中拿出来，会丢失原来的对象</span></span><br><span class="line"><span class="keyword">var</span> retrieveX = <span class="built_in">module</span>.getX</span><br><span class="line">retrieveX()</span><br><span class="line"><span class="comment">// 返回9 - 因为函数是在全局作用域中调用的</span></span><br></pre></td></tr></table></figure></li><li><p>利用bind处理</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个新函数，把 'this' 绑定到 module 对象</span></span><br><span class="line"><span class="comment">// 新手可能会将全局变量 x 与 module 的属性 x 混淆</span></span><br><span class="line">原始的对象创建一个绑定函数</span><br><span class="line"><span class="keyword">var</span> boundGetX = retrieveX.bind(<span class="built_in">module</span>)</span><br><span class="line">boundGetX() <span class="comment">// 81</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li>实现参数的传递<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">ct</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// 获取从第二个参数到最后一个参数</span></span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 注意：arguments指bind返回的函数传入的参数</span></span><br><span class="line">      <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">      self.apply(ct, args.concat(bindArgs))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>未完。。。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">MDN</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;一般bind()用的比较多的就是&lt;strong&gt;创建绑定函数&lt;/strong&gt;，还有就是&lt;strong&gt;偏函数&lt;/strong&gt;。所以这里可能就是从bind函数的一般用法来考虑实现。MDN上的Polyfill借用slice()，concat()，call()方法。这里也是差不多的实现方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g2ofiscpy6j20gs09ggnu.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day110-手写原生call()</title>
    <link href="http://lmislm.com/2019/05/02/2019-05-02/"/>
    <id>http://lmislm.com/2019/05/02/2019-05-02/</id>
    <published>2019-05-01T16:00:00.000Z</published>
    <updated>2019-05-06T14:23:14.311Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>call()反正我是用的比较少吧，但是从大家的使用量来说，这个函数是非常的重要。因为他有一些方法，起了很重要的作用。比如简单的继承，指定上下文等。 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="noopener">用法 - MDN</a></p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g2neqaijfjj20e609gglv.jpg" alt=""><br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.price = price + <span class="string">'++'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Food</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 下面的this表示Product在执行时真正的this值(严格模式。非严格模式则是指向全局对象)</span></span><br><span class="line">  Product.call(<span class="keyword">this</span>, name, price)</span><br><span class="line">  <span class="keyword">this</span>.category = <span class="string">'food'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Food(<span class="string">'cheese'</span>, <span class="number">5</span>).name)</span><br></pre></td></tr></table></figure></p><h3 id="代码-call"><a href="#代码-call" class="headerlink" title="代码-call()"></a>代码-call()</h3><blockquote><p>实现fun.protytype.myCall思路ES3 ： </p></blockquote><p><strong>步骤一</strong>确定参数数量</p><ul><li>先实现确定参数数量的myCall，因为function.prototype.call(thisArg, arg1, arg2, …),实际上是不确定参数的</li><li>fun的参数全部存到fun的临时处fun.temp</li><li>fun.temp() 输出在fun中存有的参数</li><li>删除fun中新增的temp，用delete</li></ul><blockquote><p>其他实现的思路好像都差不多。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">     args.temp = <span class="keyword">this</span></span><br><span class="line">     args.temp()</span><br><span class="line">     <span class="keyword">delete</span> args.temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤二</strong>不确定参数数量</p><blockquote><p>实现fun.protytype.myCall思路ES3 ：</p></blockquote><ul><li>对call的参数进行处理，用slice来分开参数</li><li>对分开之后的参数做不同处理</li><li>注意：非严格模式下thisArgs的null\undefined指向全局变量（浏览器是window）</li><li>用eval来连接args<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// null错误处理</span></span><br><span class="line">  args = args || <span class="built_in">window</span></span><br><span class="line">  args.temp = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result</span><br><span class="line">  <span class="keyword">if</span> (!args) &#123;</span><br><span class="line">    result = args.temp()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> argsList = []</span><br><span class="line">    <span class="comment">// 第二个参数及其以后的都存入数组, 注意arguments</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, l = <span class="built_in">arguments</span>.length; i &lt; l; i++) &#123;</span><br><span class="line">      argsList.push(<span class="string">'arguments['</span> + i + <span class="string">']'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// todo: eval不是很推荐的方法，需要一个好的方式连接 eval() https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval</span></span><br><span class="line">    result = <span class="built_in">eval</span>(<span class="string">'args.temp('</span> + argsList + <span class="string">')'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> fn.temp</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>// 待测试</p><h3 id="代码-apply"><a href="#代码-apply" class="headerlink" title="代码-apply()"></a>代码-apply()</h3><p>apply()和call()差不多，就是差在apply传入数组参数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply() = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg, argsArr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 注意Object()</span></span><br><span class="line">  thisArg = <span class="built_in">Object</span>(thisArg) || <span class="built_in">window</span></span><br><span class="line">  thisArg.temp = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">var</span> result</span><br><span class="line">  <span class="keyword">if</span> (!argsArr) &#123;</span><br><span class="line">    result = thisArg.temp</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 注意i = 0</span></span><br><span class="line">    <span class="keyword">var</span> arrTemp = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = argsArr.length; i &lt; l; i++) &#123;</span><br><span class="line">      arrTemp.push(<span class="string">'argsArr['</span> + i + <span class="string">']'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="built_in">eval</span>(<span class="string">'thisArg.temp('</span> + arrTemp + <span class="string">')'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/mqyqingfeng/Blog/issues/11" target="_blank" rel="noopener">JavaScript深入之call和apply的模拟实现 </a><br><a href="https://segmentfault.com/a/1190000017206223" target="_blank" rel="noopener">能否模拟实现JS的call和apply方法</a><br><a href="https://www.zhihu.com/question/35787390" target="_blank" rel="noopener">不能使用call,apply,bind，如何用js实现call或者apply的功能？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;call()反正我是用的比较少吧，但是从大家的使用量来说，这个函数是非常的重要。因为他有一些方法，起了很重要的作用。比如简单的继承，指定上下文等。 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;用法 - MDN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g2neqaijfjj20e609gglv.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day109-ts实现mvvm-笔记（2）</title>
    <link href="http://lmislm.com/2019/05/01/2019-05-01/"/>
    <id>http://lmislm.com/2019/05/01/2019-05-01/</id>
    <published>2019-04-30T16:00:00.000Z</published>
    <updated>2019-05-06T14:23:01.327Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>数组的依赖收集？？？</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g2m6x7ao74j20e609g3yu.jpg" alt=""><br><a id="more"></a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Dep <span class="keyword">from</span> <span class="string">"../../2019-04/30/vuejs/dep"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上文2019-04-30-vuejs</span></span><br><span class="line"><span class="comment">// 数组的依赖收集</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj: <span class="built_in">any</span>, key: <span class="built_in">string</span>, val?: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">    dep.depend()</span><br><span class="line">    <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">      childOb.dep.depend()</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">        dependArray(value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dependArray</span> (<span class="params">value: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> e, i = <span class="number">0</span>, l = value.length; i &lt; l; i++) &#123;</span><br><span class="line">    e = value[i]</span><br><span class="line">    <span class="comment">// 多维数组？？</span></span><br><span class="line">    e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend()</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(e)) &#123;</span><br><span class="line">      dependArray(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;数组的依赖收集？？？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g2m6x7ao74j20e609g3yu.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day108-ts实现mvvm-笔记（1）</title>
    <link href="http://lmislm.com/2019/04/30/2019-04-30/"/>
    <id>http://lmislm.com/2019/04/30/2019-04-30/</id>
    <published>2019-04-29T16:00:00.000Z</published>
    <updated>2019-05-01T14:25:44.691Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Vue3.0的源码要用typescript来编写，同时个人随着近期typescript的练习渐渐变多，比如上周就用typescript写了，国际化的文本提取解析和替换（其中涉及到babel），也感觉到静态语言的强大。所以就慢慢的上手typescript咯。</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g2kzpuojwjj20e509gwf6.jpg" alt=""><br><a id="more"></a></p><h3 id="代码-依赖收集-dep"><a href="#代码-依赖收集-dep" class="headerlink" title="代码-依赖收集-dep"></a>代码-依赖收集-dep</h3><p>之前依赖收集这部分还是有点迷糊的，所以这次着重先去尝试着完全理解依赖收集这部分，尤其是Dep.target = null的上下文发生的事情。还是比较习惯先上代码来说话。</p><h3 id="dep-js"><a href="#dep-js" class="headerlink" title="dep.js"></a>dep.js</h3><p>关于 Observer, Dep, Watcher相互间的联系总结出Dep的几句话：</p><ol><li>Dep实质是个数组，放置监听这个Observer的Watcher，当Observer对应的值变化时，就通知Dep中的所有Watcher执行callback。</li><li>闭包中的Dep保存这个键的Watcher</li><li><p>Watcher该<strong>放进哪些Dep</strong>中<br>规定一个全局变量，初始化null，依赖收集阶段，让<strong>全局变量指向Watcher</strong>。</p><p>主要还是Dep和Watcher是怎样的关系，这点容易迷糊。</p></li></ol><p><strong>代码</strong><br><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// util一些检验方法</span></span><br><span class="line"><span class="keyword">import</span> &#123; remove &#125; <span class="keyword">from</span> <span class="string">'./util'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Watcher &#125; <span class="keyword">from</span> <span class="string">'./watcher'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> Dep &#123;</span><br><span class="line">  <span class="comment">// Dep.target 即全局变量</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> target: Watcher | <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> id: <span class="built_in">number</span></span><br><span class="line">  <span class="keyword">public</span> subs: Watcher[]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = uid++</span><br><span class="line">    <span class="keyword">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> addSub (sub: Watcher) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> removeSub (sub: Watcher) &#123;</span><br><span class="line">    remove(<span class="keyword">this</span>.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Dep.target, ?????</span></span><br><span class="line">  <span class="keyword">public</span> depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      <span class="keyword">this</span>.addSub(Dep.target)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> notify() &#123;</span><br><span class="line">    <span class="comment">// 防止数组变化，先复制一份？???</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="keyword">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="comment">// Watcher上定义的update方法</span></span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意： 这里vuejs源码中还有加了一段。(vue/src/core/observer/dep.js, 318f29f on 10 Mar 2018)</span></span><br><span class="line"><span class="comment">// the current target watcher being evaluated.</span></span><br><span class="line"><span class="comment">// this is globally unique because there could be only one</span></span><br><span class="line"><span class="comment">// watcher being evaluated at any time.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dep.target = null</span></span><br><span class="line"><span class="comment">// const targetStack = []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// export function pushTarget(_target: ?Watcher) &#123;</span></span><br><span class="line"><span class="comment">//  if (Dep.target) targetStack.push(Dep.target)</span></span><br><span class="line"><span class="comment">//  Dep.target = _target </span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// export function popTarget () &#123;</span></span><br><span class="line"><span class="comment">//   Dep.target = targetStack.pop()</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="watcher-js"><a href="#watcher-js" class="headerlink" title="watcher.js"></a>watcher.js</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Dep <span class="keyword">from</span> <span class="string">'./dep'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Watcher &#123;</span><br><span class="line">  <span class="keyword">public</span> id: <span class="built_in">number</span></span><br><span class="line">  <span class="keyword">public</span> value: <span class="built_in">any</span></span><br><span class="line">  <span class="keyword">public</span> target: <span class="built_in">any</span></span><br><span class="line">  <span class="keyword">public</span> getter: <span class="function">(<span class="params">target: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">any</span></span><br><span class="line">  <span class="keyword">public</span> callback: <span class="function">(<span class="params">newVal: <span class="built_in">any</span>, oldVal: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line"></span><br><span class="line">  constructor(target: any, expression: string, callback: (newVal: any, oldVal: any) =&gt; void) &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = uid++</span><br><span class="line">    <span class="keyword">this</span>.target = target</span><br><span class="line">    <span class="keyword">this</span>.getter = parsePath(expression)</span><br><span class="line">    <span class="keyword">this</span>.callback = callback</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 依赖收集阶段</span></span><br><span class="line"><span class="comment">   * Evaluate the getter, and re-collect dependencies.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="comment">// 进入依赖收集阶段</span></span><br><span class="line">    Dep.target = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> value: <span class="built_in">any</span></span><br><span class="line">    <span class="keyword">const</span> obj = <span class="keyword">this</span>.target</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 调用getter,对应键的dep中放入了这个watcher</span></span><br><span class="line">      value = <span class="keyword">this</span>.getter(obj)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 退出依赖收集阶段</span></span><br><span class="line">      Dep.target = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> update() &#123;</span><br><span class="line">    <span class="keyword">this</span>.run()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> run() &#123;</span><br><span class="line">    <span class="keyword">this</span>.getAndInvoke(<span class="keyword">this</span>.callback)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> getAndInvoke(cb: <span class="function">(<span class="params">newVal: <span class="built_in">any</span>, oldVal: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">void</span>) &#123;</span><br><span class="line"> <span class="comment">// 监视目标为对象或数组的??</span></span><br><span class="line">    <span class="keyword">if</span> (value !== <span class="keyword">this</span>.value || isObject(value)) &#123;</span><br><span class="line">      <span class="keyword">const</span> oldVal = <span class="keyword">this</span>.value</span><br><span class="line">      <span class="keyword">this</span>.value = value</span><br><span class="line">  <span class="comment">// 回调</span></span><br><span class="line">      cb.call(<span class="keyword">this</span>.target, value, oldVal)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 简单的解析一个路径</span></span><br><span class="line">  <span class="keyword">const</span> bailRE = <span class="regexp">/[^\w.$]/</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span><span class="title">o</span> <span class="title">parsePath</span>(<span class="params">path: <span class="built_in">string</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.bailRE.test(path)) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> segments = path.split(<span class="string">"."</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">obj: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> segment of segments) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!obj) &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        obj = obj[segment]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Vue3.0的源码要用typescript来编写，同时个人随着近期typescript的练习渐渐变多，比如上周就用typescript写了，国际化的文本提取解析和替换（其中涉及到babel），也感觉到静态语言的强大。所以就慢慢的上手typescript咯。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g2kzpuojwjj20e509gwf6.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day107-typescript实现promise</title>
    <link href="http://lmislm.com/2019/04/29/2019-04-29/"/>
    <id>http://lmislm.com/2019/04/29/2019-04-29/</id>
    <published>2019-04-28T16:00:00.000Z</published>
    <updated>2019-04-30T13:41:37.101Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近某个babel的项目的时候接触到了typescript，感觉这个世界还是静态语言的天下啊。赶紧学起来。当然学静态语言，单元测试也是很重要的一部分。但是这个过程看来有点漫长，慢慢来吧。本文主要是笔记，看别人怎么实现promisejs。先看看实现<a href="https://promisesaplus.com/" target="_blank" rel="noopener">promise标准</a>和比较完美的<a href="http://bluebirdjs.com/docs/api-reference.html" target="_blank" rel="noopener">Bluebird方案</a>。<br>这篇文章有点扯，只是写了一部分，并没有写完全。0.0</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g2jxggrh5hj20e709g74k.jpg" alt=""><br><a id="more"></a></p><h3 id="实现（部分）"><a href="#实现（部分）" class="headerlink" title="实现（部分）"></a>实现（部分）</h3><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerOnSuccess&lt;T, U = <span class="built_in">any</span>&gt; = <span class="function">(<span class="params">value: T</span>) =&gt;</span> U | Thenable&lt;U&gt;;</span><br><span class="line"><span class="keyword">type</span> HandlerOnFail&lt;U = <span class="built_in">any</span>&gt; = <span class="function">(<span class="params">reason: <span class="built_in">any</span></span>) =&gt;</span> U | Thenable&lt;U&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Handler&lt;T, U&gt; &#123;</span><br><span class="line">  onSuccess: HandlerOnSuccess&lt;T, U&gt;;</span><br><span class="line">  onFail: HandlerOnFail&lt;U&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造器等"><a href="#构造器等" class="headerlink" title="构造器等"></a>构造器等</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> PQ&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> state: States = States.PENDING</span><br><span class="line">  <span class="keyword">private</span> handlers: Handler&lt;T, <span class="built_in">any</span>&gt;[] = []</span><br><span class="line">  <span class="keyword">private</span> value: T | <span class="built_in">any</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> errors = errors</span><br><span class="line"><span class="comment">// 构造器constructor</span></span><br><span class="line">  public constructor(callback: (resolve: Resolve&lt;T&gt;, reject: Reject) =&gt; void) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 回调参数this.resolve,this.reject</span></span><br><span class="line">      callback(<span class="keyword">this</span>.resolve, <span class="keyword">this</span>.reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">this</span>.reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> setResult = <span class="function">(<span class="params">value: T | <span class="built_in">any</span>, state: States</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">set</span> = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.state !== States.PENDING) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isThenable(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (value <span class="keyword">as</span> Thenable&lt;T&gt;).then(<span class="keyword">this</span>.resolve, <span class="keyword">this</span>.reject)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.value = value</span><br><span class="line">      <span class="keyword">this</span>.state = state</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.executeHandlers()</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(<span class="keyword">set</span>, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://medium.freecodecamp.org/how-to-implement-promises-in-javascript-1ce2680a7f51" target="_blank" rel="noopener">Implementing Promises In JavaScript</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近某个babel的项目的时候接触到了typescript，感觉这个世界还是静态语言的天下啊。赶紧学起来。当然学静态语言，单元测试也是很重要的一部分。但是这个过程看来有点漫长，慢慢来吧。本文主要是笔记，看别人怎么实现promisejs。先看看实现&lt;a href=&quot;https://promisesaplus.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;promise标准&lt;/a&gt;和比较完美的&lt;a href=&quot;http://bluebirdjs.com/docs/api-reference.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bluebird方案&lt;/a&gt;。&lt;br&gt;这篇文章有点扯，只是写了一部分，并没有写完全。0.0&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g2jxggrh5hj20e709g74k.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day106-promise-then方法</title>
    <link href="http://lmislm.com/2019/04/28/2019-04-28/"/>
    <id>http://lmislm.com/2019/04/28/2019-04-28/</id>
    <published>2019-04-27T16:00:00.000Z</published>
    <updated>2019-04-28T15:54:20.566Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文主要是then方法的实现，以及thenable的实现，then链式调用。</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g2is8ppmm5j20gs09gq3z.jpg" alt=""><br><a id="more"></a></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promise then方法实现-笔记</span></span><br><span class="line"><span class="comment">// Promise/A标准要求返回一个新对象，Promise/A+没有要求。</span></span><br><span class="line"><span class="comment">// 注意：then方法里需要onResolved或者onRejected,必须符合标准thenable</span></span><br><span class="line">MyPromise.prototype.then= <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _self = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> myPromise</span><br><span class="line">  <span class="comment">// then方法需要是function</span></span><br><span class="line">  onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">'function'</span> ? onResolved : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  onReject = <span class="keyword">typeof</span> onReject === <span class="string">'function'</span> ? onReject : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_self.status === <span class="string">'resolved'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 取onResolved结果</span></span><br><span class="line">        <span class="keyword">let</span> x = onResolved(_self.data)</span><br><span class="line">        <span class="comment">// myPromise的onResolved的返回值是一个promise对象？</span></span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">          x.then(resolve, reject)</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(x)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (_self.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> x = onReject(_self.data)</span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">          x.then(resolve, reject)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当然是没有reject</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (_self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">    <span class="comment">// 放入数组中</span></span><br><span class="line">    <span class="keyword">return</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      _self.onResolvedCallback.push(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onResolved(_self.data)</span><br><span class="line">          <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">            x.then(resolve, reject)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      _self.onRejectedCallback.push(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// try...catch, 同上</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据值来决定myPromise的状态</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Promise/A+标准规范 https://promisesaplus.com/#point-47</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; myPromise </span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; value onFulfilled or onRejected的结果</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; resolve </span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; reject </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">myPromise, value, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> then</span><br><span class="line">  <span class="comment">// 接到结果之后往后抛，then链式调用？</span></span><br><span class="line">  <span class="keyword">let</span> thenCalledOrThrow = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">if</span> (myPromise === value) &#123;<span class="comment">// 如果myPromise和value引用同一个对象，抛TypeError错,规范：2.3.1</span></span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'value和myPromise引用的同一个对象'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;<span class="comment">// 如果value是一个promise就用其声明， 2.3.2</span></span><br><span class="line">    <span class="keyword">if</span> (value.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      <span class="comment">// value的最终状态并没有确定，就必须要等确定fulfilled或rejected， 2.3.2.1</span></span><br><span class="line">      value.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        resolvePromise(myPromise, value, resolve, reject)</span><br><span class="line">      &#125;, reject)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 确定了直接取值fulfilled或rejected 2.3.2.2 \ 2.3.2.3</span></span><br><span class="line">      value.then(resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实现的不是很详细，和标准规范可能有点出入。</span></span><br><span class="line">  <span class="keyword">if</span> ((value !== <span class="literal">null</span>) &amp;&amp; ((<span class="keyword">typeof</span> value === <span class="string">'object'</span>) || (<span class="keyword">typeof</span> value === <span class="string">'function'</span>))) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      then = value.then</span><br><span class="line">      <span class="comment">// 如果检查到value.then的结果有错，则抛错</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        then.call(value, <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (thenCalledOrThrow) <span class="keyword">return</span></span><br><span class="line">          <span class="comment">// ???</span></span><br><span class="line">          thenCalledOrThrow = <span class="literal">true</span></span><br><span class="line">          <span class="keyword">return</span> reject(err)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="comment">// if (thenCalledOrThrow) return </span></span><br><span class="line">      thenCalledOrThrow = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">return</span> reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/xieranmaya/blog/issues/3" target="_blank" rel="noopener">剖析Promise内部结构</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文主要是then方法的实现，以及thenable的实现，then链式调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g2is8ppmm5j20gs09gq3z.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day105-依据对象属性去重</title>
    <link href="http://lmislm.com/2019/04/27/2019-04-27/"/>
    <id>http://lmislm.com/2019/04/27/2019-04-27/</id>
    <published>2019-04-26T16:00:00.000Z</published>
    <updated>2019-04-27T14:15:28.967Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>直接上代码吧，这个稍微简单点。</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g2hjud32j8j20e609gwex.jpg" alt=""></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [ [ <span class="string">'测'</span>, <span class="string">'测试2'</span> ], [ <span class="string">'测'</span>, <span class="string">'测试2'</span> ] ]</span><br><span class="line"><span class="comment">// 根据属性去重</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> !res.has(a[<span class="number">0</span>]) &amp;&amp; res.set(a[<span class="number">0</span>], <span class="number">1</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;直接上代码吧，这个稍微简单点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g2hjud32j8j20e609gwex.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; arr = [ [ &lt;span class=&quot;string&quot;&gt;&#39;测&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;测试2&#39;&lt;/span&gt; ], [ &lt;span class=&quot;string&quot;&gt;&#39;测&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;测试2&#39;&lt;/span&gt; ] ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 根据属性去重&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;unique&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;arr&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; res = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Map&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; arr.filter(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;a&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; !res.has(a[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]) &amp;amp;&amp;amp; res.set(a[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(unique(arr))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day103-vuejs源码-updateChildren（1）</title>
    <link href="http://lmislm.com/2019/04/25/2019-04-25/"/>
    <id>http://lmislm.com/2019/04/25/2019-04-25/</id>
    <published>2019-04-24T16:00:00.000Z</published>
    <updated>2019-04-26T15:33:52.904Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>主要是子节点中新老节点怎么相互去比较，替换。<strong>diff操作。</strong></p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g2fb93r4yjj20gs09gdgy.jpg" alt=""></p><a id="more"></a><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vuejs 源码 updateChildren</span></span><br><span class="line"><span class="comment">// 上一篇patchVnode中有这些参数的关系</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span>(<span class="params">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> oldStartIdx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> newStartIdx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">  <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class="line">  <span class="keyword">let</span> oldKeyToIdx, idxInOld, elmToMove, refElm</span><br><span class="line"></span><br><span class="line">  <span class="comment">// removeOnly is a special flag used only by &lt;transition-group&gt;</span></span><br><span class="line">  <span class="comment">// to ensure removed elemtents stay in correct relative positions</span></span><br><span class="line">  <span class="comment">// during leaving transtions</span></span><br><span class="line">  <span class="keyword">const</span> canMove = !removeOnly</span><br><span class="line">  <span class="comment">// 新老节点两列，相互两两比较，直到某个相遇的点循环结束</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// vnode has been moved left</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">      <span class="comment">// 如果指定key是相同的就判定为同一个节点</span></span><br><span class="line">      <span class="comment">// patchVnode = oldCh[++oldStartIdx]</span></span><br><span class="line">      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartVnode]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">      <span class="comment">// 开始节点到结束节点判断是否相同</span></span><br><span class="line">      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">      <span class="comment">// oldStartVnode和newEndVnode首尾相连，老的连在新的后面，进行pathchVnode之后，还要将真实DOM节点移到oldEndVnode的后面</span></span><br><span class="line">      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">      <span class="comment">// oldEndVnode和newStartVnode首尾相连，新的连在老的后面</span></span><br><span class="line">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是交叉相连的，？？？</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">          引自参考https://github.com/answershuto</span></span><br><span class="line"><span class="comment">          生成一个key与旧VNode的key对应的哈希表（只有第一次进来undefined的时候会生成，也为后面检测重复的key值做铺垫）</span></span><br><span class="line"><span class="comment">          比如childre是这样的 [&#123;xx: xx, key: 'key0'&#125;, &#123;xx: xx, key: 'key1'&#125;, &#123;xx: xx, key: 'key2'&#125;]  beginIdx = 0   endIdx = 2  </span></span><br><span class="line"><span class="comment">          结果生成&#123;key0: 0, key1: 1, key2: 2&#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">      <span class="keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">      <span class="comment">/*如果newStartVnode新的VNode节点存在key并且这个key在oldVnode中能找到则返回这个节点的idxInOld（即第几个节点，下标）*/</span></span><br><span class="line">      idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : <span class="literal">null</span></span><br><span class="line">      <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">        <span class="comment">/*newStartVnode没有key或者是该key没有在老节点中找到则创建一个新的节点*/</span></span><br><span class="line">        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*获取同key的老节点*/</span></span><br><span class="line">        elmToMove = oldCh[idxInOld]</span><br><span class="line">        <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !elmToMove) &#123;</span><br><span class="line">          <span class="comment">/*如果elmToMove不存在说明之前已经有新节点放入过这个key的DOM中，提示可能存在重复的key，确保v-for的时候item有唯一的key值*/</span></span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">'It seems there are duplicate keys that is causing an update error. '</span> +</span><br><span class="line">            <span class="string">'Make sure each v-for item has a unique key.'</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sameVnode(elmToMove, newStartVnode)) &#123;</span><br><span class="line">          <span class="comment">/*如果新VNode与得到的有相同key的节点是同一个VNode则进行patchVnode*/</span></span><br><span class="line">          patchVnode(elmToMove, newStartVnode, insertedVnodeQueue)</span><br><span class="line">          <span class="comment">/*因为已经patchVnode进去了，所以将这个老节点赋值undefined，之后如果还有新节点与该节点key相同可以检测出来提示已有重复的key*/</span></span><br><span class="line">          oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">          <span class="comment">/*当有标识位canMove实可以直接插入oldStartVnode对应的真实DOM节点前面*/</span></span><br><span class="line">          canMove &amp;&amp; nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm)</span><br><span class="line">          newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">          <span class="comment">/*当新的VNode与找到的同样key的VNode不是sameVNode的时候（比如说tag不一样或者是有不一样type的input标签），创建一个新的节点*/</span></span><br><span class="line">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)</span><br><span class="line">          newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">   <span class="comment">/*全部比较完成以后，发现oldStartIdx &gt; oldEndIdx的话，说明老节点已经遍历完了，新节点比老节点多，所以这时候多出来的新节点需要一个一个创建出来加入到真实DOM中*/</span></span><br><span class="line">   refElm = isUndef(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].elm</span><br><span class="line">   addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">   <span class="comment">/*如果全部比较完成以后发现newStartIdx &gt; newEndIdx，则说明新节点已经遍历完了，老节点多余新节点，这个时候需要将多余的老节点从真实DOM中移除*/</span></span><br><span class="line">   removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://github.com/answershuto/learnVue" target="_blank" rel="noopener">learnVue</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;主要是子节点中新老节点怎么相互去比较，替换。&lt;strong&gt;diff操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g2fb93r4yjj20gs09gdgy.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day102-vuejs源码-patchVnode</title>
    <link href="http://lmislm.com/2019/04/24/2019-04-24/"/>
    <id>http://lmislm.com/2019/04/24/2019-04-24/</id>
    <published>2019-04-23T16:00:00.000Z</published>
    <updated>2019-04-24T16:00:32.375Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>主要是讲新旧节点是怎么判断进行替换的。</p><ul><li>先理一下思路,这类的条件语句比较多,主要是节点和文本的替换，但是理完下来感觉还是蛮清爽的。</li><li>判断新旧节点同时存在，又是同一个节点，而且只能渲染一次，那么只需要相互替换组件实例就行</li><li>通过钩子，判断新老节点都有子节点oldCh的话，就对子节点进行diff，调用updateChildren方法</li><li>新旧节点，新节点有子节点，但是旧的没有，就清空旧的文本内容后，为当前DOM节点插入新节点</li><li>新旧节点，新节点没有子节点，但是旧的有，就移除该DOM节点的所有子节点</li><li>新旧节点都没有子节点的时候，就只是文本的替换</li></ul><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g2e5szpv9qj20e609ggmq.jpg" alt=""><br><a id="more"></a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span>(<span class="params">oldVnode, vnode, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (oldVnode === vnode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reuse(重用) element for static trees</span></span><br><span class="line">  <span class="comment">// note we only do this if the vnode is cloned -</span></span><br><span class="line">  <span class="comment">// if the new node is not cloned it means the render functions have been</span></span><br><span class="line">  <span class="comment">// reset by the hot-reload-api and we need to do a proper re-render.</span></span><br><span class="line">  <span class="comment">// 比较新旧是否相同且新节点是否标记了once</span></span><br><span class="line">  <span class="comment">// 第一步</span></span><br><span class="line">  <span class="keyword">if</span> (isTrue(vnode.isStatic) &amp;&amp;</span><br><span class="line">    isTrue(oldVnode.isStatic) &amp;&amp;</span><br><span class="line">    vnode.key === oldVnode.key &amp;&amp;</span><br><span class="line">    (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) &#123;</span><br><span class="line">      vnode.elm = oldVnode.elm</span><br><span class="line">      vnode.componentInstance = oldVnode.componentInstance</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 第二步</span></span><br><span class="line">    <span class="keyword">let</span> i</span><br><span class="line">    <span class="keyword">const</span> data = vnode.data</span><br><span class="line">    <span class="comment">// 判断钩子是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) &#123;</span><br><span class="line">      i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> elm = vnode.elm = oldVnode.elm</span><br><span class="line">    <span class="keyword">const</span> oldCh = oldVnode.children</span><br><span class="line">    <span class="keyword">const</span> ch = vnode.children</span><br><span class="line">    <span class="comment">// 判断是否有子节点存在？</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(data) &amp;&amp;isPatchable(vnode)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.update.length; ++i) &#123;</span><br><span class="line">        cbs.update[i](oldVnode, vnode)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) &#123;</span><br><span class="line">        i(oldVnode, vnode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有文本内容存在</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">      <span class="keyword">if</span>(isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCh !== ch) &#123;</span><br><span class="line">          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">    <span class="comment">// 第三步</span></span><br><span class="line">        <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">          nodeOps.setTextContent(elm, <span class="string">''</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意，这里要添加节点了！</span></span><br><span class="line">        addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">        removeVnodes(elm, oldCh, <span class="number">0</span>, oldCh.length <span class="number">-1</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">        <span class="comment">// 只有老节点有子节点</span></span><br><span class="line">        nodeOps.setTextContent(elm, <span class="string">''</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">      <span class="comment">// 设置文本内容，条件语句走到最后</span></span><br><span class="line">      nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用postpatch钩子</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">      <span class="keyword">if</span>(isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) &#123;</span><br><span class="line">        i(oldVnode, vnode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;主要是讲新旧节点是怎么判断进行替换的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先理一下思路,这类的条件语句比较多,主要是节点和文本的替换，但是理完下来感觉还是蛮清爽的。&lt;/li&gt;
&lt;li&gt;判断新旧节点同时存在，又是同一个节点，而且只能渲染一次，那么只需要相互替换组件实例就行&lt;/li&gt;
&lt;li&gt;通过钩子，判断新老节点都有子节点oldCh的话，就对子节点进行diff，调用updateChildren方法&lt;/li&gt;
&lt;li&gt;新旧节点，新节点有子节点，但是旧的没有，就清空旧的文本内容后，为当前DOM节点插入新节点&lt;/li&gt;
&lt;li&gt;新旧节点，新节点没有子节点，但是旧的有，就移除该DOM节点的所有子节点&lt;/li&gt;
&lt;li&gt;新旧节点都没有子节点的时候，就只是文本的替换&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g2e5szpv9qj20e609ggmq.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day101-vuejs源码-patch-笔记</title>
    <link href="http://lmislm.com/2019/04/23/2019-04-23/"/>
    <id>http://lmislm.com/2019/04/23/2019-04-23/</id>
    <published>2019-04-22T16:00:00.000Z</published>
    <updated>2019-04-24T14:33:54.329Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文主要是记录下读vuejs源码中virtualDom部分，注释一小部分的patch核心diff算法。算法通过<strong>同层的树节点</strong>进行比较而非对树进行逐层搜索遍历的方式，所以时间复杂度只有<strong>O(n)</strong>，是一种相当高效的算法<br>下面截取的<strong>代码</strong>部分是<strong>createPatchFunction</strong>(一个patch函数)的返回值，</p><blockquote><p>oldValue 与 vnode在sameVnode的时候才会进行patchVnode。</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g2cz3lqk0yj20dq09gabz.jpg" alt=""></p><a id="more"></a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">oldValue, vnode, hydrating, removeOnly, parentElm, refElm</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// vnode不存在则直接销毁钩子</span></span><br><span class="line">  <span class="keyword">if</span> (isUndef(vnode)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(oldVnode)) invokeDestroyHook(oldValue)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> insertedVnodeQueue = []</span><br><span class="line">  <span class="keyword">if</span> (isUndef(oldVnode)) &#123;</span><br><span class="line">    <span class="comment">// 空挂载（像是组件），创建新的root节点</span></span><br><span class="line">    <span class="comment">// oldValue未定义时，即为root节点时，创建一个新节点</span></span><br><span class="line">    isInitialPatch = <span class="literal">true</span></span><br><span class="line">    createElm(vnode, insertedVnodeQueue, parentElm, refElm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 标记旧的VNode是否有nodeType ??</span></span><br><span class="line">    <span class="keyword">const</span> isRealElement = isDef(oldVnode, vnode)</span><br><span class="line">    <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldValue, vnode)) &#123;</span><br><span class="line">      patchVnode(oldValue, vnode, insertedVnodeQueue, removeOnly)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isRealElement) &#123;</span><br><span class="line">        <span class="comment">// 挂载到一个真的节点</span></span><br><span class="line">        <span class="comment">// 检查是否是服务端渲染的内容且if we can perform a successful hydration(是否我们可以合并到真实DOM)</span></span><br><span class="line">        <span class="keyword">if</span> (oldVnode.nodeType === <span class="number">1</span> &amp;&amp; oldValue.hasAttribute(SSR_ATTR)) &#123;</span><br><span class="line">          oldVnode.removeAttribute(SSR_ATTR)</span><br><span class="line">          hydrating = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isTrue(hydrating)) &#123;</span><br><span class="line">          <span class="comment">// 需要合并到真实DOM</span></span><br><span class="line">          <span class="keyword">if</span>(hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;</span><br><span class="line">            invokeInsertHook(vnode, insertedVnodeQueue, <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">return</span> oldValue</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ProcessingInstruction.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">            warn(</span><br><span class="line">              <span class="string">'The client-side rendered virtual DOM tree is not matching '</span> +</span><br><span class="line">              <span class="string">'server-rendered content. This is likely caused by incorrect '</span> +</span><br><span class="line">              <span class="string">'HTML markup, for example nesting block-level elements inside '</span> +</span><br><span class="line">              <span class="string">'&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing '</span> +</span><br><span class="line">              <span class="string">'full client-side render.'</span></span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不是服务端渲染或者合并到真实DOM失败，则创建一个空的VNode节点替换它</span></span><br><span class="line">        oldValue = emptyNodeAt(oldVnode)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 取代现有元素</span></span><br><span class="line">      <span class="keyword">const</span> oldElm = oldValue.elm</span><br><span class="line">      <span class="keyword">const</span> parentElm = nodeOps.parentNode(oldElm)</span><br><span class="line">      createElm(</span><br><span class="line">        vnode,</span><br><span class="line">        insertedVnodeQueue, <span class="comment">// ???</span></span><br><span class="line">        <span class="comment">// extremely rare edge case: do not insert if old element is in a</span></span><br><span class="line">        <span class="comment">// leaving transition. Only happens when combining transition +</span></span><br><span class="line">        <span class="comment">// keep-alive + HOCs. (#4590)</span></span><br><span class="line">        oldElm._leaveCb ? <span class="literal">null</span> : parentElm,</span><br><span class="line">        nodeOps.nextSibling(oldElm)</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">if</span> (isDef(vnode.parent)) &#123;</span><br><span class="line">        <span class="comment">// 组件根节点被替换，遍历更新父节点element</span></span><br><span class="line">        <span class="keyword">let</span> ancestor = vnode.parent</span><br><span class="line">        <span class="keyword">while</span> (ancestor) &#123;</span><br><span class="line">          ancestor.elm = vnode.elm</span><br><span class="line">          ancestor = ancestor.parent</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isPatchable(vnode)) &#123;</span><br><span class="line">          <span class="comment">// 调用create回调</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.create.length; ++i) &#123;</span><br><span class="line">            cbs.create[i](emptyNode, vnode.parent)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isDef(parentElm)) &#123;</span><br><span class="line">        <span class="comment">// 移除老节点</span></span><br><span class="line">        removeVnodes(parentElm, [oldValue], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldValue.tag)) &#123;</span><br><span class="line">        invokeDestroyHook(oldVnode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)</span><br><span class="line">  <span class="keyword">return</span> vnode.elm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/answershuto/learnVue" target="_blank" rel="noopener">learnVue</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文主要是记录下读vuejs源码中virtualDom部分，注释一小部分的patch核心diff算法。算法通过&lt;strong&gt;同层的树节点&lt;/strong&gt;进行比较而非对树进行逐层搜索遍历的方式，所以时间复杂度只有&lt;strong&gt;O(n)&lt;/strong&gt;，是一种相当高效的算法&lt;br&gt;下面截取的&lt;strong&gt;代码&lt;/strong&gt;部分是&lt;strong&gt;createPatchFunction&lt;/strong&gt;(一个patch函数)的返回值，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;oldValue 与 vnode在sameVnode的时候才会进行patchVnode。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g2cz3lqk0yj20dq09gabz.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
