<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LMISLMのBlog</title>
  
  <subtitle>不积小流，无以成江海。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lmislm.com/"/>
  <updated>2019-08-26T15:54:39.661Z</updated>
  <id>http://lmislm.com/</id>
  
  <author>
    <name>lmislm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>day224-三种检测数组的方法</title>
    <link href="http://lmislm.com/2019/08/26/2019-08-26/"/>
    <id>http://lmislm.com/2019/08/26/2019-08-26/</id>
    <published>2019-08-25T16:00:00.000Z</published>
    <updated>2019-08-26T15:54:39.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li><code>Object.prototype.toString.call()</code></li><li><code>instanceof</code></li><li><code>Array.isArray()</code>、与<code>instanceof</code>比较<a id="more"></a></li></ol><h2 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h2><blockquote><p>所有的基本数据类型都能判断，其中就包括<code>null</code>和<code>undefined</code>。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="comment">// Object.prototype.toString.call()</span></span><br><span class="line">arr.toString() <span class="comment">// 1,2</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(arr) <span class="comment">// [object Array]</span></span><br></pre></td></tr></table></figure><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><blockquote><p>原理是判断<code>__proto__</code>是否能找到对应的<code>prototype</code>。<code>A.__proto__</code> ? <code>B.prototype</code></p></blockquote><p>但是<code>instanceof</code>只能用来判断对象类型，原始类型不可以。原始类型即：Undefined，Null，Boolean，Number和 String。</p><h2 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h2><p>ES5新增方法，用于确定传递的值是否是一个数组。</p><p><strong>与<code>instanceof</code>比较</strong></p><ol><li><code>instanceof</code>不支持跨iframes, 但是<code>Array.isArray</code>支持。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iframeEl = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframeEl);</span><br><span class="line">iframeArray = <span class="built_in">window</span>.frames[<span class="built_in">window</span>.frames.length - <span class="number">1</span>].Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> array2 = <span class="keyword">new</span> iframeArray(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1 <span class="keyword">instanceof</span> <span class="built_in">Array</span>);  <span class="comment">// true    </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(array1));  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array2 <span class="keyword">instanceof</span> <span class="built_in">Array</span>);  <span class="comment">// false    </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(array2));  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>instanceof</code>要比<code>Array.isArray</code>更快，<a href="https://jsperf.com/array-isarray-vs-instanceof-array" target="_blank" rel="noopener">jsperf</a>。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/326069/how-to-identify-if-a-webpage-is-being-loaded-inside-an-iframe-or-directly-into-t" target="_blank" rel="noopener">How to identify if a webpage is being loaded inside an iframe or directly into the browser window?</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures" target="_blank" rel="noopener">JavaScript 数据类型和数据结构</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Object.prototype.toString.call()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;instanceof&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Array.isArray()&lt;/code&gt;、与&lt;code&gt;instanceof&lt;/code&gt;比较
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day223-文本溢出省略</title>
    <link href="http://lmislm.com/2019/08/25/2019-08-25/"/>
    <id>http://lmislm.com/2019/08/25/2019-08-25/</id>
    <published>2019-08-24T16:00:00.000Z</published>
    <updated>2019-08-25T15:33:01.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><blockquote><p>用 css 或 js 实现多行文本溢出省略效果，考虑兼容性</p></blockquote><ol><li>单行</li><li>多行</li><li>兼容<a id="more"></a></li></ol><h2 id="单行"><a href="#单行" class="headerlink" title="单行"></a>单行</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span><span class="selector-pseudo">:ellipsis</span>;</span><br><span class="line"><span class="selector-tag">white-space</span>: <span class="selector-tag">nowrap</span>;</span><br></pre></td></tr></table></figure><h2 id="多行"><a href="#多行" class="headerlink" title="多行"></a>多行</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">-webkit-box</span>;</span><br><span class="line"><span class="selector-tag">-webkit-box-orient</span>: <span class="selector-tag">vertical</span>;</span><br><span class="line"> <span class="selector-tag">-webkit-line-clamp</span>: 3; <span class="comment">/* 行数 */</span></span><br><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br></pre></td></tr></table></figure><h2 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h2><blockquote><p>兼容的方法有个问题，如果出现了数字字母这种，是否会出现盖住半个字的操作</p></blockquote><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">position</span>: relative; <span class="attribute">line-height</span>: <span class="number">20px</span>; <span class="attribute">max-height</span>: <span class="number">40px</span>;<span class="attribute">overflow</span>: hidden;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::after</span>&#123;<span class="attribute">content</span>: <span class="string">"..."</span>; <span class="attribute">position</span>: absolute; <span class="attribute">bottom</span>: <span class="number">0</span>; <span class="attribute">right</span>: <span class="number">0</span>; <span class="attribute">padding-left</span>: <span class="number">40px</span>;</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">-webkit-linear-gradient</span>(left, transparent, #fff 55%);</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">-o-linear-gradient</span>(right, transparent, #fff 55%);</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">-moz-linear-gradient</span>(right, transparent, #fff 55%);</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to right, transparent, #fff 55%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;用 css 或 js 实现多行文本溢出省略效果，考虑兼容性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;单行&lt;/li&gt;
&lt;li&gt;多行&lt;/li&gt;
&lt;li&gt;兼容
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day222-解题-扑克牌问题-笔记</title>
    <link href="http://lmislm.com/2019/08/24/2019-08-24/"/>
    <id>http://lmislm.com/2019/08/24/2019-08-24/</id>
    <published>2019-08-23T16:00:00.000Z</published>
    <updated>2019-08-24T15:00:02.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>题目描述</li><li>题解<a id="more"></a></li></ol><h2 id="优化scrollTop"><a href="#优化scrollTop" class="headerlink" title="优化scrollTop"></a>优化scrollTop</h2><p>题目描述</p><blockquote><p>扑克牌问题</p></blockquote><p>有一堆扑克牌，将牌堆第一张放到桌子上，再将接下来的牌堆的第一张放到牌底，如此往复；</p><p>最后桌子上的牌顺序为： (牌底) 1,2,3,4,5,6,7,8,9,10,11,12,13 (牌顶)；</p><p>问：原来那堆牌的顺序，用函数实现。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> out = []</span><br><span class="line">  <span class="keyword">while</span> (arr.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span>) &#123;</span><br><span class="line">      out.unshift(arr.pop())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      out.unshift(out.pop())</span><br><span class="line">    &#125;</span><br><span class="line">    i++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">putPoke</span> (<span class="params">arr</span>) </span>&#123; <span class="comment">// 放牌，arr手里的牌，out桌子上的牌</span></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> out = []</span><br><span class="line">  <span class="keyword">while</span> (arr.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span>) &#123;</span><br><span class="line">      out.push(arr.shift()) <span class="comment">// i等于1，手里第一张放桌上；奇数牌</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      arr.push(arr.shift()) <span class="comment">// 偶数牌，放手里牌最后，一直到手里没有牌。</span></span><br><span class="line">    &#125;</span><br><span class="line">    i++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/245" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/245</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;题目描述&lt;/li&gt;
&lt;li&gt;题解
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day221-rAF-示例</title>
    <link href="http://lmislm.com/2019/08/23/2019-08-23/"/>
    <id>http://lmislm.com/2019/08/23/2019-08-23/</id>
    <published>2019-08-22T16:00:00.000Z</published>
    <updated>2019-08-23T15:47:24.644Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>优化scrollTop</li><li>Easing functions<a id="more"></a></li></ol><h2 id="优化scrollTop"><a href="#优化scrollTop" class="headerlink" title="优化scrollTop"></a>优化scrollTop</h2><p>原来的函数<code>scroll</code>用的是步长，简单的时间循环</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollTop</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> el = <span class="keyword">this</span>.el</span><br><span class="line">  <span class="keyword">let</span> step = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> interval = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (el.scrollTop &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      clearInterval(interval)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    step += <span class="number">10</span></span><br><span class="line">    el.scrollTop -= step</span><br><span class="line">  &#125;, <span class="number">20</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>rAF</code>改进后</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cubic = <span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">Math</span>.pow(value, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">const</span> easeInOutCubic = <span class="function"><span class="params">value</span> =&gt;</span> value &lt; <span class="number">0.5</span></span><br><span class="line">  ? cubic(value * <span class="number">2</span>) / <span class="number">2</span></span><br><span class="line">  : <span class="number">1</span> - cubic((<span class="number">1</span> - value) * <span class="number">2</span>) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollTop</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="keyword">this</span>.el</span><br><span class="line">  <span class="keyword">const</span> beginTime = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">const</span> beginValue = el.scrollTop</span><br><span class="line">  <span class="keyword">const</span> rAF = <span class="built_in">window</span>.requestAnimationFrame || (<span class="function"><span class="params">func</span> =&gt;</span> setTimeout(func, <span class="number">16</span>)) <span class="comment">// 兼容处理，16ms刷新</span></span><br><span class="line">  <span class="keyword">const</span> frameFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> progress = (<span class="built_in">Date</span>.now() - beginTime) / <span class="number">500</span> <span class="comment">// 在500ms内完成scroll,Date.now() - beginTime，表示控制在rAF的间隔时间内时间差值</span></span><br><span class="line">    <span class="keyword">if</span> (progress &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      el.scrollTop = beginValue * (<span class="number">1</span> - easeInOutCubic(progress))</span><br><span class="line">      rAF(frameFunc)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      el.scrollTop = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  rAF(frameFunc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Easing-functions"><a href="#Easing-functions" class="headerlink" title="Easing functions"></a>Easing functions</h2><p>改进的方法中用到了<code>贝塞斯曲线</code>，改进方法中的曲线其实也可以这么写，如下。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// easeInOutCubic</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">easeInOutCubic</span> (<span class="params">t</span>) </span>&#123; <span class="keyword">return</span> t&lt;<span class="number">.5</span> ? <span class="number">4</span>*t*t*t : (t<span class="number">-1</span>)*(<span class="number">2</span>*t<span class="number">-2</span>)*(<span class="number">2</span>*t<span class="number">-2</span>)+<span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><p>更多曲线的写法在这里 <a href="https://gist.github.com/gre/1650294" target="_blank" rel="noopener">Simple Easing Functions in Javascript</a></p><p>也可以在这里 <a href="https://easings.net/en" target="_blank" rel="noopener">Easing functions</a>，可视化的了解各种曲线。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://gist.github.com/gre/1650294" target="_blank" rel="noopener">https://gist.github.com/gre/1650294</a></p><p><a href="https://easings.net/en" target="_blank" rel="noopener">https://easings.net/en</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;优化scrollTop&lt;/li&gt;
&lt;li&gt;Easing functions
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day220-Regex-email</title>
    <link href="http://lmislm.com/2019/08/22/2019-08-22/"/>
    <id>http://lmislm.com/2019/08/22/2019-08-22/</id>
    <published>2019-08-21T16:00:00.000Z</published>
    <updated>2019-08-23T15:36:17.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>一步步写一个邮箱正则。</p><p><strong>条件：</strong></p><p>只允许[a-z][A-Z][.]且不允许”.”号连续和处于开头结尾</p><p><strong>流程：</strong></p><ol><li>数字 + 单个(.) + 数字</li><li>数字 + 多个不连续的(.) + 数字</li><li>多个数字间隔连续</li><li>完全匹配</li><li>匹配@后缀</li><li>优化建议<a id="more"></a></li></ol><h2 id="数字-单个-数字"><a href="#数字-单个-数字" class="headerlink" title="数字+单个(.)+数字"></a>数字+单个(.)+数字</h2><p><code>[a-zA-Z0-9]+(\.)+[a-zA-Z0-9]</code></p><p><strong>测试</strong></p><p>匹配：hello.world 中的 hello.w</p><p>匹配：hello……world 中的 hello……w</p><p>匹配：hello.word.hello.to 中 hello.w</p><p><strong>知识点</strong></p><p><code>&quot;+&quot;</code>：匹配前面一个表达式 1 次或者多次。等价于 {1,}。</p><h2 id="数字-多个不连续的-数字"><a href="#数字-多个不连续的-数字" class="headerlink" title="数字+多个不连续的(.)+数字"></a>数字+多个不连续的(.)+数字</h2><p><code>([a-zA-Z0-9]+)([\.{1}])?([a-zA-Z0-9])</code></p><p><strong>测试</strong></p><p>hello.world =&gt; hello.w</p><p>hello…….word =&gt; hello</p><p>hello.word.hello.to =&gt; hello.w</p><p><strong>知识点</strong></p><p><code>&quot;{n}&quot;</code>：n 是一个正整数，匹配了前面一个字符刚好出现了 n 次。</p><p><code>&quot;?&quot;</code>：匹配前面一个表达式 0 次或者 1 次。等价于 {0,1}。</p><blockquote><p>例子：/e?le?/ 匹配 “angel” 中的 ‘el’、”angle” 中的 ‘le’ 以及 “oslo’ 中的 ‘l’。</p></blockquote><h2 id="多个数字间隔连续"><a href="#多个数字间隔连续" class="headerlink" title="多个数字间隔连续"></a>多个数字间隔连续</h2><p><code>[a-zA-Z0-9]+(?:\.[a-zA-Z0-9]+)*</code></p><p><strong>测试</strong></p><p>hello.world =&gt; hello.world</p><p>hello……world =&gt; hello</p><p>hello.world.hello.to =&gt; hello.world.hello.to</p><p>hello……world.hello.to =&gt; hello</p><p>hello.world.hello……to =&gt; hello.world.hello</p><p><strong>知识点</strong></p><p><code>&quot;(?:x)&quot;</code>：匹配 ‘x’ 但是不记住匹配项。这种括号叫作<code>非捕获括号</code>，使得你能够定义与正则表达式运算符一起使用的子表达式。</p><blockquote><p>例子：/(?:\d{3}|(\d{3}))([-\/.])\d{3}\1\d{4}/。</p></blockquote><pre><code>(?: 这个正则表达式寻找三个数字字符\d{3} 或者 | 一个左半括号\(跟着三位数字\d{3}, 跟着一个封闭括号 \), (结束非捕获括号 ))， 后跟着一个短破折号或正斜杠或小数点，随后跟随三个数字字符，当记忆字符 ([-\/\.])捕获并记住，后面跟着三位小数 \d{3}，再后面跟随记住的破折号、正斜杠或小数点 \1，最后跟着四位小数 \d{4}</code></pre><blockquote><p>例子：(?:\d+)</p></blockquote><pre><code>匹配一次或多次数字字符，但是不能记住匹配的字符。</code></pre><p><code>&quot;*&quot;</code>：匹配前一个表达式 0 次或多次。等价于 {0,}。</p><h2 id="完全匹配"><a href="#完全匹配" class="headerlink" title="完全匹配"></a>完全匹配</h2><p><code>/^[a-zA-Z0-9]+(?:\.[a-zA-Z0-9]+)*$/</code></p><p><strong>测试</strong></p><p>hello.world =&gt; hello.world</p><p>hello……world =&gt; （空）</p><p>hello.world.hello.to =&gt; hello.world.hello.to</p><p>hello……world.hello.to =&gt; （空）</p><p>hello.world.hello……to =&gt; （空）</p><p><strong>知识点</strong></p><p><code>&quot;^&quot;</code>：匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。<br>  例子：/^A/ 匹配”An E” 中的 ‘A’，不匹配 “an A” 中的 ‘A’</p><p><code>&quot;$&quot;</code>：匹配输入的结束。如果多行标示被设置为 true，那么也匹配换行符前的位置。<br>  例子：/t$/ 匹配 “eat” 中的 ‘t’，不匹配 “eater” 中的 ‘t’</p><h2 id="匹配-后缀"><a href="#匹配-后缀" class="headerlink" title="匹配@后缀"></a>匹配@后缀</h2><p>后缀：<code>/@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))/</code></p><p><code>/^(([^&lt;&gt;()[\]\\.,;:\s@&quot;]+(\.[^&lt;&gt;()[\]\\.,;:\s@&quot;]+)*)|(&quot;.+&quot;))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/</code></p><h2 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h2><p>如果”_”字符允许的话，可以考虑用”\w”</p><p><code>&quot;\w&quot;</code>：匹配一个<code>单字</code>字符（字母、数字或者下划线）。等价于 [A-Za-z0-9_]。</p><blockquote><p>例子：/\w/ 匹配 “apple,” 中的 ‘a’，”$5.28,”中的 ‘5’ 和 “3D.” 中的 ‘3’。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions</a></p><p><a href="https://www.regextester.com/" target="_blank" rel="noopener">https://www.regextester.com/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;p&gt;一步步写一个邮箱正则。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;条件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只允许[a-z][A-Z][.]且不允许”.”号连续和处于开头结尾&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流程：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数字 + 单个(.) + 数字&lt;/li&gt;
&lt;li&gt;数字 + 多个不连续的(.) + 数字&lt;/li&gt;
&lt;li&gt;多个数字间隔连续&lt;/li&gt;
&lt;li&gt;完全匹配&lt;/li&gt;
&lt;li&gt;匹配@后缀&lt;/li&gt;
&lt;li&gt;优化建议
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day219-history.pushState()</title>
    <link href="http://lmislm.com/2019/08/21/2019-08-21/"/>
    <id>http://lmislm.com/2019/08/21/2019-08-21/</id>
    <published>2019-08-20T16:00:00.000Z</published>
    <updated>2019-08-22T15:49:16.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>例子</li><li>参数</li><li>与window.location中hash异同</li><li>原理<a id="more"></a></li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>浏览器地址改为<code>xxx/bar.html</code>，但是不加载，也不检查bar.html是否存在。</p><p>通过<code>pushState</code>可以在<code>stateObj</code>中保存页面状态，当页面的 url 再变回到这个 url 时，可以通过 event.state 取到这个 state 对象，从而可以对页面状态进行还原，如页面滚动条的位置、阅读进度、组件的开关。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stateObj = &#123;</span><br><span class="line">  foo: <span class="string">'bar'</span></span><br><span class="line">&#125;</span><br><span class="line">history.pushState(stateObj, <span class="string">'page 2'</span>, <span class="string">'bar.html'</span>)</span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>一个状态对象，一个标题，一个URL</p><p><strong>状态对象:</strong></p><p>  用户导航到新状态时，触发popstate事件。包含该历史记录条目状态对象的副本。状态对象能被序列化，大小限制在640k以内。</p><p><strong>标题：</strong></p><p>  给跳转的state传递短标题。</p><p><strong>URL：</strong></p><p>  定义新的历史URL记录。新URL必须与当前URL同源。否则<code>pushState()</code>会抛出异常。参数可选，默认为当前URL。</p><h2 id="异同"><a href="#异同" class="headerlink" title="异同"></a>异同</h2><p><code>pushState()</code>与<code>window.location = &#39;#foo&#39;</code>，两者都会在当前页面创建并激活新的历史记录。</p><p><code>hash</code>相对于<code>history.pushState()</code>兼容性强。</p><p>新URL可以是与当前URL同源的任意URL。设置<code>window.location</code>仅当你只修改了哈希值时才保持同一个<code>document</code>（即：hash 设置的新值不能与原来的一样，一样的值不会触发动作将记录添加到栈中）。</p><p><code>pushState()</code>可以将任意数据和新的历史记录项相关联（即：通过 stateObject 参数可以将任何数据类型添加到记录中）。而hash，要把所有相关数据编码为短字符串（即：只能添加短字符串）。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>hash</strong></p><p>onhashchange 事件，可以在 window 对象上监听这个事件。</p><p><strong>pushState</strong></p><p>hash只改变#后面的代码片段，pushState可以在window对象上监听popState()事件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;例子&lt;/li&gt;
&lt;li&gt;参数&lt;/li&gt;
&lt;li&gt;与window.location中hash异同&lt;/li&gt;
&lt;li&gt;原理
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day218-[].slice.call(arguments)</title>
    <link href="http://lmislm.com/2019/08/19/2019-08-19/"/>
    <id>http://lmislm.com/2019/08/19/2019-08-19/</id>
    <published>2019-08-18T16:00:00.000Z</published>
    <updated>2019-08-19T15:02:39.710Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>类数组的转换</li><li>call绑定其他对象的上下文</li><li>slice方法中的for…in<a id="more"></a></li></ol><h2 id="类数组的转换"><a href="#类数组的转换" class="headerlink" title="类数组的转换"></a>类数组的转换</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[].slice.call(<span class="built_in">arguments</span>)</span><br></pre></td></tr></table></figure><h2 id="call绑定其他对象的上下文"><a href="#call绑定其他对象的上下文" class="headerlink" title="call绑定其他对象的上下文"></a>call绑定其他对象的上下文</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sliced = <span class="built_in">Array</span>.prototype.slice.call(&#123;<span class="string">'0'</span>: <span class="string">'a'</span>, <span class="string">'1'</span>: <span class="string">'b'</span>, <span class="string">'2'</span>: <span class="string">'c'</span>, <span class="attr">length</span>: <span class="number">3</span>&#125;, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// [ 'c' ]</span></span><br><span class="line"><span class="keyword">var</span> sliced = <span class="built_in">Array</span>.prototype.slice.call(&#123;<span class="string">'0'</span>: <span class="string">'a'</span>, <span class="string">'1'</span>: <span class="string">'b'</span>, <span class="string">'3'</span>: <span class="string">'c'</span>, <span class="attr">length</span>: <span class="number">3</span>&#125;, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// [ &lt;1 empty item&gt; ]</span></span><br></pre></td></tr></table></figure><h2 id="slice方法中的for…in"><a href="#slice方法中的for…in" class="headerlink" title="slice方法中的for…in"></a>slice方法中的for…in</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.mockSlice = <span class="function"><span class="keyword">function</span>(<span class="params">begin, end</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// IE &lt; 9 gets unhappy with an undefined end argument</span></span><br><span class="line">  end = (<span class="keyword">typeof</span> end !== <span class="string">'undefined'</span>) ? end : <span class="keyword">this</span>.length;</span><br><span class="line">  <span class="comment">// For array like object we handle it ourselves.</span></span><br><span class="line">  <span class="keyword">var</span> i, cloned = [],</span><br><span class="line">    size, len = <span class="keyword">this</span>.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Handle negative value for "begin"</span></span><br><span class="line">  <span class="keyword">var</span> start = begin || <span class="number">0</span>;</span><br><span class="line">  start = (start &gt;= <span class="number">0</span>) ? start : <span class="built_in">Math</span>.max(<span class="number">0</span>, len + start);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Handle negative value for "end"</span></span><br><span class="line">  <span class="keyword">var</span> upTo = (<span class="keyword">typeof</span> end == <span class="string">'number'</span>) ? <span class="built_in">Math</span>.min(end, len) : len;</span><br><span class="line">  <span class="keyword">if</span> (end &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    upTo = len + end;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Actual expected size of the slice</span></span><br><span class="line">  size = upTo - start;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    cloned = <span class="keyword">new</span> <span class="built_in">Array</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.charAt) &#123; <span class="comment">// String，如果是字符型返回指定位置的字符</span></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        cloned[i] = <span class="keyword">this</span>.charAt(start + i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        cloned[i] = <span class="keyword">this</span>[start + i]; <span class="comment">// 迭代数组</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cloned;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log([].mockSlice.call(<span class="built_in">arguments</span>)) <span class="comment">// [ 'a', 'b', 'c' ]</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" target="_blank" rel="noopener">Array.prototype.slice()</a></p><p><a href="https://stackoverflow.com/questions/7056925/how-does-array-prototype-slice-call-work" target="_blank" rel="noopener">how does Array.prototype.slice.call() work?</a></p><p><a href="http://es5.github.io/x15.4.html#x15.4.4.10" target="_blank" rel="noopener">Array.prototype.slice method description</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;类数组的转换&lt;/li&gt;
&lt;li&gt;call绑定其他对象的上下文&lt;/li&gt;
&lt;li&gt;slice方法中的for…in
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day217-Intersection Observer</title>
    <link href="http://lmislm.com/2019/08/18/2019-08-18/"/>
    <id>http://lmislm.com/2019/08/18/2019-08-18/</id>
    <published>2019-08-17T16:00:00.000Z</published>
    <updated>2019-08-18T15:47:52.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>简介</li><li>Options</li><li>Callback<a id="more"></a></li></ol><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>异步观察目标元素与其祖先元素或顶级文档视窗(viewport)交叉状态的方法。</p><p><code>Intersection Observer API</code>会注册一个回调方法，每当期望被监视的元素<code>进入或者退出</code>另外一个元素的时候(或者浏览器的视口)该回调方法将会被执行，或者两个元素的<code>交集部分大小发生变化</code>的时候回调方法也会被执行。</p><h2 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  root: <span class="built_in">document</span>.querySelector(<span class="string">'#scrollArea'</span>), <span class="comment">// 所监听对象的具体祖先元素(element) ,只读</span></span><br><span class="line">  rootMargin: <span class="string">'0px'</span>, <span class="comment">// 计算交叉时添加到根(root)边界盒bounding box的矩形偏移量，只读，主要用途之一就是用来实现提前加载，提前几百像素预先加载</span></span><br><span class="line">  threshold: <span class="number">1.0</span> <span class="comment">// 包含阈值的列表，如[0, 0.25, 0.5, 0.75, 1]， 列表中的每个阈值都是监听对象的交叉区域与边界区域的比率，只读</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> IntersectionObserver(callback, options);</span><br></pre></td></tr></table></figure><h2 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> callback = <span class="function"><span class="keyword">function</span>(<span class="params">entries, observer</span>) </span>&#123; </span><br><span class="line">  entries.forEach(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Each entry describes an intersection change for one observed</span></span><br><span class="line">  <span class="comment">// target element:</span></span><br><span class="line">  <span class="comment">//   entry.boundingClientRect</span></span><br><span class="line">  <span class="comment">//   entry.intersectionRatio</span></span><br><span class="line">  <span class="comment">//   entry.intersectionRect</span></span><br><span class="line">  <span class="comment">//   entry.isIntersecting // 判断target元素在root元素中的可见性是否发生变化，isIntersecting 是 true，target元素的至少已经达到thresholds属性值当中规定的其中一个阈值</span></span><br><span class="line">  <span class="comment">//   entry.rootBounds</span></span><br><span class="line">  <span class="comment">//   entry.target</span></span><br><span class="line">  <span class="comment">//   entry.time</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/ziyunfei/p/5558712.html" target="_blank" rel="noopener">IntersectionObserver API-紫云飞</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API" target="_blank" rel="noopener">Intersection Observer API-MDN</a></p><p><a href="https://juejin.im/post/5a7973575188257a5911a749" target="_blank" rel="noopener">谈谈IntersectionObserver懒加载</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;简介&lt;/li&gt;
&lt;li&gt;Options&lt;/li&gt;
&lt;li&gt;Callback
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day216-HTTPS 中间人攻击</title>
    <link href="http://lmislm.com/2019/08/17/2019-08-17/"/>
    <id>http://lmislm.com/2019/08/17/2019-08-17/</id>
    <published>2019-08-16T16:00:00.000Z</published>
    <updated>2019-08-17T14:34:06.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>过程</li><li>防范<a id="more"></a></li></ol><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol><li><code>服务端</code>向<code>客户端</code>发送公钥</li><li>攻击者截取公钥，并伪造公钥，发送给<code>客户端</code></li><li><code>客户端</code>收到伪造的公钥后，生成加密hash值发给<code>服务端</code></li><li>攻击者获得加密hash值，用自己的私钥解密获得真密钥</li><li>同时生成假的加密hash值，发给<code>服务端</code></li><li><code>服务端</code>用私钥解密获得假密钥</li><li><code>服务端</code>用假密钥加密传输信息。</li></ol><h2 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h2><p>服务端在发送给<code>客户端</code>的公钥中，加入CA证书。浏览器可以验证CA证书的有效性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;过程&lt;/li&gt;
&lt;li&gt;防范
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day215-TCP KeepAlive-笔记</title>
    <link href="http://lmislm.com/2019/08/16/2019-08-16/"/>
    <id>http://lmislm.com/2019/08/16/2019-08-16/</id>
    <published>2019-08-15T16:00:00.000Z</published>
    <updated>2019-08-16T15:13:29.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>基本原理</li><li>TCP的连接</li><li>KeepAlive的局限<a id="more"></a></li></ol><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。</p><h2 id="TCP的连接"><a href="#TCP的连接" class="headerlink" title="TCP的连接"></a>TCP的连接</h2><p>物理层面并没有“连接”的概念。</p><p>TCP通信双方建立连接，但并不是一直数据交互，有些连接会在数据交互后，主动释放连接，而有些不会。在长时间无数据交互的时间段内，交互双方都有可能出现掉电、死机、异常重启等各种意外，当这些意外发生之后，这些 TCP 连接并未来得及正常释放，在软件层面上，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费。</p><p>为了解决这个问题，在<code>传输层</code>可以利用<code>TCP</code>的<code>KeepAlive</code>机制实现来实现。</p><h2 id="KeepAlive的局限"><a href="#KeepAlive的局限" class="headerlink" title="KeepAlive的局限"></a>KeepAlive的局限</h2><p><code>KeepAlive</code>监测的方式是发送<code>probe</code>包，会给网络带来额外的流量。</p><p><code>TCP KeepAlive</code>只能在内核层级监测连接的存活与否，而连接的存活不一定代表服务的可用。</p><p>例如当一个服务器 CPU 进程服务器占用达到 100%，已经卡死不能响应请求了，此时 TCP KeepAlive 依然会认为连接是存活的。</p><blockquote><p>因此 TCP KeepAlive 对于应用层程序的价值是相对较小的。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.tldp.org/HOWTO/html_single/TCP-Keepalive-HOWTO/" target="_blank" rel="noopener">TCP Keepalive HOWTO</a></p><p><a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html" target="_blank" rel="noopener">TCP KeepAlive</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;基本原理&lt;/li&gt;
&lt;li&gt;TCP的连接&lt;/li&gt;
&lt;li&gt;KeepAlive的局限
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day214-HTTP四次挥手</title>
    <link href="http://lmislm.com/2019/08/15/2019-08-15/"/>
    <id>http://lmislm.com/2019/08/15/2019-08-15/</id>
    <published>2019-08-14T16:00:00.000Z</published>
    <updated>2019-08-15T14:22:25.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>目的</li><li>过程<a id="more"></a></li></ol><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭，客户端或服务器均可主动发起挥手动作。</p><p>这个原则是当一方完成它的数据发送任务后就能发送标志位FIN来终止这个方向的连接。收到FIN=1只意味着这一方向上没有数据流动，一个TCP连接在收到FIN=1后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p><strong>第一次握手</strong> (FIN=1，seq=x)</p><p>假设客户端想要关闭连接，客户端发送标志位FIN为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p><p>发送完毕后，客户端进入<code>FIN_WAIT_1</code>状态。</p><p><strong>第二次握手</strong> (ACK=1，ACKnum=x+1)</p><p>服务器端确认客户端的 FIN 包，发送一个确认序号（ACKnum，又写做ack），表明已接收客户端关闭连接的请求，但还没有准备好关闭连接。</p><p>发送完毕后，服务器端进入<code>CLOSE_WAIT</code>状态。<br>客户端接收到这个确认序号后，进入<code>FIN_WAIT_2</code>状态，等待服务器端关闭连接。</p><p><strong>第三次握手</strong> (FIN=1，seq=y)</p><p>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。</p><p>发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。</p><p><strong>第四次挥手</strong> (ACK=1，ACKnum=y+1)</p><p>客户端接收到来自服务器端的关闭请求，发送一个确认序号，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。</p><p>服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</p><p><strong>最后</strong></p><p>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html" target="_blank" rel="noopener">三次握手</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;目的&lt;/li&gt;
&lt;li&gt;过程
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day213-HTTP三次握手</title>
    <link href="http://lmislm.com/2019/08/14/2019-08-14/"/>
    <id>http://lmislm.com/2019/08/14/2019-08-14/</id>
    <published>2019-08-13T16:00:00.000Z</published>
    <updated>2019-08-16T14:55:45.986Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>目的</li><li>名词</li><li>过程</li><li>疑问<a id="more"></a></li></ol><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>客户端连接服务端，建立TCP连接，交换窗口大小信息</p><h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><p><code>ISN(Initial Sequence Number)：</code>操作系统动态随机选取一个32位长的序列号，即初始序列号ISN。</p><p><code>SYN(SYNchronization)：</code>同步信号SYN，占用一个字节的编号。</p><p>在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。</p><p>对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。</p><p><code>ACKnum：</code>确认序号。Inform the sending host that the transmitted data was received successfully.</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p><strong>第一次握手</strong>（SYN=1, seq=x)</p><p>客户端发送，TCP的SYN标志位初始值为1的包，表明客户端向服务端发起连接。同时seq（ sequence numbers 序列号）包含ISN序列号x，保存在发送包序列号字段里。</p><p>发送完毕后，客户端进入<code>SYN_SEND</code>状态。</p><p><strong>第二次握手</strong>（SYN=1, seq=y, ACK=1, ACKnum=x+1）（注意ACKnum又写作ack）</p><p>服务器返回，SYN标志位和ACK标志位为1。服务端将ISN序列号放入Seq域，同时将ACKnum（Acknowledgement Number：确认序号）设置为客户端ISN序列号加1，即x+1。</p><p>发送完毕后，服务端进入<code>SYN_RCVD</code>状态。</p><p><strong>第三次握手</strong>（ACK=1，seq=x + 1，ACKnum=y+1）</p><p>客户端发送，SYN标志位为0，ACK标志位为1，将服务端的seq序号值加1，放入确认序号中，发送给服务端。</p><p>发送完毕后，客户端进入<code>ESTABLISHED</code>状态，服务端接收后，也进入ESTABLISHED状态。TCP三次握手结束</p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ol><li>为什么是三次握手不是两次握手？</li></ol><p>TCP 需要 seq 序列号来做可靠重传或接收，而避免连接复用时无法分辨出 seq 是延迟或者是旧链接的 seq。</p><blockquote><p>谢希仁版《计算机网络》：“已失效的连接请求报文段” 的产生在这样一种情况下：client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。”</p><ol start="2"><li>TCP 怎么样识别之前旧链接重发的包？</li></ol></blockquote><p>ISN（初始序列号）机制。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/24853633" target="_blank" rel="noopener">TCP 为什么是三次握手，而不是两次或四次？</a></p><p><a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html" target="_blank" rel="noopener">三次握手</a></p><p><a href="https://packetlife.net/blog/2010/jun/7/understanding-tcp-sequence-acknowledgment-numbers/" target="_blank" rel="noopener">Understanding TCP Sequence and Acknowledgment Numbers</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;目的&lt;/li&gt;
&lt;li&gt;名词&lt;/li&gt;
&lt;li&gt;过程&lt;/li&gt;
&lt;li&gt;疑问
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day212-DNS解析</title>
    <link href="http://lmislm.com/2019/08/13/2019-08-13/"/>
    <id>http://lmislm.com/2019/08/13/2019-08-13/</id>
    <published>2019-08-12T16:00:00.000Z</published>
    <updated>2019-08-16T14:52:25.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>DNS解析过程</li><li>DNS优化<a id="more"></a></li></ol><h2 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h2><p>DNS解析查IP过程：（以<a href="http://www.xxx.com为例）" target="_blank" rel="noopener">www.xxx.com为例）</a><br>过程：. -&gt; .com -&gt; xxx.com. -&gt; <a href="http://www.xxx.com" target="_blank" rel="noopener">www.xxx.com</a>.</p><ol><li>读取DNS缓存（缓存分为：浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存）</li><li>查找LDNS（本地区域名服务器，如果你在学校接入互联网，则 LDNS 服务器就在学校）。LDNS查询自己的DNS缓存，失败则进行DNS解析请求。</li><li>LDNS查找根域名服务器（<a href="http://www.xxx.com.，注意com后的“.”对应根域名服务器，默认都有，通常省略，但浏览器请求DNS时会自动加上" target="_blank" rel="noopener">www.xxx.com.，注意com后的“.”对应根域名服务器，默认都有，通常省略，但浏览器请求DNS时会自动加上</a>)</li><li>LDNS查找顶级域名服务器（COM域名服务器）</li><li>LDNS查找主域名服务器（xxx.com域名服务器），得到IP地址</li><li>LDNS将得到的IP地址，返回给操作系统，自己也存一份。</li></ol><h2 id="DNS优化"><a href="#DNS优化" class="headerlink" title="DNS优化"></a>DNS优化</h2><ol><li><p>缓存<br>主要有：浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存<br>浏览器缓存查看（Chrome版本75.0.3770.100为例）：<code>chrome://net-internals/#dns</code>。注：可以从<code>chrome://chrome-urls/</code>进去<br>系统缓存查看：（<code>/etc/hosts</code>，Linux系统）（<code>hosts</code>，Windows系统）</p></li><li><p>负载均衡<br>根据每台被请求的机器（含有请求资源）的负载量，该机器离用户地理位置的距离等等，来决定哪个机器处理，即负载均衡，又叫DNS重定向。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">前端经典面试题: 从输入URL到页面加载发生了什么？</a></p><p><a href="https://github.com/kaola-fed/blog/issues" target="_blank" rel="noopener">从输入页面地址到展示页面信息都发生了些什么？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;DNS解析过程&lt;/li&gt;
&lt;li&gt;DNS优化
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day211-localStorage、sessionStorage、Cookie</title>
    <link href="http://lmislm.com/2019/08/12/2019-08-12/"/>
    <id>http://lmislm.com/2019/08/12/2019-08-12/</id>
    <published>2019-08-11T16:00:00.000Z</published>
    <updated>2019-08-16T14:52:21.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>三者异同</li><li>三者的基本概念<a id="more"></a></li></ol><h2 id="三者异同"><a href="#三者异同" class="headerlink" title="三者异同"></a>三者异同</h2><table><thead><tr><th>特性</th><th>Cookie</th><th>localStorage</th><th>sessionStorage</th></tr></thead><tbody><tr><td>生命周期</td><td>可由服务器生成，可设置过期时间。如果在浏览器端生成Cookie，默认是关闭浏览器后清除</td><td>除非被清除，否则永久保存</td><td>仅在当前会话下有效，关闭页面或浏览器后被清除</td></tr><tr><td>可存放数据大小</td><td>4K左右</td><td>5MB左右</td><td>5MB左右</td></tr><tr><td>与服务器端通信</td><td>携带在HTTP头中</td><td>不与服务器端通信，仅仅在浏览器中保存</td><td>不与服务器端通信，仅仅在浏览器中保存</td></tr><tr><td>易用性</td><td>接口不友好</td><td>相对较容易封装</td><td>相对较容易封装</td></tr></tbody></table><h2 id="三者的基本概念"><a href="#三者的基本概念" class="headerlink" title="三者的基本概念"></a>三者的基本概念</h2><p><strong>localStorage</strong></p><p>HTML5新特性，支持IE8+、 IE6+的polyfill可以用userData。localStorage在浏览器的隐私模式下面是不可读取的。</p><p><strong>sessionStorage</strong></p><p>仅在当前会话下有效，关闭页面或浏览器后被清除。<br><strong>作用域</strong> 如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的。</p><p><strong>Cookie</strong><br>生命周期在设置的cookie过期时间之前一直有效。长度和数量的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB。属于旧方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;三者异同&lt;/li&gt;
&lt;li&gt;三者的基本概念
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day210-Content-Type</title>
    <link href="http://lmislm.com/2019/08/11/2019-08-11/"/>
    <id>http://lmislm.com/2019/08/11/2019-08-11/</id>
    <published>2019-08-10T16:00:00.000Z</published>
    <updated>2019-08-16T14:52:16.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>是什么？</li><li>句法</li><li>指令，及其注释<a id="more"></a></li></ol><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>Content-Type 实体头部用于指示资源的MIME类型 media type 。</p><h2 id="句法"><a href="#句法" class="headerlink" title="句法"></a>句法</h2><p>就是经常在header中看到的东西，如，<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Content-Type: text/html; charset=utf<span class="number">-8</span></span><br></pre></td></tr></table></figure></p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><ol><li>media-type</li></ol><p>资源或数据的 MIME type（媒体类型—通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型 ，是一种标准，用来表示文档、文件或字节流的性质和格式，如：text/html<br>、text/plain）。</p><ul><li>常见的：<br><code>multipart/form-data</code>，用以支持向服务器发送二进制数据</li></ul><p><code>application/x-www-urlencoded</code>，消息内容会经过 URL 格式编码，可用get方法和post方法，但不写enctype，无法实现文件上传</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.runoob.com/http/http-content-type.html" target="_blank" rel="noopener">HTTP content-type 对照表</a></p><p><a href="https://segmentfault.com/a/1190000003002851#articleHeader2" target="_blank" rel="noopener">理解HTTP之Content-Type</a></p><p><a href="https://juejin.im/post/5c9f4885f265da308868dad1" target="_blank" rel="noopener">上传文件multipart/form-data深入解析</a></p><p><a href="https://www.jianshu.com/p/29e38bcc8a1d" target="_blank" rel="noopener">深入解析 multipart/form-data</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;是什么？&lt;/li&gt;
&lt;li&gt;句法&lt;/li&gt;
&lt;li&gt;指令，及其注释
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day209-repaint和reflow扫盲</title>
    <link href="http://lmislm.com/2019/08/10/2019-08-10/"/>
    <id>http://lmislm.com/2019/08/10/2019-08-10/</id>
    <published>2019-08-09T16:00:00.000Z</published>
    <updated>2019-08-16T14:52:10.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>介绍</li><li>引起XX的常见操作</li><li>优化<a id="more"></a></li></ol><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>浏览器重新渲染，就需要重新生成布局和重新绘制。前者叫做”回流”（reflow，又叫重排，英文也叫Layout），后者叫做”重绘”（repaint）。</p><p>元素样式的改变不影响布局， UI 层面的重新像素绘制，重绘对元素进行更新 —— 重绘(repaint)<br>重新渲染页面 —— 回流(reflow)</p><h2 id="常见原因"><a href="#常见原因" class="headerlink" title="常见原因"></a>常见原因</h2><p><strong>常见的reflow操作：</strong></p><ol><li>页面初次渲染，浏览器窗口大小改变</li><li>元素尺寸/位置/内容发生改变</li><li>css伪类<blockquote><p>offsetTop/offsetLeft/offsetWidth/offsetHeight/offsetParent</p></blockquote></li></ol><blockquote><p>clientTop/clientLeft/clientWidth/clientHeight</p></blockquote><blockquote><p>scrollTop/scrollLeft/scrollWidth/scrollHeight</p></blockquote><blockquote><p>getComputedStyle()/getClientRects()/getBoundingClientRect()</p></blockquote><p><strong>常见的repaint操作：</strong></p><p>css属性的改变。</p><p>具体见CSS Triggers <a href="https://csstriggers.com/" target="_blank" rel="noopener">https://csstriggers.com/</a> 这里列出了哪些属性会引起reflow(即Layout)或repaint。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ul><li><p>rAF等<br>使用 window.requestAnimationFrame()、window.requestIdleCallback() 这两个方法调节重新渲染</p></li><li><p><a href="https://github.com/wilsonpage/fastdom" target="_blank" rel="noopener">FASTDOM</a> (Eliminates layout thrashing by batching DOM measurement and mutation tasks<br>)</p><blockquote><p>自动完成读写操作的批处理</p></blockquote></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/30078937" target="_blank" rel="noopener">如何不择手段提升scroll事件的性能—知乎</a></p><p><a href="https://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html" target="_blank" rel="noopener">网页性能管理详解—阮一峰</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;介绍&lt;/li&gt;
&lt;li&gt;引起XX的常见操作&lt;/li&gt;
&lt;li&gt;优化
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day208-requestAnimationFrame-了解</title>
    <link href="http://lmislm.com/2019/08/09/2019-08-09/"/>
    <id>http://lmislm.com/2019/08/09/2019-08-09/</id>
    <published>2019-08-08T16:00:00.000Z</published>
    <updated>2019-08-09T15:16:37.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>作用</li><li>应用</li><li>实例<a id="more"></a></li></ol><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><blockquote><p>要求浏览器在下次重绘之前调用指定的回调函数更新动画<sup>[1]</sup></p></blockquote><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li>减少<code>重绘</code>或<code>回流</code>。</li><li>替代通过时间管理队列的高频发事件，通过<code>requestAnimationFrame</code>来管理队列，保证 <code>requestAnimationFrame</code>的队列里，同样的回调函数只有一个。因为通常显示器16.7ms（16.7 = 1000 / 60, 即每秒60帧）的刷新间隔中，如果发生了其他绘制请求(setTimeout)，可能导致帧丢失。这里帧丢失通常就包含有，滚动、触摸这类高触发频率事件的回调可能会在同一帧内触发多次所导致，<code>requestAnimationFrame</code>就是跟着浏览器的绘制走，绘制间隔时间内绘制完毕。</li></ol><h2 id="实例-进度条"><a href="#实例-进度条" class="headerlink" title="实例-进度条"></a>实例-进度条</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span> <span class="attr">style</span>=<span class="string">"background-color: lightblue;width: 0;height: 20px;line-height: 20px;"</span>&gt;</span>0%<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span>run<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="javascript"><span class="keyword">var</span> timer; btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; myDiv.style.width = <span class="string">'0'</span>;</span></span><br><span class="line">  cancelAnimationFrame(timer);</span><br><span class="line"><span class="javascript">  timer = requestAnimationFrame(<span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span>(<span class="built_in">parseInt</span>(myDiv.style.width) &lt; <span class="number">500</span>)&#123; </span></span><br><span class="line"><span class="javascript">      myDiv.style.width = <span class="built_in">parseInt</span>(myDiv.style.width) + <span class="number">5</span> + <span class="string">'px'</span>; </span></span><br><span class="line"><span class="javascript">      myDiv.innerHTML = <span class="built_in">parseInt</span>(myDiv.style.width)/<span class="number">5</span> + <span class="string">'%'</span>; </span></span><br><span class="line">      timer = requestAnimationFrame(fn); </span><br><span class="line"><span class="javascript">    &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line">      cancelAnimationFrame(timer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>进度条例子来自：<a href="https://www.w3cplus.com/javascript/requestAnimationFrame.html" target="_blank" rel="noopener">W3Plus-被誉为神器的requestAnimationFrame</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1]. <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noopener">window.requestAnimationFrame-MDN</a></p><p><a href="https://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-%E5%8A%A8%E7%94%BB%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">CSS3动画那么强，requestAnimationFrame还有毛线用？</a></p><p><a href="https://segmentfault.com/a/1190000010229232" target="_blank" rel="noopener">requestAnimationFrame 方法你真的用对了吗？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;作用&lt;/li&gt;
&lt;li&gt;应用&lt;/li&gt;
&lt;li&gt;实例
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day207-Vue-nextTick()</title>
    <link href="http://lmislm.com/2019/08/08/2019-08-08/"/>
    <id>http://lmislm.com/2019/08/08/2019-08-08/</id>
    <published>2019-08-07T16:00:00.000Z</published>
    <updated>2019-08-08T15:12:28.727Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li><code>nextTick</code>用法</li><li><code>nextTick</code>源码相关</li><li>事件循环</li><li>源码中的降级策略<a id="more"></a></li></ol><h2 id="nextTick作用"><a href="#nextTick作用" class="headerlink" title="nextTick作用"></a><code>nextTick</code>作用</h2><blockquote><p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。<a href="https://cn.vuejs.org/v2/api/#Vue-nextTick" target="_blank" rel="noopener">来源</a></p></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 850555d on 20 Dec 2018</span></span><br><span class="line"><span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> MutationObserver !== <span class="string">'undefined'</span> &amp;&amp; (</span><br><span class="line">  isNative(MutationObserver) ||</span><br><span class="line">  <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">  MutationObserver.toString() === <span class="string">'[object MutationObserverConstructor]'</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="comment">// Use MutationObserver where native Promise is not available,</span></span><br><span class="line">  <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">  <span class="comment">// (#6466 MutationObserver is unreliable in IE11)</span></span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter)) <span class="comment">// 创建一个文本</span></span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    characterData: <span class="literal">true</span> <span class="comment">// 初始化监听文本节点</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.data = <span class="built_in">String</span>(counter) <span class="comment">// 文本节点变化监听</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上主要作用就是：监听文本变动是否完毕。</p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><ul><li><p>常见的<strong>microtask</strong>有：<br><code>Promise</code>、<code>MutationObserve</code>r、<code>Object.observe(废弃)</code>，以及nodejs中的<code>process.nextTick</code></p></li><li><p>常见的<strong>macrotask</strong> 有<code>setTimeout</code>、<code>MessageChannel</code>、<code>postMessage</code>、<code>setImmediate</code></p></li></ul><h2 id="降级策略"><a href="#降级策略" class="headerlink" title="降级策略"></a>降级策略</h2><p>在vue2.x版本的源码文件next-tick.js中，你还可以看到有其他的一些兼容性方法。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/Ma63d/vue-analysis/issues/6" target="_blank" rel="noopener">Vue源码详解之nextTick：MutationObserver只是浮云，microtask才是核心！</a></p><p><a href="https://juejin.im/entry/5aced80b518825482e39441e" target="_blank" rel="noopener">全面解析Vue.nextTick实现原理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;nextTick&lt;/code&gt;用法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nextTick&lt;/code&gt;源码相关&lt;/li&gt;
&lt;li&gt;事件循环&lt;/li&gt;
&lt;li&gt;源码中的降级策略
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day206-初识MutationObserver</title>
    <link href="http://lmislm.com/2019/08/07/2019-08-07/"/>
    <id>http://lmislm.com/2019/08/07/2019-08-07/</id>
    <published>2019-08-06T16:00:00.000Z</published>
    <updated>2019-08-07T15:29:09.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li><code>MutationObserver</code> 使用方法</li><li><code>MutationObserver</code> 的方法<code>observe()</code>(具体)和<code>takeRecords()</code>以及<code>disconnect()</code></li><li><code>MutationRecord</code><a id="more"></a></li></ol><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mObserver = <span class="keyword">new</span> MutationObserver(callback) <span class="comment">// 新建实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> word = <span class="built_in">document</span>.querySelector(<span class="string">'words'</span>);</span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  <span class="string">'childList'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'arrtibutes'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'characterData'</span>: <span class="literal">true</span>, <span class="comment">// 节点内容或节点文本的变动</span></span><br><span class="line">  <span class="string">'subtree'</span>: <span class="literal">true</span>, <span class="comment">// 所有子节点，不能单独观察，必须同时指定以上三个为`true`</span></span><br><span class="line">  <span class="string">'attributeOldValue'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'characterDataOldValue'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'attributesFilter'</span>: [<span class="string">'class'</span>, <span class="string">'str'</span>] <span class="comment">// 值为数组，表示观察的特定属性</span></span><br><span class="line">&#125;</span><br><span class="line">mObserver.observer(word, options)</span><br></pre></td></tr></table></figure><h2 id="disconnect、takeRecord"><a href="#disconnect、takeRecord" class="headerlink" title="disconnect、takeRecord"></a>disconnect、takeRecord</h2><ul><li>disconnect 表示停止观察，无参数，用法：mObserver.disconnect()</li><li>takeRecord 用来清除变动记录，无参数，用法：mObserver.takeRecords()</li></ul><h2 id="MutationRecord"><a href="#MutationRecord" class="headerlink" title="MutationRecord"></a>MutationRecord</h2><blockquote><p>每个 MutationRecord 代表一个独立的 DOM 变化，其作为参数传递给 MutationObserver 的回调函数。</p></blockquote><ol><li>参数的含义</li></ol><ul><li>type: 观察的变动类型（attribute、characterData或者childList）</li><li>target: 发生变动的DOM对象</li><li>addedNodes: 新增的DOM对象</li><li>removeNodes: 删除的DOM对象</li><li>previousSibling: 前一个同级的DOM对象，无则返回null</li><li>nextSibling: 下个同级的DOM对象，无则返回null</li><li>attributeName: 发生变动的属性，如果设置了attributeFilter，则只返回预先指定的属性</li><li>oldValue：变动前的值。只对attribute和characterData变动有效</li></ul><p>详细的属性表，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationRecord" target="_blank" rel="noopener">点击这里</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver/observe" target="_blank" rel="noopener">MDN-MutationObserver</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationRecord" target="_blank" rel="noopener">MDN-MutationRecord</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;MutationObserver&lt;/code&gt; 使用方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MutationObserver&lt;/code&gt; 的方法&lt;code&gt;observe()&lt;/code&gt;(具体)和&lt;code&gt;takeRecords()&lt;/code&gt;以及&lt;code&gt;disconnect()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MutationRecord&lt;/code&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day205-instanceOf</title>
    <link href="http://lmislm.com/2019/08/06/2019-08-06/"/>
    <id>http://lmislm.com/2019/08/06/2019-08-06/</id>
    <published>2019-08-05T16:00:00.000Z</published>
    <updated>2019-08-06T14:59:38.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>instanceOf 简单实现</p><blockquote><p>原理：检查是否在left（左边的值）的原型链上<br><a id="more"></a></p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceOf</span> (<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rightProto = right.prototype</span><br><span class="line">  left = left.__proto__</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!left) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left === rightProto) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 继续找下去</span></span><br><span class="line">    &#125;</span><br><span class="line">    left = left.__proto__ <span class="comment">// 继续遍历</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;p&gt;instanceOf 简单实现&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原理：检查是否在left（左边的值）的原型链上&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
