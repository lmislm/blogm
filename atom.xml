<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LMISLMのBlog</title>
  
  <subtitle>不积小流，无以成江海。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lmislm.com/"/>
  <updated>2019-04-29T15:36:56.205Z</updated>
  <id>http://lmislm.com/</id>
  
  <author>
    <name>lmislm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>day107-typescript实现promise</title>
    <link href="http://lmislm.com/2019/04/29/2019-04-29/"/>
    <id>http://lmislm.com/2019/04/29/2019-04-29/</id>
    <published>2019-04-28T16:00:00.000Z</published>
    <updated>2019-04-29T15:36:56.205Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近某个babel的项目的时候接触到了typescript，感觉这个世界还是静态语言的天下啊。赶紧学起来。当然学静态语言，单元测试也是很重要的一部分。但是这个过程看来有点漫长，慢慢来吧。本文主要是笔记，看别人怎么实现promisejs。先看看实现<a href="https://promisesaplus.com/" target="_blank" rel="noopener">promise标准</a>和比较完美的<a href="http://bluebirdjs.com/docs/api-reference.html" target="_blank" rel="noopener">Bluebird方案</a>。</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g2jxggrh5hj20e709g74k.jpg" alt=""><br><a id="more"></a></p><h3 id="实现（部分）"><a href="#实现（部分）" class="headerlink" title="实现（部分）"></a>实现（部分）</h3><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerOnSuccess&lt;T, U = <span class="built_in">any</span>&gt; = <span class="function">(<span class="params">value: T</span>) =&gt;</span> U | Thenable&lt;U&gt;;</span><br><span class="line"><span class="keyword">type</span> HandlerOnFail&lt;U = <span class="built_in">any</span>&gt; = <span class="function">(<span class="params">reason: <span class="built_in">any</span></span>) =&gt;</span> U | Thenable&lt;U&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Handler&lt;T, U&gt; &#123;</span><br><span class="line">  onSuccess: HandlerOnSuccess&lt;T, U&gt;;</span><br><span class="line">  onFail: HandlerOnFail&lt;U&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造器等"><a href="#构造器等" class="headerlink" title="构造器等"></a>构造器等</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> PQ&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> state: States = States.PENDING</span><br><span class="line">  <span class="keyword">private</span> handlers: Handler&lt;T, <span class="built_in">any</span>&gt;[] = []</span><br><span class="line">  <span class="keyword">private</span> value: T | <span class="built_in">any</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> errors = errors</span><br><span class="line"><span class="comment">// 构造器constructor</span></span><br><span class="line">  public constructor(callback: (resolve: Resolve&lt;T&gt;, reject: Reject) =&gt; void) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 回调参数this.resolve,this.reject</span></span><br><span class="line">      callback(<span class="keyword">this</span>.resolve, <span class="keyword">this</span>.reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">this</span>.reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> setResult = <span class="function">(<span class="params">value: T | <span class="built_in">any</span>, state: States</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">set</span> = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.state !== States.PENDING) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isThenable(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (value <span class="keyword">as</span> Thenable&lt;T&gt;).then(<span class="keyword">this</span>.resolve, <span class="keyword">this</span>.reject)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.value = value</span><br><span class="line">      <span class="keyword">this</span>.state = state</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.executeHandlers()</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(<span class="keyword">set</span>, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://medium.freecodecamp.org/how-to-implement-promises-in-javascript-1ce2680a7f51" target="_blank" rel="noopener">Implementing Promises In JavaScript</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;最近某个babel的项目的时候接触到了typescript，感觉这个世界还是静态语言的天下啊。赶紧学起来。当然学静态语言，单元测试也是很重要的一部分。但是这个过程看来有点漫长，慢慢来吧。本文主要是笔记，看别人怎么实现promisejs。先看看实现&lt;a href=&quot;https://promisesaplus.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;promise标准&lt;/a&gt;和比较完美的&lt;a href=&quot;http://bluebirdjs.com/docs/api-reference.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Bluebird方案&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g2jxggrh5hj20e709g74k.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day106-promise-then方法</title>
    <link href="http://lmislm.com/2019/04/28/2019-04-28/"/>
    <id>http://lmislm.com/2019/04/28/2019-04-28/</id>
    <published>2019-04-27T16:00:00.000Z</published>
    <updated>2019-04-28T15:54:20.566Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文主要是then方法的实现，以及thenable的实现，then链式调用。</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g2is8ppmm5j20gs09gq3z.jpg" alt=""><br><a id="more"></a></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promise then方法实现-笔记</span></span><br><span class="line"><span class="comment">// Promise/A标准要求返回一个新对象，Promise/A+没有要求。</span></span><br><span class="line"><span class="comment">// 注意：then方法里需要onResolved或者onRejected,必须符合标准thenable</span></span><br><span class="line">MyPromise.prototype.then= <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> _self = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> myPromise</span><br><span class="line">  <span class="comment">// then方法需要是function</span></span><br><span class="line">  onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">'function'</span> ? onResolved : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  onReject = <span class="keyword">typeof</span> onReject === <span class="string">'function'</span> ? onReject : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_self.status === <span class="string">'resolved'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 取onResolved结果</span></span><br><span class="line">        <span class="keyword">let</span> x = onResolved(_self.data)</span><br><span class="line">        <span class="comment">// myPromise的onResolved的返回值是一个promise对象？</span></span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">          x.then(resolve, reject)</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(x)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (_self.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> x = onReject(_self.data)</span><br><span class="line">        <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">          x.then(resolve, reject)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当然是没有reject</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (_self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">    <span class="comment">// 放入数组中</span></span><br><span class="line">    <span class="keyword">return</span> myPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      _self.onResolvedCallback.push(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> x = onResolved(_self.data)</span><br><span class="line">          <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">            x.then(resolve, reject)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          reject(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      _self.onRejectedCallback.push(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// try...catch, 同上</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据值来决定myPromise的状态</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Promise/A+标准规范 https://promisesaplus.com/#point-47</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; myPromise </span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; value onFulfilled or onRejected的结果</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; resolve </span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; reject </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">myPromise, value, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> then</span><br><span class="line">  <span class="comment">// 接到结果之后往后抛，then链式调用？</span></span><br><span class="line">  <span class="keyword">let</span> thenCalledOrThrow = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">if</span> (myPromise === value) &#123;<span class="comment">// 如果myPromise和value引用同一个对象，抛TypeError错,规范：2.3.1</span></span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'value和myPromise引用的同一个对象'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;<span class="comment">// 如果value是一个promise就用其声明， 2.3.2</span></span><br><span class="line">    <span class="keyword">if</span> (value.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      <span class="comment">// value的最终状态并没有确定，就必须要等确定fulfilled或rejected， 2.3.2.1</span></span><br><span class="line">      value.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        resolvePromise(myPromise, value, resolve, reject)</span><br><span class="line">      &#125;, reject)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 确定了直接取值fulfilled或rejected 2.3.2.2 \ 2.3.2.3</span></span><br><span class="line">      value.then(resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实现的不是很详细，和标准规范可能有点出入。</span></span><br><span class="line">  <span class="keyword">if</span> ((value !== <span class="literal">null</span>) &amp;&amp; ((<span class="keyword">typeof</span> value === <span class="string">'object'</span>) || (<span class="keyword">typeof</span> value === <span class="string">'function'</span>))) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      then = value.then</span><br><span class="line">      <span class="comment">// 如果检查到value.then的结果有错，则抛错</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        then.call(value, <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (thenCalledOrThrow) <span class="keyword">return</span></span><br><span class="line">          <span class="comment">// ???</span></span><br><span class="line">          thenCalledOrThrow = <span class="literal">true</span></span><br><span class="line">          <span class="keyword">return</span> reject(err)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="comment">// if (thenCalledOrThrow) return </span></span><br><span class="line">      thenCalledOrThrow = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">return</span> reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/xieranmaya/blog/issues/3" target="_blank" rel="noopener">剖析Promise内部结构</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文主要是then方法的实现，以及thenable的实现，then链式调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g2is8ppmm5j20gs09gq3z.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day105-依据对象属性去重</title>
    <link href="http://lmislm.com/2019/04/27/2019-04-27/"/>
    <id>http://lmislm.com/2019/04/27/2019-04-27/</id>
    <published>2019-04-26T16:00:00.000Z</published>
    <updated>2019-04-27T14:15:28.967Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>直接上代码吧，这个稍微简单点。</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g2hjud32j8j20e609gwex.jpg" alt=""></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [ [ <span class="string">'测'</span>, <span class="string">'测试2'</span> ], [ <span class="string">'测'</span>, <span class="string">'测试2'</span> ] ]</span><br><span class="line"><span class="comment">// 根据属性去重</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">a</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> !res.has(a[<span class="number">0</span>]) &amp;&amp; res.set(a[<span class="number">0</span>], <span class="number">1</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr))</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;直接上代码吧，这个稍微简单点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g2hjud32j8j20e609gwex.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; arr = [ [ &lt;span class=&quot;string&quot;&gt;&#39;测&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;测试2&#39;&lt;/span&gt; ], [ &lt;span class=&quot;string&quot;&gt;&#39;测&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;测试2&#39;&lt;/span&gt; ] ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 根据属性去重&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;unique&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;arr&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; res = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Map&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; arr.filter(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;a&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(a[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; !res.has(a[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]) &amp;amp;&amp;amp; res.set(a[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;], &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(unique(arr))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day103-vuejs源码-updateChildren（1）</title>
    <link href="http://lmislm.com/2019/04/25/2019-04-25/"/>
    <id>http://lmislm.com/2019/04/25/2019-04-25/</id>
    <published>2019-04-24T16:00:00.000Z</published>
    <updated>2019-04-26T15:33:52.904Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>主要是子节点中新老节点怎么相互去比较，替换。<strong>diff操作。</strong></p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g2fb93r4yjj20gs09gdgy.jpg" alt=""></p><a id="more"></a><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vuejs 源码 updateChildren</span></span><br><span class="line"><span class="comment">// 上一篇patchVnode中有这些参数的关系</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span>(<span class="params">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> oldStartIdx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> newStartIdx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">  <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class="line">  <span class="keyword">let</span> oldKeyToIdx, idxInOld, elmToMove, refElm</span><br><span class="line"></span><br><span class="line">  <span class="comment">// removeOnly is a special flag used only by &lt;transition-group&gt;</span></span><br><span class="line">  <span class="comment">// to ensure removed elemtents stay in correct relative positions</span></span><br><span class="line">  <span class="comment">// during leaving transtions</span></span><br><span class="line">  <span class="keyword">const</span> canMove = !removeOnly</span><br><span class="line">  <span class="comment">// 新老节点两列，相互两两比较，直到某个相遇的点循环结束</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx] <span class="comment">// vnode has been moved left</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">      <span class="comment">// 如果指定key是相同的就判定为同一个节点</span></span><br><span class="line">      <span class="comment">// patchVnode = oldCh[++oldStartIdx]</span></span><br><span class="line">      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartVnode]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">      <span class="comment">// 开始节点到结束节点判断是否相同</span></span><br><span class="line">      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123; <span class="comment">// Vnode moved right</span></span><br><span class="line">      <span class="comment">// oldStartVnode和newEndVnode首尾相连，老的连在新的后面，进行pathchVnode之后，还要将真实DOM节点移到oldEndVnode的后面</span></span><br><span class="line">      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123; <span class="comment">// Vnode moved left</span></span><br><span class="line">      <span class="comment">// oldEndVnode和newStartVnode首尾相连，新的连在老的后面</span></span><br><span class="line">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是交叉相连的，？？？</span></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">          引自参考https://github.com/answershuto</span></span><br><span class="line"><span class="comment">          生成一个key与旧VNode的key对应的哈希表（只有第一次进来undefined的时候会生成，也为后面检测重复的key值做铺垫）</span></span><br><span class="line"><span class="comment">          比如childre是这样的 [&#123;xx: xx, key: 'key0'&#125;, &#123;xx: xx, key: 'key1'&#125;, &#123;xx: xx, key: 'key2'&#125;]  beginIdx = 0   endIdx = 2  </span></span><br><span class="line"><span class="comment">          结果生成&#123;key0: 0, key1: 1, key2: 2&#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">      <span class="keyword">if</span> (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">      <span class="comment">/*如果newStartVnode新的VNode节点存在key并且这个key在oldVnode中能找到则返回这个节点的idxInOld（即第几个节点，下标）*/</span></span><br><span class="line">      idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : <span class="literal">null</span></span><br><span class="line">      <span class="keyword">if</span> (isUndef(idxInOld)) &#123; <span class="comment">// New element</span></span><br><span class="line">        <span class="comment">/*newStartVnode没有key或者是该key没有在老节点中找到则创建一个新的节点*/</span></span><br><span class="line">        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*获取同key的老节点*/</span></span><br><span class="line">        elmToMove = oldCh[idxInOld]</span><br><span class="line">        <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !elmToMove) &#123;</span><br><span class="line">          <span class="comment">/*如果elmToMove不存在说明之前已经有新节点放入过这个key的DOM中，提示可能存在重复的key，确保v-for的时候item有唯一的key值*/</span></span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">'It seems there are duplicate keys that is causing an update error. '</span> +</span><br><span class="line">            <span class="string">'Make sure each v-for item has a unique key.'</span></span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sameVnode(elmToMove, newStartVnode)) &#123;</span><br><span class="line">          <span class="comment">/*如果新VNode与得到的有相同key的节点是同一个VNode则进行patchVnode*/</span></span><br><span class="line">          patchVnode(elmToMove, newStartVnode, insertedVnodeQueue)</span><br><span class="line">          <span class="comment">/*因为已经patchVnode进去了，所以将这个老节点赋值undefined，之后如果还有新节点与该节点key相同可以检测出来提示已有重复的key*/</span></span><br><span class="line">          oldCh[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">          <span class="comment">/*当有标识位canMove实可以直接插入oldStartVnode对应的真实DOM节点前面*/</span></span><br><span class="line">          canMove &amp;&amp; nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm)</span><br><span class="line">          newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">          <span class="comment">/*当新的VNode与找到的同样key的VNode不是sameVNode的时候（比如说tag不一样或者是有不一样type的input标签），创建一个新的节点*/</span></span><br><span class="line">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)</span><br><span class="line">          newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">   <span class="comment">/*全部比较完成以后，发现oldStartIdx &gt; oldEndIdx的话，说明老节点已经遍历完了，新节点比老节点多，所以这时候多出来的新节点需要一个一个创建出来加入到真实DOM中*/</span></span><br><span class="line">   refElm = isUndef(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].elm</span><br><span class="line">   addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">   <span class="comment">/*如果全部比较完成以后发现newStartIdx &gt; newEndIdx，则说明新节点已经遍历完了，老节点多余新节点，这个时候需要将多余的老节点从真实DOM中移除*/</span></span><br><span class="line">   removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://github.com/answershuto/learnVue" target="_blank" rel="noopener">learnVue</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;主要是子节点中新老节点怎么相互去比较，替换。&lt;strong&gt;diff操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g2fb93r4yjj20gs09gdgy.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day102-vuejs源码-patchVnode</title>
    <link href="http://lmislm.com/2019/04/24/2019-04-24/"/>
    <id>http://lmislm.com/2019/04/24/2019-04-24/</id>
    <published>2019-04-23T16:00:00.000Z</published>
    <updated>2019-04-24T16:00:32.375Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>主要是讲新旧节点是怎么判断进行替换的。</p><ul><li>先理一下思路,这类的条件语句比较多,主要是节点和文本的替换，但是理完下来感觉还是蛮清爽的。</li><li>判断新旧节点同时存在，又是同一个节点，而且只能渲染一次，那么只需要相互替换组件实例就行</li><li>通过钩子，判断新老节点都有子节点oldCh的话，就对子节点进行diff，调用updateChildren方法</li><li>新旧节点，新节点有子节点，但是旧的没有，就清空旧的文本内容后，为当前DOM节点插入新节点</li><li>新旧节点，新节点没有子节点，但是旧的有，就移除该DOM节点的所有子节点</li><li>新旧节点都没有子节点的时候，就只是文本的替换</li></ul><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g2e5szpv9qj20e609ggmq.jpg" alt=""><br><a id="more"></a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span>(<span class="params">oldVnode, vnode, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (oldVnode === vnode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reuse(重用) element for static trees</span></span><br><span class="line">  <span class="comment">// note we only do this if the vnode is cloned -</span></span><br><span class="line">  <span class="comment">// if the new node is not cloned it means the render functions have been</span></span><br><span class="line">  <span class="comment">// reset by the hot-reload-api and we need to do a proper re-render.</span></span><br><span class="line">  <span class="comment">// 比较新旧是否相同且新节点是否标记了once</span></span><br><span class="line">  <span class="comment">// 第一步</span></span><br><span class="line">  <span class="keyword">if</span> (isTrue(vnode.isStatic) &amp;&amp;</span><br><span class="line">    isTrue(oldVnode.isStatic) &amp;&amp;</span><br><span class="line">    vnode.key === oldVnode.key &amp;&amp;</span><br><span class="line">    (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) &#123;</span><br><span class="line">      vnode.elm = oldVnode.elm</span><br><span class="line">      vnode.componentInstance = oldVnode.componentInstance</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 第二步</span></span><br><span class="line">    <span class="keyword">let</span> i</span><br><span class="line">    <span class="keyword">const</span> data = vnode.data</span><br><span class="line">    <span class="comment">// 判断钩子是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef(i = data.hook) &amp;&amp; isDef(i = i.prepatch)) &#123;</span><br><span class="line">      i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> elm = vnode.elm = oldVnode.elm</span><br><span class="line">    <span class="keyword">const</span> oldCh = oldVnode.children</span><br><span class="line">    <span class="keyword">const</span> ch = vnode.children</span><br><span class="line">    <span class="comment">// 判断是否有子节点存在？</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(data) &amp;&amp;isPatchable(vnode)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.update.length; ++i) &#123;</span><br><span class="line">        cbs.update[i](oldVnode, vnode)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isDef(i = data.hook) &amp;&amp; isDef(i = i.update)) &#123;</span><br><span class="line">        i(oldVnode, vnode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有文本内容存在</span></span><br><span class="line">    <span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">      <span class="keyword">if</span>(isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCh !== ch) &#123;</span><br><span class="line">          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">    <span class="comment">// 第三步</span></span><br><span class="line">        <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">          nodeOps.setTextContent(elm, <span class="string">''</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意，这里要添加节点了！</span></span><br><span class="line">        addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">        removeVnodes(elm, oldCh, <span class="number">0</span>, oldCh.length <span class="number">-1</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">        <span class="comment">// 只有老节点有子节点</span></span><br><span class="line">        nodeOps.setTextContent(elm, <span class="string">''</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">      <span class="comment">// 设置文本内容，条件语句走到最后</span></span><br><span class="line">      nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用postpatch钩子</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">      <span class="keyword">if</span>(isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) &#123;</span><br><span class="line">        i(oldVnode, vnode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;主要是讲新旧节点是怎么判断进行替换的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先理一下思路,这类的条件语句比较多,主要是节点和文本的替换，但是理完下来感觉还是蛮清爽的。&lt;/li&gt;
&lt;li&gt;判断新旧节点同时存在，又是同一个节点，而且只能渲染一次，那么只需要相互替换组件实例就行&lt;/li&gt;
&lt;li&gt;通过钩子，判断新老节点都有子节点oldCh的话，就对子节点进行diff，调用updateChildren方法&lt;/li&gt;
&lt;li&gt;新旧节点，新节点有子节点，但是旧的没有，就清空旧的文本内容后，为当前DOM节点插入新节点&lt;/li&gt;
&lt;li&gt;新旧节点，新节点没有子节点，但是旧的有，就移除该DOM节点的所有子节点&lt;/li&gt;
&lt;li&gt;新旧节点都没有子节点的时候，就只是文本的替换&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g2e5szpv9qj20e609ggmq.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day101-vuejs源码-patch-笔记</title>
    <link href="http://lmislm.com/2019/04/23/2019-04-23/"/>
    <id>http://lmislm.com/2019/04/23/2019-04-23/</id>
    <published>2019-04-22T16:00:00.000Z</published>
    <updated>2019-04-24T14:33:54.329Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文主要是记录下读vuejs源码中virtualDom部分，注释一小部分的patch核心diff算法。算法通过<strong>同层的树节点</strong>进行比较而非对树进行逐层搜索遍历的方式，所以时间复杂度只有<strong>O(n)</strong>，是一种相当高效的算法<br>下面截取的<strong>代码</strong>部分是<strong>createPatchFunction</strong>(一个patch函数)的返回值，</p><blockquote><p>oldValue 与 vnode在sameVnode的时候才会进行patchVnode。</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g2cz3lqk0yj20dq09gabz.jpg" alt=""></p><a id="more"></a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">oldValue, vnode, hydrating, removeOnly, parentElm, refElm</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// vnode不存在则直接销毁钩子</span></span><br><span class="line">  <span class="keyword">if</span> (isUndef(vnode)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(oldVnode)) invokeDestroyHook(oldValue)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> insertedVnodeQueue = []</span><br><span class="line">  <span class="keyword">if</span> (isUndef(oldVnode)) &#123;</span><br><span class="line">    <span class="comment">// 空挂载（像是组件），创建新的root节点</span></span><br><span class="line">    <span class="comment">// oldValue未定义时，即为root节点时，创建一个新节点</span></span><br><span class="line">    isInitialPatch = <span class="literal">true</span></span><br><span class="line">    createElm(vnode, insertedVnodeQueue, parentElm, refElm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 标记旧的VNode是否有nodeType ??</span></span><br><span class="line">    <span class="keyword">const</span> isRealElement = isDef(oldVnode, vnode)</span><br><span class="line">    <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldValue, vnode)) &#123;</span><br><span class="line">      patchVnode(oldValue, vnode, insertedVnodeQueue, removeOnly)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isRealElement) &#123;</span><br><span class="line">        <span class="comment">// 挂载到一个真的节点</span></span><br><span class="line">        <span class="comment">// 检查是否是服务端渲染的内容且if we can perform a successful hydration(是否我们可以合并到真实DOM)</span></span><br><span class="line">        <span class="keyword">if</span> (oldVnode.nodeType === <span class="number">1</span> &amp;&amp; oldValue.hasAttribute(SSR_ATTR)) &#123;</span><br><span class="line">          oldVnode.removeAttribute(SSR_ATTR)</span><br><span class="line">          hydrating = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isTrue(hydrating)) &#123;</span><br><span class="line">          <span class="comment">// 需要合并到真实DOM</span></span><br><span class="line">          <span class="keyword">if</span>(hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;</span><br><span class="line">            invokeInsertHook(vnode, insertedVnodeQueue, <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">return</span> oldValue</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ProcessingInstruction.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">            warn(</span><br><span class="line">              <span class="string">'The client-side rendered virtual DOM tree is not matching '</span> +</span><br><span class="line">              <span class="string">'server-rendered content. This is likely caused by incorrect '</span> +</span><br><span class="line">              <span class="string">'HTML markup, for example nesting block-level elements inside '</span> +</span><br><span class="line">              <span class="string">'&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing '</span> +</span><br><span class="line">              <span class="string">'full client-side render.'</span></span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不是服务端渲染或者合并到真实DOM失败，则创建一个空的VNode节点替换它</span></span><br><span class="line">        oldValue = emptyNodeAt(oldVnode)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 取代现有元素</span></span><br><span class="line">      <span class="keyword">const</span> oldElm = oldValue.elm</span><br><span class="line">      <span class="keyword">const</span> parentElm = nodeOps.parentNode(oldElm)</span><br><span class="line">      createElm(</span><br><span class="line">        vnode,</span><br><span class="line">        insertedVnodeQueue, <span class="comment">// ???</span></span><br><span class="line">        <span class="comment">// extremely rare edge case: do not insert if old element is in a</span></span><br><span class="line">        <span class="comment">// leaving transition. Only happens when combining transition +</span></span><br><span class="line">        <span class="comment">// keep-alive + HOCs. (#4590)</span></span><br><span class="line">        oldElm._leaveCb ? <span class="literal">null</span> : parentElm,</span><br><span class="line">        nodeOps.nextSibling(oldElm)</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">if</span> (isDef(vnode.parent)) &#123;</span><br><span class="line">        <span class="comment">// 组件根节点被替换，遍历更新父节点element</span></span><br><span class="line">        <span class="keyword">let</span> ancestor = vnode.parent</span><br><span class="line">        <span class="keyword">while</span> (ancestor) &#123;</span><br><span class="line">          ancestor.elm = vnode.elm</span><br><span class="line">          ancestor = ancestor.parent</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isPatchable(vnode)) &#123;</span><br><span class="line">          <span class="comment">// 调用create回调</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.create.length; ++i) &#123;</span><br><span class="line">            cbs.create[i](emptyNode, vnode.parent)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isDef(parentElm)) &#123;</span><br><span class="line">        <span class="comment">// 移除老节点</span></span><br><span class="line">        removeVnodes(parentElm, [oldValue], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldValue.tag)) &#123;</span><br><span class="line">        invokeDestroyHook(oldVnode)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)</span><br><span class="line">  <span class="keyword">return</span> vnode.elm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/answershuto/learnVue" target="_blank" rel="noopener">learnVue</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文主要是记录下读vuejs源码中virtualDom部分，注释一小部分的patch核心diff算法。算法通过&lt;strong&gt;同层的树节点&lt;/strong&gt;进行比较而非对树进行逐层搜索遍历的方式，所以时间复杂度只有&lt;strong&gt;O(n)&lt;/strong&gt;，是一种相当高效的算法&lt;br&gt;下面截取的&lt;strong&gt;代码&lt;/strong&gt;部分是&lt;strong&gt;createPatchFunction&lt;/strong&gt;(一个patch函数)的返回值，&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;oldValue 与 vnode在sameVnode的时候才会进行patchVnode。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g2cz3lqk0yj20dq09gabz.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day100-vuejs源码-VNode笔记</title>
    <link href="http://lmislm.com/2019/04/22/2019-04-22/"/>
    <id>http://lmislm.com/2019/04/22/2019-04-22/</id>
    <published>2019-04-21T16:00:00.000Z</published>
    <updated>2019-04-22T15:22:07.570Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p> vuejs中的VirtualDOM（VNode）在重新渲染ViewModel时非常重要。<br>什么时候调用？</p><blockquote><p>数据变化 -&gt; set监测到 -&gt;<br>dep.notify()通知Watcher -&gt;<br>Watcher调用其get()监测新值之后update()<br>??还是直接通过get方法执行vm._update(vm._render(), hydrating)</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g2btp41rvxj209g09gjrm.jpg" alt=""><br><a id="more"></a></p><h3 id="update方法"><a href="#update方法" class="headerlink" title="_update方法"></a>_update方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: Boolean</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">    callHook(vm, <span class="string">'beforeUpdate'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> prevEl = vm.$el</span><br><span class="line">  <span class="keyword">const</span> prevVnode = vm._vnode</span><br><span class="line">  <span class="keyword">const</span> prevActiveInstance = activeInstance</span><br><span class="line">  activeInstance = vm</span><br><span class="line">  vm._vnode = vnode</span><br><span class="line">  <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></span><br><span class="line">  <span class="comment">// based on the rendering backend used.</span></span><br><span class="line">  <span class="comment">// _patch_被用作一个入口</span></span><br><span class="line">  <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">    <span class="comment">// initial render,新老vnode节点相比较</span></span><br><span class="line">    vm.$el = vm.__patch__(</span><br><span class="line">      vm.$el, vnode, hydrating, <span class="literal">false</span>,</span><br><span class="line">      vm.$options._parentElm,</span><br><span class="line">      vm.$options._refElm</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// updates</span></span><br><span class="line">    vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  activeInstance = prevActiveInstance</span><br><span class="line">  <span class="comment">// update __vue__ reference</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$el) &#123;</span><br><span class="line">    vm.$el.__vue__ = vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</span><br><span class="line">    vm.$parent.$el = vm.$el</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// updated hook is called by the scheduler to ensure that children are</span></span><br><span class="line">  <span class="comment">// updated in a parent's updated hook.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://github.com/answershuto/learnVue/blob/master/docs/VirtualDOM%E4%B8%8Ediff%28Vue%E5%AE%9E%E7%8E%B0%29.MarkDown" target="_blank" rel="noopener">VirtualDOM与diff(Vue实现).MarkDown</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt; vuejs中的VirtualDOM（VNode）在重新渲染ViewModel时非常重要。&lt;br&gt;什么时候调用？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数据变化 -&amp;gt; set监测到 -&amp;gt;&lt;br&gt;dep.notify()通知Watcher -&amp;gt;&lt;br&gt;Watcher调用其get()监测新值之后update()&lt;br&gt;??还是直接通过get方法执行vm._update(vm._render(), hydrating)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g2btp41rvxj209g09gjrm.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day99-双向绑定-Compile</title>
    <link href="http://lmislm.com/2019/04/21/2019-04-21/"/>
    <id>http://lmislm.com/2019/04/21/2019-04-21/</id>
    <published>2019-04-20T16:00:00.000Z</published>
    <updated>2019-04-22T14:33:30.798Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在之前的讨论中，漏掉了解析模板指令模块Compile。这里摘抄一个作者实现的案例。另外，上一篇也有大量参考该作者该案例，说明下。<a href="https://github.com/DMQ/mvvm" target="_blank" rel="noopener">该作者文章详情</a></p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g2aopcu7pyj20e509gmxi.jpg" alt=""><br><a id="more"></a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>单独看的话有点难理解啊。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Compile.prototype = &#123;</span><br><span class="line"><span class="comment">// ... 省略</span></span><br><span class="line">compileElement: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> childNodes = el.childNodes, me = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 遍历所有节点及其子节点</span></span><br><span class="line">    [].slice.call(childNodes).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> text = node.textContent <span class="comment">// 表达式文本</span></span><br><span class="line">      <span class="keyword">let</span> reg = <span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span><span class="comment">// 文本正则</span></span><br><span class="line">      <span class="comment">// 按元素节点方式编译,这里要区分Text?</span></span><br><span class="line">      <span class="keyword">if</span> (me.isElementNode(node)) &#123;</span><br><span class="line">        me.compile(node)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (me.isTextNode(node) &amp;&amp; reg.test(text)) &#123;</span><br><span class="line">        me.compileText(node, <span class="built_in">RegExp</span>.$<span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 遍历编译子节点(递归)</span></span><br><span class="line">      <span class="keyword">if</span> (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">        me.compileElement(node)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 这里有点不好理解</span></span><br><span class="line">  compile: <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> nodeAttrs = node.attributes, me = <span class="keyword">this</span>;</span><br><span class="line">    [].slice.call(nodeAttrs).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">attr</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 规定：指令以 v-xxx 命名</span></span><br><span class="line">      <span class="comment">// 如 &lt;span v-text="content"&gt;&lt;/span&gt; 中指令为 v-text</span></span><br><span class="line">      <span class="keyword">let</span> attrName = attr.name<span class="comment">// v-text</span></span><br><span class="line">      <span class="keyword">if</span> (me.isDirective(attrName)) &#123;</span><br><span class="line">        <span class="keyword">let</span> exp = attr.value <span class="comment">// content</span></span><br><span class="line">        <span class="keyword">let</span> dir = attrName.substring(<span class="number">2</span>)<span class="comment">// text</span></span><br><span class="line">        <span class="keyword">if</span> (me.isEventDirective(dir)) &#123;</span><br><span class="line">          <span class="comment">// 事件指令, 如 v-on:click</span></span><br><span class="line">          compileUtil.eventHandler(node, me.$vm, exp, dir)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 普通指令</span></span><br><span class="line">          compileUtil[dir] &amp;&amp; compileUtil[dir](node, me.$vm, exp)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指令处理集合</span></span><br><span class="line"><span class="keyword">let</span> compileUtil = &#123;</span><br><span class="line">  text: <span class="function"><span class="keyword">function</span>(<span class="params">node, vm, exp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bind(node, vm, exp, <span class="string">'text'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...省略</span></span><br><span class="line">  bind: <span class="function"><span class="keyword">function</span>(<span class="params">node, vm, exp, dir</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> updaterFn = updater[dir + <span class="string">'Updater'</span>]</span><br><span class="line">    <span class="comment">// 第一次初始化视图</span></span><br><span class="line">    updaterFn &amp;&amp; updaterFn(node, vm[exp])</span><br><span class="line">    <span class="comment">// 实例化订阅者，此操作会在对应的属性消息订阅器中添加了该订阅者watcher</span></span><br><span class="line">    <span class="keyword">new</span> Watcher(vm, exp, <span class="function"><span class="keyword">function</span>(<span class="params">value, oldValue</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 一旦属性值有变化，会收到通知执行此更新函数，更新视图</span></span><br><span class="line">      updaterFn &amp;&amp; updaterFn(node, value, oldValue)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新函数,调用对应的指令更新函数进行绑定</span></span><br><span class="line"><span class="keyword">let</span> updater = &#123;</span><br><span class="line">  textUpdater: <span class="function"><span class="keyword">function</span>(<span class="params">node, value</span>) </span>&#123;</span><br><span class="line">    node.textContent = <span class="keyword">typeof</span> value == <span class="string">'undefined'</span> ? <span class="string">''</span> : value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在之前的讨论中，漏掉了解析模板指令模块Compile。这里摘抄一个作者实现的案例。另外，上一篇也有大量参考该作者该案例，说明下。&lt;a href=&quot;https://github.com/DMQ/mvvm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;该作者文章详情&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g2aopcu7pyj20e509gmxi.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day98-双向绑定中的依赖收集-浅浅浅析</title>
    <link href="http://lmislm.com/2019/04/20/2019-04-20/"/>
    <id>http://lmislm.com/2019/04/20/2019-04-20/</id>
    <published>2019-04-19T16:00:00.000Z</published>
    <updated>2019-04-21T15:25:10.499Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>vuejs-双向绑定中的<strong>Dep.target</strong>（即依赖收集）要从双向绑定思路说起（这里的双像绑定当然指的是vuejs的数据劫持+发布者-订阅者模式）。</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g29i3a8nxlj20e609ggmh.jpg" alt=""><br><a id="more"></a></p><h3 id="model-view-viewmodel实现思路"><a href="#model-view-viewmodel实现思路" class="headerlink" title="model-view-viewmodel实现思路"></a>model-view-viewmodel实现思路</h3><p>首先要实现Observer，监听属性变动（数据劫持）。实现时将observe的对象进行递归遍历，包括子属性对象的属性，都加上setter和getter,使其都能监听数据变化（用递归）。<br><strong>监听变化之后？通知订阅者</strong><br>用一个数组来收集订阅者，数据变动就通知（notify()），之后再进行更新（update()）。<br><strong>谁是订阅者？如何往订阅器中添加订阅者？</strong><br>通过<strong>dep</strong>（即dependency）来添加订阅者（Watcher），但是dep要在监听变化时通知订阅者。那么就可能需要闭包操作（Dep.target，即可以在Dep定义一个全局target属性）,在监听时检测到数据就在<strong>闭包内</strong>暂存watcher<br> <strong>Watcher</strong><br>Watcher订阅者作为Oberver和Compile之间通信的桥梁<br>自身实例化时往<strong>属性订阅器</strong>(dep)里面添加自己<br>自己有一个update() 方法，等属性变动时属性订阅器通知再调用update()方法，触发COmplie中绑定的回调。<br><strong>Dep.target</strong><br>在watcher中的get方法时。会用到依赖收集。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Dep.target = <span class="keyword">this</span>;<span class="comment">// 将当前订阅者指向自己</span></span><br><span class="line"><span class="keyword">let</span> value = <span class="keyword">this</span>.obj[key];<span class="comment">// 触发getter，添加自己到属性订阅器中</span></span><br><span class="line">Dep.target = <span class="literal">null</span>;<span class="comment">// 添加完毕，重置</span></span><br></pre></td></tr></table></figure></p><p>实例化Watcher时，调用get()方法，通知<strong>Dep.target = watcherInstance</strong>标记订阅者时当前watcher实例<br>可以触发属性定义的getter方法，然后在属性的订阅器<strong>dep</strong>添加当前watcher实例（即将当前订阅者指向自己）<br>使得属性值变化的时候，watcherInstance收到更新通知。<br>一个基本的思路大概就是这些，一步步建立起来的逻辑。可能有些地方还没有理清楚，需要再加深理解。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;vuejs-双向绑定中的&lt;strong&gt;Dep.target&lt;/strong&gt;（即依赖收集）要从双向绑定思路说起（这里的双像绑定当然指的是vuejs的数据劫持+发布者-订阅者模式）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g29i3a8nxlj20e609ggmh.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day97-Proxy-实现观察者模式</title>
    <link href="http://lmislm.com/2019/04/19/2019-04-19/"/>
    <id>http://lmislm.com/2019/04/19/2019-04-19/</id>
    <published>2019-04-18T16:00:00.000Z</published>
    <updated>2019-04-20T15:08:15.806Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Vue3.0之后用Proxy代替Object.defineProperty。来尝个鲜，看看怎样实现一个简单的观察者模式。</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g28cr4j3oqj20gs09g3yx.jpg" alt=""><br><a id="more"></a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123; <span class="comment">// 添加订阅者，通知变化（依赖收集类Dep）</span></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  addSub(sub) &#123; <span class="comment">// 添加订阅者</span></span><br><span class="line">    <span class="keyword">this</span>.subs.add(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  notify(key) &#123; <span class="comment">// 通知订阅者更新</span></span><br><span class="line">    <span class="comment">// 修改data中数据的时候会触发Watcher的notify，从而回调渲染函数</span></span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123; <span class="comment">// 观察者，订阅数据变化，绑定更新函数，添加订阅者，更新视图</span></span><br><span class="line">  <span class="keyword">constructor</span>(obj, key, cb) &#123;</span><br><span class="line">    <span class="keyword">this</span>.obj = obj,</span><br><span class="line">    <span class="keyword">this</span>.key = key,</span><br><span class="line">    <span class="keyword">this</span>.cb = cb <span class="comment">// 回调</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</span><br><span class="line">  &#125;</span><br><span class="line">  get() &#123; <span class="comment">// 将自身添加到dep中</span></span><br><span class="line">    <span class="comment">// 观察者Watcher实例赋值给全局的Dep.target</span></span><br><span class="line">    <span class="comment">// 触发render操作只有被Dep.target标记过的才会进行依赖收集</span></span><br><span class="line">    Dep.target = <span class="keyword">this</span> <span class="comment">// 将当前订阅者指向自己</span></span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">this</span>.obj[<span class="keyword">this</span>.key] <span class="comment">// 触发getter，添加自己到属性订阅器中</span></span><br><span class="line">    Dep.target = <span class="literal">null</span> <span class="comment">// 添加完毕，重置</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  update () &#123; <span class="comment">// 观察是否有新的值</span></span><br><span class="line">    <span class="keyword">let</span> newVal = <span class="keyword">this</span>.obj[<span class="keyword">this</span>.key]</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.value !== newVal) &#123;</span><br><span class="line">      <span class="keyword">this</span>.cb(newVal)</span><br><span class="line">      <span class="keyword">this</span>.value = newVal</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Observer</span> (<span class="params">obj</span>) </span>&#123; <span class="comment">// 劫持监听所有属性</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span>) &#123;</span><br><span class="line">      obj[key] = Observer(obj[key])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">let</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="keyword">let</span> handler = &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, receiver</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 依赖收集的时候回addSub到sub中</span></span><br><span class="line">      Dep.target &amp;&amp; dep.addSub(Dep.target)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, value, receiver</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> result = <span class="built_in">Reflect</span>.set(target, key, value, receiver)</span><br><span class="line">      dep.notify() <span class="comment">// 发布</span></span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  name: <span class="string">'lmislm'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">who</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'my name is'</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">what</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'just do'</span>, data)</span><br><span class="line">&#125;</span><br><span class="line">data = Observer(data)</span><br><span class="line"><span class="keyword">new</span> Watcher(data, <span class="string">'name'</span>, who)</span><br><span class="line"><span class="comment">// 新值旧值一样需要判断</span></span><br><span class="line">data.name = <span class="string">'lmislm2'</span></span><br><span class="line"><span class="keyword">new</span> Watcher(data, <span class="string">'what'</span>, what)</span><br><span class="line">data.what = <span class="string">'IT'</span></span><br><span class="line"><span class="comment">// my name is lmislm2</span></span><br><span class="line"><span class="comment">// just do IT</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Vue3.0之后用Proxy代替Object.defineProperty。来尝个鲜，看看怎样实现一个简单的观察者模式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g28cr4j3oqj20gs09g3yx.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day96-ES6-类机制</title>
    <link href="http://lmislm.com/2019/04/18/2019-04-18/"/>
    <id>http://lmislm.com/2019/04/18/2019-04-18/</id>
    <published>2019-04-17T16:00:00.000Z</published>
    <updated>2019-04-18T14:48:05.496Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p> 类机制核心-关键字-class表示一个块-定义一个函数原型的成员。</p><blockquote><p>ES6中增加了语法糖extends和super。extends 用来在两个函数原型之间建立[[Prototype]]委托链接，即所谓的“原型继承”</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g27686ym7rj20e609gdhr.jpg" alt=""><br><a id="more"></a></p><h3 id="extends和super"><a href="#extends和super" class="headerlink" title="extends和super"></a>extends和super</h3><blockquote><p>注意super不同位置起的作用。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(a, b) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = a</span><br><span class="line">    <span class="keyword">this</span>.y = b</span><br><span class="line">  &#125;</span><br><span class="line">  gXYZ () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.x * <span class="keyword">this</span>.y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把Bar.prototype的[[Prototype]]连接到Foo.prototype</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(a, b , c) &#123;</span><br><span class="line">    <span class="comment">// super具体指Foo</span></span><br><span class="line">    <span class="keyword">super</span>(a, b)</span><br><span class="line">    <span class="keyword">this</span>.z = c</span><br><span class="line">  &#125;</span><br><span class="line">  gXYZ () &#123;</span><br><span class="line">    <span class="comment">// super具体指Foo.prototype</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.gXYZ() * <span class="keyword">this</span>.z</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Bar(<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(b.x) <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(b.y) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b.z) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(b.gXYZ()) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt; 类机制核心-关键字-class表示一个块-定义一个函数原型的成员。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ES6中增加了语法糖extends和super。extends 用来在两个函数原型之间建立[[Prototype]]委托链接，即所谓的“原型继承”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g27686ym7rj20e609gdhr.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day95-join(..)简单实现</title>
    <link href="http://lmislm.com/2019/04/17/2019-04-17/"/>
    <id>http://lmislm.com/2019/04/17/2019-04-17/</id>
    <published>2019-04-16T16:00:00.000Z</published>
    <updated>2019-04-17T14:05:38.703Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>实现简单的join()方法。</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g25zd2ejs2j20e609gabf.jpg" alt=""><br><a id="more"></a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fakeJoin(arr, connector)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fakeJoin</span>(<span class="params">arr, connector</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">''</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      str += connector</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      str += arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(fakeJoin(a, <span class="string">'-'</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;实现简单的join()方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g25zd2ejs2j20e609gabf.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day94-寄生组合式继承</title>
    <link href="http://lmislm.com/2019/04/16/2019-04-16/"/>
    <id>http://lmislm.com/2019/04/16/2019-04-16/</id>
    <published>2019-04-15T16:00:00.000Z</published>
    <updated>2019-04-16T15:44:22.963Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>组合式继承存在一定的局限性，即为了得到一个副本，去指定子类型的原型而调用超类型的构造函数。可以通过借用构造函数来继承属性，通过原型链混成形式来继承方法。不用为了指定子类型的原型而调用超类型的构造函数,再将结果指定给子类型的原型。<strong>本质上</strong>就是用寄生式组合继承来继承超类型的原型，然后将结果指定给子类型的原型。</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g24wgmkmxdj20dw0b4wfi.jpg" alt=""><br>Photo by Jenny Caywood on Unsplash<br><a id="more"></a></p><h3 id="简单形式"><a href="#简单形式" class="headerlink" title="简单形式"></a>简单形式</h3><p>简单的寄生式组合继承组合形式。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span> (<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建对象，创建超类型副本</span></span><br><span class="line">  <span class="keyword">let</span> prototype = object(superType.prototype)</span><br><span class="line">  <span class="comment">// 增强对象，添加属性constructor,弥补因重写类型失去默认的constructor属性</span></span><br><span class="line">  prototype.constructor = subType</span><br><span class="line">  <span class="comment">// 指定对象，将新创建的对象赋值给子类型的原型</span></span><br><span class="line">  subType.prototype = prototype</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>替换为子类型原型赋值的语句（例子详情参考组合继承）<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>]</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name)</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SubType.prototype = new SuperType()</span></span><br><span class="line"><span class="comment">// SubType.prototype.constructor = SubType</span></span><br><span class="line"><span class="comment">// SubType.prototype.sayAge = function () &#123;</span></span><br><span class="line"><span class="comment">//   console.log(this.age)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 替换</span></span><br><span class="line">inheritPrototype(SubType, SuperType)</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;组合式继承存在一定的局限性，即为了得到一个副本，去指定子类型的原型而调用超类型的构造函数。可以通过借用构造函数来继承属性，通过原型链混成形式来继承方法。不用为了指定子类型的原型而调用超类型的构造函数,再将结果指定给子类型的原型。&lt;strong&gt;本质上&lt;/strong&gt;就是用寄生式组合继承来继承超类型的原型，然后将结果指定给子类型的原型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g24wgmkmxdj20dw0b4wfi.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;Photo by Jenny Caywood on Unsplash&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day93-组合继承</title>
    <link href="http://lmislm.com/2019/04/15/2019-04-15/"/>
    <id>http://lmislm.com/2019/04/15/2019-04-15/</id>
    <published>2019-04-14T16:00:00.000Z</published>
    <updated>2019-04-15T15:16:51.757Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>原型链虽然很强大，但是实现继承还是存在一些问题的。比如引用类型值问题。当然这个问题的解决也有一些，如用apply()，call()，或是借用构造函数。</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g23q72mg6dj20dw0aft8y.jpg" alt=""><br><a id="more"></a></p><h3 id="apply-call"><a href="#apply-call" class="headerlink" title="apply() call()"></a>apply() call()</h3><blockquote><p>解决原型中包含引用类型值所带来问题的过程中。可以借用构造函数。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --即在子类型构造函数的内部调用超类型构造函数。</span></span><br><span class="line"><span class="comment">// --也可以用apply()和call()方法在新创建的对象上执行构造函数。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>] </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 继承了SuperType,解决饮用类型值问题</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直接继承的写法，会导致引用类型值问题</span></span><br><span class="line"><span class="comment">// SubType.prototype = new SuperType()</span></span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubType()</span><br><span class="line">instance1.colors.push(<span class="string">'black'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors)</span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubType()</span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors)</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><blockquote><p>组合继承<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'black'</span>]</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name)</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType()</span><br><span class="line">SubType.prototype.constructor = SubType()</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance11 = <span class="keyword">new</span> SubType(<span class="string">'zhangsan'</span>, <span class="number">12</span>)</span><br><span class="line"><span class="comment">// 继承了SuperType()</span></span><br><span class="line">instance11.colors.push(<span class="string">'black'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance11.colors) <span class="comment">// 'red, blue, black'</span></span><br><span class="line">instance11.sayName() <span class="comment">// 'zhangsan'</span></span><br><span class="line">instance11.sayAge() <span class="comment">// 12</span></span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;原型链虽然很强大，但是实现继承还是存在一些问题的。比如引用类型值问题。当然这个问题的解决也有一些，如用apply()，call()，或是借用构造函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g23q72mg6dj20dw0aft8y.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day92-promise单一值传递（局限性）</title>
    <link href="http://lmislm.com/2019/04/13/2019-04-13/"/>
    <id>http://lmislm.com/2019/04/13/2019-04-13/</id>
    <published>2019-04-12T16:00:00.000Z</published>
    <updated>2019-04-13T15:59:15.517Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>promise只能是一个完成值和一个拒绝理由。但是这造成了现状只能是构造一个值封装来保存多个信息。</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g21g6gy76bj20dw0983ym.jpg" alt=""><br>Photo by Min Wu on Unsplash<br><a id="more"></a></p><h3 id="Promise的分裂值"><a href="#Promise的分裂值" class="headerlink" title="Promise的分裂值"></a>Promise的分裂值</h3><p>异步产生的两个值，封装到一个数组值中通过promise传输<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getY</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve((<span class="number">3</span>*x) - <span class="number">1</span>)</span><br><span class="line">    &#125;, <span class="number">100</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">bar, baz</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = bar * baz</span><br><span class="line">  <span class="keyword">return</span> getY(x)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 把两个值封装在容器中</span></span><br><span class="line">    <span class="keyword">return</span> [x, y]</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">foo (<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = msgs[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> y = msgs[<span class="number">1</span>]</span><br><span class="line">  <span class="built_in">console</span>.log(x, y) <span class="comment">// 200 599</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h3 id="展开-传递参数"><a href="#展开-传递参数" class="headerlink" title="展开/传递参数"></a>展开/传递参数</h3><p>利用apply.bind的技巧。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spread</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Function</span>.apply.bind(fn, <span class="literal">null</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.all(foo(<span class="number">10</span>, <span class="number">20</span>))</span><br><span class="line">.then(spread(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y) <span class="comment">// 200 599</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></p><h3 id="数组解构赋值ES6"><a href="#数组解构赋值ES6" class="headerlink" title="数组解构赋值ES6"></a>数组解构赋值ES6</h3><p>这个比上面的都更加的灵活。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all(foo(<span class="number">10</span>, <span class="number">20</span>))</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">msgs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [x,y] = msgs</span><br><span class="line">  <span class="built_in">console</span>.log(x, y) <span class="comment">// 200 599</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>更好的。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all(foo(<span class="number">10</span>, <span class="number">20</span>))</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">[x,y]</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x,y) <span class="comment">// 200 599</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;promise只能是一个完成值和一个拒绝理由。但是这造成了现状只能是构造一个值封装来保存多个信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g21g6gy76bj20dw0983ym.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;Photo by Min Wu on Unsplash&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day91-Promise的并发迭代</title>
    <link href="http://lmislm.com/2019/04/12/2019-04-12/"/>
    <id>http://lmislm.com/2019/04/12/2019-04-12/</id>
    <published>2019-04-11T16:00:00.000Z</published>
    <updated>2019-04-12T16:04:23.939Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>多任务执行。对所有Promise执行某个任务。</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g20ag1vta1j20dw0a9gmb.jpg" alt=""><br><a id="more"></a></p><h3 id="实现版本一"><a href="#实现版本一" class="headerlink" title="实现版本一"></a>实现版本一</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Promise 的并发迭代</span></span><br><span class="line"><span class="comment">// 不太好的方法</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">Promise</span>.map) &#123;</span><br><span class="line">  <span class="built_in">Promise</span>.map = <span class="function"><span class="keyword">function</span> (<span class="params">vals, cb</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 一个等待所有map的promise的新promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">      <span class="comment">// 一般数组把map(..),把值数组转换成为promise数组</span></span><br><span class="line">      vals.map(<span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 用val异步map之后决议的新promise替换val</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">          cb(val, resolve)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里不能发送异步reject信号，映射的回调中(cb(..))出现同步的异常或错误</span></span><br><span class="line"><span class="comment">// 主Promise.map(..)返回的Promise就会拒绝</span></span><br></pre></td></tr></table></figure><h3 id="较好的方法"><a href="#较好的方法" class="headerlink" title="较好的方法"></a>较好的方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 较好的方法</span></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">21</span>)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>)</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="built_in">Promise</span>.resolve(<span class="string">'oops 404'</span>)</span><br><span class="line"><span class="comment">// 列表值加倍，即使是在Promise中</span></span><br><span class="line"><span class="built_in">Promise</span>.map([p1,p2,p3], <span class="function"><span class="keyword">function</span> (<span class="params">pr, done</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 保证这一条本身就是Promise</span></span><br><span class="line">  <span class="built_in">Promise</span>.resolve(pr)</span><br><span class="line">    .then(</span><br><span class="line">      <span class="comment">// 提取值作为v</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// map完成的v到新值</span></span><br><span class="line">        done(v*<span class="number">2</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 或者map到promise拒绝消息</span></span><br><span class="line">      done</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">vals</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(vals) <span class="comment">// [42, 84, 'oops 404]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;多任务执行。对所有Promise执行某个任务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g20ag1vta1j20dw0a9gmb.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day90-支持Promise的Generator Run</title>
    <link href="http://lmislm.com/2019/04/11/2019-04-11/"/>
    <id>http://lmislm.com/2019/04/11/2019-04-11/</id>
    <published>2019-04-10T16:00:00.000Z</published>
    <updated>2019-04-11T15:46:50.161Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>专门处理。生成器yield出Promise，然后其控制生成器的迭代器来执行它，直到结束。</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g1z4l15uxpj20dw099t96.jpg" alt=""><br>Photo by Johannes Krupinski on Unsplash<br><a id="more"></a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params">gen</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>), it</span><br><span class="line">  <span class="comment">// 在当前上下文初始化生成器</span></span><br><span class="line">  it = gen.apply(<span class="keyword">this</span>, args)</span><br><span class="line">  <span class="comment">// 返回一个promise用于生成器完成</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> <span class="title">handleNext</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 对下一个yield出的值运行</span></span><br><span class="line">      <span class="keyword">let</span> next = it.next(value)</span><br><span class="line">      <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span> <span class="title">handleResult</span>(<span class="params">next</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 生成器运行完毕了吗</span></span><br><span class="line">        <span class="keyword">if</span> (next.done) &#123;</span><br><span class="line">          <span class="keyword">return</span> next.value</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//否则继续运行</span></span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(next.value)</span><br><span class="line">            .then(</span><br><span class="line">              <span class="comment">// 成功就恢复异步循环，把决议的值发回生成器</span></span><br><span class="line">              handleNext,</span><br><span class="line">              <span class="comment">// 如果value是被拒绝的promise</span></span><br><span class="line">              <span class="comment">// 就把错误传回生成器进行出错处理</span></span><br><span class="line">              <span class="function"><span class="keyword">function</span> <span class="title">handleErr</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(</span><br><span class="line">                  it.throw(err)</span><br><span class="line">                )</span><br><span class="line">                .then(handleResult)</span><br><span class="line">              &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)(next)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line">run(main)<span class="comment">// 自动异步运行你传给它的生成器</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;专门处理。生成器yield出Promise，然后其控制生成器的迭代器来执行它，直到结束。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g1z4l15uxpj20dw099t96.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;Photo by Johannes Krupinski on Unsplash&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day89-回调未调用（Promise）</title>
    <link href="http://lmislm.com/2019/04/10/2019-04-10/"/>
    <id>http://lmislm.com/2019/04/10/2019-04-10/</id>
    <published>2019-04-09T16:00:00.000Z</published>
    <updated>2019-04-10T15:29:05.640Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>回调函数本身包含JavaScript错误，Promise本身永远不被决议。怎么办？</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614ly1g1xxm4ej1tj20dw099q3d.jpg" alt=""></p><a id="more"></a><h3 id="竞态-高级抽象机制"><a href="#竞态-高级抽象机制" class="headerlink" title="竞态(高级抽象机制)"></a><em>竞态</em>(高级抽象机制)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于超时一个Promise的工具</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeoutPromise</span> (<span class="params">delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      reject(<span class="string">'timeout!'</span>)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置foo()超时</span></span><br><span class="line"><span class="built_in">Promise</span>.race([</span><br><span class="line">  foo(),</span><br><span class="line">  timeoutPromise(<span class="number">3000</span>)</span><br><span class="line">])</span><br><span class="line">.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// foo(..)及时完成</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 或者foo()被拒绝，只是没能按时完成</span></span><br><span class="line">    <span class="comment">// 查看err来了解是哪种情况</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;回调函数本身包含JavaScript错误，Promise本身永远不被决议。怎么办？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614ly1g1xxm4ej1tj20dw099q3d.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day88-异步迭代生成器</title>
    <link href="http://lmislm.com/2019/04/09/2019-04-09/"/>
    <id>http://lmislm.com/2019/04/09/2019-04-09/</id>
    <published>2019-04-08T16:00:00.000Z</published>
    <updated>2019-04-09T15:29:45.065Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文展示一个任务流程控制，通过生成器来解决解决回调问题。</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g1wsurf0htj20dw09ajru.jpg" alt=""><br>Photo by Dan Magatti on Unsplash</p><h3 id="回调方法"><a href="#回调方法" class="headerlink" title="回调方法"></a>回调方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y, cb</span>) </span>&#123;</span><br><span class="line">  ajax(</span><br><span class="line">    <span class="string">'http://some.url.1'</span>,</span><br><span class="line">    cb</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">foo (<span class="number">11</span>, <span class="number">32</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(text)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="生成器方法实现"><a href="#生成器方法实现" class="headerlink" title="生成器方法实现"></a>生成器方法实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过生成器来表达同样的任务流程控制</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  ajax(</span><br><span class="line">    <span class="string">'http://some.url.1'</span>,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">err, next</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 向*main()抛出一个错误</span></span><br><span class="line">        it.throw(err)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 响应数据恢复生成器</span></span><br><span class="line">        it.next(data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 重要的部分。调用一个普通函数foo(..),且能从ajax调用中得到text,即使函数是异步。</span></span><br><span class="line">    <span class="keyword">let</span> text = <span class="keyword">yield</span> foo(<span class="number">11</span>, <span class="number">31</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(text)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = main()</span><br><span class="line"><span class="comment">// 启动！</span></span><br><span class="line">it.next()</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文展示一个任务流程控制，通过生成器来解决解决回调问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g1wsurf0htj20dw09ajru.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;Photo by Dan Magatti on Unsplash&lt;/p&gt;
&lt;h3 id=&quot;回调方法&quot;&gt;&lt;a href=&quot;#回调方法&quot; class=&quot;headerlink&quot; title=&quot;回调方法&quot;&gt;&lt;/a&gt;回调方法&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x, y, cb&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ajax(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;http://some.url.1&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo (&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;err, next&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (err) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.error(err)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(text)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;生成器方法实现&quot;&gt;&lt;a href=&quot;#生成器方法实现&quot; class=&quot;headerlink&quot; title=&quot;生成器方法实现&quot;&gt;&lt;/a&gt;生成器方法实现&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 通过生成器来表达同样的任务流程控制&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x, y&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ajax(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;http://some.url.1&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;err, next&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (err) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 向*main()抛出一个错误&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        it.throw(err)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	  &lt;span class=&quot;comment&quot;&gt;// 响应数据恢复生成器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        it.next(data)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; *&lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 重要的部分。调用一个普通函数foo(..),且能从ajax调用中得到text,即使函数是异步。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; text = &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; foo(&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;31&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(text)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (err) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.error(err)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; it = main()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 启动！&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;it.next()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day87-生成器迭代器</title>
    <link href="http://lmislm.com/2019/04/08/2019-04-08/"/>
    <id>http://lmislm.com/2019/04/08/2019-04-08/</id>
    <published>2019-04-07T16:00:00.000Z</published>
    <updated>2019-04-08T15:24:07.187Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>生成器实现day86中的something无限数字序列生产者</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g1vn1giw3bj20dw099glw.jpg" alt="Photo by Paulin Malet on Unsplash"><br>Photo by Paulin Malet on Unsplash</p><a id="more"></a><h3 id="实现生产者"><a href="#实现生产者" class="headerlink" title="实现生产者"></a>实现生产者</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">something</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> nextVal</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextVal === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      nextVal = <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nextVal = (<span class="number">3</span> * nextVal) + <span class="number">6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成器在每次迭代中暂停.</span></span><br><span class="line">    <span class="comment">// 通过yield返回到主程序或事件循环队列中。</span></span><br><span class="line">    <span class="comment">// --函数*something()的作用域会被保持（即不需要闭包在调用直接保持变量作用域）</span></span><br><span class="line">    <span class="keyword">yield</span> nextVal</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>for…of循环使用*something()生成器</p><blockquote><p><strong>注意</strong>这里是something()而不是something。因为这里something是生成器不是迭代器。<br>something()调用产生一个迭代器，但是for…of需要一个<strong>iterable</strong>（可迭代：一个包含在其值上迭代的迭代器的对象）。<br>这是因为生成器的迭代器也有一个Symbol.iterator函数,而这个函数做的就是return this,<br>和之前迭代器里定义的iterable something一样，即生成器的迭代器也是一个iterable（可迭代）。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> something()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v)</span><br><span class="line">  <span class="comment">// 不要死循环</span></span><br><span class="line">  <span class="keyword">if</span> (v &gt; <span class="number">500</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 9 33 105 321 969</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;生成器实现day86中的something无限数字序列生产者&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g1vn1giw3bj20dw099glw.jpg&quot; alt=&quot;Photo by Paulin Malet on Unsplash&quot;&gt;&lt;br&gt;Photo by Paulin Malet on Unsplash&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
