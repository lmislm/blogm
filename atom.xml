<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LMISLMのBlog</title>
  
  <subtitle>不积小流，无以成江海。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lmislm.com/"/>
  <updated>2019-06-13T15:01:52.366Z</updated>
  <id>http://lmislm.com/</id>
  
  <author>
    <name>lmislm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>day151-LeetCode 141. Linked List Cycle</title>
    <link href="http://lmislm.com/2019/06/13/2019-06-13/"/>
    <id>http://lmislm.com/2019/06/13/2019-06-13/</id>
    <published>2019-06-12T16:00:00.000Z</published>
    <updated>2019-06-13T15:01:52.366Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a linked list, determine if it has a cycle in it.<br>Follow up: Can you solve it without using extra space?<br><a id="more"></a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>求链表中是否有个循环</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasCycle</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head === <span class="literal">null</span> || head.next === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> node = head</span><br><span class="line">  <span class="keyword">while</span> (node !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.flag) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 标记节点每一个跑过的节点</span></span><br><span class="line">    node.flag = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 跑到下一个节点</span></span><br><span class="line">    node = node.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快慢链表"><a href="#快慢链表" class="headerlink" title="快慢链表"></a>快慢链表</h3><blockquote><p>两者步长不一样</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">  ListNode slow = head, fast = head;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next.next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (slow == fast) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given a linked list, determine if it has a cycle in it.&lt;br&gt;Follow up: Can you solve it without using extra space?&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day150-LeetCode 83. Remove Duplicates from Sorted List</title>
    <link href="http://lmislm.com/2019/06/12/2019-06-12/"/>
    <id>http://lmislm.com/2019/06/12/2019-06-12/</id>
    <published>2019-06-11T16:00:00.000Z</published>
    <updated>2019-06-12T15:28:34.210Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a sorted linked list, delete all duplicates such that each element appear only once.<br>For example,<br>Given 1-&gt;1-&gt;2, return 1-&gt;2.<br>Given 1-&gt;1-&gt;2-&gt;3-&gt;3, return 1-&gt;2-&gt;3.<br><a id="more"></a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>题目意思是移除一个有序单链表中重复的节点，根据单链表的特点next指针，可以判断相邻连续的节点是否相等。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteDuplicates</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head === <span class="literal">null</span> || head.next === <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">let</span> cur = head</span><br><span class="line">  <span class="keyword">while</span>(cur.next !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 相邻连续节点是否相等</span></span><br><span class="line">    <span class="keyword">if</span> (cur.val === cur.next.val) &#123;</span><br><span class="line">      cur.next = cur.next.next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cur = cur.next</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given a sorted linked list, delete all duplicates such that each element appear only once.&lt;br&gt;For example,&lt;br&gt;Given 1-&amp;gt;1-&amp;gt;2, return 1-&amp;gt;2.&lt;br&gt;Given 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3, return 1-&amp;gt;2-&amp;gt;3.&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day149-LeetCode 237. Delete Node in a Linked List</title>
    <link href="http://lmislm.com/2019/06/11/2019-06-11/"/>
    <id>http://lmislm.com/2019/06/11/2019-06-11/</id>
    <published>2019-06-10T16:00:00.000Z</published>
    <updated>2019-06-11T15:26:43.105Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p><p>Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function.<br><a id="more"></a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>将指定单链表中的next指针指向下一个节点value就行</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; node</span></span><br><span class="line"><span class="comment"> * @return &#123;void&#125; Do not return anything, modify node in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> deleteNode = <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    node.val = node.next.val</span><br><span class="line">    node.next = node.next.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.&lt;/p&gt;
&lt;p&gt;Supposed the linked list is 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 and you are given the third node with value 3, the linked list should become 1 -&amp;gt; 2 -&amp;gt; 4 after calling your function.&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day148-LeetCode 257. Binary Tree Paths</title>
    <link href="http://lmislm.com/2019/06/10/2019-06-10/"/>
    <id>http://lmislm.com/2019/06/10/2019-06-10/</id>
    <published>2019-06-09T16:00:00.000Z</published>
    <updated>2019-06-11T15:25:08.444Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree, return all root-to-leaf paths.<br>For example, given the following binary tree:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2   3</span><br><span class="line"> \</span><br><span class="line">  5</span><br></pre></td></tr></table></figure><p>All root-to-leaf paths are: [“1-&gt;2-&gt;5”, “1-&gt;3”]<br><a id="more"></a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>和找深度的二叉树那个类似，这里是把找到的路径记录下来<br>从root节点开始走，一直到最后的节点没有左右节点，就是一条路径</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findTreePath</span> (<span class="params">nodes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!nodes) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 存储记录的路径</span></span><br><span class="line">    <span class="keyword">let</span> treePathList = []</span><br><span class="line">    findPath(root, <span class="string">''</span>)</span><br><span class="line">    <span class="keyword">return</span> treePathList</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">findPath</span> (<span class="params">node, str</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.left === <span class="literal">null</span> &amp;&amp; node.right === <span class="literal">null</span>) &#123;</span><br><span class="line">            treePathList.push(str, node.val)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.left !== <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 累加路径</span></span><br><span class="line">                findPath(node.left, str + node.val + <span class="string">'-&gt;'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right !== <span class="literal">null</span>) &#123;</span><br><span class="line">                findPath(node.right, str + node.val + <span class="string">'-&gt;'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given a binary tree, return all root-to-leaf paths.&lt;br&gt;For example, given the following binary tree:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;  1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2   3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;All root-to-leaf paths are: [“1-&amp;gt;2-&amp;gt;5”, “1-&amp;gt;3”]&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day147-LeetCode 349. Intersection of Two Arrays</title>
    <link href="http://lmislm.com/2019/06/09/2019-06-09/"/>
    <id>http://lmislm.com/2019/06/09/2019-06-09/</id>
    <published>2019-06-08T16:00:00.000Z</published>
    <updated>2019-06-11T15:25:02.964Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given two arrays, write a function to compute their intersection.</p><p>Example:</p><p>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].</p><p>Note:</p><p>Each element in the result must be unique.</p><p>The result can be in any order.</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>选较短的数组去和长数组比较；<br>短数组值依次遍历长数组；<br>找短数组中有相应的值；</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">intersection</span> (<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">let</span> longArr</span><br><span class="line">    <span class="keyword">let</span> shortArr</span><br><span class="line">    <span class="keyword">if</span> (arr1.length &gt; arr2.length) &#123;</span><br><span class="line">        longArr = arr1</span><br><span class="line">        shortArr = arr2</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shortArr = arr1</span><br><span class="line">        longArr = arr2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; shortArr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = shortArr[i]</span><br><span class="line">        <span class="comment">// 如果longArr中有shortArr的值，而且在交集数组中没有，则为新交集</span></span><br><span class="line">        <span class="keyword">if</span>(longArr.indexOf(value) &gt;= <span class="number">0</span> &amp;&amp; result.indexOf(value) === <span class="number">-1</span>) &#123;</span><br><span class="line">            result.push(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实es6可以用很快的方法解决</span></span><br><span class="line"><span class="keyword">let</span> intersection = arr1.filter(<span class="function"><span class="params">x</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Set</span>(arr2).has(x))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given two arrays, write a function to compute their intersection.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;p&gt;Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].&lt;/p&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;p&gt;Each element in the result must be unique.&lt;/p&gt;
&lt;p&gt;The result can be in any order.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day146-LeetCode 283. Move Zeroes</title>
    <link href="http://lmislm.com/2019/06/08/2019-06-08/"/>
    <id>http://lmislm.com/2019/06/08/2019-06-08/</id>
    <published>2019-06-07T16:00:00.000Z</published>
    <updated>2019-06-08T15:03:34.109Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p><p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</p><p>Note:</p><p>You must do this in-place without making a copy of the array.<br>Minimize the total number of operations.</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>注意：只能是针对当前数组操作，不能是新增数组<br>将数组中遍历的非零元素依次递增标记，以0为初始值，最后将标记的值作为数组元素下标。<br>递增次数为非零元素个数，遍历完成之后，非零元素补零。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">moveZeros</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 标记所有非零元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// n为非零元素</span></span><br><span class="line">        <span class="keyword">let</span> n = arr[i]</span><br><span class="line">        <span class="keyword">if</span> (n !== <span class="number">0</span>) &#123;</span><br><span class="line">            arr[index++] = n</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非零元素之外的元素补零</span></span><br><span class="line">    <span class="keyword">for</span> (index; index &lt; arr.length; index++) &#123;</span><br><span class="line">        arr[index] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.&lt;/p&gt;
&lt;p&gt;For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].&lt;/p&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;p&gt;You must do this in-place without making a copy of the array.&lt;br&gt;Minimize the total number of operations.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day144-LeetCode 112. Path Sum</title>
    <link href="http://lmislm.com/2019/06/06/2019-06-06/"/>
    <id>http://lmislm.com/2019/06/06/2019-06-06/</id>
    <published>2019-06-05T16:00:00.000Z</published>
    <updated>2019-06-10T14:36:41.388Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.<br>For example: Given the below binary tree and sum = 22,<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      5</span><br><span class="line">    /  \</span><br><span class="line">   4    8</span><br><span class="line">  /    / \</span><br><span class="line"> 11   13  4</span><br><span class="line"> /     \   \</span><br><span class="line">7       2   1</span><br></pre></td></tr></table></figure></p><p>return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><strong>leetcode 104</strong>的变形。用递归来计算每条路径的总和。<br>求根节点到子树的每条可能路径的和，并检测是否和给出的随机数相等。</p><p>从父节点出发，如果父节点加左节点不等于给出的随机数，则回退父节点加右节点，<br>如果不相等且子节点有左右子树则递归上述过程。<br>直到找到和随机数相等的值返回true,否则返回false</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPathEqualSum</span> (<span class="params">root, sum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">let</span> list = []</span><br><span class="line">  <span class="comment">// 计算总和</span></span><br><span class="line">  sumR2L(root, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> sumR2L(root, <span class="number">0</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sumR2L</span>(<span class="params">root, s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root.left === <span class="literal">null</span> &amp;&amp; root.right === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 到底的时候，判断总和是否是与sum相同</span></span><br><span class="line">      list.push(s)</span><br><span class="line">      s += root.val</span><br><span class="line">      <span class="keyword">return</span> s === sum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右边到底</span></span><br><span class="line">    <span class="keyword">if</span> (root.left !== <span class="literal">null</span> &amp;&amp; root.right === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> sumR2L(root.left, s + root.val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左边到底</span></span><br><span class="line">    <span class="keyword">if</span> (root.left === <span class="literal">null</span> &amp;&amp; root.right !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> sumR2L(root.right, s + root.val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 两边的树没有到底</span></span><br><span class="line">    <span class="keyword">return</span> sumR2L(root.left, s + root.val) || sumR2L(root.right, s + root.val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.&lt;br&gt;For example: Given the below binary tree and sum = 22,&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day145-LeetCode 121. Best Time to Buy and Sell Stock</title>
    <link href="http://lmislm.com/2019/06/06/2019-06-07/"/>
    <id>http://lmislm.com/2019/06/06/2019-06-07/</id>
    <published>2019-06-05T16:00:00.000Z</published>
    <updated>2019-06-08T15:03:20.915Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Say you have an array for which the ith element is the price of a given stock on day i.</p><p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p><p>Example 1: Input: [7, 1, 5, 3, 6, 4]</p><p>Output: 5</p><p>max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)</p><p>Example 2: Input: [7, 6, 4, 3, 1]</p><p>Output: 0</p><p>In this case, no transaction is done, i.e. max profit = 0.</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>数组中的元素，从index 0 到最后一位，都表示每天的股价变化。求给出的数组中，利益最大的一天。即，从后往前相减，整数最大的值</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxProfit</span> (<span class="params">prices</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 表示最低的股价，MAX_表示无限大</span></span><br><span class="line">    <span class="keyword">let</span> min = <span class="built_in">Number</span>.MAX_SAFE_INTEGER</span><br><span class="line">    <span class="keyword">let</span> maxProfit = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 冒泡找出最小值</span></span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; min) &#123;</span><br><span class="line">            min = prices[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前可获利的值</span></span><br><span class="line">        <span class="keyword">let</span> calProfit = prices[i] - min</span><br><span class="line">        <span class="keyword">if</span>(calProfit &gt; maxProfit) &#123;</span><br><span class="line">            maxProfit = calProfit</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;
&lt;p&gt;If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.&lt;/p&gt;
&lt;p&gt;Example 1: Input: [7, 1, 5, 3, 6, 4]&lt;/p&gt;
&lt;p&gt;Output: 5&lt;/p&gt;
&lt;p&gt;max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)&lt;/p&gt;
&lt;p&gt;Example 2: Input: [7, 6, 4, 3, 1]&lt;/p&gt;
&lt;p&gt;Output: 0&lt;/p&gt;
&lt;p&gt;In this case, no transaction is done, i.e. max profit = 0.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day143-LeetCode 70. Climbing Stairs</title>
    <link href="http://lmislm.com/2019/06/04/2019-06-04/"/>
    <id>http://lmislm.com/2019/06/04/2019-06-04/</id>
    <published>2019-06-03T16:00:00.000Z</published>
    <updated>2019-06-07T14:17:01.874Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>You are climbing a stair case. It takes n steps to reach to the top.<br>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这种从无穷之中找规律的题目，难免会想到动态规划，所以可以先分情况来~</p><p>n为阶梯数，p表示方法种类<br>n = 1; p = 1<br>n = 2; p = 1+1<br>n = 3; p = 1+2<br>n = 4; p = 3+2<br>规律，斐波那契数列f(n) = f(n-1) + f(n-2)</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">climbStairs</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> prev = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> cur = <span class="number">1</span></span><br><span class="line">  <span class="comment">// f(n) = f(n -1) + f(n -2)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = cur</span><br><span class="line">    cur = cur + prev</span><br><span class="line">    prev = temp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cur</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;You are climbing a stair case. It takes n steps to reach to the top.&lt;br&gt;Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day142-LeetCode 171. Excel Sheet Column Number</title>
    <link href="http://lmislm.com/2019/06/03/2019-06-03/"/>
    <id>http://lmislm.com/2019/06/03/2019-06-03/</id>
    <published>2019-06-02T16:00:00.000Z</published>
    <updated>2019-06-03T15:32:01.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Related to question Excel Sheet Column Title<br>Given a column title as appear in an Excel sheet, return its corresponding column number.</p><a id="more"></a><p>For example:<br>A -&gt; 1<br>B -&gt; 2<br>C -&gt; 3<br>…<br>Z -&gt; 26<br>AA -&gt; 27<br>AB -&gt; 28 </p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>总共26个字母，所以这个也可以算是26进制。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">titleToNumber</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> exp = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = s.length <span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="comment">// 转成数字</span></span><br><span class="line">      <span class="keyword">let</span> v = s.charCodeAt(i) - <span class="number">64</span></span><br><span class="line">      <span class="comment">// 毎多一个代表26的n次方</span></span><br><span class="line">      v = v * <span class="built_in">Math</span>.pow(<span class="number">26</span>,exp++)</span><br><span class="line">      sum += v</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Related to question Excel Sheet Column Title&lt;br&gt;Given a column title as appear in an Excel sheet, return its corresponding column number.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day141-LeetCode 110. Balanced Binary Tree</title>
    <link href="http://lmislm.com/2019/06/02/2019-06-02/"/>
    <id>http://lmislm.com/2019/06/02/2019-06-02/</id>
    <published>2019-06-01T16:00:00.000Z</published>
    <updated>2019-06-02T06:56:33.472Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree, determine if it is height-balanced.<br>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>求左右子树的最大深度<br>即：左右子树的高度差为0</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBalanceTree</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span> || (root.left === <span class="literal">null</span> &amp;&amp; root.right === <span class="literal">null</span>)) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">// 分别找出左右子树深度</span></span><br><span class="line">  <span class="keyword">let</span> deepLeft = findDeepth (root.left)</span><br><span class="line">  <span class="keyword">let</span> deepRight = findDeepth (root.right)</span><br><span class="line">  <span class="comment">// 是否是平衡树</span></span><br><span class="line">  <span class="keyword">let</span> isBalance = <span class="built_in">Math</span>.abs(deepLeft - deepRight) &lt; <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> isBalance &amp;&amp; isBalanceTree(root.left) &amp;&amp; isBalanceTree(root.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findDeepth</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> deepLeftDeepth = findDeepth(root.left) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> deepRightDeepth = findDeepth(root.right) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> deepLeftDeepth &gt; deepRightDeepth ? deepLeftDeepth : deepRightDeepth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given a binary tree, determine if it is height-balanced.&lt;br&gt;For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day140-LeetCode 206. Reverse Linked List</title>
    <link href="http://lmislm.com/2019/06/01/2019-06-01/"/>
    <id>http://lmislm.com/2019/06/01/2019-06-01/</id>
    <published>2019-05-31T16:00:00.000Z</published>
    <updated>2019-06-01T15:48:00.693Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Reverse a singly linked list.<br>{ val:1, next: {val:2, next:null} } }<br>{ val:2, next: {val:1, next:null} } }</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>链表反转</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseList</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!head.next) &#123;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> prev = head</span><br><span class="line">  <span class="keyword">let</span> cur  = head.next</span><br><span class="line">  prev.next = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">while</span> (cur !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = cur</span><br><span class="line">    <span class="comment">// 当前node指向下一个，不然会被后面操作影响</span></span><br><span class="line">    cur = cur.next</span><br><span class="line">    <span class="comment">// 只需要当前node的值，不需要他的next，temp.next = null</span></span><br><span class="line">    <span class="comment">// 之前的linked list加到当前node后面， temp.next = prev</span></span><br><span class="line">    temp.next = prev </span><br><span class="line">    prev = temp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Reverse a singly linked list.&lt;br&gt;{ val:1, next: {val:2, next:null} } }&lt;br&gt;{ val:2, next: {val:1, next:null} } }&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day139-LeetCode 101. Symmetric Tree</title>
    <link href="http://lmislm.com/2019/05/31/2019-05-31/"/>
    <id>http://lmislm.com/2019/05/31/2019-05-31/</id>
    <published>2019-05-30T16:00:00.000Z</published>
    <updated>2019-05-31T14:44:38.015Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p><p>For example, this binary tree [1,2,2,3,4,4,3] is symmetric: But the following [1,2,2,null,3,null,3] is not<br>      1<br>    /   \<br>   2     2<br>  / \   / \<br>3   4 4   3<br>把左子树反转就是右子树</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这题是反转二叉树和比较二叉树相同的结合</p><ol><li>先反转二叉树</li><li>比较反转后的二叉树是否相等</li></ol><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSymmetricTree</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span> || root.right ===  <span class="literal">null</span> || root.left === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 反转</span></span><br><span class="line">  root.left = revertTree(root.right)</span><br><span class="line">  <span class="keyword">return</span> isSameTree(root.left, root.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">revertTree</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(node == <span class="literal">null</span> || node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> temp = revertTree(node.left)</span><br><span class="line">  node.left = revertTree(node.right)</span><br><span class="line">  node.right = temp</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSameTree</span> (<span class="params">leftNode, rightNode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 空节点，递归结束</span></span><br><span class="line">  <span class="keyword">if</span> (leftNode === <span class="literal">null</span> || rightNode === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 左右子树有一个为空</span></span><br><span class="line">  <span class="keyword">if</span> (leftNode === <span class="literal">null</span> &amp;&amp; rightNode !== <span class="literal">null</span> || leftNode !== <span class="literal">null</span> &amp;&amp; rightNode === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断非空节点是否相等</span></span><br><span class="line">  <span class="keyword">if</span> (leftNode !== rightNode) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 递归</span></span><br><span class="line">  <span class="keyword">return</span> isSameTree(leftNode.right, rightNode.right) &amp;&amp; isSameTree(leftNode.left, rightNode.left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).&lt;/p&gt;
&lt;p&gt;For example, this binary tree [1,2,2,3,4,4,3] is symmetric: But the following [1,2,2,null,3,null,3] is not&lt;br&gt;      1&lt;br&gt;    /   \&lt;br&gt;   2     2&lt;br&gt;  / \   / \&lt;br&gt;3   4 4   3&lt;br&gt;把左子树反转就是右子树&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day138-LeetCode 235. Lowest Common Ancestor of a Binary Search</title>
    <link href="http://lmislm.com/2019/05/30/2019-05-30/"/>
    <id>http://lmislm.com/2019/05/30/2019-05-30/</id>
    <published>2019-05-29T16:00:00.000Z</published>
    <updated>2019-05-30T15:56:35.240Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>LeetCode 235. Lowest Common Ancestor of a Binary Search<br>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.<br>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”<br>      _6_<br>    /    \<br>    2      8<br>   /  \    / \<br>  0   4  7   9<br> / \<br>3   5</p><p>For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. </p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>注意这颗是中序遍历的二叉树，左子树节点值小于根节点值小于右子树节点值。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lowestCommonAncestor</span> (<span class="params">root, p, q</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> value =  root.val</span><br><span class="line">    <span class="keyword">if</span>(p.val &gt;= value &amp;&amp; value &gt;= q.val || p.val &lt;= value &amp;&amp; value &lt;= q.val)&#123;</span><br><span class="line">      <span class="keyword">return</span> root</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p.val &gt; value &amp;&amp; q.val &gt; value)&#123;</span><br><span class="line">      root =  root.right</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      root =  root.left</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;LeetCode 235. Lowest Common Ancestor of a Binary Search&lt;br&gt;Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.&lt;br&gt;According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”&lt;br&gt;      _6_&lt;br&gt;    /    \&lt;br&gt;    2      8&lt;br&gt;   /  \    / \&lt;br&gt;  0   4  7   9&lt;br&gt; / \&lt;br&gt;3   5&lt;/p&gt;
&lt;p&gt;For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. &lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day137-LeetCode 100. Same Tree</title>
    <link href="http://lmislm.com/2019/05/29/2019-05-29/"/>
    <id>http://lmislm.com/2019/05/29/2019-05-29/</id>
    <published>2019-05-28T16:00:00.000Z</published>
    <updated>2019-05-29T15:18:48.438Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given two binary trees, write a function to check if they are equal or not.<br>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.<br>判断两棵二叉树是否完全相等</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>用递归比较简单点。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line">isSameTree (p, q) &#123;</span><br><span class="line">  <span class="comment">// 左右子树终止条件</span></span><br><span class="line">  <span class="keyword">if</span>(p === <span class="literal">null</span> &amp;&amp; q === <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// one null, other is not null, false</span></span><br><span class="line">  <span class="keyword">if</span>(p !== <span class="literal">null</span> &amp;&amp; q === <span class="literal">null</span> || p === <span class="literal">null</span> &amp;&amp; q !== <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// val diff, false</span></span><br><span class="line">  <span class="keyword">if</span>(p.val !== q.val)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// find next level of tree</span></span><br><span class="line">  <span class="keyword">return</span> isSameTree(p.right, q.right) &amp;&amp; isSameTree(p.left, q.left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given two binary trees, write a function to check if they are equal or not.&lt;br&gt;Two binary trees are considered equal if they are structurally identical and the nodes have the same value.&lt;br&gt;判断两棵二叉树是否完全相等&lt;/p&gt;
&lt;h3 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h3&gt;&lt;p&gt;用递归比较简单点。&lt;/p&gt;
&lt;h3 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * Definition for a binary tree node.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * function TreeNode(val) &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     this.val = val;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     this.left = this.right = null;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 递归&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;isSameTree (p, q) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 左右子树终止条件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(p === &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; q === &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// one null, other is not null, false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(p !== &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; q === &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; || p === &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; q !== &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// val diff, false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(p.val !== q.val)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// find next level of tree&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; isSameTree(p.right, q.right) &amp;amp;&amp;amp; isSameTree(p.left, q.left)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day136-LeetCode 226. Invert Binary Tree</title>
    <link href="http://lmislm.com/2019/05/28/2019-05-28/"/>
    <id>http://lmislm.com/2019/05/28/2019-05-28/</id>
    <published>2019-05-27T16:00:00.000Z</published>
    <updated>2019-05-28T15:58:12.921Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Invert a binary tree.<br>反转二叉树<br>输入<br>     4<br>   /   \<br>  2     7<br> / \   / \<br>1   3 6   9<br>反转<br>     4<br>   /   \<br>  7     2<br> / \   / \<br>9  6 3   1</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>对树进行广度遍历，过程中左右节点进行交换，单节点则跳过。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invert</span> (<span class="params">treeNode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 单节点跳过</span></span><br><span class="line">  <span class="keyword">if</span>(treeNode === <span class="literal">null</span> || (treeNode.right === <span class="literal">null</span> &amp;&amp; treeNode.left === <span class="literal">null</span>))&#123;</span><br><span class="line">    <span class="keyword">return</span> treeNode</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 相互交换，并递归</span></span><br><span class="line">  <span class="keyword">let</span> temp = treeNode.left</span><br><span class="line">  treeNode.left = invertTree(treeNode.right)</span><br><span class="line">  treeNode.right = invertTree(temp)</span><br><span class="line">  <span class="keyword">return</span> treeNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Invert a binary tree.&lt;br&gt;反转二叉树&lt;br&gt;输入&lt;br&gt;     4&lt;br&gt;   /   \&lt;br&gt;  2     7&lt;br&gt; / \   / \&lt;br&gt;1   3 6   9&lt;br&gt;反转&lt;br&gt;     4&lt;br&gt;   /   \&lt;br&gt;  7     2&lt;br&gt; / \   / \&lt;br&gt;9  6 3   1&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day135-Maximum Depth of Binary Tree</title>
    <link href="http://lmislm.com/2019/05/27/2019-05-27/"/>
    <id>http://lmislm.com/2019/05/27/2019-05-27/</id>
    <published>2019-05-26T16:00:00.000Z</published>
    <updated>2019-05-27T14:11:33.754Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree, find its maximum depth.<br>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>就是判断二叉树的左右子树有没有值，有值的话就继续往下走。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binaryTreeMaxDepth</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> find (root)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">find</span> (<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断节点为空或者到底部，即没有左右子树</span></span><br><span class="line">    <span class="keyword">if</span>(node === <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> treeLeftDepth = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> treeRightDepth = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(node.left !== <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="comment">// 递归</span></span><br><span class="line">      treeLeftDepth += find(node.left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.right !== <span class="literal">null</span>)&#123;</span><br><span class="line">      treeRightDepth += find(node.right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较左右子树层数大小</span></span><br><span class="line">    <span class="keyword">return</span> treeLeftDepth &gt; treeRightDepth ?　treeLeftDepth : treeRightDepth</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given a binary tree, find its maximum depth.&lt;br&gt;The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day134-LeetCode 292. Nim Game</title>
    <link href="http://lmislm.com/2019/05/26/2019-05-26%E3%80%81/"/>
    <id>http://lmislm.com/2019/05/26/2019-05-26、/</id>
    <published>2019-05-25T16:00:00.000Z</published>
    <updated>2019-05-26T15:37:14.881Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>（动态规划）<br>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.<br>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.<br>For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>动态规划的话。先逐步分析。先分析可能的情况。</p><blockquote><p><code>剩下1-3个石头，我赢。</code><br><code>剩下4个石头，我先拿1-3个，输。</code><br><code>剩下5个石头，我先拿1个，然后剩下4个轮到他先，我赢。先拿2-3个的话，我输。</code><br><code>剩下6个石头，我先拿1个，回到上一步5个石头他先。我先拿两个，就是4个石头他先，他输。</code><br><code>剩下7个石头，我先拿1个，回到上一步6个石头他先拿，他拿两个的话就回到5个石头情况，他赢。我拿3个才能到状态4个石头他先拿，他输。</code><br>所以，我得想办法让他面前的石头数量到4个石头，这样有5-7个石头时我先拿的话都可以赢。<br>如果是8个石头,我先拿至少一个，剩下5-6个石头他先拿，只要他让我面前剩下4个，他就有优势，我都会输。</p></blockquote><p>4和8为倍数关系。归纳总结出初步结论，有可能是4的倍数的时候，我先拿就输。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">canFirstWinNimGame</span> (<span class="params">sum</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sum &lt; <span class="number">4</span>) &#123; <span class="comment">// 1-3的整数，先拿肯定赢</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n%<span class="number">4</span> !== <span class="number">0</span> <span class="comment">// 剩下的总数是4的倍数时，先拿肯定输</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;（动态规划）&lt;br&gt;You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.&lt;br&gt;Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.&lt;br&gt;For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day133-vuejs源码-template编译-笔记</title>
    <link href="http://lmislm.com/2019/05/25/2019-05-25/"/>
    <id>http://lmislm.com/2019/05/25/2019-05-25/</id>
    <published>2019-05-24T16:00:00.000Z</published>
    <updated>2019-05-25T15:29:40.736Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>包括$mount和render方法。</p><a id="more"></a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount</span><br><span class="line"><span class="comment">/*挂载组件*/</span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; query(el)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> options = <span class="keyword">this</span>.$options</span><br><span class="line">  <span class="comment">// resolve template/el and convert to render function</span></span><br><span class="line">  <span class="comment">/*优先使用render，不存在的时候编译template*/</span></span><br><span class="line">  <span class="keyword">if</span> (!options.render) &#123;</span><br><span class="line">    <span class="keyword">let</span> template = options.template</span><br><span class="line">    <span class="comment">/*template存在的时候取template，不存在的时候取el的outerHTML*/</span></span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="comment">/*当template是字符串的时候*/</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (template.charAt(<span class="number">0</span>) === <span class="string">'#'</span>) &#123;</span><br><span class="line">          template = idToTemplate(template)</span><br><span class="line">          <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">          <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !template) &#123;</span><br><span class="line">            warn(</span><br><span class="line">              <span class="string">`Template element not found or is empty: <span class="subst">$&#123;options.template&#125;</span>`</span>,</span><br><span class="line">              <span class="keyword">this</span></span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.nodeType) &#123;</span><br><span class="line">        <span class="comment">/*当template为DOM节点的时候*/</span></span><br><span class="line">        template = template.innerHTML</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*报错*/</span></span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">          warn(<span class="string">'invalid template option:'</span> + template, <span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">      <span class="comment">/*获取element的outerHTML*/</span></span><br><span class="line">      template = getOuterHTML(el)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(<span class="string">'compile'</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*将template编译成render函数，这里会有render以及staticRenderFns两个返回，这是vue的编译时优化，static静态不需要在VNode更新时进行patch，优化性能*/</span></span><br><span class="line">  <span class="comment">// ?</span></span><br><span class="line">      <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</span><br><span class="line">        shouldDecodeNewlines,</span><br><span class="line">        delimiters: options.delimiters</span><br><span class="line">      &#125;, <span class="keyword">this</span>)</span><br><span class="line">      options.render = render</span><br><span class="line">      options.staticRenderFns = staticRenderFns</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(<span class="string">'compile end'</span>)</span><br><span class="line">        measure(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>._name&#125;</span> compile`</span>, <span class="string">'compile'</span>, <span class="string">'compile end'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*Github:https://github.com/answershuto*/</span></span><br><span class="line">  <span class="comment">/*调用const mount = Vue.prototype.$mount保存下来的不带编译的mount*/</span></span><br><span class="line">  <span class="keyword">return</span> mount.call(<span class="keyword">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/answershuto/learnVue/blob/master/docs/%E8%81%8A%E8%81%8AVue%E7%9A%84template%E7%BC%96%E8%AF%91.MarkDown" target="_blank" rel="noopener">聊聊Vue的template编译.MarkDown</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;包括$mount和render方法。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day132-小试牛刀的题目-1</title>
    <link href="http://lmislm.com/2019/05/24/2019-05-24/"/>
    <id>http://lmislm.com/2019/05/24/2019-05-24/</id>
    <published>2019-05-23T16:00:00.000Z</published>
    <updated>2019-05-24T15:25:35.390Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一道构造数据结构的题目。<br>src: [{id:1}, {id:1}, {id:2}]<br>tgt: {1: [0,1], 2:[2]}</p><a id="more"></a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>个人解法。希望以后想出更好的解法。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">groupByProp</span> (<span class="params">objArray, prop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> objArray.reduce(<span class="function">(<span class="params">acc, cur, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> key = cur[prop]</span><br><span class="line">    <span class="keyword">if</span> (!acc[key]) &#123;</span><br><span class="line">      acc[key] = []</span><br><span class="line">    &#125;</span><br><span class="line">    acc[key].push(index)</span><br><span class="line">    <span class="keyword">return</span> acc</span><br><span class="line">  &#125;, &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let data = [&#123;id:1&#125;, &#123;id:1&#125;, &#123;id:2&#125;]</span></span><br><span class="line"><span class="comment">// console.log(groupByProp(data, 'id'))</span></span><br><span class="line"><span class="comment">// &#123; '1': [ 0, 1 ], '2': [ 2 ] &#125;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;一道构造数据结构的题目。&lt;br&gt;src: [{id:1}, {id:1}, {id:2}]&lt;br&gt;tgt: {1: [0,1], 2:[2]}&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
