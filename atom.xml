<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LMISLMのBlog</title>
  
  <subtitle>不积小流，无以成江海。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lmislm.com/"/>
  <updated>2019-08-20T15:04:13.757Z</updated>
  <id>http://lmislm.com/</id>
  
  <author>
    <name>lmislm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>day219-再看闭包</title>
    <link href="http://lmislm.com/2019/08/20/2019-08-20/"/>
    <id>http://lmislm.com/2019/08/20/2019-08-20/</id>
    <published>2019-08-19T16:00:00.000Z</published>
    <updated>2019-08-20T15:04:13.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>引子</li><li>闭包</li><li>闭包模拟私有方法</li><li>性能考量<a id="more"></a></li></ol><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><blockquote><p>嵌套的函数可以访问其外部声明的变量</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">'Mozilla'</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">displayName</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name) <span class="comment">// 嵌套的函数可以访问其外部声明的变量</span></span><br><span class="line">  &#125;</span><br><span class="line">  displayName()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeFunc</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">'Mozilla'</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">displayName</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> displayName</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myFunc = makeFunc()</span><br><span class="line">myFunc()</span><br></pre></td></tr></table></figure><h2 id="闭包模拟私有方法"><a href="#闭包模拟私有方法" class="headerlink" title="闭包模拟私有方法"></a>闭包模拟私有方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> makeCounter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> privateCounter = <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeBy</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    privateCounter += val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">-1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Counter1 = makeCounter()</span><br><span class="line"><span class="keyword">let</span> Counter2 = makeCounter()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Counter1.value()) <span class="comment">// 0</span></span><br><span class="line">Counter1.increment()</span><br><span class="line"><span class="built_in">console</span>.log(Counter1.value()) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(Counter2.value()) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h2 id="性能考量"><a href="#性能考量" class="headerlink" title="性能考量"></a>性能考量</h2><p>创建新的对象或者类时，方法通常关联于对象的原型，而不是定义到对象的构造器。</p><p>这将导致每次构造器被调用时，方法都会被重新赋值一次。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span> (<span class="params">name, message</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name.toString()</span><br><span class="line">  <span class="keyword">this</span>.message = message.toString()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 闭包</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.getMessage = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 闭包</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.message</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures#Practical_closures" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures#Practical_closures</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;引子&lt;/li&gt;
&lt;li&gt;闭包&lt;/li&gt;
&lt;li&gt;闭包模拟私有方法&lt;/li&gt;
&lt;li&gt;性能考量
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day218-[].slice.call(arguments)</title>
    <link href="http://lmislm.com/2019/08/19/2019-08-19/"/>
    <id>http://lmislm.com/2019/08/19/2019-08-19/</id>
    <published>2019-08-18T16:00:00.000Z</published>
    <updated>2019-08-19T15:02:39.710Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>类数组的转换</li><li>call绑定其他对象的上下文</li><li>slice方法中的for…in<a id="more"></a></li></ol><h2 id="类数组的转换"><a href="#类数组的转换" class="headerlink" title="类数组的转换"></a>类数组的转换</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[].slice.call(<span class="built_in">arguments</span>)</span><br></pre></td></tr></table></figure><h2 id="call绑定其他对象的上下文"><a href="#call绑定其他对象的上下文" class="headerlink" title="call绑定其他对象的上下文"></a>call绑定其他对象的上下文</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sliced = <span class="built_in">Array</span>.prototype.slice.call(&#123;<span class="string">'0'</span>: <span class="string">'a'</span>, <span class="string">'1'</span>: <span class="string">'b'</span>, <span class="string">'2'</span>: <span class="string">'c'</span>, <span class="attr">length</span>: <span class="number">3</span>&#125;, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// [ 'c' ]</span></span><br><span class="line"><span class="keyword">var</span> sliced = <span class="built_in">Array</span>.prototype.slice.call(&#123;<span class="string">'0'</span>: <span class="string">'a'</span>, <span class="string">'1'</span>: <span class="string">'b'</span>, <span class="string">'3'</span>: <span class="string">'c'</span>, <span class="attr">length</span>: <span class="number">3</span>&#125;, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// [ &lt;1 empty item&gt; ]</span></span><br></pre></td></tr></table></figure><h2 id="slice方法中的for…in"><a href="#slice方法中的for…in" class="headerlink" title="slice方法中的for…in"></a>slice方法中的for…in</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.mockSlice = <span class="function"><span class="keyword">function</span>(<span class="params">begin, end</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// IE &lt; 9 gets unhappy with an undefined end argument</span></span><br><span class="line">  end = (<span class="keyword">typeof</span> end !== <span class="string">'undefined'</span>) ? end : <span class="keyword">this</span>.length;</span><br><span class="line">  <span class="comment">// For array like object we handle it ourselves.</span></span><br><span class="line">  <span class="keyword">var</span> i, cloned = [],</span><br><span class="line">    size, len = <span class="keyword">this</span>.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Handle negative value for "begin"</span></span><br><span class="line">  <span class="keyword">var</span> start = begin || <span class="number">0</span>;</span><br><span class="line">  start = (start &gt;= <span class="number">0</span>) ? start : <span class="built_in">Math</span>.max(<span class="number">0</span>, len + start);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Handle negative value for "end"</span></span><br><span class="line">  <span class="keyword">var</span> upTo = (<span class="keyword">typeof</span> end == <span class="string">'number'</span>) ? <span class="built_in">Math</span>.min(end, len) : len;</span><br><span class="line">  <span class="keyword">if</span> (end &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    upTo = len + end;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Actual expected size of the slice</span></span><br><span class="line">  size = upTo - start;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    cloned = <span class="keyword">new</span> <span class="built_in">Array</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.charAt) &#123; <span class="comment">// String，如果是字符型返回指定位置的字符</span></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        cloned[i] = <span class="keyword">this</span>.charAt(start + i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        cloned[i] = <span class="keyword">this</span>[start + i]; <span class="comment">// 迭代数组</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cloned;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log([].mockSlice.call(<span class="built_in">arguments</span>)) <span class="comment">// [ 'a', 'b', 'c' ]</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" target="_blank" rel="noopener">Array.prototype.slice()</a></p><p><a href="https://stackoverflow.com/questions/7056925/how-does-array-prototype-slice-call-work" target="_blank" rel="noopener">how does Array.prototype.slice.call() work?</a></p><p><a href="http://es5.github.io/x15.4.html#x15.4.4.10" target="_blank" rel="noopener">Array.prototype.slice method description</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;类数组的转换&lt;/li&gt;
&lt;li&gt;call绑定其他对象的上下文&lt;/li&gt;
&lt;li&gt;slice方法中的for…in
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day217-Intersection Observer</title>
    <link href="http://lmislm.com/2019/08/18/2019-08-18/"/>
    <id>http://lmislm.com/2019/08/18/2019-08-18/</id>
    <published>2019-08-17T16:00:00.000Z</published>
    <updated>2019-08-18T15:47:52.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>简介</li><li>Options</li><li>Callback<a id="more"></a></li></ol><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>异步观察目标元素与其祖先元素或顶级文档视窗(viewport)交叉状态的方法。</p><p><code>Intersection Observer API</code>会注册一个回调方法，每当期望被监视的元素<code>进入或者退出</code>另外一个元素的时候(或者浏览器的视口)该回调方法将会被执行，或者两个元素的<code>交集部分大小发生变化</code>的时候回调方法也会被执行。</p><h2 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  root: <span class="built_in">document</span>.querySelector(<span class="string">'#scrollArea'</span>), <span class="comment">// 所监听对象的具体祖先元素(element) ,只读</span></span><br><span class="line">  rootMargin: <span class="string">'0px'</span>, <span class="comment">// 计算交叉时添加到根(root)边界盒bounding box的矩形偏移量，只读，主要用途之一就是用来实现提前加载，提前几百像素预先加载</span></span><br><span class="line">  threshold: <span class="number">1.0</span> <span class="comment">// 包含阈值的列表，如[0, 0.25, 0.5, 0.75, 1]， 列表中的每个阈值都是监听对象的交叉区域与边界区域的比率，只读</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> IntersectionObserver(callback, options);</span><br></pre></td></tr></table></figure><h2 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> callback = <span class="function"><span class="keyword">function</span>(<span class="params">entries, observer</span>) </span>&#123; </span><br><span class="line">  entries.forEach(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Each entry describes an intersection change for one observed</span></span><br><span class="line">  <span class="comment">// target element:</span></span><br><span class="line">  <span class="comment">//   entry.boundingClientRect</span></span><br><span class="line">  <span class="comment">//   entry.intersectionRatio</span></span><br><span class="line">  <span class="comment">//   entry.intersectionRect</span></span><br><span class="line">  <span class="comment">//   entry.isIntersecting // 判断target元素在root元素中的可见性是否发生变化，isIntersecting 是 true，target元素的至少已经达到thresholds属性值当中规定的其中一个阈值</span></span><br><span class="line">  <span class="comment">//   entry.rootBounds</span></span><br><span class="line">  <span class="comment">//   entry.target</span></span><br><span class="line">  <span class="comment">//   entry.time</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/ziyunfei/p/5558712.html" target="_blank" rel="noopener">IntersectionObserver API-紫云飞</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API" target="_blank" rel="noopener">Intersection Observer API-MDN</a></p><p><a href="https://juejin.im/post/5a7973575188257a5911a749" target="_blank" rel="noopener">谈谈IntersectionObserver懒加载</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;简介&lt;/li&gt;
&lt;li&gt;Options&lt;/li&gt;
&lt;li&gt;Callback
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day216-HTTPS 中间人攻击</title>
    <link href="http://lmislm.com/2019/08/17/2019-08-17/"/>
    <id>http://lmislm.com/2019/08/17/2019-08-17/</id>
    <published>2019-08-16T16:00:00.000Z</published>
    <updated>2019-08-17T14:34:06.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>过程</li><li>防范<a id="more"></a></li></ol><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol><li><code>服务端</code>向<code>客户端</code>发送公钥</li><li>攻击者截取公钥，并伪造公钥，发送给<code>客户端</code></li><li><code>客户端</code>收到伪造的公钥后，生成加密hash值发给<code>服务端</code></li><li>攻击者获得加密hash值，用自己的私钥解密获得真密钥</li><li>同时生成假的加密hash值，发给<code>服务端</code></li><li><code>服务端</code>用私钥解密获得假密钥</li><li><code>服务端</code>用假密钥加密传输信息。</li></ol><h2 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h2><p>服务端在发送给<code>客户端</code>的公钥中，加入CA证书。浏览器可以验证CA证书的有效性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;过程&lt;/li&gt;
&lt;li&gt;防范
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day215-TCP KeepAlive-笔记</title>
    <link href="http://lmislm.com/2019/08/16/2019-08-16/"/>
    <id>http://lmislm.com/2019/08/16/2019-08-16/</id>
    <published>2019-08-15T16:00:00.000Z</published>
    <updated>2019-08-16T15:13:29.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>基本原理</li><li>TCP的连接</li><li>KeepAlive的局限<a id="more"></a></li></ol><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。</p><h2 id="TCP的连接"><a href="#TCP的连接" class="headerlink" title="TCP的连接"></a>TCP的连接</h2><p>物理层面并没有“连接”的概念。</p><p>TCP通信双方建立连接，但并不是一直数据交互，有些连接会在数据交互后，主动释放连接，而有些不会。在长时间无数据交互的时间段内，交互双方都有可能出现掉电、死机、异常重启等各种意外，当这些意外发生之后，这些 TCP 连接并未来得及正常释放，在软件层面上，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费。</p><p>为了解决这个问题，在<code>传输层</code>可以利用<code>TCP</code>的<code>KeepAlive</code>机制实现来实现。</p><h2 id="KeepAlive的局限"><a href="#KeepAlive的局限" class="headerlink" title="KeepAlive的局限"></a>KeepAlive的局限</h2><p><code>KeepAlive</code>监测的方式是发送<code>probe</code>包，会给网络带来额外的流量。</p><p><code>TCP KeepAlive</code>只能在内核层级监测连接的存活与否，而连接的存活不一定代表服务的可用。</p><p>例如当一个服务器 CPU 进程服务器占用达到 100%，已经卡死不能响应请求了，此时 TCP KeepAlive 依然会认为连接是存活的。</p><blockquote><p>因此 TCP KeepAlive 对于应用层程序的价值是相对较小的。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.tldp.org/HOWTO/html_single/TCP-Keepalive-HOWTO/" target="_blank" rel="noopener">TCP Keepalive HOWTO</a></p><p><a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html" target="_blank" rel="noopener">TCP KeepAlive</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;基本原理&lt;/li&gt;
&lt;li&gt;TCP的连接&lt;/li&gt;
&lt;li&gt;KeepAlive的局限
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day214-HTTP四次挥手</title>
    <link href="http://lmislm.com/2019/08/15/2019-08-15/"/>
    <id>http://lmislm.com/2019/08/15/2019-08-15/</id>
    <published>2019-08-14T16:00:00.000Z</published>
    <updated>2019-08-15T14:22:25.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>目的</li><li>过程<a id="more"></a></li></ol><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭，客户端或服务器均可主动发起挥手动作。</p><p>这个原则是当一方完成它的数据发送任务后就能发送标志位FIN来终止这个方向的连接。收到FIN=1只意味着这一方向上没有数据流动，一个TCP连接在收到FIN=1后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p><strong>第一次握手</strong> (FIN=1，seq=x)</p><p>假设客户端想要关闭连接，客户端发送标志位FIN为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p><p>发送完毕后，客户端进入<code>FIN_WAIT_1</code>状态。</p><p><strong>第二次握手</strong> (ACK=1，ACKnum=x+1)</p><p>服务器端确认客户端的 FIN 包，发送一个确认序号（ACKnum，又写做ack），表明已接收客户端关闭连接的请求，但还没有准备好关闭连接。</p><p>发送完毕后，服务器端进入<code>CLOSE_WAIT</code>状态。<br>客户端接收到这个确认序号后，进入<code>FIN_WAIT_2</code>状态，等待服务器端关闭连接。</p><p><strong>第三次握手</strong> (FIN=1，seq=y)</p><p>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。</p><p>发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。</p><p><strong>第四次挥手</strong> (ACK=1，ACKnum=y+1)</p><p>客户端接收到来自服务器端的关闭请求，发送一个确认序号，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。</p><p>服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</p><p><strong>最后</strong></p><p>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html" target="_blank" rel="noopener">三次握手</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;目的&lt;/li&gt;
&lt;li&gt;过程
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day213-HTTP三次握手</title>
    <link href="http://lmislm.com/2019/08/14/2019-08-14/"/>
    <id>http://lmislm.com/2019/08/14/2019-08-14/</id>
    <published>2019-08-13T16:00:00.000Z</published>
    <updated>2019-08-16T14:55:45.986Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>目的</li><li>名词</li><li>过程</li><li>疑问<a id="more"></a></li></ol><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>客户端连接服务端，建立TCP连接，交换窗口大小信息</p><h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><p><code>ISN(Initial Sequence Number)：</code>操作系统动态随机选取一个32位长的序列号，即初始序列号ISN。</p><p><code>SYN(SYNchronization)：</code>同步信号SYN，占用一个字节的编号。</p><p>在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。</p><p>对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。</p><p><code>ACKnum：</code>确认序号。Inform the sending host that the transmitted data was received successfully.</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p><strong>第一次握手</strong>（SYN=1, seq=x)</p><p>客户端发送，TCP的SYN标志位初始值为1的包，表明客户端向服务端发起连接。同时seq（ sequence numbers 序列号）包含ISN序列号x，保存在发送包序列号字段里。</p><p>发送完毕后，客户端进入<code>SYN_SEND</code>状态。</p><p><strong>第二次握手</strong>（SYN=1, seq=y, ACK=1, ACKnum=x+1）（注意ACKnum又写作ack）</p><p>服务器返回，SYN标志位和ACK标志位为1。服务端将ISN序列号放入Seq域，同时将ACKnum（Acknowledgement Number：确认序号）设置为客户端ISN序列号加1，即x+1。</p><p>发送完毕后，服务端进入<code>SYN_RCVD</code>状态。</p><p><strong>第三次握手</strong>（ACK=1，seq=x + 1，ACKnum=y+1）</p><p>客户端发送，SYN标志位为0，ACK标志位为1，将服务端的seq序号值加1，放入确认序号中，发送给服务端。</p><p>发送完毕后，客户端进入<code>ESTABLISHED</code>状态，服务端接收后，也进入ESTABLISHED状态。TCP三次握手结束</p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ol><li>为什么是三次握手不是两次握手？</li></ol><p>TCP 需要 seq 序列号来做可靠重传或接收，而避免连接复用时无法分辨出 seq 是延迟或者是旧链接的 seq。</p><blockquote><p>谢希仁版《计算机网络》：“已失效的连接请求报文段” 的产生在这样一种情况下：client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。”</p><ol start="2"><li>TCP 怎么样识别之前旧链接重发的包？</li></ol></blockquote><p>ISN（初始序列号）机制。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/24853633" target="_blank" rel="noopener">TCP 为什么是三次握手，而不是两次或四次？</a></p><p><a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html" target="_blank" rel="noopener">三次握手</a></p><p><a href="https://packetlife.net/blog/2010/jun/7/understanding-tcp-sequence-acknowledgment-numbers/" target="_blank" rel="noopener">Understanding TCP Sequence and Acknowledgment Numbers</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;目的&lt;/li&gt;
&lt;li&gt;名词&lt;/li&gt;
&lt;li&gt;过程&lt;/li&gt;
&lt;li&gt;疑问
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day212-DNS解析</title>
    <link href="http://lmislm.com/2019/08/13/2019-08-13/"/>
    <id>http://lmislm.com/2019/08/13/2019-08-13/</id>
    <published>2019-08-12T16:00:00.000Z</published>
    <updated>2019-08-16T14:52:25.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>DNS解析过程</li><li>DNS优化<a id="more"></a></li></ol><h2 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h2><p>DNS解析查IP过程：（以<a href="http://www.xxx.com为例）" target="_blank" rel="noopener">www.xxx.com为例）</a><br>过程：. -&gt; .com -&gt; xxx.com. -&gt; <a href="http://www.xxx.com" target="_blank" rel="noopener">www.xxx.com</a>.</p><ol><li>读取DNS缓存（缓存分为：浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存）</li><li>查找LDNS（本地区域名服务器，如果你在学校接入互联网，则 LDNS 服务器就在学校）。LDNS查询自己的DNS缓存，失败则进行DNS解析请求。</li><li>LDNS查找根域名服务器（<a href="http://www.xxx.com.，注意com后的“.”对应根域名服务器，默认都有，通常省略，但浏览器请求DNS时会自动加上" target="_blank" rel="noopener">www.xxx.com.，注意com后的“.”对应根域名服务器，默认都有，通常省略，但浏览器请求DNS时会自动加上</a>)</li><li>LDNS查找顶级域名服务器（COM域名服务器）</li><li>LDNS查找主域名服务器（xxx.com域名服务器），得到IP地址</li><li>LDNS将得到的IP地址，返回给操作系统，自己也存一份。</li></ol><h2 id="DNS优化"><a href="#DNS优化" class="headerlink" title="DNS优化"></a>DNS优化</h2><ol><li><p>缓存<br>主要有：浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存<br>浏览器缓存查看（Chrome版本75.0.3770.100为例）：<code>chrome://net-internals/#dns</code>。注：可以从<code>chrome://chrome-urls/</code>进去<br>系统缓存查看：（<code>/etc/hosts</code>，Linux系统）（<code>hosts</code>，Windows系统）</p></li><li><p>负载均衡<br>根据每台被请求的机器（含有请求资源）的负载量，该机器离用户地理位置的距离等等，来决定哪个机器处理，即负载均衡，又叫DNS重定向。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">前端经典面试题: 从输入URL到页面加载发生了什么？</a></p><p><a href="https://github.com/kaola-fed/blog/issues" target="_blank" rel="noopener">从输入页面地址到展示页面信息都发生了些什么？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;DNS解析过程&lt;/li&gt;
&lt;li&gt;DNS优化
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day211-localStorage、sessionStorage、Cookie</title>
    <link href="http://lmislm.com/2019/08/12/2019-08-12/"/>
    <id>http://lmislm.com/2019/08/12/2019-08-12/</id>
    <published>2019-08-11T16:00:00.000Z</published>
    <updated>2019-08-16T14:52:21.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>三者异同</li><li>三者的基本概念<a id="more"></a></li></ol><h2 id="三者异同"><a href="#三者异同" class="headerlink" title="三者异同"></a>三者异同</h2><table><thead><tr><th>特性</th><th>Cookie</th><th>localStorage</th><th>sessionStorage</th></tr></thead><tbody><tr><td>生命周期</td><td>可由服务器生成，可设置过期时间。如果在浏览器端生成Cookie，默认是关闭浏览器后清除</td><td>除非被清除，否则永久保存</td><td>仅在当前会话下有效，关闭页面或浏览器后被清除</td></tr><tr><td>可存放数据大小</td><td>4K左右</td><td>5MB左右</td><td>5MB左右</td></tr><tr><td>与服务器端通信</td><td>携带在HTTP头中</td><td>不与服务器端通信，仅仅在浏览器中保存</td><td>不与服务器端通信，仅仅在浏览器中保存</td></tr><tr><td>易用性</td><td>接口不友好</td><td>相对较容易封装</td><td>相对较容易封装</td></tr></tbody></table><h2 id="三者的基本概念"><a href="#三者的基本概念" class="headerlink" title="三者的基本概念"></a>三者的基本概念</h2><p><strong>localStorage</strong></p><p>HTML5新特性，支持IE8+、 IE6+的polyfill可以用userData。localStorage在浏览器的隐私模式下面是不可读取的。</p><p><strong>sessionStorage</strong></p><p>仅在当前会话下有效，关闭页面或浏览器后被清除。<br><strong>作用域</strong> 如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的。</p><p><strong>Cookie</strong><br>生命周期在设置的cookie过期时间之前一直有效。长度和数量的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB。属于旧方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;三者异同&lt;/li&gt;
&lt;li&gt;三者的基本概念
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day210-Content-Type</title>
    <link href="http://lmislm.com/2019/08/11/2019-08-11/"/>
    <id>http://lmislm.com/2019/08/11/2019-08-11/</id>
    <published>2019-08-10T16:00:00.000Z</published>
    <updated>2019-08-16T14:52:16.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>是什么？</li><li>句法</li><li>指令，及其注释<a id="more"></a></li></ol><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>Content-Type 实体头部用于指示资源的MIME类型 media type 。</p><h2 id="句法"><a href="#句法" class="headerlink" title="句法"></a>句法</h2><p>就是经常在header中看到的东西，如，<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Content-Type: text/html; charset=utf<span class="number">-8</span></span><br></pre></td></tr></table></figure></p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><ol><li>media-type</li></ol><p>资源或数据的 MIME type（媒体类型—通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型 ，是一种标准，用来表示文档、文件或字节流的性质和格式，如：text/html<br>、text/plain）。</p><ul><li>常见的：<br><code>multipart/form-data</code>，用以支持向服务器发送二进制数据</li></ul><p><code>application/x-www-urlencoded</code>，消息内容会经过 URL 格式编码，可用get方法和post方法，但不写enctype，无法实现文件上传</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.runoob.com/http/http-content-type.html" target="_blank" rel="noopener">HTTP content-type 对照表</a></p><p><a href="https://segmentfault.com/a/1190000003002851#articleHeader2" target="_blank" rel="noopener">理解HTTP之Content-Type</a></p><p><a href="https://juejin.im/post/5c9f4885f265da308868dad1" target="_blank" rel="noopener">上传文件multipart/form-data深入解析</a></p><p><a href="https://www.jianshu.com/p/29e38bcc8a1d" target="_blank" rel="noopener">深入解析 multipart/form-data</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;是什么？&lt;/li&gt;
&lt;li&gt;句法&lt;/li&gt;
&lt;li&gt;指令，及其注释
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day209-repaint和reflow扫盲</title>
    <link href="http://lmislm.com/2019/08/10/2019-08-10/"/>
    <id>http://lmislm.com/2019/08/10/2019-08-10/</id>
    <published>2019-08-09T16:00:00.000Z</published>
    <updated>2019-08-16T14:52:10.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>介绍</li><li>引起XX的常见操作</li><li>优化<a id="more"></a></li></ol><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>浏览器重新渲染，就需要重新生成布局和重新绘制。前者叫做”回流”（reflow，又叫重排，英文也叫Layout），后者叫做”重绘”（repaint）。</p><p>元素样式的改变不影响布局， UI 层面的重新像素绘制，重绘对元素进行更新 —— 重绘(repaint)<br>重新渲染页面 —— 回流(reflow)</p><h2 id="常见原因"><a href="#常见原因" class="headerlink" title="常见原因"></a>常见原因</h2><p><strong>常见的reflow操作：</strong></p><ol><li>页面初次渲染，浏览器窗口大小改变</li><li>元素尺寸/位置/内容发生改变</li><li>css伪类<blockquote><p>offsetTop/offsetLeft/offsetWidth/offsetHeight/offsetParent</p></blockquote></li></ol><blockquote><p>clientTop/clientLeft/clientWidth/clientHeight</p></blockquote><blockquote><p>scrollTop/scrollLeft/scrollWidth/scrollHeight</p></blockquote><blockquote><p>getComputedStyle()/getClientRects()/getBoundingClientRect()</p></blockquote><p><strong>常见的repaint操作：</strong></p><p>css属性的改变。</p><p>具体见CSS Triggers <a href="https://csstriggers.com/" target="_blank" rel="noopener">https://csstriggers.com/</a> 这里列出了哪些属性会引起reflow(即Layout)或repaint。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ul><li><p>rAF等<br>使用 window.requestAnimationFrame()、window.requestIdleCallback() 这两个方法调节重新渲染</p></li><li><p><a href="https://github.com/wilsonpage/fastdom" target="_blank" rel="noopener">FASTDOM</a> (Eliminates layout thrashing by batching DOM measurement and mutation tasks<br>)</p><blockquote><p>自动完成读写操作的批处理</p></blockquote></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/30078937" target="_blank" rel="noopener">如何不择手段提升scroll事件的性能—知乎</a></p><p><a href="https://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html" target="_blank" rel="noopener">网页性能管理详解—阮一峰</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;介绍&lt;/li&gt;
&lt;li&gt;引起XX的常见操作&lt;/li&gt;
&lt;li&gt;优化
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day208-requestAnimationFrame-了解</title>
    <link href="http://lmislm.com/2019/08/09/2019-08-09/"/>
    <id>http://lmislm.com/2019/08/09/2019-08-09/</id>
    <published>2019-08-08T16:00:00.000Z</published>
    <updated>2019-08-09T15:16:37.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>作用</li><li>应用</li><li>实例<a id="more"></a></li></ol><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><blockquote><p>要求浏览器在下次重绘之前调用指定的回调函数更新动画<sup>[1]</sup></p></blockquote><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li>减少<code>重绘</code>或<code>回流</code>。</li><li>替代通过时间管理队列的高频发事件，通过<code>requestAnimationFrame</code>来管理队列，保证 <code>requestAnimationFrame</code>的队列里，同样的回调函数只有一个。因为通常显示器16.7ms（16.7 = 1000 / 60, 即每秒60帧）的刷新间隔中，如果发生了其他绘制请求(setTimeout)，可能导致帧丢失。这里帧丢失通常就包含有，滚动、触摸这类高触发频率事件的回调可能会在同一帧内触发多次所导致，<code>requestAnimationFrame</code>就是跟着浏览器的绘制走，绘制间隔时间内绘制完毕。</li></ol><h2 id="实例-进度条"><a href="#实例-进度条" class="headerlink" title="实例-进度条"></a>实例-进度条</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span> <span class="attr">style</span>=<span class="string">"background-color: lightblue;width: 0;height: 20px;line-height: 20px;"</span>&gt;</span>0%<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span>run<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="javascript"><span class="keyword">var</span> timer; btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; myDiv.style.width = <span class="string">'0'</span>;</span></span><br><span class="line">  cancelAnimationFrame(timer);</span><br><span class="line"><span class="javascript">  timer = requestAnimationFrame(<span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span>(<span class="built_in">parseInt</span>(myDiv.style.width) &lt; <span class="number">500</span>)&#123; </span></span><br><span class="line"><span class="javascript">      myDiv.style.width = <span class="built_in">parseInt</span>(myDiv.style.width) + <span class="number">5</span> + <span class="string">'px'</span>; </span></span><br><span class="line"><span class="javascript">      myDiv.innerHTML = <span class="built_in">parseInt</span>(myDiv.style.width)/<span class="number">5</span> + <span class="string">'%'</span>; </span></span><br><span class="line">      timer = requestAnimationFrame(fn); </span><br><span class="line"><span class="javascript">    &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line">      cancelAnimationFrame(timer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>进度条例子来自：<a href="https://www.w3cplus.com/javascript/requestAnimationFrame.html" target="_blank" rel="noopener">W3Plus-被誉为神器的requestAnimationFrame</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1]. <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noopener">window.requestAnimationFrame-MDN</a></p><p><a href="https://www.zhangxinxu.com/wordpress/2013/09/css3-animation-requestanimationframe-tween-%E5%8A%A8%E7%94%BB%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">CSS3动画那么强，requestAnimationFrame还有毛线用？</a></p><p><a href="https://segmentfault.com/a/1190000010229232" target="_blank" rel="noopener">requestAnimationFrame 方法你真的用对了吗？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;作用&lt;/li&gt;
&lt;li&gt;应用&lt;/li&gt;
&lt;li&gt;实例
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day207-Vue-nextTick()</title>
    <link href="http://lmislm.com/2019/08/08/2019-08-08/"/>
    <id>http://lmislm.com/2019/08/08/2019-08-08/</id>
    <published>2019-08-07T16:00:00.000Z</published>
    <updated>2019-08-08T15:12:28.727Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li><code>nextTick</code>用法</li><li><code>nextTick</code>源码相关</li><li>事件循环</li><li>源码中的降级策略<a id="more"></a></li></ol><h2 id="nextTick作用"><a href="#nextTick作用" class="headerlink" title="nextTick作用"></a><code>nextTick</code>作用</h2><blockquote><p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。<a href="https://cn.vuejs.org/v2/api/#Vue-nextTick" target="_blank" rel="noopener">来源</a></p></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 850555d on 20 Dec 2018</span></span><br><span class="line"><span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> MutationObserver !== <span class="string">'undefined'</span> &amp;&amp; (</span><br><span class="line">  isNative(MutationObserver) ||</span><br><span class="line">  <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">  MutationObserver.toString() === <span class="string">'[object MutationObserverConstructor]'</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="comment">// Use MutationObserver where native Promise is not available,</span></span><br><span class="line">  <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">  <span class="comment">// (#6466 MutationObserver is unreliable in IE11)</span></span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter)) <span class="comment">// 创建一个文本</span></span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    characterData: <span class="literal">true</span> <span class="comment">// 初始化监听文本节点</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.data = <span class="built_in">String</span>(counter) <span class="comment">// 文本节点变化监听</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上主要作用就是：监听文本变动是否完毕。</p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><ul><li><p>常见的<strong>microtask</strong>有：<br><code>Promise</code>、<code>MutationObserve</code>r、<code>Object.observe(废弃)</code>，以及nodejs中的<code>process.nextTick</code></p></li><li><p>常见的<strong>macrotask</strong> 有<code>setTimeout</code>、<code>MessageChannel</code>、<code>postMessage</code>、<code>setImmediate</code></p></li></ul><h2 id="降级策略"><a href="#降级策略" class="headerlink" title="降级策略"></a>降级策略</h2><p>在vue2.x版本的源码文件next-tick.js中，你还可以看到有其他的一些兼容性方法。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/Ma63d/vue-analysis/issues/6" target="_blank" rel="noopener">Vue源码详解之nextTick：MutationObserver只是浮云，microtask才是核心！</a></p><p><a href="https://juejin.im/entry/5aced80b518825482e39441e" target="_blank" rel="noopener">全面解析Vue.nextTick实现原理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;nextTick&lt;/code&gt;用法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nextTick&lt;/code&gt;源码相关&lt;/li&gt;
&lt;li&gt;事件循环&lt;/li&gt;
&lt;li&gt;源码中的降级策略
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day206-初识MutationObserver</title>
    <link href="http://lmislm.com/2019/08/07/2019-08-07/"/>
    <id>http://lmislm.com/2019/08/07/2019-08-07/</id>
    <published>2019-08-06T16:00:00.000Z</published>
    <updated>2019-08-07T15:29:09.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li><code>MutationObserver</code> 使用方法</li><li><code>MutationObserver</code> 的方法<code>observe()</code>(具体)和<code>takeRecords()</code>以及<code>disconnect()</code></li><li><code>MutationRecord</code><a id="more"></a></li></ol><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mObserver = <span class="keyword">new</span> MutationObserver(callback) <span class="comment">// 新建实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> word = <span class="built_in">document</span>.querySelector(<span class="string">'words'</span>);</span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  <span class="string">'childList'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'arrtibutes'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'characterData'</span>: <span class="literal">true</span>, <span class="comment">// 节点内容或节点文本的变动</span></span><br><span class="line">  <span class="string">'subtree'</span>: <span class="literal">true</span>, <span class="comment">// 所有子节点，不能单独观察，必须同时指定以上三个为`true`</span></span><br><span class="line">  <span class="string">'attributeOldValue'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'characterDataOldValue'</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">'attributesFilter'</span>: [<span class="string">'class'</span>, <span class="string">'str'</span>] <span class="comment">// 值为数组，表示观察的特定属性</span></span><br><span class="line">&#125;</span><br><span class="line">mObserver.observer(word, options)</span><br></pre></td></tr></table></figure><h2 id="disconnect、takeRecord"><a href="#disconnect、takeRecord" class="headerlink" title="disconnect、takeRecord"></a>disconnect、takeRecord</h2><ul><li>disconnect 表示停止观察，无参数，用法：mObserver.disconnect()</li><li>takeRecord 用来清除变动记录，无参数，用法：mObserver.takeRecords()</li></ul><h2 id="MutationRecord"><a href="#MutationRecord" class="headerlink" title="MutationRecord"></a>MutationRecord</h2><blockquote><p>每个 MutationRecord 代表一个独立的 DOM 变化，其作为参数传递给 MutationObserver 的回调函数。</p></blockquote><ol><li>参数的含义</li></ol><ul><li>type: 观察的变动类型（attribute、characterData或者childList）</li><li>target: 发生变动的DOM对象</li><li>addedNodes: 新增的DOM对象</li><li>removeNodes: 删除的DOM对象</li><li>previousSibling: 前一个同级的DOM对象，无则返回null</li><li>nextSibling: 下个同级的DOM对象，无则返回null</li><li>attributeName: 发生变动的属性，如果设置了attributeFilter，则只返回预先指定的属性</li><li>oldValue：变动前的值。只对attribute和characterData变动有效</li></ul><p>详细的属性表，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationRecord" target="_blank" rel="noopener">点击这里</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver/observe" target="_blank" rel="noopener">MDN-MutationObserver</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationRecord" target="_blank" rel="noopener">MDN-MutationRecord</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;MutationObserver&lt;/code&gt; 使用方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MutationObserver&lt;/code&gt; 的方法&lt;code&gt;observe()&lt;/code&gt;(具体)和&lt;code&gt;takeRecords()&lt;/code&gt;以及&lt;code&gt;disconnect()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MutationRecord&lt;/code&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day205-instanceOf</title>
    <link href="http://lmislm.com/2019/08/06/2019-08-06/"/>
    <id>http://lmislm.com/2019/08/06/2019-08-06/</id>
    <published>2019-08-05T16:00:00.000Z</published>
    <updated>2019-08-06T14:59:38.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>instanceOf 简单实现</p><blockquote><p>原理：检查是否在left（左边的值）的原型链上<br><a id="more"></a></p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceOf</span> (<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rightProto = right.prototype</span><br><span class="line">  left = left.__proto__</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!left) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left === rightProto) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// 继续找下去</span></span><br><span class="line">    &#125;</span><br><span class="line">    left = left.__proto__ <span class="comment">// 继续遍历</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;p&gt;instanceOf 简单实现&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原理：检查是否在left（左边的值）的原型链上&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day204-es6-笔记-Class-this</title>
    <link href="http://lmislm.com/2019/08/05/2019-08-05/"/>
    <id>http://lmislm.com/2019/08/05/2019-08-05/</id>
    <published>2019-08-04T16:00:00.000Z</published>
    <updated>2019-08-05T14:20:36.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><blockquote><p>class 构造函数<code>constructor</code>中<code>this</code>的指向<br>类的方法内部如果含有<code>this</code>,默认指向类的实例。单独使用方法时，可能报错。</p></blockquote><ul><li>解决方法：</li></ul><ol><li>构造方法中绑定`this</li><li>使用箭头函数</li><li>使用<code>Proxy</code>，获取方法的时候，自动绑定<code>this</code><a id="more"></a><h2 id="具体解决方法-3rd"><a href="#具体解决方法-3rd" class="headerlink" title="具体解决方法-3rd"></a>具体解决方法-3rd</h2></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selfish</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">WeakMap</span>() <span class="comment">// 弱引用</span></span><br><span class="line">  <span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span> (target, key) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="built_in">Reflect</span>.get(target, key)</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!cache.has(value)) &#123;</span><br><span class="line">        cache.set(value, value.bind(target)) <span class="comment">// 还是用到了bind</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> cache.get(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line">  <span class="keyword">return</span> proxy</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 示例 */</span></span><br><span class="line"><span class="keyword">const</span> logger = selfish(<span class="keyword">new</span> logger())</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;class 构造函数&lt;code&gt;constructor&lt;/code&gt;中&lt;code&gt;this&lt;/code&gt;的指向&lt;br&gt;类的方法内部如果含有&lt;code&gt;this&lt;/code&gt;,默认指向类的实例。单独使用方法时，可能报错。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;解决方法：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;构造方法中绑定`this&lt;/li&gt;
&lt;li&gt;使用箭头函数&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;Proxy&lt;/code&gt;，获取方法的时候，自动绑定&lt;code&gt;this&lt;/code&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day203-reduce题目</title>
    <link href="http://lmislm.com/2019/08/04/2019-08-04/"/>
    <id>http://lmislm.com/2019/08/04/2019-08-04/</id>
    <published>2019-08-03T16:00:00.000Z</published>
    <updated>2019-08-04T14:19:44.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol><li>求<code>[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ]</code></li></ol><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>第一个<code>[3,2,1].reduce(Math.pow)</code>结果是：<code>Math.pow(3, 2) =&gt; 9; Math.pow(9, 1) =&gt;9</code>。<br>第二个<code>[].reduce(Math.pow)</code>结果是<code>TypeError: Reduce of empty array with no initial value</code>,即：没有初始值。</p><p>输出<code>error</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;求&lt;code&gt;[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day202-简单实现Promise(4)</title>
    <link href="http://lmislm.com/2019/08/03/2019-08-03/"/>
    <id>http://lmislm.com/2019/08/03/2019-08-03/</id>
    <published>2019-08-02T16:00:00.000Z</published>
    <updated>2019-08-03T14:21:13.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li><code>resolved</code>,<code>rejected</code>和<code>pending</code>三种情况的相应处理</li></ol><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** promise */</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据标准，如果then的参数不是function，则我们需要忽略它</span></span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123; <span class="keyword">return</span> v&#125;</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123; <span class="keyword">return</span> r &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'resolved'</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里promise的状态已经确定是resolved，所以调用onResolved</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ret是onFulfilled的返回值</span></span><br><span class="line">        <span class="keyword">var</span> ret = onFulfilled(self.data)</span><br><span class="line">        <span class="keyword">if</span> (ret <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">          <span class="comment">// 如果ret是一个promise，则取其值作为新的promise的结果</span></span><br><span class="line">          ret.then(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 否则，以它的返回值作为新的promise的结果</span></span><br><span class="line">          resolve(ret)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="comment">// 如果出错，以捕获到的错误作为promise2的结果</span></span><br><span class="line">        reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里的逻辑跟前面一样，不再赘述</span></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> ret = onRejected(self.data)</span><br><span class="line">        <span class="keyword">if</span> (ret <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">          ret.then(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject(ret)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果当前的Promise还处于pending状态，则不能确定调用</span></span><br><span class="line">    <span class="comment">// onResolved还是onRejecte，只能等到Promise状态确定后，</span></span><br><span class="line">    <span class="comment">// 才能确定如何处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      self.onFulfilledCallback.push(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> ret = onFulfilled(self.data)</span><br><span class="line">          <span class="keyword">if</span> (ret <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            ret.then(resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resolve(ret)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      self.onRejectedCallback.push(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> ret = onRejected(self.data)</span><br><span class="line">          <span class="keyword">if</span> (ret <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">            ret.then(resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reject(ret)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺便实现一下catch方法</span></span><br><span class="line">MyPromise.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;resolved&lt;/code&gt;,&lt;code&gt;rejected&lt;/code&gt;和&lt;code&gt;pending&lt;/code&gt;三种情况的相应处理&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day201-简单实现Promise(3)</title>
    <link href="http://lmislm.com/2019/08/02/2019-08-02/"/>
    <id>http://lmislm.com/2019/08/02/2019-08-02/</id>
    <published>2019-08-01T16:00:00.000Z</published>
    <updated>2019-08-03T14:17:52.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>promise的<code>then</code>方法框架</li></ol><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** promise-then方法 */</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// 标准2.2.1.1. If onFulfilled is not a function, it must be ignored.</span></span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123; <span class="keyword">return</span> v &#125;</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123; <span class="keyword">return</span> r &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Promise对象存在以下三种状态，对三种状态采用不同处理</span></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'resolved'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// todo</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// todo</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// todo</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;promise的&lt;code&gt;then&lt;/code&gt;方法框架&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day200-简单实现Promise(2)</title>
    <link href="http://lmislm.com/2019/08/01/2019-08-01/"/>
    <id>http://lmislm.com/2019/08/01/2019-08-01/</id>
    <published>2019-07-31T16:00:00.000Z</published>
    <updated>2019-08-03T14:17:54.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>修改promise状态</li></ol><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 构造函数 - 雏形 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span></span><br><span class="line">  self.status = <span class="string">'pending'</span></span><br><span class="line">  self.data = <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">  self.onFulfilledCallback = [] <span class="comment">// resolve 回调函数集合</span></span><br><span class="line">  self.onRejectedCallback = [] <span class="comment">// reject 回调函数集合</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      self.status = <span class="string">'resolved'</span></span><br><span class="line">      self.data = value</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; self.onFulfilledCallback.length; i++) &#123;</span><br><span class="line">        self.onFulfilledCallback[i](value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (self.status === <span class="string">'pending'</span>) &#123;</span><br><span class="line">      self.status = <span class="string">'rejected'</span></span><br><span class="line">      self.data = reason</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; self.onRejectedCallback.length; i++) &#123;</span><br><span class="line">        self.onRejectedCallback[i](reason)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fn (resolve, reject) <span class="comment">// 执行传入的函数，传入</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;修改promise状态&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
