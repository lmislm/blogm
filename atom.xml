<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LMISLMのBlog</title>
  
  <subtitle>不积小流，无以成江海。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lmislm.com/"/>
  <updated>2019-07-12T13:53:56.916Z</updated>
  <id>http://lmislm.com/</id>
  
  <author>
    <name>lmislm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>day179-HTTPS协议-SSL和TLS的区别</title>
    <link href="http://lmislm.com/2019/07/11/2019-07-11/"/>
    <id>http://lmislm.com/2019/07/11/2019-07-11/</id>
    <published>2019-07-10T16:00:00.000Z</published>
    <updated>2019-07-12T13:53:56.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>关系（并列关系）；</li><li>SSL(Secure Socket Layer，安全套接字层)；</li><li><code>HTTP/2</code>的<code>多路复用</code>解决要点2的问题；</li><li>不适用于<code>HTTP/2</code>的优化；</li><li>SSL和TLS之间的详细关系；<a id="more"></a></li></ol><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>SSL是专门保护Web通讯的。TLS是制定的一种新协议，建立在<code>SSL3.0</code>协议规范上，<code>TLS1.0</code>和<code>SSL3.0</code>两者差别极小。</p><h2 id="SSL-Secure-Socket-Layer，安全套接字层"><a href="#SSL-Secure-Socket-Layer，安全套接字层" class="headerlink" title="SSL(Secure Socket Layer，安全套接字层)"></a>SSL(Secure Socket Layer，安全套接字层)</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>作用：SSL利用数据加密技术，确保web浏览器与服务器之间的<code>身份认证</code>和<code>数据加密</code>传输安全。通用的规格为40bit安全标准。</p><p>层级：<code>SSL协议</code>位于<code>TCP/IP协议</code>与各种应用层之间，为数据通讯提供安全支持。</p><p>分类：SSL协议主要分两层，SSL记录协议（SSL Record Protocol）和SSL握手协议（SSL Handshake Protocol）。</p><p><strong>SSL记录协议</strong>：它建立在可靠的传输协议（如TCP）上，为高层协议提供<code>数据封装</code>、<code>压缩</code>、<code>加密</code>等基本功能的支持。<br><strong>SSL握手协议</strong>：它建立在<code>SSL记录协议</code>之上，用于数据传输开始前，<code>通讯双方进行身份认证</code>、<code>协商加密算法</code>、<code>交换加密密钥</code>等。</p><h3 id="SSL协议提供的服务"><a href="#SSL协议提供的服务" class="headerlink" title="SSL协议提供的服务"></a>SSL协议<strong>提供的服务</strong></h3><p>1) 认证用户和服务端（服务器），确保数据发送到正确的客户端和服务端。<br>2) 维护数据的完整性，确保数据在传输过程中不被改变。<br>3) 加密数据以防数据中途被窃取。</p><h3 id="SSL协议的工作流程"><a href="#SSL协议的工作流程" class="headerlink" title="SSL协议的工作流程"></a>SSL协议的<strong>工作流程</strong></h3><ul><li><p>服务端认证阶段：<br>1) 客户端向服务端发送一个开始信息’Hello’以便开始一个新的会话连接；<br>2) 服务端根据客户的信息确定是否需要生成新的主密钥（什么信息申请新的主密钥？），<br>如果需要则服务端在响应客户的’Hello’信息时将包含生成主密钥所需的信息。<br>3) 客户端根据收到的服务端响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务端。<br>4) 服务端恢复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务端。</p></li><li><p>用户端认证阶段：<br>在此之前，服务端已通过客户端认证，这一阶段主要是完成对客户端的认证。<br>经认证的服务端发送一个提问给客户端，客户端则返回（数字）签名后的提问和其公开的密钥，从而向服务端提供认证。</p></li></ul><h3 id="SSL协议的总结"><a href="#SSL协议的总结" class="headerlink" title="SSL协议的总结"></a>SSL协议的总结</h3><p>SSL协议的运行基础是商家（即：服务端）对消费者（即：客户端）信息保密的承诺，有利于商家而不利于消费者。</p><p>在电子商务初级阶段，由于运作电子商务的企业大多是信誉较高的大公司，因此这问题还没有充分暴露出来。</p><p>随着电子商务的发展，各中小型公司也参与进来，这样在电子支付过程中的<code>单一认证问题</code>就越来越突出。</p><p>虽然在SSL3.0中通过数字签名和数字证书可实现浏览器和Web服务端双方的身份验证，但SSL协议仍存在一些问题，<br>比如，只能提供交易中客户端与服务端间的双方认证，在设计<code>多方的电子交易</code>中，SSL协议并不能协调各方间的安全传输和信任关系。</p><p>在这种情况下，Visa和MasterCard两大信用卡组织制定了<code>SET协议</code>，为网上信用卡支付提供了全球性的标准。</p><h2 id="TLS-Transport-Layer-Security-Protocol-安全传输层协议"><a href="#TLS-Transport-Layer-Security-Protocol-安全传输层协议" class="headerlink" title="TLS(Transport Layer Security Protocol, 安全传输层协议)"></a>TLS(Transport Layer Security Protocol, 安全传输层协议)</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>作用：TLS（安全传输层协议）用于在两个通信应用程序之间提供<code>保密性</code>和<code>数据完整性</code>。<br>分类：TLS协议主要分两层，TLS记录协议（TLS Record）和TLS握手协议（TLS Handshake）。</p><blockquote><p>较低的层为<code>TLS记录协议</code>（注：同SSL记录协议），位于某个可靠的传输协议（如TCP）上面。</p></blockquote><p><strong>TLS记录协议</strong>：它提供的<code>连接安全性</code>具有两个基本特性，<code>私有</code>、<code>可靠</code>。</p><ul><li><p>私有——<code>对称加密</code>用数据加密（DES、RC4等）。对称加密产生的密钥对每个连接都是唯一的，且此密钥基于另一个协议（如握手协议）协商。</p><blockquote><p>记录协议也可以不加密使用。</p></blockquote></li><li><p>可靠——信息传输包括使用密钥的MAC进行信息<code>完整性检查</code>。安全哈希功能（SHA、MD5等）用于MAC计算。</p><blockquote><p>记录协议在没有MAC的情况下也能操作，但一般只能用于这种模式，即有另一个协议正在使用记录协议传输协商安全参数。</p></blockquote></li></ul><p><strong>TLS握手协议</strong>：</p><ul><li>简介</li></ul><p>TLS记录协议用于封装各种高层协议。</p><p>作为这种封装协议之一的<code>握手协议</code>允许服务器于客户端在应用程序协议传输和接收其第一个数据字节前彼此之间相互认证，协商加密算法和加密密钥。</p><p>TLS握手协议提供的<code>连接安全</code>具有三个基本属性：</p><p> 1）可以使用非对称的，或公共密钥的密码来认证对方的身份。该认证是可选的，但至少需要一个结点方。</p><p> 2）共享加密密钥的协商是安全的。对偷窃者来说<code>协商加密</code>是难以获得的。以此经过认证的连接不能获得加密，及时是进入连接中间的攻击者也不能。</p><p> 3）协商是可靠的。没有经过通信方成员的检测，任何攻击者都不能修改通信协商。</p><blockquote><p>TLS的最大优势就在于：TLS是<code>独立于应用协议</code>。高层协议可以透明地分布在TLS协议上面。</p></blockquote><p>然而，TLS标准并没有规定应用程序如何在TLS上增加安全性， 它把如何启动TLS握手协议以及如何解释交换的认证证书的决定权留给协议的设计者和实施者来判断。</p><ol><li>TLS协议的<strong>协议结构</strong><br>TLS协议包括<code>两个协议组</code>（即：TLS记录协议和TLS握手协议），每组具有很多不同格式的信息。<blockquote><p>在此文件中我们只列出协议摘要并不做具体解析。具体内容可参照相关文档。</p></blockquote></li></ol><ul><li><p>TLS记录协议是一种<code>分层协议</code>。每一层中的信息可能包含长度、描述和内容等字段。记录协议支持<code>信息传输</code>、将<code>数据分段</code>到可处理块、<code>压缩数据</code>、<code>应用MAC</code>、<code>加密</code>以及<code>传输结果</code>等。<br>对接收到的数据进行解密、校验、解压缩、重组等，然后将他们传送到高层客户机。</p></li><li><p>TLS连接状态指的是TLS记录协议的操作环境。它规定了压缩算法、加密算法和MAC算法。</p></li><li><p>TLS记录层从高层接收任意大小无空块的连续数据。密钥计算：记录协议通过算法从握手协议提供的安全参数中产生密钥、IV和MAC密钥。</p></li><li><p>TLS握手协议由三个子协议组构成，允许对等双方在记录层的安全参数上达成一致、自我认证、例示协商安全参数、互相报告出错条件。</p></li></ul><h2 id="SSL和TLS之间的详细关系"><a href="#SSL和TLS之间的详细关系" class="headerlink" title="SSL和TLS之间的详细关系"></a>SSL和TLS之间的详细关系</h2><p>TLS（Transport Layer Security，传输层安全协议）是IETF制定的一种新的协议，它建立在SSL3.0协议规范之上，是SSL3.0的后续版本。<br>在TLS与SSL3.0之间存在着显著的差别，主要是所支持的<code>加密算法</code>不同,所以TLS与SSL3.0不能互操作。</p><h3 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h3><p> 版本号：TLS记录格式与SSL记录格式相同，但<code>版本号的值不同</code>，TLS的版本1.0使用的版本号为SSLv3.1。</p><p> 报文鉴别码：SSLv3.0和TLS的<code>MAC算法及MAC计算的范围不同</code>。TLS使用了RFC-2104定义的HMAC算法（消息认证代码的密钥散列法）。</p><p>SSLv3.0使用了相似的算法，两者差别在于SSLv3.0中，填充的字节与密钥之间采用的是连接运算，而HMAC算法采用的是异或运算。但是两者的安全程度是相同的。</p><p> 伪随机函数：TLS使用了称为<code>PRF的伪随机函数</code>将密钥扩展成数据块，是更安全的方式。</p><p> 报警代码：TLS支持几乎所有的SSLv3.0报警代码，而且TLS还补充定义了很多的报警代码，<br>如：解密失败（decryption_failed）、记录溢出（record_overflow）、未知CA（unknown_ca）、拒绝访问（access_denied）等。</p><p> 密文族和客户证书：SSLv3.0和TLS存在少量差别，即TLS不支持Fortezza密钥交换、加密算法和客户证书。</p><p> certificate_verify和finished消息：SSLv3.0和TLS在用certificate_verify和finished消息计算MD5和SHA-1散列码时，计算的输入有少许差别，但安全性相当。</p><p> 加密计算：TLS和SSLv3.0在计算主密值（master sercret）时采用的方式不同。</p><p> 填充：用户数据加密之前需要增加的填充字节。在SSL中，填充后的数据长度要达到密文块长度的最小整数倍。</p><p>而在TLS中，<code>填充后的数据长度可以是密文块长度的任意整数倍</code>（但填充的最大长度为255字节），这种方式可以防止基于对报文长度进行分析的攻击。</p><h3 id="TLS的主要增强内容（对比SSL"><a href="#TLS的主要增强内容（对比SSL" class="headerlink" title="TLS的主要增强内容（对比SSL)"></a><strong>TLS的主要增强内容</strong>（对比SSL)</h3><p>TLS的主要目标是使SSL更安全，并使协议的规范更精确和完善。TLS在SSLv3.0的基础上，提供了一下增强内容：<br> 1) 更安全的MAC算法。<br> 2) 更严密的警报。<br> 3) ‘灰色区域’规范的更明确定义。</p><h3 id="TLS对于安全性的改进"><a href="#TLS对于安全性的改进" class="headerlink" title="TLS对于安全性的改进"></a>TLS对于安全性的改进</h3><p> 1) 对于消息认证使用密钥散列法：TLS使用“消息认证代码的密钥散列法”（HMAC），当记录在开放网络（如：英特网）上传送时，该代码确保记录不会被变更。<br>SSLv3.0还提供键控消息认证，但HMAC比SSLv3.0使用的（消息认证代码）MAC功能更安全。<br> 2) 增强的伪随机功能（PRF）：PRF生成密钥数据。在TLS中，HMAC定义PRF。PRF使用两种散列算法保证其安全性。如果任一算法暴露了，只要第二种算法未暴露，则数据仍然是安全的。<br> 3) 改进的已完成消息验证：TLS和SSLv3.0都对两个端点提供已完成的消息，该消息认证交换的消息没有被变更。然而，TLS将此已完成消息基于PRF和HMAC值之上，这也比SSLv3.0更安全。<br> 4) 一致证书处理：与SSLv3.0不同，TLS试图制定必须在TLS之间实现交换的证书类型。<br> 5) 特定警报消息：TLS提供更多的特定和附加警报，以指示任一会话端点检测到的问题。TLS还对合适应该发送某些警报进行记录。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;关系（并列关系）；&lt;/li&gt;
&lt;li&gt;SSL(Secure Socket Layer，安全套接字层)；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HTTP/2&lt;/code&gt;的&lt;code&gt;多路复用&lt;/code&gt;解决要点2的问题；&lt;/li&gt;
&lt;li&gt;不适用于&lt;code&gt;HTTP/2&lt;/code&gt;的优化；&lt;/li&gt;
&lt;li&gt;SSL和TLS之间的详细关系；
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day180-Virtual DOM-再探</title>
    <link href="http://lmislm.com/2019/07/11/2019-07-12/"/>
    <id>http://lmislm.com/2019/07/11/2019-07-12/</id>
    <published>2019-07-10T16:00:00.000Z</published>
    <updated>2019-07-12T14:04:22.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>Virtual DOM的是三个重要步骤；</li><li>Virtual DOM的具体步骤；<a id="more"></a></li></ol><h2 id="Virtual-DOM的是三个重要步骤"><a href="#Virtual-DOM的是三个重要步骤" class="headerlink" title="Virtual DOM的是三个重要步骤"></a>Virtual DOM的是三个重要步骤</h2><ul><li>生成Virtual DOM树</li><li>对比两棵树的差异（diff）</li><li>更新试图（patch）</li></ul><h2 id="Virtual-DOM的具体步骤"><a href="#Virtual-DOM的具体步骤" class="headerlink" title="Virtual DOM的具体步骤"></a>Virtual DOM的具体步骤</h2><h3 id="生成Virtual-DOM树"><a href="#生成Virtual-DOM树" class="headerlink" title="生成Virtual DOM树"></a><strong>生成Virtual DOM树</strong></h3><p>例子：</p><h4 id="真实DOM"><a href="#真实DOM" class="headerlink" title="真实DOM"></a>真实DOM</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="DOM树"><a href="#DOM树" class="headerlink" title="DOM树"></a>DOM树</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> element = &#123;</span><br><span class="line"> tagName: <span class="string">'ul'</span>,</span><br><span class="line"> props: &#123; <span class="attr">id</span>: <span class="string">'list'</span> &#125;,</span><br><span class="line"> children: [</span><br><span class="line">   &#123; <span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">props</span>: &#123; <span class="attr">class</span>: <span class="string">'item'</span> &#125;, <span class="attr">children</span>: [<span class="string">'Item 1'</span>] &#125;,</span><br><span class="line">   &#123; <span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">props</span>: &#123; <span class="attr">class</span>: <span class="string">'item'</span> &#125;, <span class="attr">children</span>: [<span class="string">'Item 2'</span>] &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对比两棵树的差异"><a href="#对比两棵树的差异" class="headerlink" title="对比两棵树的差异"></a><strong>对比两棵树的差异</strong></h3><p>对树进行遍历：深度优先遍历、广度优先遍历</p><p>diff算法中采用深度优先遍历。对新旧两棵树进行一次深度优先的遍历，这样每个节点都会有一个唯一的标记。</p><p>遍历时，每遍历到一个节点就把该节点和新的树的同一个位置的节点进行对比，如果有差异的话就记录到一个对象（差异对象）里面。</p><h4 id="差异对象（常见的差异）"><a href="#差异对象（常见的差异）" class="headerlink" title="差异对象（常见的差异）"></a>差异对象（常见的差异）</h4><p>替换节点<br>增加/删除子节点<br>修改节点属性<br>改变文本内容</p><h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a><strong>更新视图</strong></h3><p>根据差异的不同类型，对DOM进行针对性的更新。<br>更新视图（针对相应差异的更新方法）<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">replaceChild()</span><br><span class="line">appendChild() / removeChild()</span><br><span class="line">setAttribute() / removeAttribute()</span><br><span class="line">textContent</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Virtual DOM的是三个重要步骤；&lt;/li&gt;
&lt;li&gt;Virtual DOM的具体步骤；
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day178-HTTP协议-多路复用</title>
    <link href="http://lmislm.com/2019/07/10/2019-07-10/"/>
    <id>http://lmislm.com/2019/07/10/2019-07-10/</id>
    <published>2019-07-09T16:00:00.000Z</published>
    <updated>2019-07-11T14:36:21.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li><code>Keep-Alive</code>。</li><li><code>HTTP1.1</code>存在的问题。</li><li><code>HTTP/2</code>的<code>多路复用</code>解决要点2的问题。</li><li>不适用于<code>HTTP/2</code>的优化。<a id="more"></a></li></ol><h2 id="Keep-Alive"><a href="#Keep-Alive" class="headerlink" title="Keep-Alive"></a>Keep-Alive</h2><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>每次请求都会建立一次HTTP连接,即<code>3次握手</code>和<code>四次挥手</code>。一个长连接时就会有多次不间断请求数据和建立连接的过程。</p><p>如果第一次建立连接，就一直占用通道，就省去多次请求过程，<br>即：<code>Keep-Alive</code>。</p><h3 id="详细（Keep-Alive解决的核心问题）"><a href="#详细（Keep-Alive解决的核心问题）" class="headerlink" title="详细（Keep-Alive解决的核心问题）"></a>详细（Keep-Alive解决的核心问题）</h3><p>规定的时间内，同一个域名多次请求数据，只建立一次HTTP请求，其他请求可复用每次建立的连接通道，以达到提高请求效率的问题。</p><h2 id="HTTP1-1的其他问题"><a href="#HTTP1-1的其他问题" class="headerlink" title="HTTP1.1的其他问题"></a>HTTP1.1的其他问题</h2><ul><li><code>Keep-Alive</code>解决多次连接问题</li></ul><ol><li>文件传输是<code>串行</code>进行。<br>在<code>HTTP1.1</code>协议中，传输的<code>request</code>和<code>response</code>都是基于文本的，所有的数据必须按顺序串行传输，这样接收端才能知道原本的顺序。</li><li>连接数过多。最大并发数有限为<code>50</code>(Apache)。</li></ol><h2 id="HTTP-2的多路复用"><a href="#HTTP-2的多路复用" class="headerlink" title="HTTP/2的多路复用"></a>HTTP/2的多路复用</h2><ul><li>解决以上的<code>HTTP1.1</code>中两个问题</li></ul><ol><li>解决文件串行传输。<br><code>HTTP/2</code>引入<code>二进制数据帧</code>和<code>流</code>的概念。<code>帧</code>对数据进行顺序标识,这样才能并行传输，接收端才能按照序列（即：顺序标识）对数据进行合并。<br><code>流</code>（服务器并行传输数据）。</li><li>解决连接数过多。<br>HTTP/2对同一域名下所有请求都是基于<code>流</code>,不管访问多少个文件，都只建立<strong>一路连接</strong>。<br>最大并发提升到了300(Apache)。</li></ol><h2 id="不适用于HTTP-2的优化"><a href="#不适用于HTTP-2的优化" class="headerlink" title="不适用于HTTP/2的优化"></a>不适用于HTTP/2的优化</h2><ol><li><p>JS文件合并。<br>上线时把所有多个模块代码压缩合并成一个文件，减少HTTP的请求数。但是其中某个模块改了之后，所有的文件都需要重新下载，不能被缓存。<br><code>HTTP/2</code>里，模块可以单独压缩上线不影响其他没有修改的模块。</p></li><li><p>多域名的下载速度<br>当css文件和js文件放到两个域名下面时，可以避免浏览器的<strong>6个通道限制</strong>(对于同一个协议、域名、端口，浏览器允许同时打开个 TCP 连接，一般上限为 6 个)。</p></li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>HTTP/2解决了这些缺点</li></ul><ol><li>DNS解析时间变长。</li><li>增加服务器压力。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Keep-Alive&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HTTP1.1&lt;/code&gt;存在的问题。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HTTP/2&lt;/code&gt;的&lt;code&gt;多路复用&lt;/code&gt;解决要点2的问题。&lt;/li&gt;
&lt;li&gt;不适用于&lt;code&gt;HTTP/2&lt;/code&gt;的优化。
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day177-TypeScript基础小记-构造函数</title>
    <link href="http://lmislm.com/2019/07/09/2019-07-09/"/>
    <id>http://lmislm.com/2019/07/09/2019-07-09/</id>
    <published>2019-07-08T16:00:00.000Z</published>
    <updated>2019-07-11T14:36:17.746Z</updated>
    
    <content type="html"><![CDATA[<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ol><li>构造函数。</li><li>编译成JavaScript后。</li><li>把类当做接口使用。<a id="more"></a></li></ol><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><blockquote><p>简单的构造函数</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">  greeting: string</span><br><span class="line">  <span class="keyword">constructor</span>(message: string) &#123;</span><br><span class="line">    <span class="keyword">this</span>.greeting = message</span><br><span class="line">  &#125;</span><br><span class="line">  greet() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello,'</span> + <span class="keyword">this</span>.greeting</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> greeter: Greeter <span class="comment">// Greeter类的实例的类型是Greeter</span></span><br><span class="line">greeter = <span class="keyword">new</span> Greeter(<span class="string">'TypeScript'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(greeter.greet())</span><br></pre></td></tr></table></figure><h3 id="编译成JavaScript"><a href="#编译成JavaScript" class="headerlink" title="编译成JavaScript"></a>编译成JavaScript</h3><blockquote><p><code>let Greeter</code>被赋值为<code>构造函数</code>。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Greeter = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Greeter</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.greeting = message</span><br><span class="line">  &#125;</span><br><span class="line">  Greeter.prototype.greet = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello,'</span> + <span class="keyword">this</span>.greeting</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Greeter</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">let</span> greeter</span><br><span class="line">greeter = <span class="keyword">new</span> Greeter(<span class="string">'world'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(greeter.greet())</span><br></pre></td></tr></table></figure><blockquote><p>例子改写</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> standardGreeting = <span class="string">'hello, there'</span></span><br><span class="line">  greeting: string</span><br><span class="line">  greet () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.greeting) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'hello,'</span> + <span class="keyword">this</span>.greeting</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Greeter.standardGreeting</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> greeter1: Greeter</span><br><span class="line">greeter1 = <span class="keyword">new</span> Greeter()</span><br><span class="line"><span class="built_in">console</span>.log(greeter1)</span><br><span class="line"><span class="comment">// typeof Greeter意思取Greeter类的类型，而不是实例类型。</span></span><br><span class="line"><span class="keyword">let</span> greeterMaker: <span class="keyword">typeof</span> Greeter = Greeter</span><br><span class="line">greeterMaker.standardGreeting = <span class="string">'Hey there!'</span></span><br><span class="line"><span class="keyword">let</span> greeter2: Greeter = <span class="keyword">new</span> greeterMaker()</span><br><span class="line"><span class="built_in">console</span>.log(greeter2.greet())</span><br></pre></td></tr></table></figure><h3 id="类当做接口使用"><a href="#类当做接口使用" class="headerlink" title="类当做接口使用"></a>类当做接口使用</h3><blockquote><p>类定义会创建两个东西：<br>类的实例累心和一个构造函数（因为类可以创建出类型，所以你能够在允许使用接口的地方使用类）<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  x: number</span><br><span class="line">  y: number</span><br><span class="line">&#125;</span><br><span class="line">interface Point3d extends Point &#123;</span><br><span class="line">  z: number</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> point3d: Point3d = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;构造函数。&lt;/li&gt;
&lt;li&gt;编译成JavaScript后。&lt;/li&gt;
&lt;li&gt;把类当做接口使用。
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day176-数组-嵌套数组-nested Array</title>
    <link href="http://lmislm.com/2019/07/08/2019-07-08/"/>
    <id>http://lmislm.com/2019/07/08/2019-07-08/</id>
    <published>2019-07-07T16:00:00.000Z</published>
    <updated>2019-07-11T14:36:14.116Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>给出特定结构的数据，转换成特定的数据结构。</p><ol><li><code>deepMerge</code>, <code>groupBy</code></li><li><code>flattenDeep</code>, nested Array(嵌套数组)<a id="more"></a></li></ol><h2 id="源数组-gt-目标数组"><a href="#源数组-gt-目标数组" class="headerlink" title="源数组-&gt;目标数组"></a>源数组-&gt;目标数组</h2><blockquote><p>源数据<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">'文风'</span>: &#123;</span><br><span class="line">      <span class="string">'过译'</span>: [</span><br><span class="line">        &#123; <span class="string">'errorLevel'</span>: <span class="string">'一般般'</span>, <span class="string">'count'</span>: <span class="number">5</span> &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="string">'漏译'</span>: [</span><br><span class="line">        &#123; <span class="string">'errorLevel'</span>: <span class="string">'非常严重'</span>, <span class="string">'count'</span>: <span class="number">2</span> &#125;,</span><br><span class="line">        &#123; <span class="string">'errorLevel'</span>: <span class="string">'一般般'</span>, <span class="string">'count'</span>: <span class="number">10</span> &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">'增译'</span>: [</span><br><span class="line">        &#123; <span class="string">'errorLevel'</span>: <span class="string">'非常严重'</span>, <span class="string">'count'</span>: <span class="number">22</span> &#125;,</span><br><span class="line">        &#123; <span class="string">'errorLevel'</span>: <span class="string">'一般般'</span>, <span class="string">'count'</span>: <span class="number">10</span> &#125;</span><br><span class="line">      ]</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>目标数组<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> res = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'一般般'</span>, <span class="attr">count</span>: <span class="number">27</span>, <span class="string">'过译'</span>: <span class="number">10</span>, <span class="string">'漏译'</span>: <span class="number">20</span>, <span class="string">'增译'</span>: <span class="number">22</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'非常严重'</span>, <span class="attr">count</span>: <span class="number">24</span>, <span class="string">'漏译'</span>: <span class="number">4</span>, <span class="string">'增译'</span>: <span class="number">44</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'重大错误'</span>, <span class="attr">count</span>: <span class="number">10</span>, <span class="string">'过译'</span>: <span class="number">10</span> &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="两步"><a href="#两步" class="headerlink" title="两步"></a>两步</h2><ol><li>先降维处理成一维数组</li><li>根据一维数组相关属性<code>groupBy</code></li></ol><h3 id="降维处理"><a href="#降维处理" class="headerlink" title="降维处理"></a>降维处理</h3><ul><li>注意不需要第一层的<code>keys</code>。</li><li><code>_.</code>是loadshjs的方法。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatData</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 去掉了术语、文风等</span></span><br><span class="line">  <span class="keyword">let</span> res = (data || []).map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> mergedData = _.mergeWith(&#123;&#125;, ...Object.values(item), (obj, src) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> (obj || []).concat(src)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.entries(mergedData).map(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 转为多层嵌套数组</span></span><br><span class="line">      <span class="keyword">return</span> [...value.map(<span class="function"><span class="params">item</span> =&gt;</span> (&#123;...item, <span class="attr">type</span>: key&#125;))]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> _.flattenDeep(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组分类"><a href="#数组分类" class="headerlink" title="数组分类"></a>数组分类</h3><p>由<code>嵌套数组</code>得出的结果进行数组归类。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nest</span> (<span class="params">seq, keys</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!keys.length) <span class="keyword">return</span> seq</span><br><span class="line">  <span class="keyword">let</span> first = keys[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> rest = keys.slice(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> mapValues(groupBy(seq, first), (value) =&gt; &#123;</span><br><span class="line">    <span class="comment">// return &#123; ...nest(value, rest) &#125;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(nest(value, rest))) &#123;</span><br><span class="line">      <span class="comment">// reduce by prop count</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function">(<span class="params">nest(value, rest</span>) || []).<span class="params">reduce</span>(<span class="params">(acc, obj</span>) =&gt;</span> (acc + obj[<span class="string">'count'</span>]), <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// return &#123; ...item, item: '122'&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> nest(value, rest)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;p&gt;给出特定结构的数据，转换成特定的数据结构。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;deepMerge&lt;/code&gt;, &lt;code&gt;groupBy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flattenDeep&lt;/code&gt;, nested Array(嵌套数组)
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day175-contenteditable（2）</title>
    <link href="http://lmislm.com/2019/07/07/2019-07-07/"/>
    <id>http://lmislm.com/2019/07/07/2019-07-07/</id>
    <published>2019-07-06T16:00:00.000Z</published>
    <updated>2019-07-11T14:36:09.442Z</updated>
    
    <content type="html"><![CDATA[<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><p><strong>contenteditable</strong><br>这里是<code>contentedtable</code>的第二种写法。<br><a id="more"></a></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>VEdit组件</p><blockquote><p>VEdit vue2 实现 div contenteditable=”true” 类似于 v-model 的效果</p><ul><li>参考<br><a href="https://segmentfault.com/a/1190000008261449#articleHeader1" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008261449#articleHeader1</a><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div</span><br><span class="line">    ref=<span class="string">"diveditable"</span></span><br><span class="line">    v-html=<span class="string">"innerText"</span></span><br><span class="line">    :contenteditable=<span class="string">"canEdit"</span></span><br><span class="line">    @input=<span class="string">"changeText"</span></span><br><span class="line">    @focus=<span class="string">"isLocked = true"</span></span><br><span class="line">    @blur=<span class="string">"isLocked = false"</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span></span>=<span class="string">"v-edit"</span></span><br><span class="line">  &gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'VEdit'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">''</span></span><br><span class="line">    &#125;,</span><br><span class="line">    canEdit: &#123;</span><br><span class="line">      type: <span class="built_in">Boolean</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      innerText: <span class="keyword">this</span>.value,</span><br><span class="line">      isLocked: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="string">'value'</span> () &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.isLocked || !<span class="keyword">this</span>.innerText) &#123;</span><br><span class="line">        <span class="keyword">this</span>.innerText = <span class="keyword">this</span>.value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeText () &#123;</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, <span class="keyword">this</span>.$el.innerHTML)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;style lang='less' scoped&gt;</span></span><br><span class="line"><span class="regexp">.v-edit &#123;</span></span><br><span class="line"><span class="regexp">  width: 100%;</span></span><br><span class="line"><span class="regexp">  height: 100%;</span></span><br><span class="line"><span class="regexp">  overflow: auto;</span></span><br><span class="line"><span class="regexp">  word-break: break-all;</span></span><br><span class="line"><span class="regexp">  outline: none;</span></span><br><span class="line"><span class="regexp">  user-select: text;</span></span><br><span class="line"><span class="regexp">  white-space: pre-wrap;</span></span><br><span class="line"><span class="regexp">  text-align: left;</span></span><br><span class="line"><span class="regexp">  &amp;[contenteditable=true]&#123;</span></span><br><span class="line"><span class="regexp">    user-modify: read-write-plaintext-only;</span></span><br><span class="line"><span class="regexp">    &amp;:empty:before &#123;</span></span><br><span class="line"><span class="regexp">      content: attr(placeholder);</span></span><br><span class="line"><span class="regexp">      display: block;</span></span><br><span class="line"><span class="regexp">      color: #ccc;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;contenteditable&lt;/strong&gt;&lt;br&gt;这里是&lt;code&gt;contentedtable&lt;/code&gt;的第二种写法。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day174-contenteditable</title>
    <link href="http://lmislm.com/2019/07/06/2019-07-06/"/>
    <id>http://lmislm.com/2019/07/06/2019-07-06/</id>
    <published>2019-07-05T16:00:00.000Z</published>
    <updated>2019-07-11T14:24:18.474Z</updated>
    
    <content type="html"><![CDATA[<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><p><strong>contenteditable</strong><br>利用<code>contenteditable</code>来做行内编辑。与利用<code>input</code>的区别是，能够保留内容的样式，而<code>input</code>内输入的是纯文本。<br>这里依靠<code>Vue2</code>做了一个小组件。<br><a id="more"></a></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>EditDiv组件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- EditDiv Vue <span class="number">2</span> contentEditable <span class="keyword">with</span> v-model --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div</span><br><span class="line">    ref=<span class="string">"diveditable"</span></span><br><span class="line">    contenteditable</span><br><span class="line">    v-on=<span class="string">"listeners"</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span></span>=<span class="string">"edit-div"</span></span><br><span class="line">  &gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'EditDiv'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    listeners () &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...this.$listeners, <span class="attr">input</span>: <span class="keyword">this</span>.onInput &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="keyword">this</span>.$refs.diveditable.innerText = <span class="keyword">this</span>.value</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onInput (e) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, e.target.innerText)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;style lang='less' scoped&gt;</span></span><br><span class="line"><span class="regexp">.edit-div &#123;</span></span><br><span class="line"><span class="regexp">    width: 100%;</span></span><br><span class="line"><span class="regexp">    height: 100%;</span></span><br><span class="line"><span class="regexp">    overflow: auto;</span></span><br><span class="line"><span class="regexp">    word-break: break-all;</span></span><br><span class="line"><span class="regexp">    outline: none;</span></span><br><span class="line"><span class="regexp">    user-select: text;</span></span><br><span class="line"><span class="regexp">    white-space: pre-wrap;</span></span><br><span class="line"><span class="regexp">    text-align: left;</span></span><br><span class="line"><span class="regexp">    &amp;[contenteditable=true]&#123;</span></span><br><span class="line"><span class="regexp">      user-modify: read-write-plaintext-only;</span></span><br><span class="line"><span class="regexp">      &amp;:empty:before &#123;</span></span><br><span class="line"><span class="regexp">        content: attr(placeholder);</span></span><br><span class="line"><span class="regexp">        display: block;</span></span><br><span class="line"><span class="regexp">        color: #ccc;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;contenteditable&lt;/strong&gt;&lt;br&gt;利用&lt;code&gt;contenteditable&lt;/code&gt;来做行内编辑。与利用&lt;code&gt;input&lt;/code&gt;的区别是，能够保留内容的样式，而&lt;code&gt;input&lt;/code&gt;内输入的是纯文本。&lt;br&gt;这里依靠&lt;code&gt;Vue2&lt;/code&gt;做了一个小组件。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day173-数组-结构转换</title>
    <link href="http://lmislm.com/2019/07/05/2019-07-05/"/>
    <id>http://lmislm.com/2019/07/05/2019-07-05/</id>
    <published>2019-07-04T16:00:00.000Z</published>
    <updated>2019-07-11T14:24:18.473Z</updated>
    
    <content type="html"><![CDATA[<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><p>给出特定结构的数据，转换成特定的数据结构。</p><ol><li>循环</li><li>递归<a id="more"></a></li></ol><h3 id="源数组-gt-目标数组"><a href="#源数组-gt-目标数组" class="headerlink" title="源数组-&gt;目标数组"></a>源数组-&gt;目标数组</h3><blockquote><p>源数组<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">'文风'</span>: &#123;</span><br><span class="line">      <span class="string">'过译'</span>: [</span><br><span class="line">        &#123; <span class="string">'errorLevel'</span>: <span class="string">'一般般'</span>, <span class="string">'count'</span>: <span class="number">5</span> &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="string">'漏译'</span>: [</span><br><span class="line">        &#123; <span class="string">'errorLevel'</span>: <span class="string">'非常严重'</span>, <span class="string">'count'</span>: <span class="number">2</span> &#125;,</span><br><span class="line">        &#123; <span class="string">'errorLevel'</span>: <span class="string">'一般般'</span>, <span class="string">'count'</span>: <span class="number">10</span> &#125;</span><br><span class="line">      ]</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>目标数组<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> res = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'文风'</span>, <span class="string">'过译'</span>: <span class="number">5</span>, <span class="string">'漏译'</span>: <span class="number">12</span>, <span class="string">'增译'</span>: <span class="number">3</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'准确性'</span>, <span class="string">'过译'</span>: <span class="number">21</span>, <span class="string">'漏译'</span>: <span class="number">20</span>, <span class="string">'增译'</span>: <span class="number">10</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'流畅性'</span>, <span class="string">'过译'</span>: <span class="number">9</span>, <span class="string">'漏译'</span>: <span class="number">12</span>, <span class="string">'增译'</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'术语'</span>,  <span class="string">'过译'</span>: <span class="number">34</span>, <span class="string">'漏译'</span>: <span class="number">24</span>, <span class="string">'增译'</span>: <span class="number">34</span> &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.entries(...data).map(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> newVal = <span class="built_in">Object</span>.entries(value).map(<span class="function">(<span class="params">[objkey, objVal]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> objVals = [...objVal].reduce(<span class="function">(<span class="params">acc, obj</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(k)) &#123;</span><br><span class="line">          acc[k] = (acc[k] || <span class="number">0</span>) + obj[k]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> acc</span><br><span class="line">    &#125;, &#123;&#125;)[<span class="string">'count'</span>]</span><br><span class="line">    <span class="keyword">return</span> &#123;[objkey]: objVals&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">name</span>: key, ...Object.assign(...newVal), <span class="attr">total</span>: sum &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// return [].concat(obj)</span></span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatData</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> object[i] == <span class="keyword">typeof</span> &#123;&#125;)&#123;</span><br><span class="line">      flatData(object[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(object[i])</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(object[i])) &#123;</span><br><span class="line">      <span class="keyword">let</span> tmp = object[i]</span><br><span class="line">      object[i] = tmp.reduce(<span class="function">(<span class="params">acc, obj</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">          <span class="keyword">if</span> (obj.hasOwnProperty(k)) &#123;</span><br><span class="line">            acc[k] = (acc[k] || <span class="number">0</span>) + obj[k]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> acc</span><br><span class="line">      &#125;, &#123;&#125;)[<span class="string">'count'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// return object</span></span><br><span class="line">&#125;</span><br><span class="line">flatData(data)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h3&gt;&lt;p&gt;给出特定结构的数据，转换成特定的数据结构。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;循环&lt;/li&gt;
&lt;li&gt;递归
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day172-TypeScript基础小记-抽象类</title>
    <link href="http://lmislm.com/2019/07/04/2019-07-04/"/>
    <id>http://lmislm.com/2019/07/04/2019-07-04/</id>
    <published>2019-07-03T16:00:00.000Z</published>
    <updated>2019-07-11T14:24:18.473Z</updated>
    
    <content type="html"><![CDATA[<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ol><li><code>abstract</code>关键字。</li><li>抽象方法。<a id="more"></a></li></ol><h3 id="abstract关键字"><a href="#abstract关键字" class="headerlink" title="abstract关键字"></a><code>abstract</code>关键字</h3><blockquote><p>抽象类做其他<code>派生类</code>的<code>基类</code>使用。抽象类一般不会直接被<code>实例化</code>。</p></blockquote><blockquote><p>抽象类可以包含成员的实现细节。<br><code>abstract</code>关键字是用于定义<code>抽象类</code>和在抽象类内部定义抽象方法。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  abstract makeSound(): <span class="keyword">void</span></span><br><span class="line">  move(): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'到处走'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><blockquote><p><code>抽象类</code>中的<code>抽象方法</code>不包含具体实现并且必须在<code>派生类</code>中实现。<code>抽象方法</code>的语法与<code>接口方法</code>相似。</p></blockquote><blockquote><p>两者都是定义<code>方法签名</code>但不包含<code>方法体</code>。然而，<code>抽象方法</code>必须包含<code>abstract</code>关键字并且可以包含<code>访问修饰符</code>。 </p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(public name: string) &#123;&#125;</span><br><span class="line">  printName(): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Department name:'</span> + <span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">  abstract printMeeting(): <span class="keyword">void</span> <span class="comment">// 必须在派生类中实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountingDepartment</span> <span class="keyword">extends</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">'银行'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  printMeeting(): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'银行每周一早上10点开门'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  generateReports(): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'生成银行报告'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> department: Department <span class="comment">// 允许创建一个对抽象类型的引用</span></span><br><span class="line"><span class="comment">// department = new Department() // 无法创建抽象类的实例。ts(2511)</span></span><br><span class="line">department = <span class="keyword">new</span> AccountingDepartment() <span class="comment">// 允许对一个抽象子类进行实例化和赋值</span></span><br><span class="line">department.printMeeting()</span><br><span class="line">department.printName()</span><br><span class="line">department.generateReports() <span class="comment">// 类型“Department”上不存在属性“generateReports”。ts(2339)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;abstract&lt;/code&gt;关键字。&lt;/li&gt;
&lt;li&gt;抽象方法。
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day171-获取图片原始长宽</title>
    <link href="http://lmislm.com/2019/07/03/2019-07-03/"/>
    <id>http://lmislm.com/2019/07/03/2019-07-03/</id>
    <published>2019-07-02T16:00:00.000Z</published>
    <updated>2019-07-11T14:24:18.472Z</updated>
    
    <content type="html"><![CDATA[<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ol><li>base64图片的长宽。</li><li>图片长宽。</li><li>“src图片”的长宽。<a id="more"></a></li></ol><h3 id="base64图片"><a href="#base64图片" class="headerlink" title="base64图片"></a>base64图片</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPngDimensions</span> (<span class="params">base64</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> header = atob(base64.slice(<span class="number">0</span>, <span class="number">50</span>)).slice(<span class="number">16</span>, <span class="number">24</span>)</span><br><span class="line">  <span class="keyword">const</span> uint8 = <span class="built_in">Uint8Array</span>.from(header, c =&gt; c.charCodeAt(<span class="number">0</span>))</span><br><span class="line">  <span class="keyword">const</span> dataView = <span class="keyword">new</span> <span class="built_in">DataView</span>(uint8.buffer)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    width: dataView.getInt32(<span class="number">0</span>),</span><br><span class="line">    height: dataView.getInt32(<span class="number">4</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图片长宽"><a href="#图片长宽" class="headerlink" title="图片长宽"></a>图片长宽</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">imageElement.naturalHeight</span><br><span class="line">imageElement.naturalWidth</span><br></pre></td></tr></table></figure><h3 id="“src图片”"><a href="#“src图片”" class="headerlink" title="“src图片”"></a>“src图片”</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">img.src = <span class="string">'http://www.google.com/intl/en_ALL/images/logo.gif'</span></span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.width + <span class="string">'x'</span> + <span class="keyword">this</span>.height)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://stackoverflow.com/questions/623172/how-to-get-image-size-height-width-using-javascript" target="_blank" rel="noopener">https://stackoverflow.com/questions/623172/how-to-get-image-size-height-width-using-javascript</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;base64图片的长宽。&lt;/li&gt;
&lt;li&gt;图片长宽。&lt;/li&gt;
&lt;li&gt;“src图片”的长宽。
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day170-TypeScript基础小记-参数属性</title>
    <link href="http://lmislm.com/2019/07/02/2019-07-02/"/>
    <id>http://lmislm.com/2019/07/02/2019-07-02/</id>
    <published>2019-07-01T16:00:00.000Z</published>
    <updated>2019-07-11T14:24:18.471Z</updated>
    
    <content type="html"><![CDATA[<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ol><li>存取器。</li><li>静态属性。<a id="more"></a></li></ol><h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><p>例子1</p><blockquote><p>把简单的类改写成使用<code>get</code>和<code>set</code>。<br>注意：只带<code>get</code>不带有<code>set</code>的存取器自动被推断为readonly</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 随意修改全名</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  fullName: string</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee()</span><br><span class="line">employee.fullName = <span class="string">'二柱子'</span></span><br><span class="line"><span class="keyword">if</span> (employee.fullName) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(employee.fullName)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加密，不让随意修改全名</span></span><br><span class="line"><span class="keyword">let</span> passcode = <span class="string">'secret passcode'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  private _fullName: string</span><br><span class="line">  <span class="keyword">get</span> fullName (): string &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._fullName</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> fullName (newName: string) &#123;</span><br><span class="line">    <span class="keyword">if</span> (passcode &amp;&amp; passcode == <span class="string">'secret passcode'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>._fullName = newName</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Error: 认证错误！又想把人名字改成二柱子！'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee()</span><br><span class="line">employee.fullName = <span class="string">"铁蛋"</span></span><br><span class="line"><span class="keyword">if</span> (employee.fullName) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(employee.fullName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><ol><li>这些属性存在类<code>本身</code>上而不是类的<code>实例</code>上。</li><li>例子1<blockquote><p>使用<code>static</code>定义<code>origin</code>，因为<code>origin</code>是所有网格都会用到的属性。每个实例访问该属性时，都要在<code>origin</code>前面加上类名。<br>如同在<code>实例属性</code>上使用<code>this.</code>前缀来访问<code>属性</code>，本例子用<code>Grid.</code>来访问<code>静态属性</code>。</p></blockquote></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grid</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> origin = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;</span><br><span class="line">  <span class="keyword">constructor</span> (public scale: number) &#123;&#125;</span><br><span class="line">  calculateDistanceFromOrigin (point: &#123; <span class="attr">x</span>: number, <span class="attr">y</span>: number &#125;) &#123;</span><br><span class="line">    <span class="keyword">let</span> xDis = (point.x - Grid.origin.x)</span><br><span class="line">    <span class="keyword">let</span> yDis = (point.y - Grid.origin.y)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(xDis * xDis + yDis * yDis) / <span class="keyword">this</span>.scale</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> grid1 = <span class="keyword">new</span> Grid(<span class="number">1.0</span>)</span><br><span class="line"><span class="keyword">let</span> grid2 = <span class="keyword">new</span> Grid(<span class="number">2.0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(grid1.calculateDistanceFromOrigin(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span>&#125;))</span><br><span class="line"><span class="built_in">console</span>.log(grid2.calculateDistanceFromOrigin(&#123;<span class="attr">x</span>: <span class="number">2</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;存取器。&lt;/li&gt;
&lt;li&gt;静态属性。
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day169-手写debounce</title>
    <link href="http://lmislm.com/2019/07/01/2019-07-01/"/>
    <id>http://lmislm.com/2019/07/01/2019-07-01/</id>
    <published>2019-06-30T16:00:00.000Z</published>
    <updated>2019-07-11T14:24:18.471Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>手写防抖函数<code>debounce</code>。<br>防抖和节流的区别：<br>防抖：一定时间内只执行最后一次（非立即执行），如：<code>window</code>触发<code>resize</code>，<code>search搜索</code>联想。<br>节流：一定时间内只执行一次，如：多次连续点击按钮，防抖只执行一次；<code>rAF</code>。<br><a id="more"></a></p><h3 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout, args, ctx, timestamp, result</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> later = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 距离上一次触发时间间隔</span></span><br><span class="line">    <span class="keyword">const</span> last = +<span class="keyword">new</span> <span class="built_in">Date</span>() - timestamp</span><br><span class="line">    <span class="comment">// wait: 当前时间间隔；lat：上次被包装函数调用的时间间隔</span></span><br><span class="line">    <span class="keyword">if</span> (wait &gt; last &amp;&amp; last &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 继续等待一定时间执行</span></span><br><span class="line">      timeout = setTimeout(later, wait - last)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 超过约定的时间</span></span><br><span class="line">      timeout = <span class="literal">null</span></span><br><span class="line">      <span class="comment">// 前提是没有设置立即执行</span></span><br><span class="line">      <span class="keyword">if</span> (!immediate) &#123;</span><br><span class="line">        <span class="comment">// 可以立即执行</span></span><br><span class="line">        result = func.apply(ctx, args)</span><br><span class="line">        <span class="comment">// 第一次执行完毕，重置各种条件</span></span><br><span class="line">        <span class="keyword">if</span> (!timeout) ctx = args = <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    ctx = <span class="keyword">this</span></span><br><span class="line">    timestamp = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    <span class="keyword">const</span> callImmediate = immediate &amp;&amp; !timeout</span><br><span class="line">    <span class="comment">// 非立即执行</span></span><br><span class="line">    <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">      timeout = setTimeout(later, wait)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 立即执行</span></span><br><span class="line">    <span class="keyword">if</span> (callImmediate) &#123;</span><br><span class="line">      result = func.apply(ctx, args)</span><br><span class="line">      ctx = args = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;手写防抖函数&lt;code&gt;debounce&lt;/code&gt;。&lt;br&gt;防抖和节流的区别：&lt;br&gt;防抖：一定时间内只执行最后一次（非立即执行），如：&lt;code&gt;window&lt;/code&gt;触发&lt;code&gt;resize&lt;/code&gt;，&lt;code&gt;search搜索&lt;/code&gt;联想。&lt;br&gt;节流：一定时间内只执行一次，如：多次连续点击按钮，防抖只执行一次；&lt;code&gt;rAF&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day168-TypeScript基础小记-private与protected</title>
    <link href="http://lmislm.com/2019/06/30/2019-06-30/"/>
    <id>http://lmislm.com/2019/06/30/2019-06-30/</id>
    <published>2019-06-29T16:00:00.000Z</published>
    <updated>2019-07-11T14:24:18.470Z</updated>
    
    <content type="html"><![CDATA[<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ol><li><code>private</code>、<code>protected</code>类型的比较。</li><li><code>private</code>、<code>protected</code>修饰符。</li><li><code>protected</code>与类。<a id="more"></a></li></ol><h3 id="类型比较"><a href="#类型比较" class="headerlink" title="类型比较"></a>类型比较</h3><ol><li>比较不同的类型时，如果所有成员类型都是兼容的，就认为类型是兼容的。</li><li>比较<code>private</code>或<code>protected</code>成员的类型时，只有来自<strong>同一处声明</strong>时，才认为两个类型是<strong>兼容</strong>的。</li></ol><p>例子1<br><code>Employee</code>赋值给<code>Animal</code>时，类型不兼容，因为<code>Employee</code>里也有一个<code>私有成员name</code>，但并不是<code>Animal</code>里面定义的那个。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  private name: string</span><br><span class="line">  <span class="keyword">constructor</span>(theName: string) &#123; <span class="keyword">this</span>.name = theName &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rhino</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; <span class="keyword">super</span>(<span class="string">'犀牛哥已提前就位'</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">  private name: string</span><br><span class="line">  <span class="keyword">constructor</span>(theName: string) &#123; <span class="keyword">this</span>.name = theName &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal(<span class="string">'羊总'</span>)</span><br><span class="line"><span class="keyword">let</span> rhino = <span class="keyword">new</span> Rhino()</span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee(<span class="string">'护林员'</span>)</span><br><span class="line">animal = rhino</span><br><span class="line"><span class="comment">// 不能将类型“Employee”分配给类型“Animal”。类型具有私有属性“name”的单独声明。ts(2322)</span></span><br><span class="line"><span class="comment">// 注意定义的private name相同</span></span><br><span class="line">animal = employee</span><br></pre></td></tr></table></figure></p><h3 id="private、protected修饰符"><a href="#private、protected修饰符" class="headerlink" title="private、protected修饰符"></a><code>private</code>、<code>protected</code>修饰符</h3><ol><li><p><code>protected</code> 修饰符与 <code>private</code> 修饰符的行为相似，但有不同，<code>protected</code> 成员在<code>派生类</code>中仍然可以访问。</p></li><li><p>例子1</p><blockquote><p>不能在<code>Person</code>类外使用<code>name</code>，但是可以通过子类<code>Employee</code>类实例方法访问，因为<code>Employee</code>是由<code>Person</code>派生而来。</p></blockquote></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  protected name: string</span><br><span class="line">  <span class="keyword">constructor</span>(name: string) &#123; <span class="keyword">this</span>.name = name &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  private department: string</span><br><span class="line">  <span class="keyword">constructor</span>(name: string, department: string) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name)</span><br><span class="line">    <span class="keyword">this</span>.department = department</span><br><span class="line">  &#125;</span><br><span class="line">  public getElevatorPitch () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`你好，老弟。我叫 <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> 在附近 <span class="subst">$&#123;<span class="keyword">this</span>.department&#125;</span> 工作`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> howard = <span class="keyword">new</span> Employee(<span class="string">'小刘'</span>, <span class="string">'小卖部'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(howard.getElevatorPitch())</span><br><span class="line"><span class="comment">// 属性“name”受保护，只能在类“Person”及其子类中访问。ts(2445)</span></span><br><span class="line"><span class="built_in">console</span>.log(howard.name)</span><br></pre></td></tr></table></figure><h3 id="protected与类"><a href="#protected与类" class="headerlink" title="protected与类"></a><code>protected</code>与类</h3><p><code>构造函数</code>也可以被标记成<code>protected</code>。意味着，这个类不能在包含它的类外被<code>实例化</code>，但是能被继承<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  protected name: string</span><br><span class="line">  protected <span class="keyword">constructor</span>(theName: string) &#123; <span class="keyword">this</span>.name = theName &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  private department: string</span><br><span class="line">  <span class="keyword">constructor</span>(name: string, department: string) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name)</span><br><span class="line">    <span class="keyword">this</span>.department = department</span><br><span class="line">  &#125;</span><br><span class="line">  public getElevatorPitch () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`你好，老哥。我叫<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>，我家搁附近<span class="subst">$&#123;<span class="keyword">this</span>.department&#125;</span>。`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> howard = <span class="keyword">new</span> Employee(<span class="string">'二柱子'</span>, <span class="string">'洞拐八拐银行附近'</span>)</span><br><span class="line"><span class="comment">// 类“Person”的构造函数是受保护的，仅可在类声明中访问。ts(2674)</span></span><br><span class="line"><span class="keyword">let</span> john = <span class="keyword">new</span> Person(<span class="string">'铁蛋'</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;private&lt;/code&gt;、&lt;code&gt;protected&lt;/code&gt;类型的比较。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;private&lt;/code&gt;、&lt;code&gt;protected&lt;/code&gt;修饰符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;protected&lt;/code&gt;与类。
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day167-TypeScript基础小记-类（2）</title>
    <link href="http://lmislm.com/2019/06/29/2019-06-29/"/>
    <id>http://lmislm.com/2019/06/29/2019-06-29/</id>
    <published>2019-06-28T16:00:00.000Z</published>
    <updated>2019-07-11T14:24:18.469Z</updated>
    
    <content type="html"><![CDATA[<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ol><li>类的例子</li><li>继承</li><li>公共、私有与受保护的修饰符<a id="more"></a></li></ol><h3 id="类的例子"><a href="#类的例子" class="headerlink" title="类的例子"></a>类的例子</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">  greeting: string</span><br><span class="line">  <span class="keyword">constructor</span>(message: string) &#123;</span><br><span class="line">    <span class="keyword">this</span>.greeting = message</span><br><span class="line">  &#125;</span><br><span class="line">  greet () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span> + <span class="keyword">this</span>.greeting</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> greeter = <span class="keyword">new</span> Greeter(<span class="string">'world'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(greeter)</span><br></pre></td></tr></table></figure><h3 id="继承-例子1"><a href="#继承-例子1" class="headerlink" title="继承-例子1"></a>继承-例子1</h3><ul><li>例子1：</li></ul><p>类（Dog）从基类（Animal)中继承了属性和方法。<code>Dog</code>是一个<code>派生类</code>,它派生自<code>Animal`</code>基类`。</p><p>通过<code>extends</code>关键字，<code>派生类</code>通常被称作<strong>子类</strong>，<code>基类</code>通常被称作<strong>超类</strong>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  move(distanceInMeters: number = <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`目标被动物吓退了 <span class="subst">$&#123;distanceInMeters&#125;</span>m`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  bark () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'汪汪汪'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog() <span class="comment">// 创建一个Dog能够`bark()`和`move()`的实例</span></span><br><span class="line">dog.bark()</span><br><span class="line">dog.move(<span class="number">10</span>)</span><br><span class="line">dog.bark()</span><br></pre></td></tr></table></figure><h3 id="继承-例子2"><a href="#继承-例子2" class="headerlink" title="继承-例子2"></a>继承-例子2</h3><p> 和例子1有点不同，这个<code>派生类（子类）</code>必须调用<code>super()</code>，它会执行<code>基类（超类）</code>的<strong>构造函数</strong>。</p><p> 且，在<strong>构造函数</strong>里访问<code>this</code>的属性之前，一定要调用<code>super()</code>（这个是TypeScript强制执行的一条规则）。</p><p> 例子2，演示了如何在子类里可以重写父类方法。Snake类和Horse类都创建了move方法，它们重写了从Animal继承来的move方法，使得move方法根据不同的类而具有不同的功能。</p><p> 例子2中<code>tom: Animal</code>，tom被声明为<code>Animal类型</code>，但因为它的值是<code>Horse</code>类型（等于号右边部分），调用<code>tom.move(90)</code>时，它会调用Horse里<strong>重写</strong>的方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  name: string</span><br><span class="line">  <span class="keyword">constructor</span>(theName: string) &#123; <span class="keyword">this</span>.name = theName &#125;</span><br><span class="line">  move (distanceInMeters: number = <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> 跑了 <span class="subst">$&#123;distanceInMeters&#125;</span>米`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Snake</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name: string) &#123; <span class="keyword">super</span>(name) &#125;</span><br><span class="line">  move(distanceInMeters = <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'蛇出溜滑，遛了遛了..'</span>)</span><br><span class="line">    <span class="keyword">super</span>.move(distanceInMeters)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Horse</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name: string) &#123; <span class="keyword">super</span>(name) &#125;</span><br><span class="line">  move(distanceInMeters = <span class="number">45</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我老马先跑一步...'</span>)</span><br><span class="line">    <span class="keyword">super</span>.move(distanceInMeters)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> sam = <span class="keyword">new</span> Snake(<span class="string">'哟，这不是子类蛇嘛'</span>)</span><br><span class="line"><span class="keyword">let</span> tom: Animal = <span class="keyword">new</span> Horse(<span class="string">'马哥，马哥，子类马，雷吼'</span>)</span><br><span class="line">sam.move()</span><br><span class="line">tom.move(<span class="number">90</span>)</span><br></pre></td></tr></table></figure><h3 id="公共、私有与受保护的修饰符"><a href="#公共、私有与受保护的修饰符" class="headerlink" title="公共、私有与受保护的修饰符"></a>公共、私有与受保护的修饰符</h3><p>public、private</p><h4 id="public"><a href="#public" class="headerlink" title="public"></a>public</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  public name: string</span><br><span class="line">  public <span class="keyword">constructor</span>(theName: string) &#123; <span class="keyword">this</span>.name = theName &#125;</span><br><span class="line">  public move (distanceInMeters: number) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> 移动 <span class="subst">$&#123;distanceInMeters&#125;</span>米。`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  private name: string</span><br><span class="line">  <span class="keyword">constructor</span>(theName: string) &#123; <span class="keyword">this</span>.name = theName &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 属性“name”为私有属性，只能在类“Animal”中访问。ts(2341)</span></span><br><span class="line"><span class="keyword">new</span> Animal(<span class="string">'Cat'</span>).name</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;类的例子&lt;/li&gt;
&lt;li&gt;继承&lt;/li&gt;
&lt;li&gt;公共、私有与受保护的修饰符
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day166-TypeScript基础小记-继承(接口)</title>
    <link href="http://lmislm.com/2019/06/28/2019-06-28/"/>
    <id>http://lmislm.com/2019/06/28/2019-06-28/</id>
    <published>2019-06-27T16:00:00.000Z</published>
    <updated>2019-07-11T14:24:18.469Z</updated>
    
    <content type="html"><![CDATA[<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ol><li>继承接口。</li><li>一个接口继承多个接口，创建出多个接口的合成接口。</li><li>接口继承类。<a id="more"></a></li></ol><h3 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface Shape &#123;</span><br><span class="line">  color: string</span><br><span class="line">&#125;</span><br><span class="line">interface Square extends Shape &#123;</span><br><span class="line">  sideLength: number</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> square = <span class="xml"><span class="tag">&lt;<span class="name">Square</span>&gt;</span>&#123;&#125;</span></span><br><span class="line"><span class="xml">square.color = 'red'</span></span><br><span class="line"><span class="xml">square.sideLength = 6</span></span><br></pre></td></tr></table></figure><h3 id="继承多接口-合成接口"><a href="#继承多接口-合成接口" class="headerlink" title="继承多接口|合成接口"></a>继承多接口|合成接口</h3><blockquote><p>一个接口继承多个接口，创建出多个接口的合成接口。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface Shape &#123;</span><br><span class="line">  color: string</span><br><span class="line">&#125;</span><br><span class="line">interface PenStroke &#123;</span><br><span class="line">  penWidth: number</span><br><span class="line">&#125;</span><br><span class="line">interface Square extends Shape, PenStroke &#123;</span><br><span class="line">  sideLength: number</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> square = <span class="xml"><span class="tag">&lt;<span class="name">Square</span>&gt;</span>&#123;&#125;</span></span><br><span class="line"><span class="xml">square.color = 'red'</span></span><br><span class="line"><span class="xml">square.sideLength = 9</span></span><br><span class="line"><span class="xml">square.penWidth = 5.0</span></span><br></pre></td></tr></table></figure></p></blockquote><h3 id="对象“多类型”"><a href="#对象“多类型”" class="headerlink" title="对象“多类型”"></a>对象“多类型”</h3><blockquote><p>一个对象同时具有多种类型</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface Counter &#123;</span><br><span class="line">  (start: number): string</span><br><span class="line">  interval: number</span><br><span class="line">  reset(): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span>function (start: number): string &#123; return '' &#125;</span></span><br><span class="line"><span class="xml">  counter.interval = 123</span></span><br><span class="line"><span class="xml">  counter.reset = function () &#123;&#125;</span></span><br><span class="line"><span class="xml">  return counter</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">let c = getCounter()</span></span><br><span class="line"><span class="xml">c(10)</span></span><br><span class="line"><span class="xml">c.reset()</span></span><br><span class="line"><span class="xml">c.interval = 5.0</span></span><br></pre></td></tr></table></figure><h3 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h3><blockquote><p>接口继承一个<code>类类型</code>时，它会继承类的成员但不包括其<code>实现</code>。（大概就是：<code>接口</code>能声明所有类中存在的成员，但是不提供<strong>具体实现</strong>）<br><code>SelectableControl</code>包含了<code>Control</code>的所有<code>成员</code>,包括<strong>私有成员</strong><code>state</code>。<br>即：当接口继承了一个拥有<code>私有成员</code>或<code>受保护成员</code>的类时，这个<code>接口类型</code>只能是被这个类或其子类所实现。</p></blockquote><blockquote><p><code>SelectableControl</code>包含了Control的所有成员,包括私有成员state<br>因为state是私有成员，只能Control的子类才能实现<code>SelectablControl</code>接口。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Control</span> </span>&#123;</span><br><span class="line">  private state: any</span><br><span class="line">&#125;</span><br><span class="line">interface SelectableControl extends Control &#123;</span><br><span class="line">  select(): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">Control</span> <span class="title">implements</span> <span class="title">SelectableControl</span> </span>&#123;</span><br><span class="line">  select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBox</span> <span class="keyword">extends</span> <span class="title">Control</span> </span>&#123;</span><br><span class="line">  select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span> <span class="title">implements</span> <span class="title">SelectableControl</span> </span>&#123;</span><br><span class="line">  select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Interfaces.html" target="_blank" rel="noopener">https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/Interfaces.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;继承接口。&lt;/li&gt;
&lt;li&gt;一个接口继承多个接口，创建出多个接口的合成接口。&lt;/li&gt;
&lt;li&gt;接口继承类。
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day165-TypeScript基础小记-类</title>
    <link href="http://lmislm.com/2019/06/27/2019-06-27/"/>
    <id>http://lmislm.com/2019/06/27/2019-06-27/</id>
    <published>2019-06-26T16:00:00.000Z</published>
    <updated>2019-07-11T14:24:18.468Z</updated>
    
    <content type="html"><![CDATA[<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ol><li>类类型</li><li>类静态部分和实例部分的区别</li><li>直接操作类的静态部分</li><li>使用<code>类表达式</code>直接操作类的静态部分<a id="more"></a></li></ol><h4 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h4><blockquote><p>强制一个类去符合<br>实现接口<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface ClockInterface &#123;</span><br><span class="line">  currentTime: <span class="built_in">Date</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="title">implements</span> <span class="title">ClockInterface</span> </span>&#123;</span><br><span class="line">  currentTime: <span class="built_in">Date</span> = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">  <span class="keyword">constructor</span>(h: number, m: number) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">interface ClockInterface &#123;</span><br><span class="line">  currentTime: <span class="built_in">Date</span></span><br><span class="line">  setTime(d: <span class="built_in">Date</span>): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>接口描述类的公共部分<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface ClockInterface &#123;</span><br><span class="line">  currentTime: <span class="built_in">Date</span></span><br><span class="line">  <span class="comment">// 在接口中描述一个方法，在类里实现</span></span><br><span class="line">  setTime(d: <span class="built_in">Date</span>): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="title">implements</span> <span class="title">ClockInterface</span> </span>&#123;</span><br><span class="line">  currentTime: <span class="built_in">Date</span> = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">  setTime(d: <span class="built_in">Date</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentTime = d</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constructor</span>(h: number, m: number) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="类静态部分和实例部分的区别"><a href="#类静态部分和实例部分的区别" class="headerlink" title="类静态部分和实例部分的区别"></a>类静态部分和实例部分的区别</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface ClockConstructor &#123;</span><br><span class="line">  <span class="comment">// h: hour, m: minute</span></span><br><span class="line">  <span class="comment">/** 构造器 */</span></span><br><span class="line">  <span class="keyword">new</span> (h: number, <span class="attr">m</span>: number)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类实现接口时，只对实例部分进行类型检查。而constructor存在于类的静态部分</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="title">implements</span> <span class="title">ClockConstructor</span> </span>&#123;</span><br><span class="line">  currentTime: <span class="built_in">Date</span></span><br><span class="line">  <span class="comment">// 缺少构造函数实现。ts(2390)</span></span><br><span class="line">  <span class="comment">// constructor(h: number, m: number)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="直接操作类的静态部分"><a href="#直接操作类的静态部分" class="headerlink" title="直接操作类的静态部分"></a>直接操作类的静态部分</h4><blockquote><p>定义两个接口，分别为<code>构造函数</code>和<code>实例方法</code>所用</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface ClockConstructor &#123;</span><br><span class="line">  <span class="keyword">new</span> (h: number, <span class="attr">m</span>: number): ClockInterface</span><br><span class="line">&#125;</span><br><span class="line">interface ClockInterface &#123;</span><br><span class="line">  tick(): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** ClockConstructor为构造函数所用 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createClock</span> (<span class="params">ctor: ClockConstructor, h: number, m: number</span>): <span class="title">ClockInterface</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ctor(h, m)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** ClockInterface为实例方法所用 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DigitalClock</span> <span class="title">implements</span> <span class="title">ClockInterface</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(h: number, m: number) &#123;&#125;</span><br><span class="line">  tick () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'beep'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnalogClock</span> <span class="title">implements</span> <span class="title">ClockInterface</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(h: number, m: number) &#123;&#125;</span><br><span class="line">  tick () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'tick tock'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> digital = createClock(DigitalClock, <span class="number">12</span>, <span class="number">17</span>)</span><br><span class="line"><span class="comment">// 检查AnalogClock是否符合构造函数签名</span></span><br><span class="line"><span class="keyword">let</span> analog = createClock(AnalogClock, <span class="number">7</span>, <span class="number">32</span>)</span><br></pre></td></tr></table></figure><h4 id="使用类表达式直接操作类的静态部分"><a href="#使用类表达式直接操作类的静态部分" class="headerlink" title="使用类表达式直接操作类的静态部分"></a>使用<code>类表达式</code>直接操作类的静态部分</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface ClockConstructor &#123;</span><br><span class="line">  <span class="keyword">new</span> (h: number, <span class="attr">m</span>: number)</span><br><span class="line">&#125;</span><br><span class="line">interface ClockInterface &#123;</span><br><span class="line">  tick()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Clock: ClockConstructor = <span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="title">implements</span> <span class="title">ClockInterface</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(h: number, m: number) &#123;&#125;</span><br><span class="line">  tick () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'beep'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;类类型&lt;/li&gt;
&lt;li&gt;类静态部分和实例部分的区别&lt;/li&gt;
&lt;li&gt;直接操作类的静态部分&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;类表达式&lt;/code&gt;直接操作类的静态部分
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day164-TypeScript基础小记-interface</title>
    <link href="http://lmislm.com/2019/06/26/2019-06-26/"/>
    <id>http://lmislm.com/2019/06/26/2019-06-26/</id>
    <published>2019-06-25T16:00:00.000Z</published>
    <updated>2019-07-11T14:24:18.467Z</updated>
    
    <content type="html"><![CDATA[<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><p>接口的作用：</p><ol><li>多个属性处理类型判断</li><li>接口描述函数类型<a id="more"></a><h4 id="多个属性如何处理类型判断？"><a href="#多个属性如何处理类型判断？" class="headerlink" title="多个属性如何处理类型判断？"></a>多个属性如何处理类型判断？</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span> (<span class="params">labeledObj: &#123; label: string &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(labeledObj.label)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myObj = &#123; <span class="attr">size</span>: <span class="number">10</span>, <span class="attr">label</span>: <span class="string">'Size 10 Object'</span> &#125;</span><br><span class="line">printLabel(myObj)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以上是对象只有一个label属性，多个属性如何处理？</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">interface LabeledValue &#123;</span><br><span class="line">  label: string</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">labeledObj: LabeledValue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(labeledObj.label)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myObj = &#123; <span class="attr">size</span>: <span class="number">10</span>, <span class="attr">label</span>: <span class="string">'Size 10 Object'</span> &#125;</span><br><span class="line">printLabel(myObj)</span><br></pre></td></tr></table></figure></li></ol><h4 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h4><blockquote><p>interface里的值<strong>不是</strong>所有的都是<strong>必需</strong>的<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">  color?: string</span><br><span class="line">  width?: number</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span> (<span class="params">config: SquareConfig</span>): </span>&#123; color: string, <span class="attr">area</span>: number &#125; &#123;</span><br><span class="line">  <span class="keyword">let</span> newSquare = &#123; <span class="attr">color</span>: <span class="string">'white'</span>, <span class="attr">area</span>: <span class="number">100</span> &#125;</span><br><span class="line">  <span class="keyword">if</span> (config.color) &#123;</span><br><span class="line">    newSquare.color = config.color</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (config.width) &#123;</span><br><span class="line">    newSquare.area = config.width * config.width</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newSquare</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123;<span class="attr">color</span>: <span class="string">'black'</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(mySquare)</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="接口描述函数类型"><a href="#接口描述函数类型" class="headerlink" title="接口描述函数类型"></a>接口描述函数类型</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface SearchFunc &#123;</span><br><span class="line">  (source: string, <span class="attr">subString</span>: string): boolean</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span> (<span class="params">source: string, subString: string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = source.search(subString)</span><br><span class="line">  <span class="keyword">return</span> result &gt; <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h4><blockquote><p>ts支持两种索引签名：字符串和数字<br><code>数字索引</code>的返回值必须是<code>字符串索引</code>返回值类型的<strong>子类型</strong><br>因为用number来索引时，JS会将它转换成string然后再去索引对象。即：用100去索引等同于用“100”去索引。<br>问题：<code>dictionary模式</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface StringArray &#123;</span><br><span class="line">  [index: number]: string</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myArray: StringArray</span><br><span class="line">myArray = [<span class="string">'liu'</span>, <span class="string">'mon'</span>]</span><br><span class="line"><span class="comment">// 当用number去索引StringArray时会得到string类型的返回值</span></span><br><span class="line"><span class="keyword">let</span> myStr: string = myArray[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">console</span>.log(myArray)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  name: string</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 养殖</span></span><br><span class="line">  breed: string</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 错误：使用数值型的字符串</span></span><br><span class="line">interface NotOkay &#123;</span><br><span class="line">  <span class="comment">// 数字索引类型“Animal”不能赋给字符串索引类型“Dog”。ts(2413)</span></span><br><span class="line">  <span class="comment">// [x: number]: Animal</span></span><br><span class="line">  [x: string]: Dog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h3&gt;&lt;p&gt;接口的作用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多个属性处理类型判断&lt;/li&gt;
&lt;li&gt;接口描述函数类型
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day163-正则点滴</title>
    <link href="http://lmislm.com/2019/06/25/2019-06-25/"/>
    <id>http://lmislm.com/2019/06/25/2019-06-25/</id>
    <published>2019-06-24T16:00:00.000Z</published>
    <updated>2019-07-11T14:24:18.466Z</updated>
    
    <content type="html"><![CDATA[<h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><ol><li>判断是否仅有数字或者”.”、”,”。</li><li>找出并“格式化”字符串中的所有数字。<a id="more"></a></li></ol><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><ol><li><p>判断是否仅有数字或者”.”、”,”。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/^[<span class="number">0</span><span class="number">-9.</span>,]+$/</span><br><span class="line"><span class="comment">// 配合test用比较好。如：reg.test(str)</span></span><br></pre></td></tr></table></figure></li><li><p>找出并“格式化”字符串中的所有数字。</p></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(str.match(<span class="regexp">/\d+/g</span>) || []).map(<span class="built_in">Number</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;正则&quot;&gt;&lt;a href=&quot;#正则&quot; class=&quot;headerlink&quot; title=&quot;正则&quot;&gt;&lt;/a&gt;正则&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;判断是否仅有数字或者”.”、”,”。&lt;/li&gt;
&lt;li&gt;找出并“格式化”字符串中的所有数字。
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day162-键值对，以value为键的结果对象</title>
    <link href="http://lmislm.com/2019/06/24/2019-06-24/"/>
    <id>http://lmislm.com/2019/06/24/2019-06-24/</id>
    <published>2019-06-23T16:00:00.000Z</published>
    <updated>2019-07-11T14:24:18.466Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">  &#123; <span class="string">'id'</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">'a'</span>, <span class="string">'code'</span>: <span class="number">11</span> &#125;,</span><br><span class="line">  &#123; <span class="string">'id'</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">'b'</span>, <span class="string">'code'</span>: <span class="number">22</span> &#125;,</span><br><span class="line">  &#123; <span class="string">'id'</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">'c'</span>, <span class="string">'code'</span>: <span class="number">33</span> &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>以code值为key的结果对象</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>主要是<code>[]</code>的用法，灵活的很呐！</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> getKey = <span class="function">(<span class="params">data, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> data.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      [item[key]]: item</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; data = [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123; &lt;span class=&quot;string&quot;&gt;&#39;id&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;code&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;11&lt;/span&gt; &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123; &lt;span class=&quot;string&quot;&gt;&#39;id&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;code&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;22&lt;/span&gt; &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123; &lt;span class=&quot;string&quot;&gt;&#39;id&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;c&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;code&#39;&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;33&lt;/span&gt; &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以code值为key的结果对象&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day161-统计数组中所有对象相同属性值的总和，（假设值为整数）</title>
    <link href="http://lmislm.com/2019/06/23/2019-06-23/"/>
    <id>http://lmislm.com/2019/06/23/2019-06-23/</id>
    <published>2019-06-22T16:00:00.000Z</published>
    <updated>2019-07-11T14:24:18.465Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>输入：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="string">'1.pdf'</span>, <span class="attr">z</span>: <span class="number">2</span> &#125;,&#123; <span class="attr">x</span>: <span class="number">2</span>, <span class="attr">y</span>: <span class="string">'2.pdf'</span>, <span class="attr">z</span>: <span class="number">3</span> &#125;,&#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="string">'3.pdf'</span>, <span class="attr">z</span>: <span class="number">4</span> &#125;]</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">x</span>: <span class="number">6</span>, <span class="attr">y</span>: <span class="string">'01.pdf2.pdf3.pdf'</span>, <span class="attr">z</span>: <span class="number">9</span> &#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumObjectsSameKey</span>(<span class="params">...objs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> objs.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">acc, obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (obj.hasOwnProperty(k)) &#123;</span><br><span class="line">        acc[k] = (acc[k] || <span class="number">0</span>) + obj[k]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> acc</span><br><span class="line">  &#125;, &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sumObjectsSameKey(...arr))</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://stackoverflow.com/questions/42488048/javascript-sum-of-two-object-with-same-properties" target="_blank" rel="noopener">https://stackoverflow.com/questions/42488048/javascript-sum-of-two-object-with-same-properties</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;输入：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&amp;#123; &lt;span class=&quot;attr&quot;&gt;x&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;y&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;1.pdf&#39;&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;z&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &amp;#125;,&amp;#123; &lt;span class=&quot;attr&quot;&gt;x&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;y&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;2.pdf&#39;&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;z&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &amp;#125;,&amp;#123; &lt;span class=&quot;attr&quot;&gt;x&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;y&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;3.pdf&#39;&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;z&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; &amp;#125;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;输出：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; &lt;span class=&quot;attr&quot;&gt;x&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;y&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;01.pdf2.pdf3.pdf&#39;&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;z&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
</feed>
