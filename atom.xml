<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LMISLMのBlog</title>
  
  <subtitle>不积小流，无以成江海。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lmislm.com/"/>
  <updated>2020-01-07T13:29:42.230Z</updated>
  <id>http://lmislm.com/</id>
  
  <author>
    <name>lmislm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>day229-2020-启程</title>
    <link href="http://lmislm.com/2020/01/01/2020-01-07/"/>
    <id>http://lmislm.com/2020/01/01/2020-01-07/</id>
    <published>2019-12-31T16:00:00.000Z</published>
    <updated>2020-01-07T13:29:42.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>滴滴，这里是逼逼叨的一天！</p><p>去年坚持到了9月1号，然后就没写博客了！主要是写来写去感觉质量不是很高，像是完成任务一样。</p><p>今年，希望能写出好点的文章吧！一周一篇争取吧~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;p&gt;滴滴，这里是逼逼叨的一天！&lt;/p&gt;
&lt;p&gt;去年坚持到了9月1号，然后就没写博客了！主要是写来写去感觉质量不是很高，像是完成任务一样。&lt;/p&gt;
      
    
    </summary>
    
      <category term="生活" scheme="http://lmislm.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day228-Koa-封装HTTP server</title>
    <link href="http://lmislm.com/2019/08/30/2019-08-30/"/>
    <id>http://lmislm.com/2019/08/30/2019-08-30/</id>
    <published>2019-08-29T16:00:00.000Z</published>
    <updated>2020-01-07T13:26:36.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>创建Koa类构造函数、封装http server</li><li>实现koa的服务器应用和端口监听</li></ol><p>完成对http server简单的封装并创建了一个可以生成koa实例的类class，</p><p>class类包含app.use用来注册中间件和注册回调函数，</p><p>app.listen用来开启服务器实例并传入callback回调函数</p><h2 id="封装http-server"><a href="#封装http-server" class="headerlink" title="封装http server"></a>封装http server</h2><p>node原生代码实现的服务器监听</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">let</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>);</span><br><span class="line">    res.end(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; &#123;    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'listenning on 3000'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>封装实现成koa的模式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><h2 id="基于node的原生代码封装"><a href="#基于node的原生代码封装" class="headerlink" title="基于node的原生代码封装"></a>基于node的原生代码封装</h2><p>在application.js实现一个Application类的构造函数，对以上的这个过程进行封装。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">constructor</span>() &#123;        </span><br><span class="line">        <span class="keyword">this</span>.callbackFunc;</span><br><span class="line">    &#125;</span><br><span class="line">    listen(port) &#123;        </span><br><span class="line">        <span class="keyword">let</span> server = http.createServer(<span class="keyword">this</span>.callback());</span><br><span class="line">        server.listen(port);</span><br><span class="line">    &#125;</span><br><span class="line">    use(fn) &#123;</span><br><span class="line">        <span class="keyword">this</span>.callbackFunc = fn;</span><br><span class="line">    &#125;</span><br><span class="line">    callback() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.callbackFunc(req, res);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = Application;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Koa = <span class="built_in">require</span>(<span class="string">'./application'</span>);</span><br><span class="line"><span class="keyword">let</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line">app.use(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>);</span><br><span class="line">    res.end(<span class="string">'hello world'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'listening on 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;创建Koa类构造函数、封装http server&lt;/li&gt;
&lt;li&gt;实现koa的服务器应用和端口监听&lt;/li&gt;
&lt;/ol&gt;
&lt;p
      
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day227-koa源码结构</title>
    <link href="http://lmislm.com/2019/08/29/2019-08-29/"/>
    <id>http://lmislm.com/2019/08/29/2019-08-29/</id>
    <published>2019-08-28T16:00:00.000Z</published>
    <updated>2019-08-29T14:36:38.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>lib目录下各个js文件</li><li>各js文件的简介</li></ol><h2 id="lib目录下各个js文件"><a href="#lib目录下各个js文件" class="headerlink" title="lib目录下各个js文件"></a>lib目录下各个js文件</h2><ol><li>application.js</li><li>context.js</li><li>request.js</li><li>response.js</li></ol><h2 id="各js文件的简介"><a href="#各js文件的简介" class="headerlink" title="各js文件的简介"></a>各js文件的简介</h2><p><strong>application.js</strong></p><p>继承events(class Application extends Emitter)，能进行事件监听和事件触发</p><p>暴露api：listen(…args)、toJSON()、use(fn)、handleRequest()</p><ul><li><p>listen: http.createServer(this.callback()) 对http的封装。</p><p>其中this.callback() 包含中间件的合并，上下文的处理，以及对res的特殊处理</p></li><li><p>use: this.middleware.push(fn) 收集中间件，然后在callback()中，compose(this.middleware)，调用这些中间件。</p></li></ul><p><strong>context.js</strong></p><p>koa应用上下文ctx，重点在引入的delegate代理，其中包括Response delegation，Request delegation。</p><p>访问ctx.repsponse.status可以通过delegate，直接访问ctx.status</p><p><strong>request.js</strong></p><p> 对原生的res、req的一些操作</p><p><strong>response.js</strong></p><p>对原生的res、req的一些操作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;lib目录下各个js文件&lt;/li&gt;
&lt;li&gt;各js文件的简介&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;lib目录下各个js文件&quot;&gt;
      
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day226-vue-router 路由重置</title>
    <link href="http://lmislm.com/2019/08/28/2019-08-28/"/>
    <id>http://lmislm.com/2019/08/28/2019-08-28/</id>
    <published>2019-08-27T16:00:00.000Z</published>
    <updated>2019-08-28T14:21:13.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>实现路由重置（权限控制）</li></ol><p><code>vue-router</code>如何删除（重置）通过 addRoutes 方法添加的动态路由，实现权限控制？</p><p><code>location.refresh</code>?</p><p>替换路由实例的 matcher 对象来实现路由的 重置<br><a id="more"></a></p><p>代码如下：代码来源于vue-router中的<a href="https://github.com/vuejs/vue-router/issues/1234#issuecomment-357941465" target="_blank" rel="noopener">issue</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createRouter = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  routes: []</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = createRouter()</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resetRouter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newRouter = createRouter()</span><br><span class="line">  router.matcher = newRouter.matcher <span class="comment">// the relevant part</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;实现路由重置（权限控制）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;vue-router&lt;/code&gt;如何删除（重置）通过 addRoutes 方法添加的动态路由，实现权限控制？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;location.refresh&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;替换路由实例的 matcher 对象来实现路由的 重置&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day225-展开运算符 vs Object.assign()</title>
    <link href="http://lmislm.com/2019/08/27/2019-08-27/"/>
    <id>http://lmislm.com/2019/08/27/2019-08-27/</id>
    <published>2019-08-26T16:00:00.000Z</published>
    <updated>2019-08-27T14:27:56.339Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>展开运算符</li><li><code>Object.assign()</code></li><li>以上两者的异同<a id="more"></a></li></ol><h2 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h2><p>Object Spread 只是用已存在的对象的properties创建了一个新的普通对象 具体可见<a href="https://github.com/tc39/proposal-object-rest-spread" target="_blank" rel="noopener">tc39-proposal-object-rest-spread</a></p><ol><li>构造字面量数组</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>] <span class="keyword">let</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> mergeArr = [...arr1, ...arr2]</span><br></pre></td></tr></table></figure><ol start="2"><li>构造字面量对象</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">x</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">'baz'</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">let</span> mergeObj = &#123; <span class="attr">foo</span>: <span class="string">'baz'</span>, <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mergeObj = &#123; ...obj1, ...obj2 &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>函数调用时使用展开语法</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// old:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFn</span> (<span class="params">x, y, z</span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">myFn.apply(<span class="literal">null</span>, args)</span><br><span class="line"><span class="comment">// new: </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFn</span> (<span class="params">x, y, z</span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">myFn(...args)</span><br></pre></td></tr></table></figure><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><ol><li>合并对象 </li><li>复制一个对象</li><li>拷贝 symbol 类型的属性, 但是不可拷贝继承属性和不可枚举属性</li></ol><h2 id="以上两者异同"><a href="#以上两者异同" class="headerlink" title="以上两者异同"></a>以上两者异同</h2><h3 id="异"><a href="#异" class="headerlink" title="异"></a>异</h3><p>Object.assign()会触发ES6的setters。</p><p>如果喜欢用immutable技术，对象展开符操作更加合适。</p><p>用Object.assign()，第一个参数必须是{}。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">set</span> val (v) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Setter called'</span>, v)</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> MyClass()</span><br><span class="line"><span class="built_in">Object</span>.assign(obj, &#123; <span class="attr">val</span>: <span class="number">3</span> &#125;) <span class="comment">// Setter called 3</span></span><br></pre></td></tr></table></figure></p><h3 id="同"><a href="#同" class="headerlink" title="同"></a>同</h3><p>两者都不会复制继承属性或class信息，但是可以拷贝<code>ES6 symbols</code>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> </span>&#123;</span><br><span class="line">  foo() &#123;<span class="keyword">return</span> <span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">BaseClass</span> </span>&#123;</span><br><span class="line">  bar() &#123;<span class="keyword">return</span> <span class="number">2</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> MyClass()</span><br><span class="line">obj.baz = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="number">3</span>&#125;</span><br><span class="line">obj[<span class="built_in">Symbol</span>.for(<span class="string">'test'</span>)] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clone = &#123; ...obj &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(clone) <span class="comment">// &#123; baz: [Function], [Symbol(test)]: 4 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(clone.constructor.name)</span><br><span class="line"><span class="built_in">console</span>.log(clone <span class="keyword">instanceof</span> MyClass)</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-performpromisethen" target="_blank" rel="noopener">http://www.ecma-international.org/ecma-262/6.0/#sec-performpromisethen</a></p><p><a href="https://thecodebarbarian.com/object-assign-vs-object-spread.html" target="_blank" rel="noopener">https://thecodebarbarian.com/object-assign-vs-object-spread.html</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax</a></p><p><a href="https://github.com/tc39/proposal-object-rest-spread" target="_blank" rel="noopener">https://github.com/tc39/proposal-object-rest-spread</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;展开运算符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object.assign()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;以上两者的异同
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day224-三种检测数组的方法</title>
    <link href="http://lmislm.com/2019/08/26/2019-08-26/"/>
    <id>http://lmislm.com/2019/08/26/2019-08-26/</id>
    <published>2019-08-25T16:00:00.000Z</published>
    <updated>2019-08-26T15:54:39.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li><code>Object.prototype.toString.call()</code></li><li><code>instanceof</code></li><li><code>Array.isArray()</code>、与<code>instanceof</code>比较<a id="more"></a></li></ol><h2 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h2><blockquote><p>所有的基本数据类型都能判断，其中就包括<code>null</code>和<code>undefined</code>。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="comment">// Object.prototype.toString.call()</span></span><br><span class="line">arr.toString() <span class="comment">// 1,2</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(arr) <span class="comment">// [object Array]</span></span><br></pre></td></tr></table></figure><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><blockquote><p>原理是判断<code>__proto__</code>是否能找到对应的<code>prototype</code>。<code>A.__proto__</code> ? <code>B.prototype</code></p></blockquote><p>但是<code>instanceof</code>只能用来判断对象类型，原始类型不可以。原始类型即：Undefined，Null，Boolean，Number和 String。</p><h2 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h2><p>ES5新增方法，用于确定传递的值是否是一个数组。</p><p><strong>与<code>instanceof</code>比较</strong></p><ol><li><code>instanceof</code>不支持跨iframes, 但是<code>Array.isArray</code>支持。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iframeEl = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframeEl);</span><br><span class="line">iframeArray = <span class="built_in">window</span>.frames[<span class="built_in">window</span>.frames.length - <span class="number">1</span>].Array;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> array2 = <span class="keyword">new</span> iframeArray(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1 <span class="keyword">instanceof</span> <span class="built_in">Array</span>);  <span class="comment">// true    </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(array1));  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array2 <span class="keyword">instanceof</span> <span class="built_in">Array</span>);  <span class="comment">// false    </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(array2));  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>instanceof</code>要比<code>Array.isArray</code>更快，<a href="https://jsperf.com/array-isarray-vs-instanceof-array" target="_blank" rel="noopener">jsperf</a>。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/326069/how-to-identify-if-a-webpage-is-being-loaded-inside-an-iframe-or-directly-into-t" target="_blank" rel="noopener">How to identify if a webpage is being loaded inside an iframe or directly into the browser window?</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures" target="_blank" rel="noopener">JavaScript 数据类型和数据结构</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Object.prototype.toString.call()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;instanceof&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Array.isArray()&lt;/code&gt;、与&lt;code&gt;instanceof&lt;/code&gt;比较
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day223-文本溢出省略</title>
    <link href="http://lmislm.com/2019/08/25/2019-08-25/"/>
    <id>http://lmislm.com/2019/08/25/2019-08-25/</id>
    <published>2019-08-24T16:00:00.000Z</published>
    <updated>2019-08-25T15:33:01.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><blockquote><p>用 css 或 js 实现多行文本溢出省略效果，考虑兼容性</p></blockquote><ol><li>单行</li><li>多行</li><li>兼容<a id="more"></a></li></ol><h2 id="单行"><a href="#单行" class="headerlink" title="单行"></a>单行</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span><span class="selector-pseudo">:ellipsis</span>;</span><br><span class="line"><span class="selector-tag">white-space</span>: <span class="selector-tag">nowrap</span>;</span><br></pre></td></tr></table></figure><h2 id="多行"><a href="#多行" class="headerlink" title="多行"></a>多行</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">-webkit-box</span>;</span><br><span class="line"><span class="selector-tag">-webkit-box-orient</span>: <span class="selector-tag">vertical</span>;</span><br><span class="line"> <span class="selector-tag">-webkit-line-clamp</span>: 3; <span class="comment">/* 行数 */</span></span><br><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br></pre></td></tr></table></figure><h2 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h2><blockquote><p>兼容的方法有个问题，如果出现了数字字母这种，是否会出现盖住半个字的操作</p></blockquote><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;<span class="attribute">position</span>: relative; <span class="attribute">line-height</span>: <span class="number">20px</span>; <span class="attribute">max-height</span>: <span class="number">40px</span>;<span class="attribute">overflow</span>: hidden;&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::after</span>&#123;<span class="attribute">content</span>: <span class="string">"..."</span>; <span class="attribute">position</span>: absolute; <span class="attribute">bottom</span>: <span class="number">0</span>; <span class="attribute">right</span>: <span class="number">0</span>; <span class="attribute">padding-left</span>: <span class="number">40px</span>;</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">-webkit-linear-gradient</span>(left, transparent, #fff 55%);</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">-o-linear-gradient</span>(right, transparent, #fff 55%);</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">-moz-linear-gradient</span>(right, transparent, #fff 55%);</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to right, transparent, #fff 55%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;用 css 或 js 实现多行文本溢出省略效果，考虑兼容性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;单行&lt;/li&gt;
&lt;li&gt;多行&lt;/li&gt;
&lt;li&gt;兼容
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day222-解题-扑克牌问题-笔记</title>
    <link href="http://lmislm.com/2019/08/24/2019-08-24/"/>
    <id>http://lmislm.com/2019/08/24/2019-08-24/</id>
    <published>2019-08-23T16:00:00.000Z</published>
    <updated>2019-08-24T15:00:02.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>题目描述</li><li>题解<a id="more"></a></li></ol><h2 id="优化scrollTop"><a href="#优化scrollTop" class="headerlink" title="优化scrollTop"></a>优化scrollTop</h2><p>题目描述</p><blockquote><p>扑克牌问题</p></blockquote><p>有一堆扑克牌，将牌堆第一张放到桌子上，再将接下来的牌堆的第一张放到牌底，如此往复；</p><p>最后桌子上的牌顺序为： (牌底) 1,2,3,4,5,6,7,8,9,10,11,12,13 (牌顶)；</p><p>问：原来那堆牌的顺序，用函数实现。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> out = []</span><br><span class="line">  <span class="keyword">while</span> (arr.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span>) &#123;</span><br><span class="line">      out.unshift(arr.pop())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      out.unshift(out.pop())</span><br><span class="line">    &#125;</span><br><span class="line">    i++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">putPoke</span> (<span class="params">arr</span>) </span>&#123; <span class="comment">// 放牌，arr手里的牌，out桌子上的牌</span></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> out = []</span><br><span class="line">  <span class="keyword">while</span> (arr.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span>) &#123;</span><br><span class="line">      out.push(arr.shift()) <span class="comment">// i等于1，手里第一张放桌上；奇数牌</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      arr.push(arr.shift()) <span class="comment">// 偶数牌，放手里牌最后，一直到手里没有牌。</span></span><br><span class="line">    &#125;</span><br><span class="line">    i++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/245" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/245</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;题目描述&lt;/li&gt;
&lt;li&gt;题解
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day221-rAF-示例</title>
    <link href="http://lmislm.com/2019/08/23/2019-08-23/"/>
    <id>http://lmislm.com/2019/08/23/2019-08-23/</id>
    <published>2019-08-22T16:00:00.000Z</published>
    <updated>2019-08-23T15:47:24.644Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>优化scrollTop</li><li>Easing functions<a id="more"></a></li></ol><h2 id="优化scrollTop"><a href="#优化scrollTop" class="headerlink" title="优化scrollTop"></a>优化scrollTop</h2><p>原来的函数<code>scroll</code>用的是步长，简单的时间循环</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollTop</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> el = <span class="keyword">this</span>.el</span><br><span class="line">  <span class="keyword">let</span> step = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> interval = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (el.scrollTop &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      clearInterval(interval)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    step += <span class="number">10</span></span><br><span class="line">    el.scrollTop -= step</span><br><span class="line">  &#125;, <span class="number">20</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>rAF</code>改进后</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cubic = <span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">Math</span>.pow(value, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">const</span> easeInOutCubic = <span class="function"><span class="params">value</span> =&gt;</span> value &lt; <span class="number">0.5</span></span><br><span class="line">  ? cubic(value * <span class="number">2</span>) / <span class="number">2</span></span><br><span class="line">  : <span class="number">1</span> - cubic((<span class="number">1</span> - value) * <span class="number">2</span>) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrollTop</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="keyword">this</span>.el</span><br><span class="line">  <span class="keyword">const</span> beginTime = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">const</span> beginValue = el.scrollTop</span><br><span class="line">  <span class="keyword">const</span> rAF = <span class="built_in">window</span>.requestAnimationFrame || (<span class="function"><span class="params">func</span> =&gt;</span> setTimeout(func, <span class="number">16</span>)) <span class="comment">// 兼容处理，16ms刷新</span></span><br><span class="line">  <span class="keyword">const</span> frameFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> progress = (<span class="built_in">Date</span>.now() - beginTime) / <span class="number">500</span> <span class="comment">// 在500ms内完成scroll,Date.now() - beginTime，表示控制在rAF的间隔时间内时间差值</span></span><br><span class="line">    <span class="keyword">if</span> (progress &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      el.scrollTop = beginValue * (<span class="number">1</span> - easeInOutCubic(progress))</span><br><span class="line">      rAF(frameFunc)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      el.scrollTop = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  rAF(frameFunc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Easing-functions"><a href="#Easing-functions" class="headerlink" title="Easing functions"></a>Easing functions</h2><p>改进的方法中用到了<code>贝塞斯曲线</code>，改进方法中的曲线其实也可以这么写，如下。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// easeInOutCubic</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">easeInOutCubic</span> (<span class="params">t</span>) </span>&#123; <span class="keyword">return</span> t&lt;<span class="number">.5</span> ? <span class="number">4</span>*t*t*t : (t<span class="number">-1</span>)*(<span class="number">2</span>*t<span class="number">-2</span>)*(<span class="number">2</span>*t<span class="number">-2</span>)+<span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><p>更多曲线的写法在这里 <a href="https://gist.github.com/gre/1650294" target="_blank" rel="noopener">Simple Easing Functions in Javascript</a></p><p>也可以在这里 <a href="https://easings.net/en" target="_blank" rel="noopener">Easing functions</a>，可视化的了解各种曲线。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://gist.github.com/gre/1650294" target="_blank" rel="noopener">https://gist.github.com/gre/1650294</a></p><p><a href="https://easings.net/en" target="_blank" rel="noopener">https://easings.net/en</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;优化scrollTop&lt;/li&gt;
&lt;li&gt;Easing functions
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day220-Regex-email</title>
    <link href="http://lmislm.com/2019/08/22/2019-08-22/"/>
    <id>http://lmislm.com/2019/08/22/2019-08-22/</id>
    <published>2019-08-21T16:00:00.000Z</published>
    <updated>2019-08-23T15:36:17.544Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>一步步写一个邮箱正则。</p><p><strong>条件：</strong></p><p>只允许[a-z][A-Z][.]且不允许”.”号连续和处于开头结尾</p><p><strong>流程：</strong></p><ol><li>数字 + 单个(.) + 数字</li><li>数字 + 多个不连续的(.) + 数字</li><li>多个数字间隔连续</li><li>完全匹配</li><li>匹配@后缀</li><li>优化建议<a id="more"></a></li></ol><h2 id="数字-单个-数字"><a href="#数字-单个-数字" class="headerlink" title="数字+单个(.)+数字"></a>数字+单个(.)+数字</h2><p><code>[a-zA-Z0-9]+(\.)+[a-zA-Z0-9]</code></p><p><strong>测试</strong></p><p>匹配：hello.world 中的 hello.w</p><p>匹配：hello……world 中的 hello……w</p><p>匹配：hello.word.hello.to 中 hello.w</p><p><strong>知识点</strong></p><p><code>&quot;+&quot;</code>：匹配前面一个表达式 1 次或者多次。等价于 {1,}。</p><h2 id="数字-多个不连续的-数字"><a href="#数字-多个不连续的-数字" class="headerlink" title="数字+多个不连续的(.)+数字"></a>数字+多个不连续的(.)+数字</h2><p><code>([a-zA-Z0-9]+)([\.{1}])?([a-zA-Z0-9])</code></p><p><strong>测试</strong></p><p>hello.world =&gt; hello.w</p><p>hello…….word =&gt; hello</p><p>hello.word.hello.to =&gt; hello.w</p><p><strong>知识点</strong></p><p><code>&quot;{n}&quot;</code>：n 是一个正整数，匹配了前面一个字符刚好出现了 n 次。</p><p><code>&quot;?&quot;</code>：匹配前面一个表达式 0 次或者 1 次。等价于 {0,1}。</p><blockquote><p>例子：/e?le?/ 匹配 “angel” 中的 ‘el’、”angle” 中的 ‘le’ 以及 “oslo’ 中的 ‘l’。</p></blockquote><h2 id="多个数字间隔连续"><a href="#多个数字间隔连续" class="headerlink" title="多个数字间隔连续"></a>多个数字间隔连续</h2><p><code>[a-zA-Z0-9]+(?:\.[a-zA-Z0-9]+)*</code></p><p><strong>测试</strong></p><p>hello.world =&gt; hello.world</p><p>hello……world =&gt; hello</p><p>hello.world.hello.to =&gt; hello.world.hello.to</p><p>hello……world.hello.to =&gt; hello</p><p>hello.world.hello……to =&gt; hello.world.hello</p><p><strong>知识点</strong></p><p><code>&quot;(?:x)&quot;</code>：匹配 ‘x’ 但是不记住匹配项。这种括号叫作<code>非捕获括号</code>，使得你能够定义与正则表达式运算符一起使用的子表达式。</p><blockquote><p>例子：/(?:\d{3}|(\d{3}))([-\/.])\d{3}\1\d{4}/。</p></blockquote><pre><code>(?: 这个正则表达式寻找三个数字字符\d{3} 或者 | 一个左半括号\(跟着三位数字\d{3}, 跟着一个封闭括号 \), (结束非捕获括号 ))， 后跟着一个短破折号或正斜杠或小数点，随后跟随三个数字字符，当记忆字符 ([-\/\.])捕获并记住，后面跟着三位小数 \d{3}，再后面跟随记住的破折号、正斜杠或小数点 \1，最后跟着四位小数 \d{4}</code></pre><blockquote><p>例子：(?:\d+)</p></blockquote><pre><code>匹配一次或多次数字字符，但是不能记住匹配的字符。</code></pre><p><code>&quot;*&quot;</code>：匹配前一个表达式 0 次或多次。等价于 {0,}。</p><h2 id="完全匹配"><a href="#完全匹配" class="headerlink" title="完全匹配"></a>完全匹配</h2><p><code>/^[a-zA-Z0-9]+(?:\.[a-zA-Z0-9]+)*$/</code></p><p><strong>测试</strong></p><p>hello.world =&gt; hello.world</p><p>hello……world =&gt; （空）</p><p>hello.world.hello.to =&gt; hello.world.hello.to</p><p>hello……world.hello.to =&gt; （空）</p><p>hello.world.hello……to =&gt; （空）</p><p><strong>知识点</strong></p><p><code>&quot;^&quot;</code>：匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。<br>  例子：/^A/ 匹配”An E” 中的 ‘A’，不匹配 “an A” 中的 ‘A’</p><p><code>&quot;$&quot;</code>：匹配输入的结束。如果多行标示被设置为 true，那么也匹配换行符前的位置。<br>  例子：/t$/ 匹配 “eat” 中的 ‘t’，不匹配 “eater” 中的 ‘t’</p><h2 id="匹配-后缀"><a href="#匹配-后缀" class="headerlink" title="匹配@后缀"></a>匹配@后缀</h2><p>后缀：<code>/@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))/</code></p><p><code>/^(([^&lt;&gt;()[\]\\.,;:\s@&quot;]+(\.[^&lt;&gt;()[\]\\.,;:\s@&quot;]+)*)|(&quot;.+&quot;))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/</code></p><h2 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h2><p>如果”_”字符允许的话，可以考虑用”\w”</p><p><code>&quot;\w&quot;</code>：匹配一个<code>单字</code>字符（字母、数字或者下划线）。等价于 [A-Za-z0-9_]。</p><blockquote><p>例子：/\w/ 匹配 “apple,” 中的 ‘a’，”$5.28,”中的 ‘5’ 和 “3D.” 中的 ‘3’。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions</a></p><p><a href="https://www.regextester.com/" target="_blank" rel="noopener">https://www.regextester.com/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;p&gt;一步步写一个邮箱正则。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;条件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只允许[a-z][A-Z][.]且不允许”.”号连续和处于开头结尾&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;流程：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数字 + 单个(.) + 数字&lt;/li&gt;
&lt;li&gt;数字 + 多个不连续的(.) + 数字&lt;/li&gt;
&lt;li&gt;多个数字间隔连续&lt;/li&gt;
&lt;li&gt;完全匹配&lt;/li&gt;
&lt;li&gt;匹配@后缀&lt;/li&gt;
&lt;li&gt;优化建议
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day219-history.pushState()</title>
    <link href="http://lmislm.com/2019/08/21/2019-08-21/"/>
    <id>http://lmislm.com/2019/08/21/2019-08-21/</id>
    <published>2019-08-20T16:00:00.000Z</published>
    <updated>2019-08-22T15:49:16.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>例子</li><li>参数</li><li>与window.location中hash异同</li><li>原理<a id="more"></a></li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>浏览器地址改为<code>xxx/bar.html</code>，但是不加载，也不检查bar.html是否存在。</p><p>通过<code>pushState</code>可以在<code>stateObj</code>中保存页面状态，当页面的 url 再变回到这个 url 时，可以通过 event.state 取到这个 state 对象，从而可以对页面状态进行还原，如页面滚动条的位置、阅读进度、组件的开关。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stateObj = &#123;</span><br><span class="line">  foo: <span class="string">'bar'</span></span><br><span class="line">&#125;</span><br><span class="line">history.pushState(stateObj, <span class="string">'page 2'</span>, <span class="string">'bar.html'</span>)</span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>一个状态对象，一个标题，一个URL</p><p><strong>状态对象:</strong></p><p>  用户导航到新状态时，触发popstate事件。包含该历史记录条目状态对象的副本。状态对象能被序列化，大小限制在640k以内。</p><p><strong>标题：</strong></p><p>  给跳转的state传递短标题。</p><p><strong>URL：</strong></p><p>  定义新的历史URL记录。新URL必须与当前URL同源。否则<code>pushState()</code>会抛出异常。参数可选，默认为当前URL。</p><h2 id="异同"><a href="#异同" class="headerlink" title="异同"></a>异同</h2><p><code>pushState()</code>与<code>window.location = &#39;#foo&#39;</code>，两者都会在当前页面创建并激活新的历史记录。</p><p><code>hash</code>相对于<code>history.pushState()</code>兼容性强。</p><p>新URL可以是与当前URL同源的任意URL。设置<code>window.location</code>仅当你只修改了哈希值时才保持同一个<code>document</code>（即：hash 设置的新值不能与原来的一样，一样的值不会触发动作将记录添加到栈中）。</p><p><code>pushState()</code>可以将任意数据和新的历史记录项相关联（即：通过 stateObject 参数可以将任何数据类型添加到记录中）。而hash，要把所有相关数据编码为短字符串（即：只能添加短字符串）。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><strong>hash</strong></p><p>onhashchange 事件，可以在 window 对象上监听这个事件。</p><p><strong>pushState</strong></p><p>hash只改变#后面的代码片段，pushState可以在window对象上监听popState()事件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;例子&lt;/li&gt;
&lt;li&gt;参数&lt;/li&gt;
&lt;li&gt;与window.location中hash异同&lt;/li&gt;
&lt;li&gt;原理
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day218-[].slice.call(arguments)</title>
    <link href="http://lmislm.com/2019/08/19/2019-08-19/"/>
    <id>http://lmislm.com/2019/08/19/2019-08-19/</id>
    <published>2019-08-18T16:00:00.000Z</published>
    <updated>2019-08-19T15:02:39.710Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>类数组的转换</li><li>call绑定其他对象的上下文</li><li>slice方法中的for…in<a id="more"></a></li></ol><h2 id="类数组的转换"><a href="#类数组的转换" class="headerlink" title="类数组的转换"></a>类数组的转换</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[].slice.call(<span class="built_in">arguments</span>)</span><br></pre></td></tr></table></figure><h2 id="call绑定其他对象的上下文"><a href="#call绑定其他对象的上下文" class="headerlink" title="call绑定其他对象的上下文"></a>call绑定其他对象的上下文</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sliced = <span class="built_in">Array</span>.prototype.slice.call(&#123;<span class="string">'0'</span>: <span class="string">'a'</span>, <span class="string">'1'</span>: <span class="string">'b'</span>, <span class="string">'2'</span>: <span class="string">'c'</span>, <span class="attr">length</span>: <span class="number">3</span>&#125;, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// [ 'c' ]</span></span><br><span class="line"><span class="keyword">var</span> sliced = <span class="built_in">Array</span>.prototype.slice.call(&#123;<span class="string">'0'</span>: <span class="string">'a'</span>, <span class="string">'1'</span>: <span class="string">'b'</span>, <span class="string">'3'</span>: <span class="string">'c'</span>, <span class="attr">length</span>: <span class="number">3</span>&#125;, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// [ &lt;1 empty item&gt; ]</span></span><br></pre></td></tr></table></figure><h2 id="slice方法中的for…in"><a href="#slice方法中的for…in" class="headerlink" title="slice方法中的for…in"></a>slice方法中的for…in</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.mockSlice = <span class="function"><span class="keyword">function</span>(<span class="params">begin, end</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// IE &lt; 9 gets unhappy with an undefined end argument</span></span><br><span class="line">  end = (<span class="keyword">typeof</span> end !== <span class="string">'undefined'</span>) ? end : <span class="keyword">this</span>.length;</span><br><span class="line">  <span class="comment">// For array like object we handle it ourselves.</span></span><br><span class="line">  <span class="keyword">var</span> i, cloned = [],</span><br><span class="line">    size, len = <span class="keyword">this</span>.length;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Handle negative value for "begin"</span></span><br><span class="line">  <span class="keyword">var</span> start = begin || <span class="number">0</span>;</span><br><span class="line">  start = (start &gt;= <span class="number">0</span>) ? start : <span class="built_in">Math</span>.max(<span class="number">0</span>, len + start);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Handle negative value for "end"</span></span><br><span class="line">  <span class="keyword">var</span> upTo = (<span class="keyword">typeof</span> end == <span class="string">'number'</span>) ? <span class="built_in">Math</span>.min(end, len) : len;</span><br><span class="line">  <span class="keyword">if</span> (end &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    upTo = len + end;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Actual expected size of the slice</span></span><br><span class="line">  size = upTo - start;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    cloned = <span class="keyword">new</span> <span class="built_in">Array</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.charAt) &#123; <span class="comment">// String，如果是字符型返回指定位置的字符</span></span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        cloned[i] = <span class="keyword">this</span>.charAt(start + i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        cloned[i] = <span class="keyword">this</span>[start + i]; <span class="comment">// 迭代数组</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cloned;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log([].mockSlice.call(<span class="built_in">arguments</span>)) <span class="comment">// [ 'a', 'b', 'c' ]</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" target="_blank" rel="noopener">Array.prototype.slice()</a></p><p><a href="https://stackoverflow.com/questions/7056925/how-does-array-prototype-slice-call-work" target="_blank" rel="noopener">how does Array.prototype.slice.call() work?</a></p><p><a href="http://es5.github.io/x15.4.html#x15.4.4.10" target="_blank" rel="noopener">Array.prototype.slice method description</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;类数组的转换&lt;/li&gt;
&lt;li&gt;call绑定其他对象的上下文&lt;/li&gt;
&lt;li&gt;slice方法中的for…in
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day217-Intersection Observer</title>
    <link href="http://lmislm.com/2019/08/18/2019-08-18/"/>
    <id>http://lmislm.com/2019/08/18/2019-08-18/</id>
    <published>2019-08-17T16:00:00.000Z</published>
    <updated>2019-08-18T15:47:52.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>简介</li><li>Options</li><li>Callback<a id="more"></a></li></ol><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>异步观察目标元素与其祖先元素或顶级文档视窗(viewport)交叉状态的方法。</p><p><code>Intersection Observer API</code>会注册一个回调方法，每当期望被监视的元素<code>进入或者退出</code>另外一个元素的时候(或者浏览器的视口)该回调方法将会被执行，或者两个元素的<code>交集部分大小发生变化</code>的时候回调方法也会被执行。</p><h2 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  root: <span class="built_in">document</span>.querySelector(<span class="string">'#scrollArea'</span>), <span class="comment">// 所监听对象的具体祖先元素(element) ,只读</span></span><br><span class="line">  rootMargin: <span class="string">'0px'</span>, <span class="comment">// 计算交叉时添加到根(root)边界盒bounding box的矩形偏移量，只读，主要用途之一就是用来实现提前加载，提前几百像素预先加载</span></span><br><span class="line">  threshold: <span class="number">1.0</span> <span class="comment">// 包含阈值的列表，如[0, 0.25, 0.5, 0.75, 1]， 列表中的每个阈值都是监听对象的交叉区域与边界区域的比率，只读</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> IntersectionObserver(callback, options);</span><br></pre></td></tr></table></figure><h2 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> callback = <span class="function"><span class="keyword">function</span>(<span class="params">entries, observer</span>) </span>&#123; </span><br><span class="line">  entries.forEach(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Each entry describes an intersection change for one observed</span></span><br><span class="line">  <span class="comment">// target element:</span></span><br><span class="line">  <span class="comment">//   entry.boundingClientRect</span></span><br><span class="line">  <span class="comment">//   entry.intersectionRatio</span></span><br><span class="line">  <span class="comment">//   entry.intersectionRect</span></span><br><span class="line">  <span class="comment">//   entry.isIntersecting // 判断target元素在root元素中的可见性是否发生变化，isIntersecting 是 true，target元素的至少已经达到thresholds属性值当中规定的其中一个阈值</span></span><br><span class="line">  <span class="comment">//   entry.rootBounds</span></span><br><span class="line">  <span class="comment">//   entry.target</span></span><br><span class="line">  <span class="comment">//   entry.time</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/ziyunfei/p/5558712.html" target="_blank" rel="noopener">IntersectionObserver API-紫云飞</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API" target="_blank" rel="noopener">Intersection Observer API-MDN</a></p><p><a href="https://juejin.im/post/5a7973575188257a5911a749" target="_blank" rel="noopener">谈谈IntersectionObserver懒加载</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;简介&lt;/li&gt;
&lt;li&gt;Options&lt;/li&gt;
&lt;li&gt;Callback
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day216-HTTPS 中间人攻击</title>
    <link href="http://lmislm.com/2019/08/17/2019-08-17/"/>
    <id>http://lmislm.com/2019/08/17/2019-08-17/</id>
    <published>2019-08-16T16:00:00.000Z</published>
    <updated>2019-08-17T14:34:06.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>过程</li><li>防范<a id="more"></a></li></ol><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol><li><code>服务端</code>向<code>客户端</code>发送公钥</li><li>攻击者截取公钥，并伪造公钥，发送给<code>客户端</code></li><li><code>客户端</code>收到伪造的公钥后，生成加密hash值发给<code>服务端</code></li><li>攻击者获得加密hash值，用自己的私钥解密获得真密钥</li><li>同时生成假的加密hash值，发给<code>服务端</code></li><li><code>服务端</code>用私钥解密获得假密钥</li><li><code>服务端</code>用假密钥加密传输信息。</li></ol><h2 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h2><p>服务端在发送给<code>客户端</code>的公钥中，加入CA证书。浏览器可以验证CA证书的有效性。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;过程&lt;/li&gt;
&lt;li&gt;防范
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day215-TCP KeepAlive-笔记</title>
    <link href="http://lmislm.com/2019/08/16/2019-08-16/"/>
    <id>http://lmislm.com/2019/08/16/2019-08-16/</id>
    <published>2019-08-15T16:00:00.000Z</published>
    <updated>2019-08-16T15:13:29.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>基本原理</li><li>TCP的连接</li><li>KeepAlive的局限<a id="more"></a></li></ol><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。</p><h2 id="TCP的连接"><a href="#TCP的连接" class="headerlink" title="TCP的连接"></a>TCP的连接</h2><p>物理层面并没有“连接”的概念。</p><p>TCP通信双方建立连接，但并不是一直数据交互，有些连接会在数据交互后，主动释放连接，而有些不会。在长时间无数据交互的时间段内，交互双方都有可能出现掉电、死机、异常重启等各种意外，当这些意外发生之后，这些 TCP 连接并未来得及正常释放，在软件层面上，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费。</p><p>为了解决这个问题，在<code>传输层</code>可以利用<code>TCP</code>的<code>KeepAlive</code>机制实现来实现。</p><h2 id="KeepAlive的局限"><a href="#KeepAlive的局限" class="headerlink" title="KeepAlive的局限"></a>KeepAlive的局限</h2><p><code>KeepAlive</code>监测的方式是发送<code>probe</code>包，会给网络带来额外的流量。</p><p><code>TCP KeepAlive</code>只能在内核层级监测连接的存活与否，而连接的存活不一定代表服务的可用。</p><p>例如当一个服务器 CPU 进程服务器占用达到 100%，已经卡死不能响应请求了，此时 TCP KeepAlive 依然会认为连接是存活的。</p><blockquote><p>因此 TCP KeepAlive 对于应用层程序的价值是相对较小的。</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.tldp.org/HOWTO/html_single/TCP-Keepalive-HOWTO/" target="_blank" rel="noopener">TCP Keepalive HOWTO</a></p><p><a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html" target="_blank" rel="noopener">TCP KeepAlive</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;基本原理&lt;/li&gt;
&lt;li&gt;TCP的连接&lt;/li&gt;
&lt;li&gt;KeepAlive的局限
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day214-HTTP四次挥手</title>
    <link href="http://lmislm.com/2019/08/15/2019-08-15/"/>
    <id>http://lmislm.com/2019/08/15/2019-08-15/</id>
    <published>2019-08-14T16:00:00.000Z</published>
    <updated>2019-08-15T14:22:25.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>目的</li><li>过程<a id="more"></a></li></ol><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭，客户端或服务器均可主动发起挥手动作。</p><p>这个原则是当一方完成它的数据发送任务后就能发送标志位FIN来终止这个方向的连接。收到FIN=1只意味着这一方向上没有数据流动，一个TCP连接在收到FIN=1后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p><strong>第一次握手</strong> (FIN=1，seq=x)</p><p>假设客户端想要关闭连接，客户端发送标志位FIN为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p><p>发送完毕后，客户端进入<code>FIN_WAIT_1</code>状态。</p><p><strong>第二次握手</strong> (ACK=1，ACKnum=x+1)</p><p>服务器端确认客户端的 FIN 包，发送一个确认序号（ACKnum，又写做ack），表明已接收客户端关闭连接的请求，但还没有准备好关闭连接。</p><p>发送完毕后，服务器端进入<code>CLOSE_WAIT</code>状态。<br>客户端接收到这个确认序号后，进入<code>FIN_WAIT_2</code>状态，等待服务器端关闭连接。</p><p><strong>第三次握手</strong> (FIN=1，seq=y)</p><p>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。</p><p>发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。</p><p><strong>第四次挥手</strong> (ACK=1，ACKnum=y+1)</p><p>客户端接收到来自服务器端的关闭请求，发送一个确认序号，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。</p><p>服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</p><p><strong>最后</strong></p><p>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html" target="_blank" rel="noopener">三次握手</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;目的&lt;/li&gt;
&lt;li&gt;过程
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day213-HTTP三次握手</title>
    <link href="http://lmislm.com/2019/08/14/2019-08-14/"/>
    <id>http://lmislm.com/2019/08/14/2019-08-14/</id>
    <published>2019-08-13T16:00:00.000Z</published>
    <updated>2019-08-16T14:55:45.986Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>目的</li><li>名词</li><li>过程</li><li>疑问<a id="more"></a></li></ol><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>客户端连接服务端，建立TCP连接，交换窗口大小信息</p><h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><p><code>ISN(Initial Sequence Number)：</code>操作系统动态随机选取一个32位长的序列号，即初始序列号ISN。</p><p><code>SYN(SYNchronization)：</code>同步信号SYN，占用一个字节的编号。</p><p>在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。</p><p>对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。</p><p><code>ACKnum：</code>确认序号。Inform the sending host that the transmitted data was received successfully.</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p><strong>第一次握手</strong>（SYN=1, seq=x)</p><p>客户端发送，TCP的SYN标志位初始值为1的包，表明客户端向服务端发起连接。同时seq（ sequence numbers 序列号）包含ISN序列号x，保存在发送包序列号字段里。</p><p>发送完毕后，客户端进入<code>SYN_SEND</code>状态。</p><p><strong>第二次握手</strong>（SYN=1, seq=y, ACK=1, ACKnum=x+1）（注意ACKnum又写作ack）</p><p>服务器返回，SYN标志位和ACK标志位为1。服务端将ISN序列号放入Seq域，同时将ACKnum（Acknowledgement Number：确认序号）设置为客户端ISN序列号加1，即x+1。</p><p>发送完毕后，服务端进入<code>SYN_RCVD</code>状态。</p><p><strong>第三次握手</strong>（ACK=1，seq=x + 1，ACKnum=y+1）</p><p>客户端发送，SYN标志位为0，ACK标志位为1，将服务端的seq序号值加1，放入确认序号中，发送给服务端。</p><p>发送完毕后，客户端进入<code>ESTABLISHED</code>状态，服务端接收后，也进入ESTABLISHED状态。TCP三次握手结束</p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ol><li>为什么是三次握手不是两次握手？</li></ol><p>TCP 需要 seq 序列号来做可靠重传或接收，而避免连接复用时无法分辨出 seq 是延迟或者是旧链接的 seq。</p><blockquote><p>谢希仁版《计算机网络》：“已失效的连接请求报文段” 的产生在这样一种情况下：client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。”</p><ol start="2"><li>TCP 怎么样识别之前旧链接重发的包？</li></ol></blockquote><p>ISN（初始序列号）机制。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zhihu.com/question/24853633" target="_blank" rel="noopener">TCP 为什么是三次握手，而不是两次或四次？</a></p><p><a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html" target="_blank" rel="noopener">三次握手</a></p><p><a href="https://packetlife.net/blog/2010/jun/7/understanding-tcp-sequence-acknowledgment-numbers/" target="_blank" rel="noopener">Understanding TCP Sequence and Acknowledgment Numbers</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;目的&lt;/li&gt;
&lt;li&gt;名词&lt;/li&gt;
&lt;li&gt;过程&lt;/li&gt;
&lt;li&gt;疑问
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day212-DNS解析</title>
    <link href="http://lmislm.com/2019/08/13/2019-08-13/"/>
    <id>http://lmislm.com/2019/08/13/2019-08-13/</id>
    <published>2019-08-12T16:00:00.000Z</published>
    <updated>2019-08-16T14:52:25.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>DNS解析过程</li><li>DNS优化<a id="more"></a></li></ol><h2 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h2><p>DNS解析查IP过程：（以<a href="http://www.xxx.com为例）" target="_blank" rel="noopener">www.xxx.com为例）</a><br>过程：. -&gt; .com -&gt; xxx.com. -&gt; <a href="http://www.xxx.com" target="_blank" rel="noopener">www.xxx.com</a>.</p><ol><li>读取DNS缓存（缓存分为：浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存）</li><li>查找LDNS（本地区域名服务器，如果你在学校接入互联网，则 LDNS 服务器就在学校）。LDNS查询自己的DNS缓存，失败则进行DNS解析请求。</li><li>LDNS查找根域名服务器（<a href="http://www.xxx.com.，注意com后的“.”对应根域名服务器，默认都有，通常省略，但浏览器请求DNS时会自动加上" target="_blank" rel="noopener">www.xxx.com.，注意com后的“.”对应根域名服务器，默认都有，通常省略，但浏览器请求DNS时会自动加上</a>)</li><li>LDNS查找顶级域名服务器（COM域名服务器）</li><li>LDNS查找主域名服务器（xxx.com域名服务器），得到IP地址</li><li>LDNS将得到的IP地址，返回给操作系统，自己也存一份。</li></ol><h2 id="DNS优化"><a href="#DNS优化" class="headerlink" title="DNS优化"></a>DNS优化</h2><ol><li><p>缓存<br>主要有：浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存<br>浏览器缓存查看（Chrome版本75.0.3770.100为例）：<code>chrome://net-internals/#dns</code>。注：可以从<code>chrome://chrome-urls/</code>进去<br>系统缓存查看：（<code>/etc/hosts</code>，Linux系统）（<code>hosts</code>，Windows系统）</p></li><li><p>负载均衡<br>根据每台被请求的机器（含有请求资源）的负载量，该机器离用户地理位置的距离等等，来决定哪个机器处理，即负载均衡，又叫DNS重定向。</p></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">前端经典面试题: 从输入URL到页面加载发生了什么？</a></p><p><a href="https://github.com/kaola-fed/blog/issues" target="_blank" rel="noopener">从输入页面地址到展示页面信息都发生了些什么？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;DNS解析过程&lt;/li&gt;
&lt;li&gt;DNS优化
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day211-localStorage、sessionStorage、Cookie</title>
    <link href="http://lmislm.com/2019/08/12/2019-08-12/"/>
    <id>http://lmislm.com/2019/08/12/2019-08-12/</id>
    <published>2019-08-11T16:00:00.000Z</published>
    <updated>2019-08-16T14:52:21.063Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>三者异同</li><li>三者的基本概念<a id="more"></a></li></ol><h2 id="三者异同"><a href="#三者异同" class="headerlink" title="三者异同"></a>三者异同</h2><table><thead><tr><th>特性</th><th>Cookie</th><th>localStorage</th><th>sessionStorage</th></tr></thead><tbody><tr><td>生命周期</td><td>可由服务器生成，可设置过期时间。如果在浏览器端生成Cookie，默认是关闭浏览器后清除</td><td>除非被清除，否则永久保存</td><td>仅在当前会话下有效，关闭页面或浏览器后被清除</td></tr><tr><td>可存放数据大小</td><td>4K左右</td><td>5MB左右</td><td>5MB左右</td></tr><tr><td>与服务器端通信</td><td>携带在HTTP头中</td><td>不与服务器端通信，仅仅在浏览器中保存</td><td>不与服务器端通信，仅仅在浏览器中保存</td></tr><tr><td>易用性</td><td>接口不友好</td><td>相对较容易封装</td><td>相对较容易封装</td></tr></tbody></table><h2 id="三者的基本概念"><a href="#三者的基本概念" class="headerlink" title="三者的基本概念"></a>三者的基本概念</h2><p><strong>localStorage</strong></p><p>HTML5新特性，支持IE8+、 IE6+的polyfill可以用userData。localStorage在浏览器的隐私模式下面是不可读取的。</p><p><strong>sessionStorage</strong></p><p>仅在当前会话下有效，关闭页面或浏览器后被清除。<br><strong>作用域</strong> 如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的。</p><p><strong>Cookie</strong><br>生命周期在设置的cookie过期时间之前一直有效。长度和数量的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB。属于旧方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;三者异同&lt;/li&gt;
&lt;li&gt;三者的基本概念
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day210-Content-Type</title>
    <link href="http://lmislm.com/2019/08/11/2019-08-11/"/>
    <id>http://lmislm.com/2019/08/11/2019-08-11/</id>
    <published>2019-08-10T16:00:00.000Z</published>
    <updated>2019-08-16T14:52:16.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>是什么？</li><li>句法</li><li>指令，及其注释<a id="more"></a></li></ol><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>Content-Type 实体头部用于指示资源的MIME类型 media type 。</p><h2 id="句法"><a href="#句法" class="headerlink" title="句法"></a>句法</h2><p>就是经常在header中看到的东西，如，<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Content-Type: text/html; charset=utf<span class="number">-8</span></span><br></pre></td></tr></table></figure></p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><ol><li>media-type</li></ol><p>资源或数据的 MIME type（媒体类型—通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型 ，是一种标准，用来表示文档、文件或字节流的性质和格式，如：text/html<br>、text/plain）。</p><ul><li>常见的：<br><code>multipart/form-data</code>，用以支持向服务器发送二进制数据</li></ul><p><code>application/x-www-urlencoded</code>，消息内容会经过 URL 格式编码，可用get方法和post方法，但不写enctype，无法实现文件上传</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.runoob.com/http/http-content-type.html" target="_blank" rel="noopener">HTTP content-type 对照表</a></p><p><a href="https://segmentfault.com/a/1190000003002851#articleHeader2" target="_blank" rel="noopener">理解HTTP之Content-Type</a></p><p><a href="https://juejin.im/post/5c9f4885f265da308868dad1" target="_blank" rel="noopener">上传文件multipart/form-data深入解析</a></p><p><a href="https://www.jianshu.com/p/29e38bcc8a1d" target="_blank" rel="noopener">深入解析 multipart/form-data</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;是什么？&lt;/li&gt;
&lt;li&gt;句法&lt;/li&gt;
&lt;li&gt;指令，及其注释
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
