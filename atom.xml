<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LMISLMのBlog</title>
  
  <subtitle>不积小流，无以成江海。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lmislm.com/"/>
  <updated>2019-06-09T15:55:34.461Z</updated>
  <id>http://lmislm.com/</id>
  
  <author>
    <name>lmislm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>day146-LeetCode 349. Intersection of Two Arrays</title>
    <link href="http://lmislm.com/2019/06/09/2019-06-09/"/>
    <id>http://lmislm.com/2019/06/09/2019-06-09/</id>
    <published>2019-06-08T16:00:00.000Z</published>
    <updated>2019-06-09T15:55:34.461Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given two arrays, write a function to compute their intersection.</p><p>Example:</p><p>Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].</p><p>Note:</p><p>Each element in the result must be unique.</p><p>The result can be in any order.</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>选较短的数组去和长数组比较；<br>短数组值依次遍历长数组；<br>找短数组中有相应的值；</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">intersection</span> (<span class="params">arr1, arr2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">let</span> longArr</span><br><span class="line">    <span class="keyword">let</span> shortArr</span><br><span class="line">    <span class="keyword">if</span> (arr1.length &gt; arr2.length) &#123;</span><br><span class="line">        longArr = arr1</span><br><span class="line">        shortArr = arr2</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shortArr = arr1</span><br><span class="line">        longArr = arr2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; shortArr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = shortArr[i]</span><br><span class="line">        <span class="comment">// 如果longArr中有shortArr的值，而且在交集数组中没有，则为新交集</span></span><br><span class="line">        <span class="keyword">if</span>(longArr.indexOf(value) &gt;= <span class="number">0</span> &amp;&amp; result.indexOf(value) === <span class="number">-1</span>) &#123;</span><br><span class="line">            result.push(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其实es6可以用很快的方法解决</span></span><br><span class="line"><span class="keyword">let</span> intersection = arr1.filter(<span class="function"><span class="params">x</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Set</span>(arr2).has(x))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given two arrays, write a function to compute their intersection.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;p&gt;Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].&lt;/p&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;p&gt;Each element in the result must be unique.&lt;/p&gt;
&lt;p&gt;The result can be in any order.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day146-LeetCode 283. Move Zeroes</title>
    <link href="http://lmislm.com/2019/06/08/2019-06-08/"/>
    <id>http://lmislm.com/2019/06/08/2019-06-08/</id>
    <published>2019-06-07T16:00:00.000Z</published>
    <updated>2019-06-08T15:03:34.109Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p><p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</p><p>Note:</p><p>You must do this in-place without making a copy of the array.<br>Minimize the total number of operations.</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>注意：只能是针对当前数组操作，不能是新增数组<br>将数组中遍历的非零元素依次递增标记，以0为初始值，最后将标记的值作为数组元素下标。<br>递增次数为非零元素个数，遍历完成之后，非零元素补零。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">moveZeros</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 标记所有非零元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// n为非零元素</span></span><br><span class="line">        <span class="keyword">let</span> n = arr[i]</span><br><span class="line">        <span class="keyword">if</span> (n !== <span class="number">0</span>) &#123;</span><br><span class="line">            arr[index++] = n</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非零元素之外的元素补零</span></span><br><span class="line">    <span class="keyword">for</span> (index; index &lt; arr.length; index++) &#123;</span><br><span class="line">        arr[index] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.&lt;/p&gt;
&lt;p&gt;For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].&lt;/p&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;p&gt;You must do this in-place without making a copy of the array.&lt;br&gt;Minimize the total number of operations.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day144-LeetCode 112. Path Sum</title>
    <link href="http://lmislm.com/2019/06/06/2019-06-06/"/>
    <id>http://lmislm.com/2019/06/06/2019-06-06/</id>
    <published>2019-06-05T16:00:00.000Z</published>
    <updated>2019-06-08T15:03:16.155Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.<br>For example: Given the below binary tree and sum = 22,<br><a id="more"></a><br>5<br>/ \<br>4   8<br>/   / \<br>11  13  4<br>/  \      \<br>7    2      1</p><p>return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><strong>leetcode 104</strong>的变形。用递归来计算每条路径的总和。<br>求根节点到子树的每条可能路径的和，并检测是否和给出的随机数相等。</p><p>从父节点出发，如果父节点加左节点不等于给出的随机数，则回退父节点加右节点，<br>如果不相等且子节点有左右子树则递归上述过程。<br>直到找到和随机数相等的值返回true,否则返回false</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPathEqualSum</span> (<span class="params">root, sum</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="keyword">let</span> list = []</span><br><span class="line">  <span class="comment">// 计算总和</span></span><br><span class="line">  sumR2L(root, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> sumR2L(root, <span class="number">0</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sumR2L</span>(<span class="params">root, s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root.left === <span class="literal">null</span> &amp;&amp; root.right === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 到底的时候，判断总和是否是与sum相同</span></span><br><span class="line">      list.push(s)</span><br><span class="line">      s += root.val</span><br><span class="line">      <span class="keyword">return</span> s === sum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右边到底</span></span><br><span class="line">    <span class="keyword">if</span> (root.left !== <span class="literal">null</span> &amp;&amp; root.right === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> sumR2L(root.left, s + root.val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左边到底</span></span><br><span class="line">    <span class="keyword">if</span> (root.left === <span class="literal">null</span> &amp;&amp; root.right !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> sumR2L(root.right, s + root.val)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 两边的树没有到底</span></span><br><span class="line">    <span class="keyword">return</span> sumR2L(root.left, s + root.val) || sumR2L(root.right, s + root.val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.&lt;br&gt;For example: Given the below binary tree and sum = 22,&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day145-LeetCode 121. Best Time to Buy and Sell Stock</title>
    <link href="http://lmislm.com/2019/06/06/2019-06-07/"/>
    <id>http://lmislm.com/2019/06/06/2019-06-07/</id>
    <published>2019-06-05T16:00:00.000Z</published>
    <updated>2019-06-08T15:03:20.915Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Say you have an array for which the ith element is the price of a given stock on day i.</p><p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p><p>Example 1: Input: [7, 1, 5, 3, 6, 4]</p><p>Output: 5</p><p>max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)</p><p>Example 2: Input: [7, 6, 4, 3, 1]</p><p>Output: 0</p><p>In this case, no transaction is done, i.e. max profit = 0.</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>数组中的元素，从index 0 到最后一位，都表示每天的股价变化。求给出的数组中，利益最大的一天。即，从后往前相减，整数最大的值</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxProfit</span> (<span class="params">prices</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 表示最低的股价，MAX_表示无限大</span></span><br><span class="line">    <span class="keyword">let</span> min = <span class="built_in">Number</span>.MAX_SAFE_INTEGER</span><br><span class="line">    <span class="keyword">let</span> maxProfit = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 冒泡找出最小值</span></span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; min) &#123;</span><br><span class="line">            min = prices[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前可获利的值</span></span><br><span class="line">        <span class="keyword">let</span> calProfit = prices[i] - min</span><br><span class="line">        <span class="keyword">if</span>(calProfit &gt; maxProfit) &#123;</span><br><span class="line">            maxProfit = calProfit</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;
&lt;p&gt;If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.&lt;/p&gt;
&lt;p&gt;Example 1: Input: [7, 1, 5, 3, 6, 4]&lt;/p&gt;
&lt;p&gt;Output: 5&lt;/p&gt;
&lt;p&gt;max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)&lt;/p&gt;
&lt;p&gt;Example 2: Input: [7, 6, 4, 3, 1]&lt;/p&gt;
&lt;p&gt;Output: 0&lt;/p&gt;
&lt;p&gt;In this case, no transaction is done, i.e. max profit = 0.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day143-LeetCode 70. Climbing Stairs</title>
    <link href="http://lmislm.com/2019/06/04/2019-06-04/"/>
    <id>http://lmislm.com/2019/06/04/2019-06-04/</id>
    <published>2019-06-03T16:00:00.000Z</published>
    <updated>2019-06-07T14:17:01.874Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>You are climbing a stair case. It takes n steps to reach to the top.<br>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这种从无穷之中找规律的题目，难免会想到动态规划，所以可以先分情况来~</p><p>n为阶梯数，p表示方法种类<br>n = 1; p = 1<br>n = 2; p = 1+1<br>n = 3; p = 1+2<br>n = 4; p = 3+2<br>规律，斐波那契数列f(n) = f(n-1) + f(n-2)</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">climbStairs</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> prev = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> cur = <span class="number">1</span></span><br><span class="line">  <span class="comment">// f(n) = f(n -1) + f(n -2)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = cur</span><br><span class="line">    cur = cur + prev</span><br><span class="line">    prev = temp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cur</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;You are climbing a stair case. It takes n steps to reach to the top.&lt;br&gt;Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day142-LeetCode 171. Excel Sheet Column Number</title>
    <link href="http://lmislm.com/2019/06/03/2019-06-03/"/>
    <id>http://lmislm.com/2019/06/03/2019-06-03/</id>
    <published>2019-06-02T16:00:00.000Z</published>
    <updated>2019-06-03T15:32:01.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Related to question Excel Sheet Column Title<br>Given a column title as appear in an Excel sheet, return its corresponding column number.</p><a id="more"></a><p>For example:<br>A -&gt; 1<br>B -&gt; 2<br>C -&gt; 3<br>…<br>Z -&gt; 26<br>AA -&gt; 27<br>AB -&gt; 28 </p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>总共26个字母，所以这个也可以算是26进制。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">titleToNumber</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> exp = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = s.length <span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="comment">// 转成数字</span></span><br><span class="line">      <span class="keyword">let</span> v = s.charCodeAt(i) - <span class="number">64</span></span><br><span class="line">      <span class="comment">// 毎多一个代表26的n次方</span></span><br><span class="line">      v = v * <span class="built_in">Math</span>.pow(<span class="number">26</span>,exp++)</span><br><span class="line">      sum += v</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Related to question Excel Sheet Column Title&lt;br&gt;Given a column title as appear in an Excel sheet, return its corresponding column number.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day141-LeetCode 110. Balanced Binary Tree</title>
    <link href="http://lmislm.com/2019/06/02/2019-06-02/"/>
    <id>http://lmislm.com/2019/06/02/2019-06-02/</id>
    <published>2019-06-01T16:00:00.000Z</published>
    <updated>2019-06-02T06:56:33.472Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree, determine if it is height-balanced.<br>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>求左右子树的最大深度<br>即：左右子树的高度差为0</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBalanceTree</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span> || (root.left === <span class="literal">null</span> &amp;&amp; root.right === <span class="literal">null</span>)) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment">// 分别找出左右子树深度</span></span><br><span class="line">  <span class="keyword">let</span> deepLeft = findDeepth (root.left)</span><br><span class="line">  <span class="keyword">let</span> deepRight = findDeepth (root.right)</span><br><span class="line">  <span class="comment">// 是否是平衡树</span></span><br><span class="line">  <span class="keyword">let</span> isBalance = <span class="built_in">Math</span>.abs(deepLeft - deepRight) &lt; <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> isBalance &amp;&amp; isBalanceTree(root.left) &amp;&amp; isBalanceTree(root.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findDeepth</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> deepLeftDeepth = findDeepth(root.left) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> deepRightDeepth = findDeepth(root.right) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> deepLeftDeepth &gt; deepRightDeepth ? deepLeftDeepth : deepRightDeepth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given a binary tree, determine if it is height-balanced.&lt;br&gt;For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day140-LeetCode 206. Reverse Linked List</title>
    <link href="http://lmislm.com/2019/06/01/2019-06-01/"/>
    <id>http://lmislm.com/2019/06/01/2019-06-01/</id>
    <published>2019-05-31T16:00:00.000Z</published>
    <updated>2019-06-01T15:48:00.693Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Reverse a singly linked list.<br>{ val:1, next: {val:2, next:null} } }<br>{ val:2, next: {val:1, next:null} } }</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>链表反转</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseList</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!head.next) &#123;</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> prev = head</span><br><span class="line">  <span class="keyword">let</span> cur  = head.next</span><br><span class="line">  prev.next = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">while</span> (cur !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = cur</span><br><span class="line">    <span class="comment">// 当前node指向下一个，不然会被后面操作影响</span></span><br><span class="line">    cur = cur.next</span><br><span class="line">    <span class="comment">// 只需要当前node的值，不需要他的next，temp.next = null</span></span><br><span class="line">    <span class="comment">// 之前的linked list加到当前node后面， temp.next = prev</span></span><br><span class="line">    temp.next = prev </span><br><span class="line">    prev = temp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> prev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Reverse a singly linked list.&lt;br&gt;{ val:1, next: {val:2, next:null} } }&lt;br&gt;{ val:2, next: {val:1, next:null} } }&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day139-LeetCode 101. Symmetric Tree</title>
    <link href="http://lmislm.com/2019/05/31/2019-05-31/"/>
    <id>http://lmislm.com/2019/05/31/2019-05-31/</id>
    <published>2019-05-30T16:00:00.000Z</published>
    <updated>2019-05-31T14:44:38.015Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p><p>For example, this binary tree [1,2,2,3,4,4,3] is symmetric: But the following [1,2,2,null,3,null,3] is not<br>      1<br>    /   \<br>   2     2<br>  / \   / \<br>3   4 4   3<br>把左子树反转就是右子树</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这题是反转二叉树和比较二叉树相同的结合</p><ol><li>先反转二叉树</li><li>比较反转后的二叉树是否相等</li></ol><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSymmetricTree</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span> || root.right ===  <span class="literal">null</span> || root.left === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 反转</span></span><br><span class="line">  root.left = revertTree(root.right)</span><br><span class="line">  <span class="keyword">return</span> isSameTree(root.left, root.right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">revertTree</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(node == <span class="literal">null</span> || node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> temp = revertTree(node.left)</span><br><span class="line">  node.left = revertTree(node.right)</span><br><span class="line">  node.right = temp</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSameTree</span> (<span class="params">leftNode, rightNode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 空节点，递归结束</span></span><br><span class="line">  <span class="keyword">if</span> (leftNode === <span class="literal">null</span> || rightNode === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 左右子树有一个为空</span></span><br><span class="line">  <span class="keyword">if</span> (leftNode === <span class="literal">null</span> &amp;&amp; rightNode !== <span class="literal">null</span> || leftNode !== <span class="literal">null</span> &amp;&amp; rightNode === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断非空节点是否相等</span></span><br><span class="line">  <span class="keyword">if</span> (leftNode !== rightNode) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 递归</span></span><br><span class="line">  <span class="keyword">return</span> isSameTree(leftNode.right, rightNode.right) &amp;&amp; isSameTree(leftNode.left, rightNode.left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).&lt;/p&gt;
&lt;p&gt;For example, this binary tree [1,2,2,3,4,4,3] is symmetric: But the following [1,2,2,null,3,null,3] is not&lt;br&gt;      1&lt;br&gt;    /   \&lt;br&gt;   2     2&lt;br&gt;  / \   / \&lt;br&gt;3   4 4   3&lt;br&gt;把左子树反转就是右子树&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day138-LeetCode 235. Lowest Common Ancestor of a Binary Search</title>
    <link href="http://lmislm.com/2019/05/30/2019-05-30/"/>
    <id>http://lmislm.com/2019/05/30/2019-05-30/</id>
    <published>2019-05-29T16:00:00.000Z</published>
    <updated>2019-05-30T15:56:35.240Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>LeetCode 235. Lowest Common Ancestor of a Binary Search<br>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.<br>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”<br>      _6_<br>    /    \<br>    2      8<br>   /  \    / \<br>  0   4  7   9<br> / \<br>3   5</p><p>For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. </p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>注意这颗是中序遍历的二叉树，左子树节点值小于根节点值小于右子树节点值。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lowestCommonAncestor</span> (<span class="params">root, p, q</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> value =  root.val</span><br><span class="line">    <span class="keyword">if</span>(p.val &gt;= value &amp;&amp; value &gt;= q.val || p.val &lt;= value &amp;&amp; value &lt;= q.val)&#123;</span><br><span class="line">      <span class="keyword">return</span> root</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p.val &gt; value &amp;&amp; q.val &gt; value)&#123;</span><br><span class="line">      root =  root.right</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      root =  root.left</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;LeetCode 235. Lowest Common Ancestor of a Binary Search&lt;br&gt;Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.&lt;br&gt;According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).”&lt;br&gt;      _6_&lt;br&gt;    /    \&lt;br&gt;    2      8&lt;br&gt;   /  \    / \&lt;br&gt;  0   4  7   9&lt;br&gt; / \&lt;br&gt;3   5&lt;/p&gt;
&lt;p&gt;For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. &lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day137-LeetCode 100. Same Tree</title>
    <link href="http://lmislm.com/2019/05/29/2019-05-29/"/>
    <id>http://lmislm.com/2019/05/29/2019-05-29/</id>
    <published>2019-05-28T16:00:00.000Z</published>
    <updated>2019-05-29T15:18:48.438Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given two binary trees, write a function to check if they are equal or not.<br>Two binary trees are considered equal if they are structurally identical and the nodes have the same value.<br>判断两棵二叉树是否完全相等</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>用递归比较简单点。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * function TreeNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.left = this.right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line">isSameTree (p, q) &#123;</span><br><span class="line">  <span class="comment">// 左右子树终止条件</span></span><br><span class="line">  <span class="keyword">if</span>(p === <span class="literal">null</span> &amp;&amp; q === <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// one null, other is not null, false</span></span><br><span class="line">  <span class="keyword">if</span>(p !== <span class="literal">null</span> &amp;&amp; q === <span class="literal">null</span> || p === <span class="literal">null</span> &amp;&amp; q !== <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// val diff, false</span></span><br><span class="line">  <span class="keyword">if</span>(p.val !== q.val)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// find next level of tree</span></span><br><span class="line">  <span class="keyword">return</span> isSameTree(p.right, q.right) &amp;&amp; isSameTree(p.left, q.left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given two binary trees, write a function to check if they are equal or not.&lt;br&gt;Two binary trees are considered equal if they are structurally identical and the nodes have the same value.&lt;br&gt;判断两棵二叉树是否完全相等&lt;/p&gt;
&lt;h3 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h3&gt;&lt;p&gt;用递归比较简单点。&lt;/p&gt;
&lt;h3 id=&quot;题解&quot;&gt;&lt;a href=&quot;#题解&quot; class=&quot;headerlink&quot; title=&quot;题解&quot;&gt;&lt;/a&gt;题解&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * Definition for a binary tree node.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * function TreeNode(val) &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     this.val = val;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *     this.left = this.right = null;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 递归&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;isSameTree (p, q) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 左右子树终止条件&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(p === &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; q === &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// one null, other is not null, false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(p !== &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; q === &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; || p === &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; q !== &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// val diff, false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(p.val !== q.val)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// find next level of tree&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; isSameTree(p.right, q.right) &amp;amp;&amp;amp; isSameTree(p.left, q.left)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day136-LeetCode 226. Invert Binary Tree</title>
    <link href="http://lmislm.com/2019/05/28/2019-05-28/"/>
    <id>http://lmislm.com/2019/05/28/2019-05-28/</id>
    <published>2019-05-27T16:00:00.000Z</published>
    <updated>2019-05-28T15:58:12.921Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Invert a binary tree.<br>反转二叉树<br>输入<br>     4<br>   /   \<br>  2     7<br> / \   / \<br>1   3 6   9<br>反转<br>     4<br>   /   \<br>  7     2<br> / \   / \<br>9  6 3   1</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>对树进行广度遍历，过程中左右节点进行交换，单节点则跳过。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invert</span> (<span class="params">treeNode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 单节点跳过</span></span><br><span class="line">  <span class="keyword">if</span>(treeNode === <span class="literal">null</span> || (treeNode.right === <span class="literal">null</span> &amp;&amp; treeNode.left === <span class="literal">null</span>))&#123;</span><br><span class="line">    <span class="keyword">return</span> treeNode</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 相互交换，并递归</span></span><br><span class="line">  <span class="keyword">let</span> temp = treeNode.left</span><br><span class="line">  treeNode.left = invertTree(treeNode.right)</span><br><span class="line">  treeNode.right = invertTree(temp)</span><br><span class="line">  <span class="keyword">return</span> treeNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Invert a binary tree.&lt;br&gt;反转二叉树&lt;br&gt;输入&lt;br&gt;     4&lt;br&gt;   /   \&lt;br&gt;  2     7&lt;br&gt; / \   / \&lt;br&gt;1   3 6   9&lt;br&gt;反转&lt;br&gt;     4&lt;br&gt;   /   \&lt;br&gt;  7     2&lt;br&gt; / \   / \&lt;br&gt;9  6 3   1&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day135-Maximum Depth of Binary Tree</title>
    <link href="http://lmislm.com/2019/05/27/2019-05-27/"/>
    <id>http://lmislm.com/2019/05/27/2019-05-27/</id>
    <published>2019-05-26T16:00:00.000Z</published>
    <updated>2019-05-27T14:11:33.754Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given a binary tree, find its maximum depth.<br>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>就是判断二叉树的左右子树有没有值，有值的话就继续往下走。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">binaryTreeMaxDepth</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> find (root)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">find</span> (<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断节点为空或者到底部，即没有左右子树</span></span><br><span class="line">    <span class="keyword">if</span>(node === <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> treeLeftDepth = <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> treeRightDepth = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(node.left !== <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="comment">// 递归</span></span><br><span class="line">      treeLeftDepth += find(node.left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.right !== <span class="literal">null</span>)&#123;</span><br><span class="line">      treeRightDepth += find(node.right)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 比较左右子树层数大小</span></span><br><span class="line">    <span class="keyword">return</span> treeLeftDepth &gt; treeRightDepth ?　treeLeftDepth : treeRightDepth</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;Given a binary tree, find its maximum depth.&lt;br&gt;The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day134-LeetCode 292. Nim Game</title>
    <link href="http://lmislm.com/2019/05/26/2019-05-26%E3%80%81/"/>
    <id>http://lmislm.com/2019/05/26/2019-05-26、/</id>
    <published>2019-05-25T16:00:00.000Z</published>
    <updated>2019-05-26T15:37:14.881Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>（动态规划）<br>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.<br>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.<br>For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.</p><a id="more"></a><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>动态规划的话。先逐步分析。先分析可能的情况。</p><blockquote><p><code>剩下1-3个石头，我赢。</code><br><code>剩下4个石头，我先拿1-3个，输。</code><br><code>剩下5个石头，我先拿1个，然后剩下4个轮到他先，我赢。先拿2-3个的话，我输。</code><br><code>剩下6个石头，我先拿1个，回到上一步5个石头他先。我先拿两个，就是4个石头他先，他输。</code><br><code>剩下7个石头，我先拿1个，回到上一步6个石头他先拿，他拿两个的话就回到5个石头情况，他赢。我拿3个才能到状态4个石头他先拿，他输。</code><br>所以，我得想办法让他面前的石头数量到4个石头，这样有5-7个石头时我先拿的话都可以赢。<br>如果是8个石头,我先拿至少一个，剩下5-6个石头他先拿，只要他让我面前剩下4个，他就有优势，我都会输。</p></blockquote><p>4和8为倍数关系。归纳总结出初步结论，有可能是4的倍数的时候，我先拿就输。</p><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">canFirstWinNimGame</span> (<span class="params">sum</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sum &lt; <span class="number">4</span>) &#123; <span class="comment">// 1-3的整数，先拿肯定赢</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n%<span class="number">4</span> !== <span class="number">0</span> <span class="comment">// 剩下的总数是4的倍数时，先拿肯定输</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;（动态规划）&lt;br&gt;You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.&lt;br&gt;Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.&lt;br&gt;For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="acm" scheme="http://lmislm.com/tags/acm/"/>
    
  </entry>
  
  <entry>
    <title>day133-vuejs源码-template编译-笔记</title>
    <link href="http://lmislm.com/2019/05/25/2019-05-25/"/>
    <id>http://lmislm.com/2019/05/25/2019-05-25/</id>
    <published>2019-05-24T16:00:00.000Z</published>
    <updated>2019-05-25T15:29:40.736Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>包括$mount和render方法。</p><a id="more"></a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount</span><br><span class="line"><span class="comment">/*挂载组件*/</span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; query(el)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> options = <span class="keyword">this</span>.$options</span><br><span class="line">  <span class="comment">// resolve template/el and convert to render function</span></span><br><span class="line">  <span class="comment">/*优先使用render，不存在的时候编译template*/</span></span><br><span class="line">  <span class="keyword">if</span> (!options.render) &#123;</span><br><span class="line">    <span class="keyword">let</span> template = options.template</span><br><span class="line">    <span class="comment">/*template存在的时候取template，不存在的时候取el的outerHTML*/</span></span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="comment">/*当template是字符串的时候*/</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (template.charAt(<span class="number">0</span>) === <span class="string">'#'</span>) &#123;</span><br><span class="line">          template = idToTemplate(template)</span><br><span class="line">          <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">          <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !template) &#123;</span><br><span class="line">            warn(</span><br><span class="line">              <span class="string">`Template element not found or is empty: <span class="subst">$&#123;options.template&#125;</span>`</span>,</span><br><span class="line">              <span class="keyword">this</span></span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.nodeType) &#123;</span><br><span class="line">        <span class="comment">/*当template为DOM节点的时候*/</span></span><br><span class="line">        template = template.innerHTML</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*报错*/</span></span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">          warn(<span class="string">'invalid template option:'</span> + template, <span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">      <span class="comment">/*获取element的outerHTML*/</span></span><br><span class="line">      template = getOuterHTML(el)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(<span class="string">'compile'</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*将template编译成render函数，这里会有render以及staticRenderFns两个返回，这是vue的编译时优化，static静态不需要在VNode更新时进行patch，优化性能*/</span></span><br><span class="line">  <span class="comment">// ?</span></span><br><span class="line">      <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</span><br><span class="line">        shouldDecodeNewlines,</span><br><span class="line">        delimiters: options.delimiters</span><br><span class="line">      &#125;, <span class="keyword">this</span>)</span><br><span class="line">      options.render = render</span><br><span class="line">      options.staticRenderFns = staticRenderFns</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(<span class="string">'compile end'</span>)</span><br><span class="line">        measure(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>._name&#125;</span> compile`</span>, <span class="string">'compile'</span>, <span class="string">'compile end'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*Github:https://github.com/answershuto*/</span></span><br><span class="line">  <span class="comment">/*调用const mount = Vue.prototype.$mount保存下来的不带编译的mount*/</span></span><br><span class="line">  <span class="keyword">return</span> mount.call(<span class="keyword">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/answershuto/learnVue/blob/master/docs/%E8%81%8A%E8%81%8AVue%E7%9A%84template%E7%BC%96%E8%AF%91.MarkDown" target="_blank" rel="noopener">聊聊Vue的template编译.MarkDown</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;包括$mount和render方法。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day132-小试牛刀的题目-1</title>
    <link href="http://lmislm.com/2019/05/24/2019-05-24/"/>
    <id>http://lmislm.com/2019/05/24/2019-05-24/</id>
    <published>2019-05-23T16:00:00.000Z</published>
    <updated>2019-05-24T15:25:35.390Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一道构造数据结构的题目。<br>src: [{id:1}, {id:1}, {id:2}]<br>tgt: {1: [0,1], 2:[2]}</p><a id="more"></a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>个人解法。希望以后想出更好的解法。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">groupByProp</span> (<span class="params">objArray, prop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> objArray.reduce(<span class="function">(<span class="params">acc, cur, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> key = cur[prop]</span><br><span class="line">    <span class="keyword">if</span> (!acc[key]) &#123;</span><br><span class="line">      acc[key] = []</span><br><span class="line">    &#125;</span><br><span class="line">    acc[key].push(index)</span><br><span class="line">    <span class="keyword">return</span> acc</span><br><span class="line">  &#125;, &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let data = [&#123;id:1&#125;, &#123;id:1&#125;, &#123;id:2&#125;]</span></span><br><span class="line"><span class="comment">// console.log(groupByProp(data, 'id'))</span></span><br><span class="line"><span class="comment">// &#123; '1': [ 0, 1 ], '2': [ 2 ] &#125;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;一道构造数据结构的题目。&lt;br&gt;src: [{id:1}, {id:1}, {id:2}]&lt;br&gt;tgt: {1: [0,1], 2:[2]}&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day131-vuejs源码-数据绑定-3</title>
    <link href="http://lmislm.com/2019/05/23/2019-05-23/"/>
    <id>http://lmislm.com/2019/05/23/2019-05-23/</id>
    <published>2019-05-22T16:00:00.000Z</published>
    <updated>2019-05-23T15:38:52.141Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在Observer中，有一个<code>walk</code>方法：<br>在其构造器中，如果<code>observer</code>实例是对象则<code>walk</code>进行绑定<br><code>walk</code>方法会遍历对象的每一个属性进行<code>defineReactive</code>绑定<br><code>defineReactive</code>的作用则是通过<code>Object.defineProperty</code>为<br>数据定义上<code>getter\setter</code>方法，进行依赖收集后<br>闭包中的<code>Deps</code>会存放<code>Watcher</code>对象。触发<code>setter</code>改变数据时<br>会通知<code>Deps</code>订阅者通知所有的<code>Watcher</code>观察者对象进行视图的更新。</p><a id="more"></a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a reactive property on an Object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  obj: Object,</span></span></span><br><span class="line"><span class="function"><span class="params">  key: string,</span></span></span><br><span class="line"><span class="function"><span class="params">  val: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  customSetter?: ?Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  shallow?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 闭包Dep</span></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果之前定义过了就取出来</span></span><br><span class="line">  <span class="comment">// cater（注：迎合） for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set</span><br><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter () &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        <span class="comment">/* 依赖收集 */</span></span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          <span class="comment">/* 子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend -- 引 */</span></span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          <span class="comment">/* 判断是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。 */</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter (newVal) &#123;</span><br><span class="line">      <span class="comment">/* 如果原本对象拥有getter方法则执行 */</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">      <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span></span><br><span class="line">      <span class="comment">/* 判断原本对象拥有setter方法，有的话直接执行setter */</span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* 新值需要重新进行observe，保证数据响应式 */</span></span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      <span class="comment">/* 通知观察者 */</span></span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在Observer中，有一个&lt;code&gt;walk&lt;/code&gt;方法：&lt;br&gt;在其构造器中，如果&lt;code&gt;observer&lt;/code&gt;实例是对象则&lt;code&gt;walk&lt;/code&gt;进行绑定&lt;br&gt;&lt;code&gt;walk&lt;/code&gt;方法会遍历对象的每一个属性进行&lt;code&gt;defineReactive&lt;/code&gt;绑定&lt;br&gt;&lt;code&gt;defineReactive&lt;/code&gt;的作用则是通过&lt;code&gt;Object.defineProperty&lt;/code&gt;为&lt;br&gt;数据定义上&lt;code&gt;getter\setter&lt;/code&gt;方法，进行依赖收集后&lt;br&gt;闭包中的&lt;code&gt;Deps&lt;/code&gt;会存放&lt;code&gt;Watcher&lt;/code&gt;对象。触发&lt;code&gt;setter&lt;/code&gt;改变数据时&lt;br&gt;会通知&lt;code&gt;Deps&lt;/code&gt;订阅者通知所有的&lt;code&gt;Watcher&lt;/code&gt;观察者对象进行视图的更新。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day130-vuejs源码-数据绑定-2</title>
    <link href="http://lmislm.com/2019/05/22/2019-05-22/"/>
    <id>http://lmislm.com/2019/05/22/2019-05-22/</id>
    <published>2019-05-21T16:00:00.000Z</published>
    <updated>2019-05-22T15:45:19.202Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这次是再一次看watcher.js中的东西了，一直对dep涉及的闭包有点模糊。希望这次能懂更多点。</p><a id="more"></a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 再看数据绑定中的Watcher，class Watcher</span></span><br><span class="line"><span class="comment">// ...变量定义</span></span><br><span class="line"><span class="keyword">get</span> () &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  Dep中的pushTarget</span></span><br><span class="line"><span class="comment">   *  export function pushTarget (target: ?Watcher) &#123;</span></span><br><span class="line"><span class="comment">        targetStack.push(target)</span></span><br><span class="line"><span class="comment">        Dep.target = target</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  pushTarget(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">let</span> value</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="keyword">this</span>.vm</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    执行了getter操作，看似执行了渲染操作，其实是执行了依赖收集。</span></span><br><span class="line"><span class="comment">    在将Dep.target设置为自身观察者实例以后，执行getter操作。</span></span><br><span class="line"><span class="comment">    譬如说现在的的data中可能有a、b、c三个数据，getter渲染需要依赖a跟c，</span></span><br><span class="line"><span class="comment">    那么在执行getter的时候就会触发a跟c两个数据的getter函数，</span></span><br><span class="line"><span class="comment">    在getter函数中即可判断Dep.target是否存在然后完成依赖收集，</span></span><br><span class="line"><span class="comment">    将该观察者对象放入闭包中的Dep的subs中去。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value = <span class="keyword">this</span>.getter.call(vm, vm)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      handleError(e, vm, <span class="string">`getter for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    value = <span class="keyword">this</span>.getter.call(vm, vm)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// "touch" every property so they are all tracked as</span></span><br><span class="line">  <span class="comment">// dependencies for deep watching</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.deep) &#123;</span><br><span class="line">    <span class="comment">/*递归*/</span></span><br><span class="line">    traverse(value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * dep中的popTarget</span></span><br><span class="line"><span class="comment">   *  export function popTarget () &#123;</span></span><br><span class="line"><span class="comment">        targetStack.pop()</span></span><br><span class="line"><span class="comment">        Dep.target = targetStack[targetStack.length - 1]</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  popTarget()</span><br><span class="line">  <span class="keyword">this</span>.cleanupDeps()</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add a dependency to this directive（）.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">addDep (dep: Dep) &#123;</span><br><span class="line">  <span class="keyword">const</span> id = dep.id</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">    <span class="keyword">this</span>.newDepIds.add(id)</span><br><span class="line">    <span class="keyword">this</span>.newDeps.push(dep)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.has(id)) &#123;</span><br><span class="line">      dep.addSub(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Clean up for dependency collection.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">cleanupDeps () &#123;</span><br><span class="line">  <span class="comment">/*移除所有观察者对象*/</span></span><br><span class="line">  <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">this</span>.deps[i]</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.newDepIds.has(dep.id)) &#123;</span><br><span class="line">      dep.removeSub(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> tmp = <span class="keyword">this</span>.depIds</span><br><span class="line">  <span class="keyword">this</span>.depIds = <span class="keyword">this</span>.newDepIds</span><br><span class="line">  <span class="keyword">this</span>.newDepIds = tmp</span><br><span class="line">  <span class="keyword">this</span>.newDepIds.clear()</span><br><span class="line">  tmp = <span class="keyword">this</span>.deps</span><br><span class="line">  <span class="keyword">this</span>.deps = <span class="keyword">this</span>.newDeps</span><br><span class="line">  <span class="keyword">this</span>.newDeps = tmp</span><br><span class="line">  <span class="keyword">this</span>.newDeps.length = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subscriber（注：调度者） interface.</span></span><br><span class="line"><span class="comment"> * Will be called when a dependency changes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">    调度者接口，当依赖发生改变的时候进行回调。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">update () &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">    <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">    <span class="comment">/*同步则执行run直接渲染视图*/</span></span><br><span class="line">    <span class="keyword">this</span>.run()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/*异步推送到观察者队列中，由调度者调用。*/</span></span><br><span class="line">    queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scheduler job interface.</span></span><br><span class="line"><span class="comment"> * Will be called by the scheduler.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">run () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="keyword">this</span>.get()</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      value !== <span class="keyword">this</span>.value ||</span><br><span class="line">      <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">      <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">      <span class="comment">// have mutated.</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">          即便值相同，拥有Deep属性的观察者以及在对象／数组上的观察者应该被触发更新，因为它们的值可能发生改变。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      isObject(value) ||</span><br><span class="line">      <span class="keyword">this</span>.deep</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// set new value</span></span><br><span class="line">      <span class="keyword">const</span> oldValue = <span class="keyword">this</span>.value</span><br><span class="line">      <span class="comment">/*设置新的值*/</span></span><br><span class="line">      <span class="keyword">this</span>.value = value</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*触发回调渲染视图*/</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.user) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          handleError(e, <span class="keyword">this</span>.vm, <span class="string">`callback for watcher "<span class="subst">$&#123;<span class="keyword">this</span>.expression&#125;</span>"`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, value, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Evaluate the value of the watcher.</span></span><br><span class="line"><span class="comment"> * This only gets called for lazy watchers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*获取观察者的值*/</span></span><br><span class="line">evaluate () &#123;</span><br><span class="line">  <span class="keyword">this</span>.value = <span class="keyword">this</span>.get()</span><br><span class="line">  <span class="keyword">this</span>.dirty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Depend on all deps collected by this watcher.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*收集该watcher的所有deps依赖*/</span></span><br><span class="line">depend () &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">this</span>.deps[i].depend()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Remove self from all dependencies' subscriber list.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*将自身从所有依赖收集订阅列表删除*/</span></span><br><span class="line">teardown () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.active) &#123;</span><br><span class="line">    <span class="comment">// remove self from vm's watcher list</span></span><br><span class="line">    <span class="comment">// this is a somewhat expensive operation so we skip it</span></span><br><span class="line">    <span class="comment">// if the vm is being destroyed.</span></span><br><span class="line">    <span class="comment">/*从vm实例的观察者列表中将自身移除，由于该操作比较耗费资源，所以如果vm实例正在被销毁则跳过该步骤。--引*/</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.vm._isBeingDestroyed) &#123;</span><br><span class="line">      remove(<span class="keyword">this</span>.vm._watchers, <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="keyword">this</span>.deps.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="keyword">this</span>.deps[i].removeSub(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.active = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这次是再一次看watcher.js中的东西了，一直对dep涉及的闭包有点模糊。希望这次能懂更多点。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day129-vuejs源码-数据绑定原理-1</title>
    <link href="http://lmislm.com/2019/05/21/2019-05-21/"/>
    <id>http://lmislm.com/2019/05/21/2019-05-21/</id>
    <published>2019-05-20T16:00:00.000Z</published>
    <updated>2019-05-22T14:40:31.104Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这里从<code>initData</code>开始入手<br><code>initData</code>作用是初始化data中的数据，之后Observer数据，监听数据的变化。</p><a id="more"></a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://github.com/vuejs/vue/blob/dev/src/core/instance/state.js</span></span><br><span class="line"><span class="comment"> * initData主要是初始化data中的数据，将数据进行Observer，监听数据的变化，其他的监视原理一致</span></span><br><span class="line"><span class="comment"> * @param vm </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.$options.data</span><br><span class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">'function'</span></span><br><span class="line">    ? getData(data, vm)</span><br><span class="line">    : data || &#123;&#125;</span><br><span class="line">  <span class="comment">// 判断data是否是纯对象</span></span><br><span class="line">  <span class="keyword">if</span> (!isPlainObject(data)) &#123;</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">'data functions should return an object:\n'</span> +</span><br><span class="line">      <span class="string">'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function'</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// proxy data on instance</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data)</span><br><span class="line">  <span class="keyword">const</span> props = vm.$options.props</span><br><span class="line">  <span class="keyword">const</span> methods = vm.$options.methods</span><br><span class="line">  <span class="keyword">let</span> i = keys.length</span><br><span class="line">  <span class="comment">// 遍历data中的一些声明</span></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">      <span class="comment">// 检查methods命名和data中命名的冲突</span></span><br><span class="line">      <span class="keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" has already been defined as a data property.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查props命名和data中命名的冲突</span></span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">        <span class="string">`The data property "<span class="subst">$&#123;key&#125;</span>" is already declared as a prop. `</span> +</span><br><span class="line">        <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isReserved(key)) &#123;</span><br><span class="line">      <span class="comment">// 将data中的属性代理到vm实例上</span></span><br><span class="line">      proxy(vm, <span class="string">`_data`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  <span class="comment">// 开始对数据进行绑定</span></span><br><span class="line">  <span class="comment">// asRootData表示作为根数据，observe会递归对深层对象的绑定</span></span><br><span class="line">  observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;这里从&lt;code&gt;initData&lt;/code&gt;开始入手&lt;br&gt;&lt;code&gt;initData&lt;/code&gt;作用是初始化data中的数据，之后Observer数据，监听数据的变化。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day128-vuejs源码-事件机制</title>
    <link href="http://lmislm.com/2019/05/20/2019-05-20/"/>
    <id>http://lmislm.com/2019/05/20/2019-05-20/</id>
    <published>2019-05-19T16:00:00.000Z</published>
    <updated>2019-05-20T15:53:40.928Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>vuejs源码 v2.x.x 的实例方法 / 事件，$on，$once，$off，$emit</p><a id="more"></a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;.../core/instance/events.js&gt;  on 20 Dec 2018</span></span><br><span class="line"><span class="comment">// $on</span></span><br><span class="line"><span class="comment">// 监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。-- https://cn.vuejs.org/v2/api/#vm-on</span></span><br><span class="line"><span class="keyword">const</span> hookRE = <span class="regexp">/^hook:/</span></span><br><span class="line">Vue.prototype.$on = <span class="function"><span class="keyword">function</span> (<span class="params">event: string | Array&lt;string&gt;, fn: Function</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// $on可以是数组值</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(event)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = event.length; i &lt; l; i++) &#123;</span><br><span class="line">      vm.$on(event[i], fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    (vm._events[event] || (vm._events[event] = [])).push(fn)</span><br><span class="line">    <span class="comment">// optimize hook:event cost by using a boolean flag marked at registration</span></span><br><span class="line">    <span class="comment">// instead of a hash lookup（注：利用布尔值标识是否注册时存在钩子事件，而不是利用hash查询）</span></span><br><span class="line">    <span class="keyword">if</span> (hookRE.test(event)) &#123;</span><br><span class="line">      vm._hasHookEvent = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $once</span></span><br><span class="line"><span class="comment">// 监听一个自定义事件，但是只触发一次，在第一次触发之后移除监听器。-- https://cn.vuejs.org/v2/api/#vm-once</span></span><br><span class="line">Vue.prototype.$once = <span class="function"><span class="keyword">function</span> (<span class="params">event: string, fn: Function</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">on</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// $off表示将事件销毁，第一执行之后就销毁</span></span><br><span class="line">    vm.$off(event, on)</span><br><span class="line">    <span class="comment">// 调用方法</span></span><br><span class="line">    fn.apply(vm, <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  on.fn = fn</span><br><span class="line">  <span class="comment">// 监听事件</span></span><br><span class="line">  vm.$on(event, on)</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// $off</span></span><br><span class="line"><span class="comment">// 移除自定义事件监听器。</span></span><br><span class="line"><span class="comment">// 如果没有提供参数，则移除所有的事件监听器；</span></span><br><span class="line"><span class="comment">// 如果只提供了事件，则移除该事件所有的监听器；</span></span><br><span class="line"><span class="comment">// 如果同时提供了事件与回调，则只移除这个回调的监听器。https://cn.vuejs.org/v2/api/#vm-off</span></span><br><span class="line">Vue.prototype.$off = <span class="function"><span class="keyword">function</span> (<span class="params">event?: string | Array&lt;string&gt;, fn?: Function</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// all</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">    <span class="comment">// 返回创建的空对象</span></span><br><span class="line">    vm._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// array of events</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(event)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = event.length; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="comment">// 递归调用？</span></span><br><span class="line">      vm.$off(event[i], fn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// specific event</span></span><br><span class="line">  <span class="keyword">const</span> cbs = vm._events[event]</span><br><span class="line">  <span class="comment">// 事件不存在则返回本身</span></span><br><span class="line">  <span class="keyword">if</span> (!cbs) &#123;</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 事件置空</span></span><br><span class="line">  <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">    vm._events[event] = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// specific handler</span></span><br><span class="line">  <span class="comment">// 找对应的方法fn，找到就移除</span></span><br><span class="line">  <span class="keyword">let</span> cb</span><br><span class="line">  <span class="keyword">let</span> i = cbs.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    cb = cbs[i]</span><br><span class="line">    <span class="keyword">if</span> (cb === fn || cb.fn === fn) &#123;</span><br><span class="line">      cbs.splice(i, <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// $emit</span></span><br><span class="line"><span class="comment">// 触发当前实例上的事件。附加参数都会传给监听器回调。</span></span><br><span class="line">Vue.prototype.$emit = <span class="function"><span class="keyword">function</span> (<span class="params">event: string</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> lowerCaseEvent = event.toLowerCase()</span><br><span class="line">    <span class="keyword">if</span> (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) &#123;</span><br><span class="line">      tip(</span><br><span class="line">        <span class="string">`Event "<span class="subst">$&#123;lowerCaseEvent&#125;</span>" is emitted in component `</span> +</span><br><span class="line">        <span class="string">`<span class="subst">$&#123;formatComponentName(vm)&#125;</span> but the handler is registered for "<span class="subst">$&#123;event&#125;</span>". `</span> +</span><br><span class="line">        <span class="string">`Note that HTML attributes are case-insensitive and you cannot use `</span> +</span><br><span class="line">        <span class="string">`v-on to listen to camelCase events when using in-DOM templates. `</span> +</span><br><span class="line">        <span class="string">`You should probably use "<span class="subst">$&#123;hyphenate(event)&#125;</span>" instead of "<span class="subst">$&#123;event&#125;</span>".`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> cbs = vm._events[event]</span><br><span class="line">  <span class="keyword">if</span> (cbs) &#123;</span><br><span class="line">    <span class="comment">// toArray：类数组转为数组</span></span><br><span class="line">    cbs = cbs.length &gt; <span class="number">1</span> ? toArray(cbs) : cbs</span><br><span class="line">    <span class="keyword">const</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">const</span> info = <span class="string">`event handler for "<span class="subst">$&#123;event&#125;</span>"`</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = cbs.length; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="comment">// invokeWithErrorHandling 来自：&lt;src/core/util/error.js&gt;，避免嵌套调用时多次触发</span></span><br><span class="line">      invokeWithErrorHandling(cbs[i], vm, args, vm, info)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;vuejs源码 v2.x.x 的实例方法 / 事件，$on，$once，$off，$emit&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
