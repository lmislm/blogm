<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LMISLMのBlog</title>
  
  <subtitle>不积小流，无以成江海。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lmislm.com/"/>
  <updated>2019-05-20T15:53:40.928Z</updated>
  <id>http://lmislm.com/</id>
  
  <author>
    <name>lmislm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>day128-vuejs源码-事件机制</title>
    <link href="http://lmislm.com/2019/05/20/2019-05-20/"/>
    <id>http://lmislm.com/2019/05/20/2019-05-20/</id>
    <published>2019-05-19T16:00:00.000Z</published>
    <updated>2019-05-20T15:53:40.928Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>vuejs源码 v2.x.x 的实例方法 / 事件，$on，$once，$off，$emit</p><a id="more"></a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;.../core/instance/events.js&gt;  on 20 Dec 2018</span></span><br><span class="line"><span class="comment">// $on</span></span><br><span class="line"><span class="comment">// 监听当前实例上的自定义事件。事件可以由vm.$emit触发。回调函数会接收所有传入事件触发函数的额外参数。-- https://cn.vuejs.org/v2/api/#vm-on</span></span><br><span class="line"><span class="keyword">const</span> hookRE = <span class="regexp">/^hook:/</span></span><br><span class="line">Vue.prototype.$on = <span class="function"><span class="keyword">function</span> (<span class="params">event: string | Array&lt;string&gt;, fn: Function</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// $on可以是数组值</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(event)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = event.length; i &lt; l; i++) &#123;</span><br><span class="line">      vm.$on(event[i], fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    (vm._events[event] || (vm._events[event] = [])).push(fn)</span><br><span class="line">    <span class="comment">// optimize hook:event cost by using a boolean flag marked at registration</span></span><br><span class="line">    <span class="comment">// instead of a hash lookup（注：利用布尔值标识是否注册时存在钩子事件，而不是利用hash查询）</span></span><br><span class="line">    <span class="keyword">if</span> (hookRE.test(event)) &#123;</span><br><span class="line">      vm._hasHookEvent = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// $once</span></span><br><span class="line"><span class="comment">// 监听一个自定义事件，但是只触发一次，在第一次触发之后移除监听器。-- https://cn.vuejs.org/v2/api/#vm-once</span></span><br><span class="line">Vue.prototype.$once = <span class="function"><span class="keyword">function</span> (<span class="params">event: string, fn: Function</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">on</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// $off表示将事件销毁，第一执行之后就销毁</span></span><br><span class="line">    vm.$off(event, on)</span><br><span class="line">    <span class="comment">// 调用方法</span></span><br><span class="line">    fn.apply(vm, <span class="built_in">arguments</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  on.fn = fn</span><br><span class="line">  <span class="comment">// 监听事件</span></span><br><span class="line">  vm.$on(event, on)</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// $off</span></span><br><span class="line"><span class="comment">// 移除自定义事件监听器。</span></span><br><span class="line"><span class="comment">// 如果没有提供参数，则移除所有的事件监听器；</span></span><br><span class="line"><span class="comment">// 如果只提供了事件，则移除该事件所有的监听器；</span></span><br><span class="line"><span class="comment">// 如果同时提供了事件与回调，则只移除这个回调的监听器。https://cn.vuejs.org/v2/api/#vm-off</span></span><br><span class="line">Vue.prototype.$off = <span class="function"><span class="keyword">function</span> (<span class="params">event?: string | Array&lt;string&gt;, fn?: Function</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// all</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">    <span class="comment">// 返回创建的空对象</span></span><br><span class="line">    vm._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// array of events</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(event)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = event.length; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="comment">// 递归调用？</span></span><br><span class="line">      vm.$off(event[i], fn)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// specific event</span></span><br><span class="line">  <span class="keyword">const</span> cbs = vm._events[event]</span><br><span class="line">  <span class="comment">// 事件不存在则返回本身</span></span><br><span class="line">  <span class="keyword">if</span> (!cbs) &#123;</span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 事件置空</span></span><br><span class="line">  <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">    vm._events[event] = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// specific handler</span></span><br><span class="line">  <span class="comment">// 找对应的方法fn，找到就移除</span></span><br><span class="line">  <span class="keyword">let</span> cb</span><br><span class="line">  <span class="keyword">let</span> i = cbs.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    cb = cbs[i]</span><br><span class="line">    <span class="keyword">if</span> (cb === fn || cb.fn === fn) &#123;</span><br><span class="line">      cbs.splice(i, <span class="number">1</span>)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// $emit</span></span><br><span class="line"><span class="comment">// 触发当前实例上的事件。附加参数都会传给监听器回调。</span></span><br><span class="line">Vue.prototype.$emit = <span class="function"><span class="keyword">function</span> (<span class="params">event: string</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> lowerCaseEvent = event.toLowerCase()</span><br><span class="line">    <span class="keyword">if</span> (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) &#123;</span><br><span class="line">      tip(</span><br><span class="line">        <span class="string">`Event "<span class="subst">$&#123;lowerCaseEvent&#125;</span>" is emitted in component `</span> +</span><br><span class="line">        <span class="string">`<span class="subst">$&#123;formatComponentName(vm)&#125;</span> but the handler is registered for "<span class="subst">$&#123;event&#125;</span>". `</span> +</span><br><span class="line">        <span class="string">`Note that HTML attributes are case-insensitive and you cannot use `</span> +</span><br><span class="line">        <span class="string">`v-on to listen to camelCase events when using in-DOM templates. `</span> +</span><br><span class="line">        <span class="string">`You should probably use "<span class="subst">$&#123;hyphenate(event)&#125;</span>" instead of "<span class="subst">$&#123;event&#125;</span>".`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> cbs = vm._events[event]</span><br><span class="line">  <span class="keyword">if</span> (cbs) &#123;</span><br><span class="line">    <span class="comment">// toArray：类数组转为数组</span></span><br><span class="line">    cbs = cbs.length &gt; <span class="number">1</span> ? toArray(cbs) : cbs</span><br><span class="line">    <span class="keyword">const</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">const</span> info = <span class="string">`event handler for "<span class="subst">$&#123;event&#125;</span>"`</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = cbs.length; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="comment">// invokeWithErrorHandling 来自：&lt;src/core/util/error.js&gt;，避免嵌套调用时多次触发</span></span><br><span class="line">      invokeWithErrorHandling(cbs[i], vm, args, vm, info)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;vuejs源码 v2.x.x 的实例方法 / 事件，$on，$once，$off，$emit&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day127-vuejs源码-nextTick()-3</title>
    <link href="http://lmislm.com/2019/05/19/2019-05-19/"/>
    <id>http://lmislm.com/2019/05/19/2019-05-19/</id>
    <published>2019-05-18T16:00:00.000Z</published>
    <updated>2019-05-19T15:46:33.066Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>上一次，还记得在了解队列刷新的时候<br>做了方法队列刷新完毕之后watcher会被推入watcher队列，<br>最后做了调用了一个方法：nextTick(flushSchedulerQueue)<br>但是没有对方法做一些了解，这里了解下flushSchedulerQueue()。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;src/core/observer/scheduler.js&gt;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Flush both queues and run the watchers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSchedulerQueue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  currentFlushTimestamp = getNow()</span><br><span class="line">  flushing = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">let</span> watcher, id</span><br><span class="line">  <span class="comment">// 注意排序的原因</span></span><br><span class="line">  <span class="comment">// Sort queue before flush.</span></span><br><span class="line">  <span class="comment">// This ensures that:</span></span><br><span class="line">  <span class="comment">// 1. Components are updated from parent to child. (because parent is always</span></span><br><span class="line">  <span class="comment">//    created before the child)</span></span><br><span class="line">  <span class="comment">// 2. A component's user watchers are run before its render watcher (because</span></span><br><span class="line">  <span class="comment">//    user watchers are created before the render watcher)</span></span><br><span class="line">  <span class="comment">// 3. If a component is destroyed during a parent component's watcher run,</span></span><br><span class="line">  <span class="comment">//    its watchers can be skipped.</span></span><br><span class="line">  queue.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do not cache length because more watchers might be pushed</span></span><br><span class="line">  <span class="comment">// as we run existing watchers</span></span><br><span class="line">  <span class="comment">// 这里？？？</span></span><br><span class="line">  <span class="comment">/*这里不用index = queue.length;index &gt; 0; index--的方式写是因为不要将length进行缓存，因为在执行处理现有watcher对象期间，更多的watcher对象可能会被push进queue*/</span></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; queue.length; index++) &#123;</span><br><span class="line">    watcher = queue[index]</span><br><span class="line">    <span class="keyword">if</span> (watcher.before) &#123;</span><br><span class="line">      watcher.before()</span><br><span class="line">    &#125;</span><br><span class="line">    id = watcher.id</span><br><span class="line">    <span class="comment">//之前推入队列时候的标记：function queueWatcher()</span></span><br><span class="line">    has[id] = <span class="literal">null</span></span><br><span class="line">    watcher.run()</span><br><span class="line">    <span class="comment">// in dev build, check and stop circular updates.(注：检测函数中的死循环)</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; has[id] != <span class="literal">null</span>) &#123;</span><br><span class="line">      circular[id] = (circular[id] || <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> (circular[id] &gt; MAX_UPDATE_COUNT) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">'You may have an infinite update loop '</span> + (</span><br><span class="line">            watcher.user</span><br><span class="line">              ? <span class="string">`in watcher with expression "<span class="subst">$&#123;watcher.expression&#125;</span>"`</span></span><br><span class="line">              : <span class="string">`in a component render function.`</span></span><br><span class="line">          ),</span><br><span class="line">          watcher.vm</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// keep copies of post queues before resetting state</span></span><br><span class="line">  <span class="comment">// 注： 这里的activatedChildren方法应该是属于queueActivatedComponent()函数中保存kept-alive组件</span></span><br><span class="line">  <span class="comment">// slice() 拷贝</span></span><br><span class="line">  <span class="keyword">const</span> activatedQueue = activatedChildren.slice()</span><br><span class="line">  <span class="keyword">const</span> updatedQueue = queue.slice()</span><br><span class="line"></span><br><span class="line">  resetSchedulerState()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// call component updated and activated hooks（注：调用钩子）</span></span><br><span class="line">  callActivatedHooks(activatedQueue)</span><br><span class="line">  callUpdatedHooks(updatedQueue)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// devtool hook</span></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (devtools &amp;&amp; config.devtools) &#123;</span><br><span class="line">    devtools.emit(<span class="string">'flush'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;上一次，还记得在了解队列刷新的时候&lt;br&gt;做了方法队列刷新完毕之后watcher会被推入watcher队列，&lt;br&gt;最后做了调用了一个方法：
      
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day126-vuejs源码-nextTick()-2</title>
    <link href="http://lmislm.com/2019/05/18/2019-05-18/"/>
    <id>http://lmislm.com/2019/05/18/2019-05-18/</id>
    <published>2019-05-17T16:00:00.000Z</published>
    <updated>2019-05-18T15:07:29.954Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>继续nextTick()的探讨。这里引用的比较多，同时也更新了引用文章中对于vuejs源码的解释。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// https://github.com/vuejs/vue/blob/dev/src/core/util/next-tick.js -- 版本24 Jan 2019</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Defer a task to execute it asynchronously.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">    延迟一个任务使其异步执行，在下一个tick时执行，一个立即执行函数，返回一个function</span></span><br><span class="line"><span class="comment">    这个函数的作用是在task或者microtask中推入一个timerFunc，在当前调用栈执行完以后以此执行直到执行到timerFunc</span></span><br><span class="line"><span class="comment">    目的是延迟到当前调用栈执行完以后执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> nextTick = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> isUsingMicroTask = <span class="literal">false</span></span><br><span class="line">  <span class="comment">/*异步回调*/</span></span><br><span class="line">  <span class="keyword">const</span> callbacks = []</span><br><span class="line">  <span class="comment">/*标记位，有timerFunc被推送到任务队列中去则不需要重复推送*/</span></span><br><span class="line">  <span class="keyword">let</span> pending = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*下一个tick时的回调*/</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">nextTickHandler</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*一个标记位，标记等待状态（即函数已经被推入任务队列或者主线程，已经在等待当前栈执行完毕去执行），这样就不需要在push多个回调到callbacks时将timerFunc多次推入任务队列或者主线程*/</span></span><br><span class="line">    pending = <span class="literal">false</span></span><br><span class="line">    <span class="comment">/*执行所有callback*/</span></span><br><span class="line">    <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>)</span><br><span class="line">    callbacks.length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">      copies[i]()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里是源码的一些解释</span></span><br><span class="line">  <span class="comment">// Here we have async deferring wrappers using microtasks.</span></span><br><span class="line">  <span class="comment">// In 2.5 we used (macro) tasks (in combination with microtasks).</span></span><br><span class="line">  <span class="comment">// However, it has subtle problems when state is changed right before repaint</span></span><br><span class="line">  <span class="comment">// (e.g. #6813, out-in transitions).</span></span><br><span class="line">  <span class="comment">// Also, using (macro) tasks in event handler would cause some weird（注：奇怪的） behaviors</span></span><br><span class="line">  <span class="comment">// that cannot be circumvented(注：绕开) (e.g. #7109, #7153, #7546, #7834, #8109).</span></span><br><span class="line">  <span class="comment">// So we now use microtasks everywhere, again.</span></span><br><span class="line">  <span class="comment">// A major drawback of this tradeoff is that there are some scenarios （注：这种权衡的一个主要缺点是存在一些情况）</span></span><br><span class="line">  <span class="comment">// where microtasks have too high a priority and fire in between supposedly</span></span><br><span class="line">  <span class="comment">// sequential events (e.g. #4521, #6690, which have workarounds)</span></span><br><span class="line">  <span class="comment">// or even between bubbling of the same event (#6566).</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> timerFunc</span><br><span class="line">  <span class="comment">// The nextTick behavior leverages the microtask queue, which can be accessed</span></span><br><span class="line">  <span class="comment">// via either native Promise.then or MutationObserver.</span></span><br><span class="line">  <span class="comment">// MutationObserver has wider support, however it is seriously bugged in</span></span><br><span class="line">  <span class="comment">// UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It</span></span><br><span class="line">  <span class="comment">// completely stops working after triggering a few times... so, if native</span></span><br><span class="line">  <span class="comment">// Promise is available, we will use it:</span></span><br><span class="line">  <span class="comment">/* istanbul ignore next, $flow-disable-line */</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里解释一下，一共有Promise、MutationObserver以及setTimeout三种尝试得到timerFunc的方法</span></span><br><span class="line"><span class="comment">    按照Promise，MutationObserver，setTimeout优先级，使用timerFunc</span></span><br><span class="line"><span class="comment">    优先使用Promise，在Promise不存在的情况下使用MutationObserver，这两个方法都会在microtask中执行，会比setTimeout更早执行，所以优先使用。</span></span><br><span class="line"><span class="comment">    如果上述两种方法都不支持的环境则会使用setTimeout，在task尾部推入这个函数，等待调用执行。</span></span><br><span class="line"><span class="comment">    参考：https://www.zhihu.com/question/55364497</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">    <span class="comment">/*使用Promise*/</span></span><br><span class="line">    <span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">    <span class="keyword">var</span> logError = <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="built_in">console</span>.error(err) &#125;</span><br><span class="line">    timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      p.then(nextTickHandler).catch(logError)</span><br><span class="line">      <span class="comment">// In problematic UIWebViews, Promise.then doesn't completely break, but</span></span><br><span class="line">      <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class="line">      <span class="comment">// microtask queue but the queue isn't being flushed, until the browser</span></span><br><span class="line">      <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">      <span class="comment">// "force" the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">      <span class="keyword">if</span> (isIOS) setTimeout(noop)</span><br><span class="line">      isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> MutationObserver !== <span class="string">'undefined'</span> &amp;&amp; (</span><br><span class="line">    isNative(MutationObserver) ||</span><br><span class="line">    <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">    MutationObserver.toString() === <span class="string">'[object MutationObserverConstructor]'</span></span><br><span class="line">  )) &#123;</span><br><span class="line">    <span class="comment">// use MutationObserver where native Promise is not available,</span></span><br><span class="line">    <span class="comment">// e.g. PhantomJS IE11, iOS7, Android 4.4</span></span><br><span class="line">    <span class="comment">/*新建一个textNode的DOM对象，用MutationObserver绑定该DOM并指定回调函数，在DOM变化的时候则会触发回调,该回调会进入主线程（比任务队列优先执行），即textNode.data = String(counter)时便会触发回调*/</span></span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(nextTickHandler)</span><br><span class="line">    <span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line">    observer.observe(textNode, &#123;</span><br><span class="line">      characterData: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">      textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新增一个标记位</span></span><br><span class="line">    isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Fallback to setImmediate.</span></span><br><span class="line">    <span class="comment">// Techinically it leverages the (macro) task queue,</span></span><br><span class="line">    <span class="comment">// but it is still a better choice than setTimeout.</span></span><br><span class="line">    <span class="comment">/*使用setTimeout将回调推入任务队列尾部*/</span></span><br><span class="line">    timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setTimeout(nextTickHandler, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    推送到队列中下一个tick时执行</span></span><br><span class="line"><span class="comment">    cb 回调函数</span></span><br><span class="line"><span class="comment">    ctx 上下文</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">queueNextTick</span> (<span class="params">cb?: Function, ctx?: Object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _resolve</span><br><span class="line">    <span class="comment">/*cb存到callbacks中*/</span></span><br><span class="line">    callbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          cb.call(ctx)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          handleError(e, ctx, <span class="string">'nextTick'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">        _resolve(ctx)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">      pending = <span class="literal">true</span></span><br><span class="line">      timerFunc()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        _resolve = resolve</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><blockquote><p>引自参考：<br>JS 的 event loop 执行时会区分 task 和 microtask，引擎在每个 task 执行完毕，从队列中取下一个 task 来执行之前，会先执行完所有 microtask 队列中的 microtask。<br>setTimeout 回调会被分配到一个新的 task 中执行，而 Promise 的 resolver、MutationObserver 的回调都会被安排到一个新的 microtask 中执行，会比 setTimeout 产生的 task 先执行。<br>要创建一个新的 microtask，优先使用 Promise，如果浏览器不支持，再尝试 MutationObserver。<br>实在不行，只能用 setTimeout 创建 task 了。<br>为啥要用 microtask？<br>根据 HTML Standard，在每个 task 运行完以后，UI 都会重渲染，那么在 microtask 中就完成数据更新，当前 task 结束就可以得到最新的 UI 了。<br>反之如果新建一个 task 来做数据更新，那么渲染就会进行两次。</p></blockquote><p>参考顾轶灵知乎的回答：<a href="https://www.zhihu.com/question/55364497/answer/144215284" target="_blank" rel="noopener">https://www.zhihu.com/question/55364497/answer/144215284</a></p><blockquote><p>MutationObserver新建一个textNode的DOM对象，用MutationObserver绑定该DOM并指定回调函数，在DOM变化的时候则会触发回调,该回调会进入microtask，即textNode.data = String(counter)时便会加入该回调。</p></blockquote><blockquote><p>setTimeout是最后的一种备选方案，它会将回调函数加入task中，等到执行。</p></blockquote><blockquote><p>综上，nextTick的目的就是产生一个回调函数加入task或者microtask中，当前栈执行完以后（可能中间还有别的排在前面的函数）调用该回调函数，起到了异步触发（即下一个tick时触发）的目的。</p></blockquote><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/answershuto/learnVue/blob/master/docs/Vue.js%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0DOM%E7%AD%96%E7%95%A5%E5%8F%8AnextTick.MarkDown" target="_blank" rel="noopener">Vue.js异步更新DOM策略及nextTick</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;继续nextTick()的探讨。这里引用的比较多，同时也更新了引用文章中对于vuejs源码的解释。&lt;/p&gt;
&lt;h3 id=&quot;代码&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day125-vuejs源码-nextTick()-1</title>
    <link href="http://lmislm.com/2019/05/17/2019-05-17/"/>
    <id>http://lmislm.com/2019/05/17/2019-05-17/</id>
    <published>2019-05-16T16:00:00.000Z</published>
    <updated>2019-05-18T14:49:22.446Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>了解vuejs中的<strong>异步更新DOM策略</strong>，了解vuejs操作DOM过程中一些原理。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vuejs 中的 nextTick</span></span><br><span class="line"><span class="comment">// 响应式数据发生变化的时候，它的setter函数会通知闭包中的Dep，Dep则会调用它管理的所有Watch对象。触发Watch对象的update实现。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subscriber interface.</span></span><br><span class="line"><span class="comment"> * Will be called when a dependency changes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 在watcher.js文件中</span></span><br><span class="line">update () &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="comment">// this.lazy = !!options.lazy 和 deep什么的同级</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">      <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">      <span class="comment">/*同步则执行run直接渲染视图*/</span></span><br><span class="line">      <span class="keyword">this</span>.run()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/*异步推送到观察者队列中*/</span></span><br><span class="line">      queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &lt;scheduler.js&gt;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Push a watcher into the watcher queue.</span></span><br><span class="line"><span class="comment"> * Jobs with duplicate IDs will be skipped unless it's</span></span><br><span class="line"><span class="comment"> * pushed when the queue is being flushed.</span></span><br><span class="line"><span class="comment"> * // 队列刷新完毕之后watcher才会被推入watcher队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span> (<span class="params">watcher: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = watcher.id</span><br><span class="line">  <span class="comment">// 哈希表has，标记是否存在id，这个id指的是？</span></span><br><span class="line">  <span class="comment">// 如果不是刷新状态也不是等待状态则进入刷新事件队列。</span></span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">      <span class="comment">// 不在刷新状态中，直接推到队列中</span></span><br><span class="line">      queue.push(watcher)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// if already flushing, splice the watcher based on its id</span></span><br><span class="line">      <span class="comment">// if already past its id, it will be run next immediately.</span></span><br><span class="line">      <span class="keyword">let</span> i = queue.length - <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(i + <span class="number">1</span>, <span class="number">0</span>, watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// queue the flush</span></span><br><span class="line">    <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">      waiting = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">        flushSchedulerQueue()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      nextTick(flushSchedulerQueue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;了解vuejs中的&lt;strong&gt;异步更新DOM策略&lt;/strong&gt;，了解vuejs操作DOM过程中一些原理。&lt;/p&gt;
&lt;h3 id=&quot;代
      
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day124-设计 LazyMan 类 -笔记</title>
    <link href="http://lmislm.com/2019/05/16/2019-05-16/"/>
    <id>http://lmislm.com/2019/05/16/2019-05-16/</id>
    <published>2019-05-15T16:00:00.000Z</published>
    <updated>2019-05-16T15:43:29.779Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>设计 LazyMan 类，实现以下功能：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">LazyMan(<span class="string">'Tony'</span>);</span><br><span class="line"><span class="comment">// Hi I am Tony</span></span><br><span class="line"></span><br><span class="line">LazyMan(<span class="string">'Tony'</span>).sleep(<span class="number">10</span>).eat(<span class="string">'lunch'</span>);</span><br><span class="line"><span class="comment">// Hi I am Tony</span></span><br><span class="line"><span class="comment">// 等待了10秒...</span></span><br><span class="line"><span class="comment">// I am eating lunch</span></span><br><span class="line"></span><br><span class="line">LazyMan(<span class="string">'Tony'</span>).eat(<span class="string">'lunch'</span>).sleep(<span class="number">10</span>).eat(<span class="string">'dinner'</span>);</span><br><span class="line"><span class="comment">// Hi I am Tony</span></span><br><span class="line"><span class="comment">// I am eating lunch</span></span><br><span class="line"><span class="comment">// 等待了10秒...</span></span><br><span class="line"><span class="comment">// I am eating diner</span></span><br><span class="line"></span><br><span class="line">LazyMan(<span class="string">'Tony'</span>).eat(<span class="string">'lunch'</span>).eat(<span class="string">'dinner'</span>).sleepFirst(<span class="number">5</span>).sleep(<span class="number">10</span>).eat(<span class="string">'junk food'</span>);</span><br><span class="line"><span class="comment">// Hi I am Tony</span></span><br><span class="line"><span class="comment">// 等待了5秒...</span></span><br><span class="line"><span class="comment">// I am eating lunch</span></span><br><span class="line"><span class="comment">// I am eating dinner</span></span><br><span class="line"><span class="comment">// 等待了10秒...</span></span><br><span class="line"><span class="comment">// I am eating junk food</span></span><br></pre></td></tr></table></figure></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyManClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.taskList = [];</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Hi I am <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.next();</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    eat (name) &#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> fn = (<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`I am eating <span class="subst">$&#123;n&#125;</span>`</span>)</span><br><span class="line">                that.next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(name);</span><br><span class="line">        <span class="keyword">this</span>.taskList.push(fn);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleepFirst (time) &#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> fn = (<span class="function"><span class="keyword">function</span> (<span class="params">t</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">`等待了<span class="subst">$&#123;t&#125;</span>秒...`</span>)</span><br><span class="line">                    that.next();</span><br><span class="line">                &#125;, t * <span class="number">1000</span>);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(time);</span><br><span class="line">        <span class="keyword">this</span>.taskList.unshift(fn);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep (time) &#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">var</span> fn = (<span class="function"><span class="keyword">function</span> (<span class="params">t</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">`等待了<span class="subst">$&#123;t&#125;</span>秒...`</span>)</span><br><span class="line">                    that.next();</span><br><span class="line">                &#125;, t * <span class="number">1000</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)(time);</span><br><span class="line">        <span class="keyword">this</span>.taskList.push(fn);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    next () &#123;</span><br><span class="line">        <span class="keyword">var</span> fn = <span class="keyword">this</span>.taskList.shift();</span><br><span class="line">        fn &amp;&amp; fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LazyMan</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LazyManClass(name);</span><br><span class="line">&#125;</span><br><span class="line">LazyMan(<span class="string">'Tony'</span>).eat(<span class="string">'lunch'</span>).eat(<span class="string">'dinner'</span>).sleepFirst(<span class="number">5</span>).sleep(<span class="number">4</span>).eat(<span class="string">'junk food'</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;设计 LazyMan 类，实现以下功能：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;t
      
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day123-数据结构处理-数组</title>
    <link href="http://lmislm.com/2019/05/15/2019-05-15/"/>
    <id>http://lmislm.com/2019/05/15/2019-05-15/</id>
    <published>2019-05-14T16:00:00.000Z</published>
    <updated>2019-05-15T15:30:40.160Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>某公司 1 到 12 月份的销售额存在一个对象里面，如下：<code>{1:222, 2:123, 5:888}</code>，请把数据处理为如下结构：<code>[222, 123, null, null, 888, null, null, null, null, null, null, null]</code>。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简短： 这个和上次生成随机数那个很像啊，用到了数组的生成</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="number">1</span>:<span class="number">222</span>, <span class="number">2</span>:<span class="number">123</span>, <span class="number">5</span>:<span class="number">888</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> result = [...Array(<span class="number">12</span>)].map(<span class="function">(<span class="params">_, index</span>) =&gt;</span> obj[index + <span class="number">1</span>] || <span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 或者 - 引</span></span><br><span class="line"><span class="comment">// const result = Array.from(&#123; length: 12 &#125;).map((_, index) =&gt; obj[index + 1] || null);</span></span><br><span class="line"><span class="comment">// 或者直接一行 - 引</span></span><br><span class="line"><span class="comment">// Array.from(&#123;length:12&#125;,(v,i)=&gt;(&#123;1:222,2:123,5:888&#125;[i+1])||null)</span></span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;某公司 1 到 12 月份的销售额存在一个对象里面，如下：&lt;code&gt;{1:222, 2:123, 5:888}&lt;/code&gt;，请把数据处理
      
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day122-随机生成数组</title>
    <link href="http://lmislm.com/2019/05/14/2019-05-14/"/>
    <id>http://lmislm.com/2019/05/14/2019-05-14/</id>
    <published>2019-05-13T16:00:00.000Z</published>
    <updated>2019-05-14T15:58:42.349Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>题目：<code>随机生成一个长度为 10 的整数类型的数组，例如 [2, 10, 3, 4, 5, 11, 10, 11, 20]，将其排列成一个新数组，要求新数组形式如下，例如 [[2, 3, 4, 5], [10, 11], [20]]。</code></p><a id="more"></a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ---</span></span><br><span class="line"><span class="comment"> * 随机生成一个长度为 10 的整数类型的数组，</span></span><br><span class="line"><span class="comment"> * 例如 [2, 10, 3, 4, 5, 11, 10, 11, 20]，</span></span><br><span class="line"><span class="comment"> * 将其排列成一个新数组，要求新数组形式如下，</span></span><br><span class="line"><span class="comment"> * 例如 [[2, 3, 4, 5], [10, 11], [20]]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 1. 生成两位整数,各个数生成的概率接近相等。（有问题，81-100之间的数有问题？）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomIntDouble</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> randomIntSingle = (<span class="built_in">Math</span>.random() * <span class="number">10</span>).toFixed(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.pow(randomIntSingle, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 生成一个长度为10的随机数数组</span></span><br><span class="line"><span class="comment">// let randomIntArr = Array.from(&#123;length: 10&#125;, _ =&gt; getRandomIntDouble())</span></span><br><span class="line"><span class="keyword">let</span> randomIntArr = [...Array(<span class="number">10</span>)].map(<span class="function"><span class="params">_</span> =&gt;</span> getRandomIntDouble())</span><br><span class="line"><span class="comment">// 3. 去重</span></span><br><span class="line"><span class="keyword">let</span> uniqueArr = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(randomIntArr))</span><br><span class="line"><span class="comment">// 4. 排序</span></span><br><span class="line"><span class="keyword">let</span> sortedUniqueArr = uniqueArr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br><span class="line"><span class="comment">// 5. 新数组，0~10,10~20...80~99各占一个数组</span></span><br><span class="line"><span class="comment">// ----</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">sortedUniqueArr.map(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> intNum = <span class="built_in">Math</span>.floor(i/<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span> (!obj[intNum]) obj[intNum] = [];</span><br><span class="line">    obj[intNum].push(i);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="keyword">const</span> resArr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    resArr.push(obj[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(resArr)</span><br></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/5836833/create-a-array-with-random-values" target="_blank" rel="noopener">Create a array with random values</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;题目：&lt;code&gt;随机生成一个长度为 10 的整数类型的数组，例如 [2, 10, 3, 4, 5, 11, 10, 11, 20]，将其排列成一个新数组，要求新数组形式如下，例如 [[2, 3, 4, 5], [10, 11], [20]]。&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day121-数组扁平化-去重-升序</title>
    <link href="http://lmislm.com/2019/05/13/2019-05-13/"/>
    <id>http://lmislm.com/2019/05/13/2019-05-13/</id>
    <published>2019-05-12T16:00:00.000Z</published>
    <updated>2019-05-13T15:27:18.495Z</updated>
    
    <content type="html"><![CDATA[<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr.flat(<span class="literal">Infinity</span>))).sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123; <span class="keyword">return</span> a-b&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;sp
      
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day120-js深拷贝</title>
    <link href="http://lmislm.com/2019/05/12/2019-05-12/"/>
    <id>http://lmislm.com/2019/05/12/2019-05-12/</id>
    <published>2019-05-11T16:00:00.000Z</published>
    <updated>2019-05-12T15:29:12.172Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>来一个js的深拷贝，和JSON.stringify实现的还是有点区别的。</p><a id="more"></a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//判断是否是简单数据类型，</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> obj == <span class="string">"object"</span>)&#123;</span><br><span class="line">        <span class="comment">//复杂数据类型</span></span><br><span class="line">        <span class="keyword">var</span> result = obj.constructor == <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> obj)&#123;</span><br><span class="line">            result[i] = <span class="keyword">typeof</span> obj[i] == <span class="string">"object"</span> ? deepCopy(obj[i]) : obj[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//简单数据类型 直接 == 赋值</span></span><br><span class="line">        <span class="keyword">var</span> result = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;来一个js的深拷贝，和JSON.stringify实现的还是有点区别的。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day119-实现一个instanceOf笔记</title>
    <link href="http://lmislm.com/2019/05/10/2019-05-11/"/>
    <id>http://lmislm.com/2019/05/10/2019-05-11/</id>
    <published>2019-05-09T16:00:00.000Z</published>
    <updated>2019-05-10T16:14:39.163Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>话不多说，这篇是水篇。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现一个instanceOf</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceOf</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> proto = left.__proto__</span><br><span class="line">  <span class="keyword">let</span> prototype = right.prototype</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!proto) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proto === prototype) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    proto === proto.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;话不多说，这篇是水篇。&lt;/p&gt;
&lt;h3 id=&quot;代码&quot;&gt;&lt;a href=&quot;#代码&quot; class=&quot;headerlink&quot; title=&quot;代码&quot;&gt;&lt;/a&gt;代码&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 实现一个instanceOf&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;myInstanceOf&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;left, right&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; proto = left.__proto__&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; prototype = right.prototype&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!proto) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (proto === prototype) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    proto === proto.__proto__&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day118-手写简单的函数柯里化-笔记</title>
    <link href="http://lmislm.com/2019/05/10/2019-05-10/"/>
    <id>http://lmislm.com/2019/05/10/2019-05-10/</id>
    <published>2019-05-09T16:00:00.000Z</published>
    <updated>2019-05-10T15:37:09.628Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>函数柯里化是属于高阶函数中一种常见的技术。特点就是<code>参数复用</code>、<code>提前返回</code>和<code>延迟执行</code>。</p><a id="more"></a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span> (<span class="params">fn, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> length = fn.length</span><br><span class="line">  <span class="keyword">var</span> args = args || []</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    newArgs = args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>))</span><br><span class="line">    <span class="keyword">if</span> (newArgs.length &lt; length) &#123;</span><br><span class="line">      <span class="keyword">return</span> curry.call(<span class="keyword">this</span>, fn, newArgs)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, newArgs)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiFn</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * b * c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> multi = curry(multiFn)</span><br><span class="line"></span><br><span class="line">multi(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br><span class="line">multi(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">multi(<span class="number">1</span>)(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">multi(<span class="number">1</span>,<span class="number">2</span>)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;函数柯里化是属于高阶函数中一种常见的技术。特点就是&lt;code&gt;参数复用&lt;/code&gt;、&lt;code&gt;提前返回&lt;/code&gt;和&lt;code&gt;延迟执行&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day117-手写简单防抖</title>
    <link href="http://lmislm.com/2019/05/09/2019-05-09/"/>
    <id>http://lmislm.com/2019/05/09/2019-05-09/</id>
    <published>2019-05-08T16:00:00.000Z</published>
    <updated>2019-05-09T15:44:43.901Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>其实就是一个apply调用。非常简单。重点是理解防抖和节流这两个概念吧。<br>首次事件发生之后，需要<strong>延迟(wait)时间</strong>处理。<br>延迟时间段内有第二次事件，则以第二次事件为准<strong>延迟处理</strong>。<br>知道最后一次时间段内没有事件，则执行最后一次。</p><a id="more"></a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li><p>debounce</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">fn, wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 注意arguments是当前函数内的参数</span></span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123; fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>) &#125;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123; clearTimeout(timer) &#125;</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>throttle</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prev = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    <span class="comment">// 在wait时间内只执行一次</span></span><br><span class="line">    <span class="keyword">if</span> (now - prev &gt; wait) &#123;</span><br><span class="line">      <span class="comment">// 注意arguments是当前函数内的参数</span></span><br><span class="line">      fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">      prev = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>总结就是：<strong>throttle限制函数调用频率，debounce则限制函数调用速率</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;其实就是一个apply调用。非常简单。重点是理解防抖和节流这两个概念吧。&lt;br&gt;首次事件发生之后，需要&lt;strong&gt;延迟(wait)时间&lt;/strong&gt;处理。&lt;br&gt;延迟时间段内有第二次事件，则以第二次事件为准&lt;strong&gt;延迟处理&lt;/strong&gt;。&lt;br&gt;知道最后一次时间段内没有事件，则执行最后一次。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day116-手写JSON.stringify</title>
    <link href="http://lmislm.com/2019/05/08/2019-05-08/"/>
    <id>http://lmislm.com/2019/05/08/2019-05-08/</id>
    <published>2019-05-07T16:00:00.000Z</published>
    <updated>2019-05-09T15:25:34.205Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>没啥可说的，这篇比较水。<br><code>JSON.stringify(value[, replacer [, space]])</code></p><a id="more"></a><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonStringify</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> type = <span class="keyword">typeof</span> obj</span><br><span class="line">  <span class="keyword">if</span> (type !== <span class="string">"object"</span>) &#123;</span><br><span class="line">    <span class="comment">// undefined 什么的会被忽略，循环引用也会被忽略</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/string|undefined|function/</span>.test(type)) &#123;</span><br><span class="line">      obj = <span class="string">'"'</span> + obj + <span class="string">'"'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>(obj)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> json = []</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="built_in">Array</span>.isArray(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">let</span> v = obj[k]</span><br><span class="line">      <span class="keyword">let</span> type = <span class="keyword">typeof</span> v</span><br><span class="line">      <span class="keyword">if</span> (<span class="regexp">/string|undefined|function/</span>.test(type)) &#123;</span><br><span class="line">        v = <span class="string">'"'</span> + v + <span class="string">'"'</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">"object"</span>) &#123;</span><br><span class="line">        v = jsonStringify(v)</span><br><span class="line">      &#125;</span><br><span class="line">      json.push((arr ? <span class="string">""</span> : <span class="string">'"'</span> + k + <span class="string">'":'</span>) + <span class="built_in">String</span>(v))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (arr ? <span class="string">"["</span> : <span class="string">"&#123;"</span>) + <span class="built_in">String</span>(json) + (arr ? <span class="string">"]"</span> : <span class="string">"&#125;"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://juejin.im/post/5c9c3989e51d454e3a3902b6#heading-1" target="_blank" rel="noopener">JavaScript手写代码无敌秘籍</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;没啥可说的，这篇比较水。&lt;br&gt;&lt;code&gt;JSON.stringify(value[, replacer [, space]])&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day115-实现事件类Event</title>
    <link href="http://lmislm.com/2019/05/07/2019-05-07/"/>
    <id>http://lmislm.com/2019/05/07/2019-05-07/</id>
    <published>2019-05-06T16:00:00.000Z</published>
    <updated>2019-05-08T14:40:37.316Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong>源起：</strong><br>同页面组件间通信使用事件监听和派发的方式，而不是直接相互调用组件方法。用[订阅发布模式]，保证组件的独立性和降低组件间耦合度。</p><p><img src="https://i.loli.net/2019/05/07/5cd1a8d874919.jpg" alt="">·</p><a id="more"></a><p><strong>核心：</strong><br>核心是一个<em>事件类型</em>对应回调函数的数据设计。</p><h3 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h3><p>本质上是一个观察者模式的实现。且Node.js原生自带<strong>EventEmitter</strong>模块，所以这部分是比较重要的。<br>实现一个事件类Event ，包含下面功能：</p><ol><li>绑定事件</li><li>解绑事件</li><li>派发事件</li></ol><ul><li><p><strong>on(eventName, func)</strong>：<br>  监听 eventName事件， 事件触发的时候调用 func函数</p></li><li><p><strong>emit(eventName, arg1, arg2, arg3,arg4…)</strong>：<br> 触发eventName 事件, 并且把参数 arg1, arg2, arg3,arg4…传给事件处理函数</p></li><li><strong>off(eventName, func)</strong>：<br>  停止监听某个事件</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/60324936" target="_blank" rel="noopener">实现一个Event类（发布订阅模式）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;源起：&lt;/strong&gt;&lt;br&gt;同页面组件间通信使用事件监听和派发的方式，而不是直接相互调用组件方法。用[订阅发布模式]，保证组件的独立性和降低组件间耦合度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/05/07/5cd1a8d874919.jpg&quot; alt=&quot;&quot;&gt;·&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day114-实现new运算符（2）</title>
    <link href="http://lmislm.com/2019/05/06/2019-05-06/"/>
    <id>http://lmislm.com/2019/05/06/2019-05-06/</id>
    <published>2019-05-05T16:00:00.000Z</published>
    <updated>2019-05-08T14:40:14.398Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>new 模拟实现大致思路：</p><ol><li>建立一个新对象</li><li>通过<code>new</code>创建的每个对象将最终被<code>[[Prototype]]</code>链接到这个函数的<code>prototype</code>对象上</li><li>实例可以访问原型上的属性</li></ol><h4 id="原型的知识复习"><a href="#原型的知识复习" class="headerlink" title="原型的知识复习"></a>原型的知识复习</h4><p><strong>[[prototype]] 是什么？</strong><br>JavaScript中的对象，都有一个特殊的[[prototype]]内置属性，其实就是对于其他对象的引用。（你不知道的JavaScript-上卷-第五章）<br><a id="more"></a><br><strong>__proto__ 是什么？</strong><br>__proto__ ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.__proto__ 时，可以理解成返回了 Object.getPrototypeOf(obj)。<br><strong>new.target 是什么？</strong><br>new.target属性允许你检测函数或构造方法是否是通过new运算符被调用的。在通过new运算符被初始化的函数或构造方法中，new.target返回一个指向构造方法或函数的引用。在普通的函数调用中，new.target 的值是undefined。</p><p>原型关系图：</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1fytrxmsbzsj20eg0gbq6u.jpg" alt=""></p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myObjectFactory</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Constructor = [].shift.call(<span class="built_in">arguments</span>) <span class="comment">// 取外部传入的构造器</span></span><br><span class="line">  <span class="keyword">var</span> newObj = <span class="built_in">Object</span>.create(Constructor.prototype)</span><br><span class="line">  <span class="comment">// newObj也可以这么写</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * var obj = new Object()</span></span><br><span class="line"><span class="comment">   * obj.__proto__ = Constructor.prototype</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">var</span> ctorResult = Constructor.apply(newObj, <span class="built_in">arguments</span>)</span><br><span class="line">  <span class="comment">// 判断返回的值是不是一个对象，如果是一个对象，则返回对象</span></span><br><span class="line">  <span class="comment">// 注意：判ctorResult是否空</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> ctorResult === <span class="string">'object'</span> ? ctorResult||newObj : newObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一种实现<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">unction New(func) &#123;</span><br><span class="line">    <span class="keyword">var</span> res = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (func.prototype !== <span class="literal">null</span>) &#123;</span><br><span class="line">        res.__proto__ = func.prototype;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> ret = func.apply(res, <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">typeof</span> ret === <span class="string">"object"</span> || <span class="keyword">typeof</span> ret === <span class="string">"function"</span>) &amp;&amp; ret !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = New(A, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// equals to</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> A(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><p>引自：<a href="https://juejin.im/post/5c9c3989e51d454e3a3902b6#heading-1" target="_blank" rel="noopener">实现一个new操作符</a></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 测试用例-1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.habit = <span class="string">'Games'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test.prototype.age = <span class="number">22</span></span><br><span class="line"></span><br><span class="line">Test.prototype.sayYourName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'I am '</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = myObjectFactory(Test, <span class="string">'zhangsan'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// zhangsan</span></span><br><span class="line"><span class="built_in">console</span>.log(person.habit) <span class="comment">// Games</span></span><br><span class="line"><span class="built_in">console</span>.log(person.age) <span class="comment">// 22</span></span><br><span class="line"></span><br><span class="line">person.sayYourName() <span class="comment">// I am zhangsan</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试用例-2 虚实__proto__(Object.create(null))</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Otaku</span> (<span class="params">age</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Otaku.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = myObjectFactory(Otaku, <span class="string">'Kevin'</span>, <span class="string">'18'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person) <span class="comment">// Otaku &#123;&#125;</span></span><br><span class="line">person.sayHello() <span class="comment">// hello</span></span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/mqyqingfeng/Blog/issues/13" target="_blank" rel="noopener">JavaScript深入之new的模拟实现</a><br><a href="https://www.zhihu.com/question/34183746" target="_blank" rel="noopener">js中_proto_和prototype的区别和关系？</a><br><a href="https://lmislm.com//2019/01/10/2019-01-10/#%E8%A1%A5%E5%85%85">怎么实现new</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new.target" target="_blank" rel="noopener">new​.target</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;new 模拟实现大致思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立一个新对象&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;new&lt;/code&gt;创建的每个对象将最终被&lt;code&gt;[[Prototype]]&lt;/code&gt;链接到这个函数的&lt;code&gt;prototype&lt;/code&gt;对象上&lt;/li&gt;
&lt;li&gt;实例可以访问原型上的属性&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;原型的知识复习&quot;&gt;&lt;a href=&quot;#原型的知识复习&quot; class=&quot;headerlink&quot; title=&quot;原型的知识复习&quot;&gt;&lt;/a&gt;原型的知识复习&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;[[prototype]] 是什么？&lt;/strong&gt;&lt;br&gt;JavaScript中的对象，都有一个特殊的[[prototype]]内置属性，其实就是对于其他对象的引用。（你不知道的JavaScript-上卷-第五章）&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day113-实现new运算符（1）</title>
    <link href="http://lmislm.com/2019/05/05/2019-05-05/"/>
    <id>http://lmislm.com/2019/05/05/2019-05-05/</id>
    <published>2019-05-04T16:00:00.000Z</published>
    <updated>2019-05-06T15:44:39.093Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一些实现new运算符的思路整理。</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g2qtkmlyotj20e709g75f.jpg" alt=""><br><a id="more"></a><br>new 运算符，new关键字的操作（MDN）：</p><ol><li><p>Creates a blank, plain JavaScript object;</p><blockquote><p>创建一个空的简单JavaScript对象（即{}）；</p></blockquote></li><li><p>Links (sets the constructor of) this object to another object;</p><blockquote><p>链接该对象（即设置该对象的构造函数）到另一个对象 ；</p></blockquote></li><li><p>Passes the newly created object from Step 1 as the this context;</p><blockquote><p>将步骤1新创建的对象作为this的上下文 ；</p></blockquote></li><li><p>Returns this if the function doesn’t return its own object.</p><blockquote><p>如果该函数没有返回对象，则返回this。</p></blockquote></li></ol><p>new Foo() 发生了什么？<br>当代码 new Foo(…) 执行时，会发生以下事情：</p><ol><li>一个继承自 Foo.prototype 的新对象被创建。</li><li>使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象。new Foo 等同于 Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。</li><li>由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;一些实现new运算符的思路整理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g2qtkmlyotj20e709g75f.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day112-手写原生bind()-2</title>
    <link href="http://lmislm.com/2019/05/04/2019-05-04/"/>
    <id>http://lmislm.com/2019/05/04/2019-05-04/</id>
    <published>2019-05-03T16:00:00.000Z</published>
    <updated>2019-05-06T14:23:25.560Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前实现的bind()，能返回新函数，也能参数传递，实际原生的bind()还能实现<strong>构造函数</strong>的效果。这个用法也是很常用的。其中还涉及到绑定函数时，需要了解<strong>new 的模拟实现</strong>。</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g2qtkma14uj20cl09gjrq.jpg" alt=""><br><a id="more"></a></p><blockquote><p>MDN上作为构造函数的绑定函数，如下。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bind() 作为构造函数的绑定函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x</span><br><span class="line">  <span class="keyword">this</span>.y = y</span><br><span class="line">&#125;</span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.x + <span class="string">','</span> + <span class="keyword">this</span>.y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> YAxisPoint = Point.bind(<span class="literal">null</span>, <span class="number">0</span><span class="comment">/*x*/</span>)</span><br><span class="line"><span class="keyword">var</span> axisPoint = <span class="keyword">new</span> YAxisPoint(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">var</span> result = axisPoint.toString()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// 0,5</span></span><br></pre></td></tr></table></figure><p>做一些改动。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 改动</span></span><br><span class="line"><span class="keyword">var</span> contextObj = &#123;</span><br><span class="line">  x: <span class="string">'1'</span>,</span><br><span class="line">  y: <span class="string">'2'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> YAxisPoint2 = Point.bind(contextObj)</span><br><span class="line"><span class="keyword">var</span> result2 = <span class="keyword">new</span> YAxisPoint(<span class="string">'1'</span>, <span class="string">'9'</span>)</span><br><span class="line"><span class="comment">// 绑定的 this 失效</span></span><br><span class="line"><span class="built_in">console</span>.log(YAxisPoint2.x) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p>代码里有些要注意的点。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">ct</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _self = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 原型变量</span></span><br><span class="line">  <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 注意：arguments是当前函数的参数</span></span><br><span class="line">    <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="comment">// fBound做构造函数时，将绑定函数的this指向该实例，让实例获得来自绑定函数的值</span></span><br><span class="line">    <span class="keyword">return</span> _self.apply(fNOP.prototype.isPrototype(<span class="keyword">this</span>) ? <span class="keyword">this</span> : ct, args.concat(bindArgs))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实例继承绑定函数原型</span></span><br><span class="line">  <span class="comment">// fBound.prototype = this.prototype</span></span><br><span class="line">  <span class="comment">// 这里args长度会变化？？？</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.prototype) &#123;</span><br><span class="line">    <span class="comment">// 维护原型关系，空函数中转</span></span><br><span class="line">    fNOP.protytype = <span class="keyword">this</span>.prototype</span><br><span class="line">  &#125;</span><br><span class="line">  fBound.prototype = <span class="keyword">new</span> fNOP()</span><br><span class="line">  <span class="keyword">return</span> fBound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一些细节：<br>    这部分实现创建的绑定函数所有的 length 属性并不是同ECMA-262标准一致的：它创建的函数的 length 是0，而在实际的实现中根据目标函数的 length 和预先指定的参数个数可能会返回非零的 length。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/mqyqingfeng/Blog/issues/12" target="_blank" rel="noopener">JavaScript深入之bind的模拟实现</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">MDN(中文版)Function​.prototype​.bind()</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">MDN(英文版)Function​.prototype​.bind()</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;之前实现的bind()，能返回新函数，也能参数传递，实际原生的bind()还能实现&lt;strong&gt;构造函数&lt;/strong&gt;的效果。这个用法也是很常用的。其中还涉及到绑定函数时，需要了解&lt;strong&gt;new 的模拟实现&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g2qtkma14uj20cl09gjrq.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day111-手写原生bind()-1</title>
    <link href="http://lmislm.com/2019/05/03/2019-05-03/"/>
    <id>http://lmislm.com/2019/05/03/2019-05-03/</id>
    <published>2019-05-02T16:00:00.000Z</published>
    <updated>2019-05-05T14:40:18.482Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一般bind()用的比较多的就是<strong>创建绑定函数</strong>，还有就是<strong>偏函数</strong>。所以这里可能就是从bind函数的一般用法来考虑实现。MDN上的Polyfill借用slice()，concat()，call()方法。这里也是差不多的实现方法。</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g2ofiscpy6j20gs09ggnu.jpg" alt=""><br><a id="more"></a></p><ul><li><p>MDN上的例子</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.x = <span class="number">9</span>;    <span class="comment">// 在浏览器中，this指向全局的 "window" 对象</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">  x: <span class="number">81</span>,</span><br><span class="line">  getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.x &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.getX() <span class="comment">// 81</span></span><br><span class="line"><span class="comment">//注意：新手容易错的地方-将一个方法从对象中拿出来，会丢失原来的对象</span></span><br><span class="line"><span class="keyword">var</span> retrieveX = <span class="built_in">module</span>.getX</span><br><span class="line">retrieveX()</span><br><span class="line"><span class="comment">// 返回9 - 因为函数是在全局作用域中调用的</span></span><br></pre></td></tr></table></figure></li><li><p>利用bind处理</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个新函数，把 'this' 绑定到 module 对象</span></span><br><span class="line"><span class="comment">// 新手可能会将全局变量 x 与 module 的属性 x 混淆</span></span><br><span class="line">原始的对象创建一个绑定函数</span><br><span class="line"><span class="keyword">var</span> boundGetX = retrieveX.bind(<span class="built_in">module</span>)</span><br><span class="line">boundGetX() <span class="comment">// 81</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ul><li>实现参数的传递<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">ct</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// 获取从第二个参数到最后一个参数</span></span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 注意：arguments指bind返回的函数传入的参数</span></span><br><span class="line">      <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">      self.apply(ct, args.concat(bindArgs))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>未完。。。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">MDN</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;一般bind()用的比较多的就是&lt;strong&gt;创建绑定函数&lt;/strong&gt;，还有就是&lt;strong&gt;偏函数&lt;/strong&gt;。所以这里可能就是从bind函数的一般用法来考虑实现。MDN上的Polyfill借用slice()，concat()，call()方法。这里也是差不多的实现方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g2ofiscpy6j20gs09ggnu.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day110-手写原生call()</title>
    <link href="http://lmislm.com/2019/05/02/2019-05-02/"/>
    <id>http://lmislm.com/2019/05/02/2019-05-02/</id>
    <published>2019-05-01T16:00:00.000Z</published>
    <updated>2019-05-06T14:23:14.311Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>call()反正我是用的比较少吧，但是从大家的使用量来说，这个函数是非常的重要。因为他有一些方法，起了很重要的作用。比如简单的继承，指定上下文等。 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call" target="_blank" rel="noopener">用法 - MDN</a></p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g2neqaijfjj20e609gglv.jpg" alt=""><br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Product</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.price = price + <span class="string">'++'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Food</span>(<span class="params">name, price</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 下面的this表示Product在执行时真正的this值(严格模式。非严格模式则是指向全局对象)</span></span><br><span class="line">  Product.call(<span class="keyword">this</span>, name, price)</span><br><span class="line">  <span class="keyword">this</span>.category = <span class="string">'food'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Food(<span class="string">'cheese'</span>, <span class="number">5</span>).name)</span><br></pre></td></tr></table></figure></p><h3 id="代码-call"><a href="#代码-call" class="headerlink" title="代码-call()"></a>代码-call()</h3><blockquote><p>实现fun.protytype.myCall思路ES3 ： </p></blockquote><p><strong>步骤一</strong>确定参数数量</p><ul><li>先实现确定参数数量的myCall，因为function.prototype.call(thisArg, arg1, arg2, …),实际上是不确定参数的</li><li>fun的参数全部存到fun的临时处fun.temp</li><li>fun.temp() 输出在fun中存有的参数</li><li>删除fun中新增的temp，用delete</li></ul><blockquote><p>其他实现的思路好像都差不多。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">     args.temp = <span class="keyword">this</span></span><br><span class="line">     args.temp()</span><br><span class="line">     <span class="keyword">delete</span> args.temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤二</strong>不确定参数数量</p><blockquote><p>实现fun.protytype.myCall思路ES3 ：</p></blockquote><ul><li>对call的参数进行处理，用slice来分开参数</li><li>对分开之后的参数做不同处理</li><li>注意：非严格模式下thisArgs的null\undefined指向全局变量（浏览器是window）</li><li>用eval来连接args<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// null错误处理</span></span><br><span class="line">  args = args || <span class="built_in">window</span></span><br><span class="line">  args.temp = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result</span><br><span class="line">  <span class="keyword">if</span> (!args) &#123;</span><br><span class="line">    result = args.temp()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> argsList = []</span><br><span class="line">    <span class="comment">// 第二个参数及其以后的都存入数组, 注意arguments</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, l = <span class="built_in">arguments</span>.length; i &lt; l; i++) &#123;</span><br><span class="line">      argsList.push(<span class="string">'arguments['</span> + i + <span class="string">']'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// todo: eval不是很推荐的方法，需要一个好的方式连接 eval() https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval</span></span><br><span class="line">    result = <span class="built_in">eval</span>(<span class="string">'args.temp('</span> + argsList + <span class="string">')'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> fn.temp</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>// 待测试</p><h3 id="代码-apply"><a href="#代码-apply" class="headerlink" title="代码-apply()"></a>代码-apply()</h3><p>apply()和call()差不多，就是差在apply传入数组参数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply() = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg, argsArr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 注意Object()</span></span><br><span class="line">  thisArg = <span class="built_in">Object</span>(thisArg) || <span class="built_in">window</span></span><br><span class="line">  thisArg.temp = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">var</span> result</span><br><span class="line">  <span class="keyword">if</span> (!argsArr) &#123;</span><br><span class="line">    result = thisArg.temp</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 注意i = 0</span></span><br><span class="line">    <span class="keyword">var</span> arrTemp = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = argsArr.length; i &lt; l; i++) &#123;</span><br><span class="line">      arrTemp.push(<span class="string">'argsArr['</span> + i + <span class="string">']'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="built_in">eval</span>(<span class="string">'thisArg.temp('</span> + arrTemp + <span class="string">')'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/mqyqingfeng/Blog/issues/11" target="_blank" rel="noopener">JavaScript深入之call和apply的模拟实现 </a><br><a href="https://segmentfault.com/a/1190000017206223" target="_blank" rel="noopener">能否模拟实现JS的call和apply方法</a><br><a href="https://www.zhihu.com/question/35787390" target="_blank" rel="noopener">不能使用call,apply,bind，如何用js实现call或者apply的功能？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;call()反正我是用的比较少吧，但是从大家的使用量来说，这个函数是非常的重要。因为他有一些方法，起了很重要的作用。比如简单的继承，指定上下文等。 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;用法 - MDN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g2neqaijfjj20e609gglv.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day109-ts实现mvvm-笔记（2）</title>
    <link href="http://lmislm.com/2019/05/01/2019-05-01/"/>
    <id>http://lmislm.com/2019/05/01/2019-05-01/</id>
    <published>2019-04-30T16:00:00.000Z</published>
    <updated>2019-05-06T14:23:01.327Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>数组的依赖收集？？？</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1g2m6x7ao74j20e609g3yu.jpg" alt=""><br><a id="more"></a></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Dep <span class="keyword">from</span> <span class="string">"../../2019-04/30/vuejs/dep"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上文2019-04-30-vuejs</span></span><br><span class="line"><span class="comment">// 数组的依赖收集</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj: <span class="built_in">any</span>, key: <span class="built_in">string</span>, val?: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">    dep.depend()</span><br><span class="line">    <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">      childOb.dep.depend()</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">        dependArray(value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dependArray</span> (<span class="params">value: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> e, i = <span class="number">0</span>, l = value.length; i &lt; l; i++) &#123;</span><br><span class="line">    e = value[i]</span><br><span class="line">    <span class="comment">// 多维数组？？</span></span><br><span class="line">    e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend()</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(e)) &#123;</span><br><span class="line">      dependArray(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;数组的依赖收集？？？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1g2m6x7ao74j20e609g3yu.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
