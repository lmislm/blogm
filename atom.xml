<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LMISLMのBlog</title>
  
  <subtitle>“   故不积跬步，无以至千里；不积小流，无以成江海。  -  荀子《劝学篇》”</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.booml.cn/"/>
  <updated>2019-01-11T15:21:53.366Z</updated>
  <id>http://blog.booml.cn/</id>
  
  <author>
    <name>lmislm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第十一天2019-01-11</title>
    <link href="http://blog.booml.cn/2019/01/11/2019-01-11/"/>
    <id>http://blog.booml.cn/2019/01/11/2019-01-11/</id>
    <published>2019-01-10T16:00:00.000Z</published>
    <updated>2019-01-11T15:21:53.366Z</updated>
    
    <content type="html"><![CDATA[<p>呦呦呦，上线了一个功能！所以今天回来的可能有点晚啊！今天临上线前又更新了一点需求，这个更新需求这个事情，对于有些场景来说，真的是不可避免啊，但是这个问题本身可能是在敲定最终需求的时候，需求不明确所导致的，但是整个过程怎么去优化，还是个很大的问题。所以，我觉得最后优化的空间还会很大的。好吧，好像说了很多的空话，但实际上是有点想吐槽下自己代码效率的，对于更新速度快的需求不能够很好的对代码进行解耦和快速的组装，这个说明在设计代码的时候还是很有必要加强训练！</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1fyx7u0mosmj20qo0qot9y.jpg" alt=""><br>– end<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;呦呦呦，上线了一个功能！所以今天回来的可能有点晚啊！今天临上线前又更新了一点需求，这个更新需求这个事情，对于有些场景来说，真的是不可避免啊，但是这个问题本身可能是在敲定最终需求的时候，需求不明确所导致的，但是整个过程怎么去优化，还是个很大的问题。所以，我觉得最后优化的空间还会很大的。好吧，好像说了很多的空话，但实际上是有点想吐槽下自己代码效率的，对于更新速度快的需求不能够很好的对代码进行解耦和快速的组装，这个说明在设计代码的时候还是很有必要加强训练！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1fyx7u0mosmj20qo0qot9y.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;– end&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://blog.booml.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="感悟" scheme="http://blog.booml.cn/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>第十天2019-01-10</title>
    <link href="http://blog.booml.cn/2019/01/10/2019-01-10/"/>
    <id>http://blog.booml.cn/2019/01/10/2019-01-10/</id>
    <published>2019-01-09T16:00:00.000Z</published>
    <updated>2019-01-10T15:14:57.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>最近都没有不同的图片可以贴了，还需要找点图片啊。今天早上看了下怎么实现<code>new</code>操作符，感觉又回到了，原型和原型链的理解，<strong>“new”一个函数的时候，到底发生了什么</strong>？兜兜转转看来还是这个理解的不到位。说起理解不到位，让我想起了，今天写业务代码的时候，写到Vue渲染先后顺序这个地方，愣是卡了很久。看来这是对于整个的Vue运行机制还掌握的不够。</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1fyygpxh56kj20hr0hr3yx.jpg" alt=""><br><a id="more"></a></p><h2 id="笔记-new操作符-上"><a href="#笔记-new操作符-上" class="headerlink" title="笔记-new操作符-上"></a>笔记-new操作符-上</h2><h3 id="“new”-发生了什么"><a href="#“new”-发生了什么" class="headerlink" title="“new” 发生了什么"></a>“new” 发生了什么</h3><h4 id="先来看看MDN上是怎么解释的？2"><a href="#先来看看MDN上是怎么解释的？2" class="headerlink" title="先来看看MDN上是怎么解释的？2"></a>先来看看MDN上是怎么解释的？<sup><a href="https://juejin.im/post/5bde7c926fb9a049f66b8b52" target="_blank" rel="noopener">2</a></sup></h4><ul><li>语法<br><code>new constructor[([arguments])]</code> // constructor：指定对象实例的类型的类或函数</li><li>描述<blockquote><p>当代码 new Foo(…) 执行时，会发生以下事情：</p></blockquote></li></ul><ol><li>一个继承自 Foo.prototype 的新对象被创建。</li><li>使用指定的参数调用构造函数 Foo ，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表，Foo 不带任何参数调用的情况。</li><li>由构造函数返回的对象就是 new 表达式的结果。如果构造函数没有显式返回一个对象，则使用步骤1创建的对象。（一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤）</li></ol><h4 id="网友总结的-1"><a href="#网友总结的-1" class="headerlink" title="网友总结的[1]"></a>网友总结的<sup>[1]</sup></h4><ol><li>创建了一个全新的对象。</li><li>这个对象会被执行[[Prototype]]（也就是<strong>proto</strong>）链接。</li><li>生成的新对象会绑定到函数调用的this。</li><li>通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。</li><li>如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用会自动返回这个新的对象。</li></ol><p>这个是总结出来的，总觉得有点不科学啊。但目前好像是最好的办法，通过new的功能反推new的实现。</p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>使用 Function.prototype 属性将共享属性添加到以前定义的对象类型<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Car() &#123;&#125;</span><br><span class="line">car1 = new Car()</span><br><span class="line"></span><br><span class="line">Car.prototype.color = null</span><br><span class="line">console.log(car1.color) // null</span><br></pre></td></tr></table></figure></p><h2 id="怎么实现new"><a href="#怎么实现new" class="headerlink" title="怎么实现new"></a>怎么实现new</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 模拟实现 new 操作符</span><br><span class="line"> * @param  &#123;Function&#125; ctor [构造函数]</span><br><span class="line"> * @return &#123;Object|Function|Regex|Date|Error&#125;      [返回结果]</span><br><span class="line"> */</span><br><span class="line">function newOperator(ctor)&#123;</span><br><span class="line">    if(typeof ctor !== &apos;function&apos;)&#123;</span><br><span class="line">      throw &apos;newOperator function the first param must be a function&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    // ES6 new.target 是指向构造函数</span><br><span class="line">// new.target 后面会补充下</span><br><span class="line">    newOperator.target = ctor;</span><br><span class="line">    // 1.创建一个全新的对象，</span><br><span class="line">    // 2.并且执行[[Prototype]]链接</span><br><span class="line">    // 4.通过`new`创建的每个对象将最终被`[[Prototype]]`链接到这个函数的`prototype`对象上。</span><br><span class="line">    var newObj = Object.create(ctor.prototype);</span><br><span class="line">    // ES5 arguments转成数组 当然也可以用ES6 [...arguments], Aarry.from(arguments);</span><br><span class="line">    // 除去ctor构造函数的其余参数</span><br><span class="line">    var argsArr = [].slice.call(arguments, 1);</span><br><span class="line">    // 3.生成的新对象会绑定到函数调用的`this`。</span><br><span class="line">    // 获取到ctor函数返回结果</span><br><span class="line">    var ctorReturnResult = ctor.apply(newObj, argsArr);</span><br><span class="line">    // 小结4 中这些类型中合并起来只有Object和Function两种类型 typeof null 也是&apos;object&apos;所以要不等于null，排除null</span><br><span class="line">    var isObject = typeof ctorReturnResult === &apos;object&apos; &amp;&amp; ctorReturnResult !== null;</span><br><span class="line">    var isFunction = typeof ctorReturnResult === &apos;function&apos;;</span><br><span class="line">    if(isObject || isFunction)&#123;</span><br><span class="line">        return ctorReturnResult;</span><br><span class="line">    &#125;</span><br><span class="line">    // 5.如果函数没有返回对象类型`Object`(包含`Functoin`, `Array`, `Date`, `RegExg`, `Error`)，那么`new`表达式中的函数调用会自动返回这个新的对象。</span><br><span class="line">    return newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实现，除去一些排除异常的条件，我理解的就几步，把对象复制过去，然后参数绑定过去，排除边界条件，整个咋一看并不是很难，但是很考验对整个操作符的掌握和熟悉程度。</p><h3 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h3><p>在构造方法调用中，<code>new.target</code>指向被<code>new</code>调用的构造函数，所以”new.”成为了一个虚拟上下文<sup>[2]</sup></p><ul><li>普通函数中<br>  <code>new.target</code>的值是undefined,可以检测一个函数是否是作为构造函数通过<code>new</code>被调用的。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">  if (!new.target) throw &quot;Foo() must be called with new&quot;;</span><br><span class="line">  console.log(&quot;Foo instantiated with new&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo(); // throws &quot;Foo() must be called with new&quot;</span><br><span class="line">new Foo(); // logs &quot;Foo instantiated with new&quot;， 检测到由new调用</span><br></pre></td></tr></table></figure></li></ul><ol><li>构造函数中<br>稍微复杂点，这里暂时不讨论可以到<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new.target" target="_blank" rel="noopener">MDN</a>去看。<br>今天暂时讨论到这啊！明天还得上线呢！有点晚，早点睡觉吧。<pre><code>--end </code></pre>参考：<br>[1]. <a href="https://juejin.im/post/5bde7c926fb9a049f66b8b52" target="_blank" rel="noopener">面试官问：能否模拟实现JS的new操作符</a><br>[2]. <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener">new运算符</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;碎碎念&quot;&gt;&lt;a href=&quot;#碎碎念&quot; class=&quot;headerlink&quot; title=&quot;碎碎念&quot;&gt;&lt;/a&gt;碎碎念&lt;/h2&gt;&lt;p&gt;最近都没有不同的图片可以贴了，还需要找点图片啊。今天早上看了下怎么实现&lt;code&gt;new&lt;/code&gt;操作符，感觉又回到了，原型和原型链的理解，&lt;strong&gt;“new”一个函数的时候，到底发生了什么&lt;/strong&gt;？兜兜转转看来还是这个理解的不到位。说起理解不到位，让我想起了，今天写业务代码的时候，写到Vue渲染先后顺序这个地方，愣是卡了很久。看来这是对于整个的Vue运行机制还掌握的不够。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1fyygpxh56kj20hr0hr3yx.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://blog.booml.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="感悟" scheme="http://blog.booml.cn/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>第九天2019-01-09</title>
    <link href="http://blog.booml.cn/2019/01/09/2019-01-09/"/>
    <id>http://blog.booml.cn/2019/01/09/2019-01-09/</id>
    <published>2019-01-08T16:00:00.000Z</published>
    <updated>2019-01-09T14:15:37.061Z</updated>
    
    <content type="html"><![CDATA[<p>这几天很忙啊！！早上都去的很晚！早点睡觉早点睡觉！</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1fz0osud97tj20go0godg5.jpg" alt=""><br>–end<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天很忙啊！！早上都去的很晚！早点睡觉早点睡觉！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1fz0osud97tj20go0godg5.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;–end&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://blog.booml.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="感悟" scheme="http://blog.booml.cn/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>第八天2019-01-08</title>
    <link href="http://blog.booml.cn/2019/01/08/2019-01-08/"/>
    <id>http://blog.booml.cn/2019/01/08/2019-01-08/</id>
    <published>2019-01-07T16:00:00.000Z</published>
    <updated>2019-01-08T15:13:38.690Z</updated>
    
    <content type="html"><![CDATA[<h3 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h3><p>今天入职以来第一次迟到，作啊，8点43分有车，然后悠哉一会儿，52有车，悠哉穿个衣服，然后就9.20的车了。可能还有可能到公司，但是，出了隧道之后，公交每个红绿灯都停了，没有例外的巧合啊！期间还火车过道，这运气没谁了！最后10点10分才到公司。辛亏一个月可以迟到两次。</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1fyzkpuhasnj20g40c3tas.jpg" alt=""></p><a id="more"></a><h3 id="笔记-Object-assign-下"><a href="#笔记-Object-assign-下" class="headerlink" title="笔记-Object.assign()-下"></a>笔记-Object.assign()-下</h3><h4 id="继承属性和不可枚举属性是不能拷贝的"><a href="#继承属性和不可枚举属性是不能拷贝的" class="headerlink" title="继承属性和不可枚举属性是不能拷贝的"></a>继承属性和不可枚举属性是不能拷贝的</h4><blockquote><p>原生情况下挂载在 <strong>Object</strong> 上的属性是不可枚举的，但是直接在 <strong>Object</strong> 上挂载属性 a 之后是可枚举的，所以这里必须使用 <code>Object.defineProperty</code>，并设置 enumerable: false 以及 writable: true, configurable: true。<sup><a href="https://juejin.im/post/5c31e5c4e51d45524975d05a" target="_blank" rel="noopener">3</a></sup></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj = Object.create(&#123;foo: 1&#125;, &#123; // foo 是个继承属性。</span><br><span class="line">    bar: &#123;</span><br><span class="line">        value: 2  // bar 是个不可枚举属性。</span><br><span class="line">    &#125;,</span><br><span class="line">    baz: &#123;</span><br><span class="line">        value: 3,</span><br><span class="line">        enumerable: true  // baz 是个自身可枚举属性。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var copy = Object.assign(&#123;&#125;, obj);</span><br><span class="line">console.log(copy); // &#123; baz: 3 &#125;</span><br></pre></td></tr></table></figure><h5 id="检查是否可以枚举"><a href="#检查是否可以枚举" class="headerlink" title="检查是否可以枚举"></a>检查是否可以枚举</h5><blockquote><p>查看Object.assign 是否可枚举，使用 <strong>Object.getOwnPropertyDescriptor</strong> 或者 <strong>Object.propertyIsEnumerable</strong>（会检查给定的属性名是否直接存在于对象中,而不是在原型链上,并且满足  enumerable: true）。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 方法一：查看Object.assign()是否可以枚举</span><br><span class="line">Object.getOwnPropertyDescriptor(Object, &quot;assign&quot;);</span><br><span class="line">// 方法二</span><br><span class="line">Object.propertyIsEnumerable(&quot;assign&quot;); // false</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 实现 Object.assign时要用</span><br><span class="line">Object.defineProperty(Object,  &apos;assign&apos;,&#123;</span><br><span class="line">...</span><br><span class="line"> writable: true, </span><br><span class="line"> enumerable: false,</span><br><span class="line"> configurable: true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="原始类型会被包装为对象"><a href="#原始类型会被包装为对象" class="headerlink" title="原始类型会被包装为对象"></a>原始类型会被包装为对象</h4><p>有时候可以利用这一点包装为对象<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var v1 = &quot;abc&quot;;</span><br><span class="line">var v2 = true;</span><br><span class="line">var v3 = 10;</span><br><span class="line">var v4 = Symbol(&quot;foo&quot;)</span><br><span class="line"></span><br><span class="line">var obj = Object.assign(&#123;&#125;, v1, null, v2, undefined, v3, v4); </span><br><span class="line">// 原始类型会被包装，null 和 undefined 会被忽略。</span><br><span class="line">// 注意，只有字符串的包装对象才可能有自身可枚举属性。</span><br><span class="line">console.log(obj); // &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125;</span><br></pre></td></tr></table></figure></p><h4 id="异常会打断后续拷贝任务"><a href="#异常会打断后续拷贝任务" class="headerlink" title="异常会打断后续拷贝任务"></a>异常会打断后续拷贝任务</h4><blockquote><p>在出现错误的情况下，例如，如果属性不可写，会引发TypeError，如果在引发错误之前添加了任何属性，则可以更改target对象<sup><a href="https://www.css88.com/archives/8319" target="_blank" rel="noopener">2</a></sup>。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 定义不能写</span><br><span class="line">var target = Object.defineProperty(&#123;&#125;, &quot;foo&quot;, &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    writable: false</span><br><span class="line">&#125;); // target 的 foo 属性是个只读属性。</span><br><span class="line"></span><br><span class="line">Object.assign(target, &#123;bar: 2&#125;, &#123;foo2: 3, foo: 3, foo3: 3&#125;, &#123;baz: 4&#125;);</span><br><span class="line">// TypeError: &quot;foo&quot; is read-only</span><br><span class="line">// 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。</span><br><span class="line">console.log(target.bar);  // 2，说明第一个源对象拷贝成功了。</span><br><span class="line">console.log(target.foo2); // 3，说明第二个源对象的第一个属性也拷贝成功了。</span><br><span class="line">console.log(target.foo);  // 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。这里异常</span><br><span class="line">console.log(target.foo3); // undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。</span><br><span class="line">console.log(target.baz);  // undefined，第三个源对象更是不会被拷贝到的。</span><br></pre></td></tr></table></figure><h4 id="拷贝访问器"><a href="#拷贝访问器" class="headerlink" title="拷贝访问器"></a>拷贝访问器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  foo: 1,</span><br><span class="line">  // get 访问器</span><br><span class="line">  get bar() &#123;</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var copy = Object.assign(&#123;&#125;, obj); </span><br><span class="line">console.log(copy); // &#123; foo: 1, bar: 2 &#125;</span><br><span class="line">// copy.bar的值来自obj.bar的getter函数的返回值</span><br></pre></td></tr></table></figure><h5 id="拷贝所有自有属性的属性描述符（难点）"><a href="#拷贝所有自有属性的属性描述符（难点）" class="headerlink" title="拷贝所有自有属性的属性描述符（难点）"></a>拷贝所有自有属性的属性描述符（难点）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  foo: 1,</span><br><span class="line">  get bar() &#123;</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">function completeAssign(target, ...sources) &#123;</span><br><span class="line">  sources.forEach(source =&gt; &#123;</span><br><span class="line">   // reduce 可能是不太好理解，下期可能需要出一个笔记</span><br><span class="line">    let descriptors = Object.keys(source).reduce((descriptors, key) =&gt; &#123;</span><br><span class="line">// 获取属性描述符（可以分为数据描述符和存取描述符均，属性的信息可以查看：Object.defineProperty）</span><br><span class="line">      descriptors[key] = Object.getOwnPropertyDescriptor(source, key);</span><br><span class="line">      return descriptors;</span><br><span class="line">    &#125;, &#123;&#125;);</span><br><span class="line">    // Object.assign 默认也会拷贝可枚举的Symbols</span><br><span class="line">// Object.getOwnPropertySymbols() 方法返回一个给定对象自身的所有 Symbol 属性的数组。</span><br><span class="line">    Object.getOwnPropertySymbols(source).forEach(sym =&gt; &#123;</span><br><span class="line">      let descriptor = Object.getOwnPropertyDescriptor(source, sym);</span><br><span class="line">      if (descriptor.enumerable) &#123;</span><br><span class="line">        descriptors[sym] = descriptor;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Object.defineProperties(target, descriptors);</span><br><span class="line">  &#125;);</span><br><span class="line">  return target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var copy = completeAssign(&#123;&#125;, obj);</span><br><span class="line">console.log(copy);</span><br><span class="line">// &#123; foo:1, get bar() &#123; return 2 &#125; &#125;</span><br></pre></td></tr></table></figure><h4 id="MDN实现Obeject-assign"><a href="#MDN实现Obeject-assign" class="headerlink" title="MDN实现Obeject.assign()"></a>MDN实现Obeject.assign()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (typeof Object.assign != &apos;function&apos;) &#123;</span><br><span class="line">  // Must be writable: true, enumerable: false, configurable: true</span><br><span class="line">  Object.defineProperty(Object, &quot;assign&quot;, &#123;</span><br><span class="line">    value: function assign(target, varArgs) &#123; // .length of function is 2</span><br><span class="line">      &apos;use strict&apos;;</span><br><span class="line">      if (target == null) &#123; // TypeError if undefined or null</span><br><span class="line">        throw new TypeError(&apos;Cannot convert undefined or null to object&apos;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      var to = Object(target);</span><br><span class="line"></span><br><span class="line">      for (var index = 1; index &lt; arguments.length; index++) &#123;</span><br><span class="line">        var nextSource = arguments[index];</span><br><span class="line"></span><br><span class="line">        if (nextSource != null) &#123; // Skip over if undefined or null</span><br><span class="line">          for (var nextKey in nextSource) &#123;</span><br><span class="line">            // Avoid bugs when hasOwnProperty is shadowed</span><br><span class="line">// 直接使用 myObject.hasOwnProperty(..) 是有问题的，因为有的对象可能没有连接到 Object.prototype 上所以这里用上call()</span><br><span class="line">            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) &#123;</span><br><span class="line">              to[nextKey] = nextSource[nextKey];</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return to;</span><br><span class="line">    &#125;,</span><br><span class="line">    writable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>今天就先很粗糙地写一下，明天再详细的谈一些细节部分吧。<br>– end</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>[1].  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener">Object.assign()–MDN</a><br>[2]. <a href="https://www.css88.com/archives/8319" target="_blank" rel="noopener">JavaScript 中的对象拷贝</a><br>[3]. <a href="https://juejin.im/post/5c31e5c4e51d45524975d05a" target="_blank" rel="noopener">【进阶4-2期】Object.assign 原理及其实现</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;碎碎念&quot;&gt;&lt;a href=&quot;#碎碎念&quot; class=&quot;headerlink&quot; title=&quot;碎碎念&quot;&gt;&lt;/a&gt;碎碎念&lt;/h3&gt;&lt;p&gt;今天入职以来第一次迟到，作啊，8点43分有车，然后悠哉一会儿，52有车，悠哉穿个衣服，然后就9.20的车了。可能还有可能到公司，但是，出了隧道之后，公交每个红绿灯都停了，没有例外的巧合啊！期间还火车过道，这运气没谁了！最后10点10分才到公司。辛亏一个月可以迟到两次。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1fyzkpuhasnj20g40c3tas.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://blog.booml.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="感悟" scheme="http://blog.booml.cn/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>第七天2019-01-07</title>
    <link href="http://blog.booml.cn/2019/01/07/2019-01-07/"/>
    <id>http://blog.booml.cn/2019/01/07/2019-01-07/</id>
    <published>2019-01-06T16:00:00.000Z</published>
    <updated>2019-01-08T15:12:46.322Z</updated>
    
    <content type="html"><![CDATA[<h4 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h4><p>最近发现写代码的速度有提升，这说明写业务代码基础都差不多了，接下来就应该深究其内容了，该向代码底层的一些原理进行深入探究了，当然还是得夯实基础。之前看过一点<code>Lodashjs</code>的基础，但是有些关联性太强，没办法一下子联系起来，得慢慢的来看内容。今早上看了js中一个<code>Object.assign()</code>中的一些原理，发现其实并没有想象的那么难，但是手写起来可是非常考验功底，需要真正理解才能去写出浅拷贝的<code>Objecr.assign()</code>。下面来浅谈下。</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1fyygpxh56kj20hr0hr3yx.jpg" alt=""></p><a id="more"></a><h3 id="笔记-Object-assign-–上"><a href="#笔记-Object-assign-–上" class="headerlink" title="笔记-Object.assign()–上"></a>笔记-Object.assign()–上</h3><ul><li>描述<blockquote><p>如果目标对象中的属性具有相同的键，则属性将被源中的属性覆盖。后来的源的属性将类似地覆盖早先的属性。<br>这里应该讲的是<figure class="highlight plain"><figcaption><span>的**陷阱**。</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 拷贝问题</span><br><span class="line"></span><br><span class="line">```javascript?linenums</span><br><span class="line">// 1. 浅拷贝</span><br><span class="line">let obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;;  // 源对象</span><br><span class="line"></span><br><span class="line">let obj2 = Object.assign(&#123;&#125;, obj1); // 目标对象</span><br><span class="line">console.log(JSON.stringify(obj2)); // &#123; a: 0, b: &#123; c: 0&#125;&#125;</span><br><span class="line">// 2. 改变源对象的属性值，拷贝的值并不会改变</span><br><span class="line">obj1.a = 1;</span><br><span class="line">console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125; ，</span><br><span class="line">console.log(JSON.stringify(obj2)); // &#123; a: 0, b: &#123; c: 0&#125;&#125;</span><br><span class="line">// 3. 修改目标对象的属性</span><br><span class="line">obj2.a = 2;</span><br><span class="line">console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125;</span><br><span class="line">console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 0&#125;&#125;</span><br><span class="line">// 4. 改变了目标对象的值，因为复制了对源对象的引用，对目标对象属性的修改也能改源对象，如何解决这种问题？</span><br><span class="line">obj2.b.c = 3;</span><br><span class="line">console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 3&#125;&#125;</span><br><span class="line">console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 3&#125;&#125;</span><br><span class="line">// 5. 常用的深拷贝JSON.parse(JSON.stringify()),这个方法也有缺点</span><br><span class="line">obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;;</span><br><span class="line">let obj3 = JSON.parse(JSON.stringify(obj1));</span><br><span class="line">obj1.a = 4;</span><br><span class="line">obj1.b.c = 4;</span><br><span class="line">console.log(JSON.stringify(obj3)); // &#123; a: 0, b: &#123; c: 0&#125;&#125;</span><br></pre></td></tr></table></figure></p></blockquote></li></ul><h4 id="合并对象（常用）"><a href="#合并对象（常用）" class="headerlink" title="合并对象（常用）"></a>合并对象（常用）</h4><blockquote><p>以下代码引自MDN</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var o1 = &#123; a: 1 &#125;;</span><br><span class="line">var o2 = &#123; b: 2 &#125;;</span><br><span class="line">var o3 = &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">var obj = Object.assign(o1, o2, o3);</span><br><span class="line">console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;</span><br><span class="line">console.log(o1);  // &#123; a: 1, b: 2, c: 3 &#125;</span><br></pre></td></tr></table></figure><ul><li>注意目标对象自身也会改变。</li></ul><h4 id="合并具有相同属性的对象"><a href="#合并具有相同属性的对象" class="headerlink" title="合并具有相同属性的对象"></a>合并具有相同属性的对象</h4><blockquote><p>以下代码引自MDN</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var o1 = &#123; a: 1, b: 1, c: 1 &#125;;</span><br><span class="line">var o2 = &#123; b: 2, c: 2 &#125;;</span><br><span class="line">var o3 = &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">var obj = Object.assign(&#123;&#125;, o1, o2, o3);</span><br><span class="line">console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;</span><br></pre></td></tr></table></figure><ul><li>注意后续参数覆盖问题</li></ul><h4 id="拷贝-symbol-类型的属性"><a href="#拷贝-symbol-类型的属性" class="headerlink" title="拷贝 symbol 类型的属性"></a>拷贝 symbol 类型的属性</h4><ul><li>描述<blockquote><p>Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。String类型和 Symbol 类型的属性都会被拷贝。</p></blockquote></li></ul><blockquote><p>以下代码引自MDN</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var o1 = &#123; a: 1 &#125;;</span><br><span class="line">var o2 = &#123; [Symbol(&apos;foo&apos;)]: 2 &#125;;</span><br><span class="line"></span><br><span class="line">var obj = Object.assign(&#123;&#125;, o1, o2);</span><br><span class="line">console.log(obj); // &#123; a : 1, [Symbol(&quot;foo&quot;)]: 2 &#125;    (cf. bug 1207182 on Firefox)</span><br><span class="line">Object.getOwnPropertySymbols(obj); // [Symbol(foo)]</span><br></pre></td></tr></table></figure><h3 id="先探究到这里吧"><a href="#先探究到这里吧" class="headerlink" title="先探究到这里吧"></a>先探究到这里吧</h3><p>针对深拷贝，需要使用其他方法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。常用的可能是<code>JSON.parse(JSON.stringify())</code>,这个方法也有缺点。</p><h4 id="知识扩展-简单对比"><a href="#知识扩展-简单对比" class="headerlink" title="知识扩展-简单对比"></a>知识扩展-简单对比</h4><ol><li>Object.assign()</li><li>JSON.parse(JSON.stringify())</li></ol><ul><li><code>2</code>，不适合<strong>复制循环引用对象</strong>,不适合<strong>复制对象方法</strong> </li></ul><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>[1].  <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener">Object.assign()–MDN</a><br>[2]. <a href="https://www.css88.com/archives/8319" target="_blank" rel="noopener">JavaScript 中的对象拷贝</a><br>–end</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;碎碎念&quot;&gt;&lt;a href=&quot;#碎碎念&quot; class=&quot;headerlink&quot; title=&quot;碎碎念&quot;&gt;&lt;/a&gt;碎碎念&lt;/h4&gt;&lt;p&gt;最近发现写代码的速度有提升，这说明写业务代码基础都差不多了，接下来就应该深究其内容了，该向代码底层的一些原理进行深入探究了，当然还是得夯实基础。之前看过一点&lt;code&gt;Lodashjs&lt;/code&gt;的基础，但是有些关联性太强，没办法一下子联系起来，得慢慢的来看内容。今早上看了js中一个&lt;code&gt;Object.assign()&lt;/code&gt;中的一些原理，发现其实并没有想象的那么难，但是手写起来可是非常考验功底，需要真正理解才能去写出浅拷贝的&lt;code&gt;Objecr.assign()&lt;/code&gt;。下面来浅谈下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1fyygpxh56kj20hr0hr3yx.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://blog.booml.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JS" scheme="http://blog.booml.cn/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>第六天2019-01-06</title>
    <link href="http://blog.booml.cn/2019/01/06/2019-01-06/"/>
    <id>http://blog.booml.cn/2019/01/06/2019-01-06/</id>
    <published>2019-01-05T16:00:00.000Z</published>
    <updated>2019-01-06T14:07:02.900Z</updated>
    
    <content type="html"><![CDATA[<h4 id="讲讲生活哈"><a href="#讲讲生活哈" class="headerlink" title="讲讲生活哈"></a>讲讲生活哈</h4><p>今天一天，早上起来之后就买了，汤骨和一些作料来做饭吃，真是很便宜，比在外面吃不知道要好多少啊。下面谈谈观影感受。</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1fyx7u0mosmj20qo0qot9y.jpg" alt=""></p><a id="more"></a><p>然后就开始在B站看电影，毕竟也是买了年度大会员的哈，总要找点专门属于会员的来看哈，因为最近上映的大黄蜂电影，于是就挑这个前传看，就在刚才结束的变形金刚前三部的观看，据说第四部和第五部分与原创相差太大。嗯，于是就不继续看下去吧。但是变形金刚的前三部是真的很帅！看完第一步，你完全想象不到这居然是零几年拍摄的电影CG效果简直不能再好。连看了三部之后真是觉得很热血啊。里面的人物价值观也设置的很合理，<strong>为了不同的追求，永远没有对和错，只有对事情角度的不同，影响。</strong></p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1fyx7t096iwj20go096jtu.jpg" alt=""><br>这个周日也就一下子过去了。当然，上午还看了一大半的绣春刀，这部电影镜头什么的真的没话说，就是看到卢大哥被赏百户的时候，看不下去了，觉得，这是沈大人做的孽啊，为什么要为了一己私欲放走了魏忠贤，你觉得他会放过一个知道秘密的人？有时候真的是所有的错误，全在一瞬间决定。当我们遇到这种情况的时候，切记，一定要保持理智啊！因为<strong>摧毁你的不太可能是一个很明显的错误，是你最脆弱的时候犯的错误。</strong><br>今天谈感受就谈到这里吧！<br>–end<br><!--more--></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;讲讲生活哈&quot;&gt;&lt;a href=&quot;#讲讲生活哈&quot; class=&quot;headerlink&quot; title=&quot;讲讲生活哈&quot;&gt;&lt;/a&gt;讲讲生活哈&lt;/h4&gt;&lt;p&gt;今天一天，早上起来之后就买了，汤骨和一些作料来做饭吃，真是很便宜，比在外面吃不知道要好多少啊。下面谈谈观影感受。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1fyx7u0mosmj20qo0qot9y.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://blog.booml.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="感悟" scheme="http://blog.booml.cn/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>五2019-01-05</title>
    <link href="http://blog.booml.cn/2019/01/05/2019-01-05/"/>
    <id>http://blog.booml.cn/2019/01/05/2019-01-05/</id>
    <published>2019-01-04T16:00:00.000Z</published>
    <updated>2019-01-06T14:05:14.605Z</updated>
    
    <content type="html"><![CDATA[<h3 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h3><p>今天加班啊！真是一件不太舒服的事情，加班都是为了一件事，让我一个人上线负责主要的内容。<br><img src="https://ws1.sinaimg.cn/large/b15ca614gy1fyw05v0dcuj20go0h1dgb.jpg" alt=""><br>有点累。早上起得有点晚，出门下着小雨，在公交上都没法看点知识类的东西。晃晃悠悠到公司。结果发现我和产品来的最早啊。坑爹啊。不过，加班中午大家一起出去饭馆吃，老板请客这点倒是蛮不错，今天的才也都蛮合胃口！就是鼻子有鼻炎，总感觉人多的时候不太好，鼻子有失体面，下次一定把鼻子这事搞定吧。坚持用就行。<br>下午顺利上线，真是ok。<br>—end</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;碎碎念&quot;&gt;&lt;a href=&quot;#碎碎念&quot; class=&quot;headerlink&quot; title=&quot;碎碎念&quot;&gt;&lt;/a&gt;碎碎念&lt;/h3&gt;&lt;p&gt;今天加班啊！真是一件不太舒服的事情，加班都是为了一件事，让我一个人上线负责主要的内容。&lt;br&gt;&lt;img src=&quot;https://w
      
    
    </summary>
    
      <category term="生活" scheme="http://blog.booml.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="感悟" scheme="http://blog.booml.cn/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>第四天 2019-01-04</title>
    <link href="http://blog.booml.cn/2019/01/04/2019-01-04/"/>
    <id>http://blog.booml.cn/2019/01/04/2019-01-04/</id>
    <published>2019-01-03T16:00:00.000Z</published>
    <updated>2019-01-04T15:52:25.376Z</updated>
    
    <content type="html"><![CDATA[<h5 id="一天"><a href="#一天" class="headerlink" title="一天"></a>一天</h5><p>以为项目会今天上线，结果，一天提了50-60个样式问题。虽然问题都很简单，但是真的是找的要命啊！下面讲讲今天这些问题的来源，讲八卦。</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1fyuz4phl2hj20go0godg5.jpg" alt=""></p><a id="more"></a><h4 id="放图"><a href="#放图" class="headerlink" title="放图"></a>放图</h4><p>看到这奖状没？够专业了吧？</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1fyuyo4h4zhj20ma0grtov.jpg" alt=""></p><p>你以为就只有奖状？！<strong>错</strong>，还有实在的<strong>礼品</strong>！<br>第三名和第二名！如图：</p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1fyuyo489j1j208a08dgrj.jpg" alt=""></p><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1fyuyo3w6wvj208d08bq75.jpg" alt=""><br><strong>真是非常辛苦产品小姐姐了！</strong>然而，我下班还当着产品的面，抱怨加需求。也是非常可以的了。<br>第一名有两位！奖励手机壳！<br>本来想聊一聊今天看的一篇，如何优化代码的文章！明天还要早起，算了吧。聊点八卦。<br>–end</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;一天&quot;&gt;&lt;a href=&quot;#一天&quot; class=&quot;headerlink&quot; title=&quot;一天&quot;&gt;&lt;/a&gt;一天&lt;/h5&gt;&lt;p&gt;以为项目会今天上线，结果，一天提了50-60个样式问题。虽然问题都很简单，但是真的是找的要命啊！下面讲讲今天这些问题的来源，讲八卦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1fyuz4phl2hj20go0godg5.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://blog.booml.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="感悟" scheme="http://blog.booml.cn/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>第三天2019-01-03</title>
    <link href="http://blog.booml.cn/2019/01/03/2019-01-03/"/>
    <id>http://blog.booml.cn/2019/01/03/2019-01-03/</id>
    <published>2019-01-02T16:00:00.000Z</published>
    <updated>2019-01-04T15:33:23.054Z</updated>
    
    <content type="html"><![CDATA[<h4 id="忙碌的一天"><a href="#忙碌的一天" class="headerlink" title="忙碌的一天"></a>忙碌的一天</h4><p>啊！国际化终于要上线了。总是改文案改样式，我都快改死了。这个译文的调整真不是改的。细化到空格，逗号，括号。<br>今天眼睛又是眯着回来的。不知道怎么了，是眼睛困了，会进行自我保护?所以眼睛会眯着？<br><img src="https://ws1.sinaimg.cn/large/b15ca614gy1fyts90gsxyj20k10k3gm4.jpg" alt=""><br>今天又看了原型和原型链的一片文章，发现真是永远也讲不完，<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">```prototype```, 这种&quot;面向关联&quot;的模式真的是比较奇怪但是有中用。</span><br><span class="line">**列一下几个重要的等式吧。**</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">// 函数的构造器是Function</span><br><span class="line">Object.__proto__  === Function.prototype // true</span><br><span class="line"></span><br><span class="line">// 函数字面量的__proto__ 指向Function</span><br><span class="line">(function () &#123;&#125;).__proto__ === Function.prototype // true</span><br><span class="line"></span><br><span class="line">// 对象字面量</span><br><span class="line">(&#123;&#125;).__proto__  === Object.prototype // true</span><br><span class="line"></span><br><span class="line">// Object函数原型的__proto__指向 null</span><br><span class="line">Object.prototype.__proto__ === null</span><br><span class="line"></span><br><span class="line">// Function 函数的__proto__ 指向自身prototype</span><br><span class="line">Function.__proto__ === Function.prototype // true</span><br><span class="line"></span><br><span class="line">// Function的prototype是一个对象，所以Function.prototype.__proto__指向Object.prototype</span><br><span class="line">Function.prototype.__proto__ === Object.prototype // true</span><br></pre></td></tr></table></figure></p><h3 id="放图！"><a href="#放图！" class="headerlink" title="放图！"></a>放图！</h3><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1fytrfhpdmwj20eg0gamxv.jpg" alt=""></p><h5 id="图说明"><a href="#图说明" class="headerlink" title="图说明"></a>图说明</h5><p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1fytrxmsbzsj20eg0gbq6u.jpg" alt=""></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li><p>对象有属性<code>__proto__</code>(又可以称为隐式原型),指向该对象的构造函数的原型对象</p></li><li><p>方法(Function)除了有属性<code>__proto__</code>,还有属性<code>prototype</code>指向该方法的原型对象（包含所有实例共享的属性和方法叫做原型对象），原型对象也有属性<code>constructor</code>指回原构造函数。</p></li><li><p>先有Object.prototype（原型链顶端），Function.prototype继承Object.prototype而产生，最后，Function和Object和其它构造函数继承Function.prototype而产生</p></li></ol><h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>今天就到这吧，这是个很好的开端！！</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><code>[1]</code> <a href="https://www.zhihu.com/question/34183746" target="_blank" rel="noopener">js中<strong>proto</strong>和prototype的区别和关系？</a><br><code>[2]</code> <a href="https://juejin.im/post/5c2c211e6fb9a049a62caf30" target="_blank" rel="noopener">JavaScript原型与继承的秘密</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;忙碌的一天&quot;&gt;&lt;a href=&quot;#忙碌的一天&quot; class=&quot;headerlink&quot; title=&quot;忙碌的一天&quot;&gt;&lt;/a&gt;忙碌的一天&lt;/h4&gt;&lt;p&gt;啊！国际化终于要上线了。总是改文案改样式，我都快改死了。这个译文的调整真不是改的。细化到空格，逗号，括号。&lt;br&gt;今
      
    
    </summary>
    
      <category term="生活" scheme="http://blog.booml.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="感悟" scheme="http://blog.booml.cn/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>第二天2019-01-02</title>
    <link href="http://blog.booml.cn/2019/01/02/2019-01-02/"/>
    <id>http://blog.booml.cn/2019/01/02/2019-01-02/</id>
    <published>2019-01-01T16:00:00.000Z</published>
    <updated>2019-01-02T14:44:31.730Z</updated>
    
    <content type="html"><![CDATA[<h4 id="谈一天感受"><a href="#谈一天感受" class="headerlink" title="谈一天感受"></a>谈一天感受</h4><p>今天早上起来，发现这几天真的好冷啊。真是降温到极点了。扫兴的是，居然还牙疼，都怪假期三天吃的太多了，这智齿问题又出来了，哪天找个机会真的把它给拔了！<br><img src="https://ws1.sinaimg.cn/large/b15ca614gy1fysmf2k2xqj20k30k574t.jpg" alt=""><br><a id="more"></a><br>今天转了一篇微信文章，要集赞然后获取《经济学人》98年到18年的文章。真是幸运，前几天还念叨着，要想办法拿下经济学人的文章合集就好。真是运气啊，今天就有机会获得了。新年开始，运气都这么好的吗？<br>今天把推荐码和红包都写好了，不容易啊，断断续续一个星期，中间还惨杂这user-server的URL修改，实际工作时间真的就是三四天。剩下的还有后台管理的一小部分。其中掺杂着一些YiCAT的国际化，国际化你可快点上线吧，天天各种细节，译文修改，真是琐碎的很。还特别占时间。完全是体力活，原谅我再一次吐槽这个译文的修改。从第一次拿到译文，到现在为止，我已经数不清，改了多少次译文了。真想写个接口。让他们自己去修改。省得自己天天改译文文案。吐槽就到这里吧。<br>这些天不知道眼睛怎么了，总是表现出很困的感觉，一直不自觉眯着眼睛。可能是没有早睡的原因。真是佩服公司同事，每天熬夜到一两点，精神气还十足。<br>– end</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;谈一天感受&quot;&gt;&lt;a href=&quot;#谈一天感受&quot; class=&quot;headerlink&quot; title=&quot;谈一天感受&quot;&gt;&lt;/a&gt;谈一天感受&lt;/h4&gt;&lt;p&gt;今天早上起来，发现这几天真的好冷啊。真是降温到极点了。扫兴的是，居然还牙疼，都怪假期三天吃的太多了，这智齿问题又出来了，哪天找个机会真的把它给拔了！&lt;br&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1fysmf2k2xqj20k30k574t.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://blog.booml.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="感悟" scheme="http://blog.booml.cn/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>新年第一天-2019-01-01</title>
    <link href="http://blog.booml.cn/2019/01/01/2019-01-01/"/>
    <id>http://blog.booml.cn/2019/01/01/2019-01-01/</id>
    <published>2018-12-31T16:00:00.000Z</published>
    <updated>2019-01-01T12:35:04.544Z</updated>
    
    <content type="html"><![CDATA[<h3 id="友情提示"><a href="#友情提示" class="headerlink" title="友情提示"></a>友情提示</h3><p>以下内容都是一些碎碎念，生活、读后感、今天生活内容。<br>ps: 附上我的“专业插画师”提供的图片。<br><img src="https://ws1.sinaimg.cn/large/b15ca614gy1fyrcswupyxj20jg0jggmk.jpg" alt=""><br><a id="more"></a></p><h4 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h4><p>新年第一天，昨晚在群里抢红包，一直热闹到很晚才睡。今早10点才慵懒的起来，起的有点晚。中午炸鸡腿，惨不忍睹。后来玩游戏，庸庸碌碌的一天就过去了。这是假期最后一天。希望晚上的时候能收收心看点书。顺带一提昨天晚上看了组件详解。</p><h4 id="读Vue-组件基础之组件通信-《Vue-js实战》"><a href="#读Vue-组件基础之组件通信-《Vue-js实战》" class="headerlink" title="读Vue 组件基础之组件通信 -《Vue js实战》"></a>读Vue 组件基础之组件通信 -《Vue js实战》</h4><h5 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h5><p>组件的复用，复用离不开值得传递。父子组件，兄弟组件相互之间的传值。基本的有<code>props</code>，父组件传递给子组件，子组件通过<code>$emit()</code>、<code>v-on:</code> 来将值通知父组件。不太常用的有<code>$parent</code>(书中提到可以通过此通信访问父实例或组件），在组件中引用父组件，<code>$child</code>,父组件引用子组件。《Vue js实战》书中提到了，通过利用实例化一个空的<code>BUS</code>组件起到<code>总线</code>的作用，这种方法还挺新鲜。另外，组件通信时还有slot的内容分发，slot默认名称是可以和具名slot一起用的。相互之间并不影响。好吧，之前用的时候，总是会不自觉给slot取名字。理解的不够深刻。</p><h5 id="高级组件"><a href="#高级组件" class="headerlink" title="高级组件"></a>高级组件</h5><ol><li>组件可以递归自己。</li><li>异步组件。</li></ol><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>总感觉这种组件通信方式还有待于改善，应该多读一下开源的一些组件是怎么写出来的。因为上次研究element-UI的时候并没有看它运用这些（指的是通信手段，也可能是我忽略？）但是表现出了很强的可扩展性。很值得学习。包括其中CSS中的书写。</p><h5 id="插播"><a href="#插播" class="headerlink" title="插播"></a>插播</h5><p>元旦放假头一天，买了100的零食，一个大箱子，有优惠。现在好像吃的牙有点疼。作啊。明明要减肥的人。</p><h5 id="发现好的视频"><a href="#发现好的视频" class="headerlink" title="发现好的视频"></a>发现好的视频</h5><p>今天看B站排行榜的时候发现一个点评动漫的UP主，LexBurner?“艺名”：蕾丝。他的视频看动漫的角度还真是蛮特别，应该是有大量的漫画番剧的基础，能有空看这么多视频和漫画，这人真是不简单。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;友情提示&quot;&gt;&lt;a href=&quot;#友情提示&quot; class=&quot;headerlink&quot; title=&quot;友情提示&quot;&gt;&lt;/a&gt;友情提示&lt;/h3&gt;&lt;p&gt;以下内容都是一些碎碎念，生活、读后感、今天生活内容。&lt;br&gt;ps: 附上我的“专业插画师”提供的图片。&lt;br&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1fyrcswupyxj20jg0jggmk.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://blog.booml.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="感悟" scheme="http://blog.booml.cn/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>2018年最后一天</title>
    <link href="http://blog.booml.cn/2018/12/31/2018-%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9/"/>
    <id>http://blog.booml.cn/2018/12/31/2018-最后一天/</id>
    <published>2018-12-30T16:00:00.000Z</published>
    <updated>2018-12-31T01:47:06.004Z</updated>
    
    <content type="html"><![CDATA[<p>2018年就要拜拜了。<br>早上9点起来的也不算太晚。折腾了一会儿博客样式之（发现是又拍云开启浏览器缓存的锅）。<br>今天打算看一些书度过。额，还是先玩会儿游戏放空下？不然感觉不太想看书。<br><img src="https://ws1.sinaimg.cn/large/b15ca614gy1fypoomy5vaj20qq0cr0ub.jpg" alt=""><br>放张图片吧，可能就是需要这样来自嘲。<br>– end<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2018年就要拜拜了。&lt;br&gt;早上9点起来的也不算太晚。折腾了一会儿博客样式之（发现是又拍云开启浏览器缓存的锅）。&lt;br&gt;今天打算看一些书度过。额，还是先玩会儿游戏放空下？不然感觉不太想看书。&lt;br&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1fypoomy5vaj20qq0cr0ub.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;放张图片吧，可能就是需要这样来自嘲。&lt;br&gt;– end&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://blog.booml.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="感悟" scheme="http://blog.booml.cn/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>markdown-trick</title>
    <link href="http://blog.booml.cn/2018/12/30/markdown-trick/"/>
    <id>http://blog.booml.cn/2018/12/30/markdown-trick/</id>
    <published>2018-12-30T11:20:04.493Z</published>
    <updated>2018-12-30T11:20:04.493Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vscode-snippets"><a href="#vscode-snippets" class="headerlink" title="vscode snippets"></a>vscode snippets</h2><blockquote><p>以设置 markdown 代码片段为例</p></blockquote><a id="more"></a><h4 id="开启设置"><a href="#开启设置" class="headerlink" title="开启设置"></a><a href="https://github.com/Microsoft/vscode/issues/28048" target="_blank" rel="noopener">开启设置</a></h4><blockquote><p>文件 &gt; 首选项 &gt; 设置</p></blockquote><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"[markdown]":  &#123;</span><br><span class="line">    "editor.quickSuggestions": true</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="设置模板"><a href="#设置模板" class="headerlink" title="设置模板"></a><a href="https://code.visualstudio.com/docs/editor/userdefinedsnippets" target="_blank" rel="noopener">设置模板</a></h4><blockquote><p>文件 &gt; 首选项 &gt; 用户代码片段 &gt; markdown.json</p></blockquote><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"markdown write template"</span>: &#123;</span><br><span class="line">    <span class="attr">"prefix"</span>: <span class="string">"mdrt"</span>,</span><br><span class="line">    <span class="attr">"body"</span>: [</span><br><span class="line">      <span class="string">"--- $1"</span>,</span><br><span class="line">      <span class="string">"title: $TM_FILENAME_BASE"</span>,</span><br><span class="line">      <span class="string">"tags:"</span>,</span><br><span class="line">      <span class="string">"* xx"</span>,</span><br><span class="line">      <span class="string">"categories:"</span>,</span><br><span class="line">      <span class="string">"* xx"</span>,</span><br><span class="line">      <span class="string">"date: $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE-$CURRENT_HOUR"</span>,</span><br><span class="line">      <span class="string">"--- "</span>,</span><br><span class="line">      <span class="string">" \n "</span>,</span><br><span class="line"></span><br><span class="line">      <span class="string">"&lt;!--more--&gt; $2"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"Create template for markdown write"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: md-kill</span><br><span class="line">tags:</span><br><span class="line">* xx</span><br><span class="line">categories:</span><br><span class="line">* xx</span><br><span class="line">date: 2018-03-31-20</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://github.com/Microsoft/vscode/issues/28048" target="_blank" rel="noopener">Markdown Snippet Prefix Does Not Trigger Snippet #28048</a><br><a href="https://code.visualstudio.com/docs/editor/userdefinedsnippets" target="_blank" rel="noopener">Creating your own snippets</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;vscode-snippets&quot;&gt;&lt;a href=&quot;#vscode-snippets&quot; class=&quot;headerlink&quot; title=&quot;vscode snippets&quot;&gt;&lt;/a&gt;vscode snippets&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;以设置 markdown 代码片段为例&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="日常操作" scheme="http://blog.booml.cn/categories/%E6%97%A5%E5%B8%B8%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="小技巧" scheme="http://blog.booml.cn/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>fib</title>
    <link href="http://blog.booml.cn/2018/12/30/fib/"/>
    <id>http://blog.booml.cn/2018/12/30/fib/</id>
    <published>2018-12-30T11:20:04.473Z</published>
    <updated>2018-12-30T11:20:04.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><blockquote><p>打印斐波那契数列，递归法，迭代法，提升递归效率</p></blockquote><a id="more"></a><p>[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]<br>后一位数是前两位数之和<br>(例如 fib(2) === 0 + 1) === 1;</p><p>提升递归效率，创建一个数据存储，或者一个小的缓存对象，缓存对象是数组</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function memoize(fn) &#123;</span><br><span class="line">  const cache = &#123;&#125;;</span><br><span class="line">  return function(...args) &#123;</span><br><span class="line">    // ...args ： 数组集</span><br><span class="line">    if (cache[args]) &#123;</span><br><span class="line">      return cache[args];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const result = fn.apply(this, args);</span><br><span class="line">    cache[args] = result;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function slowFib(n) &#123;</span><br><span class="line">  if (n &lt; 2) &#123;</span><br><span class="line">    return n;</span><br><span class="line">  &#125;</span><br><span class="line">  return slowFib(n - 1) + slowFib(n - 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const fib = memoize(slowFib);</span><br></pre></td></tr></table></figure><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fib(n) &#123;</span><br><span class="line">  if (n &lt; 2) &#123;</span><br><span class="line">    return n;</span><br><span class="line">  &#125;</span><br><span class="line">  return fib(n - 1) + fib(n - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> a = result[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> b = result[i - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    result.push(a + b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;斐波那契数列&quot;&gt;&lt;a href=&quot;#斐波那契数列&quot; class=&quot;headerlink&quot; title=&quot;斐波那契数列&quot;&gt;&lt;/a&gt;斐波那契数列&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;打印斐波那契数列，递归法，迭代法，提升递归效率&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习" scheme="http://blog.booml.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JS" scheme="http://blog.booml.cn/tags/JS/"/>
    
      <category term="编程" scheme="http://blog.booml.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Interview" scheme="http://blog.booml.cn/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>2019--启程</title>
    <link href="http://blog.booml.cn/2018/12/30/2019-%E5%90%AF%E7%A8%8B/"/>
    <id>http://blog.booml.cn/2018/12/30/2019-启程/</id>
    <published>2018-12-30T11:20:04.437Z</published>
    <updated>2018-12-30T11:20:04.438Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/b15ca614gy1fyonjtz2hlj20c80qdwen.jpg" alt=""><br>即将告别2018年，这个对于我来说，<strong>多灾多难</strong>的一年。<br>这一年发生了太多的事，每一年也都会发生很多事，但从来没有哪一年能够像2018年这样让人印象深刻。<br><strong>考研结束。</strong><br><strong>毕业。</strong><br><strong>工作。</strong><br><strong>最悲痛的莫过于最亲的人去世。</strong><br>事业也刚刚起步，爱情失去了方向。<br>真是让人印象深刻的一年。<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/b15ca614gy1fyonjtz2hlj20c80qdwen.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;即将告别2018年，这个对于我来说，&lt;strong&gt;多灾多难&lt;/strong&gt;的一年。&lt;br&gt;这一年发生了太多的事，每一年也都会发生很多事，但从来没有哪一年能够像2018年这样让人印象深刻。&lt;br&gt;&lt;strong&gt;考研结束。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;毕业。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;工作。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;最悲痛的莫过于最亲的人去世。&lt;/strong&gt;&lt;br&gt;事业也刚刚起步，爱情失去了方向。&lt;br&gt;真是让人印象深刻的一年。&lt;br&gt;
    
    </summary>
    
      <category term="生活" scheme="http://blog.booml.cn/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="感悟" scheme="http://blog.booml.cn/tags/%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>matrix</title>
    <link href="http://blog.booml.cn/2018/03/28/matrix/"/>
    <id>http://blog.booml.cn/2018/03/28/matrix/</id>
    <published>2018-03-27T16:00:00.000Z</published>
    <updated>2018-12-30T11:20:04.503Z</updated>
    
    <content type="html"><![CDATA[<h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><blockquote><p>写一个函数，输入数字 N,返会一个 N*N 的矩阵(环序)。</p></blockquote><a id="more"></a><h4 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// matrix(2)</span></span><br><span class="line"><span class="comment">//      [[1, 2],</span></span><br><span class="line"><span class="comment">//       [3, 4]]</span></span><br><span class="line"><span class="comment">// matrix(3)</span></span><br><span class="line"><span class="comment">//      [[1, 2, 3],</span></span><br><span class="line"><span class="comment">//       [8, 9, 4],</span></span><br><span class="line"><span class="comment">//       [7, 6, 5]]</span></span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matrix</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> results = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    results.push([]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> startColumn = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> endColumn = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> startRow = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> endRow = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (startColumn &lt;= endColumn &amp;&amp; startRow &lt;= endRow) &#123;</span><br><span class="line">    <span class="comment">//顶列开头到结尾</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = startColumn; i &lt;= endColumn; i++) &#123;</span><br><span class="line">      results[startRow][i] = counter;</span><br><span class="line">      counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    startRow++;</span><br><span class="line">    <span class="comment">//最右列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = startRow; i &lt;= endRow; i++) &#123;</span><br><span class="line">      results[i][endColumn] = counter;</span><br><span class="line">      counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    endColumn--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 底部行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = endColumn; i &gt;= startColumn; i--) &#123;</span><br><span class="line">      results[endRow][i] = counter;</span><br><span class="line">      counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    endRow--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start 列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = endRow; i &gt;= startRow; i--) &#123;</span><br><span class="line">      results[i][startColumn] = counter;</span><br><span class="line">      counter++;</span><br><span class="line">    &#125;</span><br><span class="line">    startColumn++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> matrix = <span class="built_in">require</span>(<span class="string">'./index'</span>);</span><br><span class="line"></span><br><span class="line">test(<span class="string">'matrix 函数已定义'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="keyword">typeof</span> matrix).toEqual(<span class="string">'function'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(<span class="string">'matrix produces a 2x2 array'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> m = matrix(<span class="number">2</span>);</span><br><span class="line">  expect(m.length).toEqual(<span class="number">2</span>);</span><br><span class="line">  expect(m[<span class="number">0</span>]).toEqual([<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line">  expect(m[<span class="number">1</span>]).toEqual([<span class="number">4</span>, <span class="number">3</span>]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(<span class="string">'matrix produces a 3x3 array'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> m = matrix(<span class="number">3</span>);</span><br><span class="line">  expect(m.length).toEqual(<span class="number">3</span>);</span><br><span class="line">  expect(m[<span class="number">0</span>]).toEqual([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">  expect(m[<span class="number">1</span>]).toEqual([<span class="number">8</span>, <span class="number">9</span>, <span class="number">4</span>]);</span><br><span class="line">  expect(m[<span class="number">2</span>]).toEqual([<span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(<span class="string">'matrix produces a 4x4 array'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> m = matrix(<span class="number">4</span>);</span><br><span class="line">  expect(m.length).toEqual(<span class="number">4</span>);</span><br><span class="line">  expect(m[<span class="number">0</span>]).toEqual([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line">  expect(m[<span class="number">1</span>]).toEqual([<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">5</span>]);</span><br><span class="line">  expect(m[<span class="number">2</span>]).toEqual([<span class="number">11</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">6</span>]);</span><br><span class="line">  expect(m[<span class="number">3</span>]).toEqual([<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;矩阵&quot;&gt;&lt;a href=&quot;#矩阵&quot; class=&quot;headerlink&quot; title=&quot;矩阵&quot;&gt;&lt;/a&gt;矩阵&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;写一个函数，输入数字 N,返会一个 N*N 的矩阵(环序)。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习" scheme="http://blog.booml.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JS" scheme="http://blog.booml.cn/tags/JS/"/>
    
      <category term="编程" scheme="http://blog.booml.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Interview" scheme="http://blog.booml.cn/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>reversint</title>
    <link href="http://blog.booml.cn/2018/03/19/reversInt/"/>
    <id>http://blog.booml.cn/2018/03/19/reversInt/</id>
    <published>2018-03-18T16:00:00.000Z</published>
    <updated>2018-12-30T11:20:04.521Z</updated>
    
    <content type="html"><![CDATA[<h3 id="整数反转-reversint"><a href="#整数反转-reversint" class="headerlink" title="整数反转(reversint)"></a>整数反转(reversint)</h3><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><blockquote><p>给你一个带符号的整数，返回这些数值的倒序</p></blockquote><blockquote><p>//例如</p></blockquote><blockquote><p>// reverseint(1243) === 3421</p></blockquote><a id="more"></a><blockquote><p>// reverseint(123) === 321</p></blockquote><blockquote><p>// reverseint(-12) === -21</p></blockquote><blockquote><p>// reverseint(-10) === -1</p></blockquote><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseint</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> reversed = n</span><br><span class="line">    .toString()</span><br><span class="line">    .split(<span class="string">''</span>)</span><br><span class="line">    .reverse()</span><br><span class="line">    .join(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(reversed) * <span class="built_in">Math</span>.sign(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverseint</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (n =</span><br><span class="line">    <span class="built_in">Math</span>.abs(n)</span><br><span class="line">      .toString()</span><br><span class="line">      .split(<span class="string">''</span>)</span><br><span class="line">      .reverse()</span><br><span class="line">      .join(<span class="string">''</span>) * <span class="built_in">Math</span>.sign(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;整数反转-reversint&quot;&gt;&lt;a href=&quot;#整数反转-reversint&quot; class=&quot;headerlink&quot; title=&quot;整数反转(reversint)&quot;&gt;&lt;/a&gt;整数反转(reversint)&lt;/h3&gt;&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;给你一个带符号的整数，返回这些数值的倒序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;//例如&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;// reverseint(1243) === 3421&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习" scheme="http://blog.booml.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JS" scheme="http://blog.booml.cn/tags/JS/"/>
    
      <category term="编程" scheme="http://blog.booml.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Interview" scheme="http://blog.booml.cn/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>Git 仓库合并（实例）</title>
    <link href="http://blog.booml.cn/2018/03/05/git-progress/"/>
    <id>http://blog.booml.cn/2018/03/05/git-progress/</id>
    <published>2018-03-04T16:00:00.000Z</published>
    <updated>2018-12-30T11:20:04.477Z</updated>
    
    <content type="html"><![CDATA[<p>最近想着整理一下 github 上一些零散的代码到同一个库中，问题是如何合并两个仓库并且保留每个文件的提交记录？如果只是两个目录并为一个，不需保留每个库的提交的记录，你只要在本地 A 仓库中 clone B 再提交就行，而本文所做的就是实践这个过程，参考的博客在文末。</p><a id="more"></a><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><ul><li>合并两个库/提交记录</li></ul><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><ul><li>本地环境 Windows os ,所有均在命令 git bash 中操作</li><li>远程仓库 A,如图左，远程仓库 B,如图右。</li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><img src="https://i.imgur.com/NWbZygn.png" alt="enter description here"></td><td><img src="https://i.imgur.com/FidxLZc.png" alt="enter description here"></td></tr></tbody></table><h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><ul><li>clone 到本地<br><code>git clone https://github.com/lmislm/Code_Repository.git</code></li><li><p><a href="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8" target="_blank" rel="noopener">添加远程仓库</a></p><ul><li><p><code>cd Code_Repository/</code></p></li><li><p><code>git remote add -f CSS_Ex git://github.com/lmislm/CSS_Ex.git</code></p><ul><li>添加一个新的远程仓库，指定一个简单的名字，以便将来引用，运行 <code>git remote add [shortname] [url]：</code></li></ul></li></ul><ul><li><p><code>git merge --strategy ours --no-commit CSS_Ex/master</code> + 可能报错<code>fatal: refusing to merge unrelated histories</code>忽略就行。 + <a href="https://git-scm.com/docs/merge-strategies#merge-strategies-ours" target="_blank" rel="noopener"><strong>ours</strong></a> 选项强制冲突由‘our’版本自动解决，即：来自其他分支树不会影响到我们这边映射到合并的结果。 + &gt; 即忽略冲突只保留<strong>Code_Repository</strong>文件树并且把 <strong>CSS_Ex</strong>的历史记录合并进来。</p></li><li><p><code>git remote -v</code> + 此命令将全部列出远程仓库。检查一下是否存在</p></li><li><p><code>git read-tree --prefix=css/ -u CSS_Ex/master</code> + <code>--prefix=css/</code>：这里 Code_Repository/目录下有 css/子目录 + &gt; –prefix 用于指定文件树读取后保存的路径，相对于当前路径并且一定要追加 /<br>–no-commit 的原因，<a href="https://segmentfault.com/a/1190000000678808" target="_blank" rel="noopener">该选项会在合并解析完成后中断，停留在最后的提交步骤之前。</a></p><ul><li><code>git read-tree --prefix=css/ -u CSS_Ex/master</code> + &gt; -u 是说在读取后更新 index，使得 working tree 与 index 保持同步 + <code>git commit -m &quot;finish,迁移CSS_Ex到了Code_Repository/css/下&quot;</code> + <code>git add .</code> + <code>git commit -m &quot;迁移完成&quot;</code> + <code>git push -u origin master</code></li></ul></li></ul></li></ul><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><table><thead><tr><th></th></tr></thead><tbody><tr><td><img src="https://i.imgur.com/QNW1boS.png" alt="enter description here"></td></tr></tbody></table><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><ul><li>在操作完成之后确实实现了合并到同一个仓库，但是<strong>并没有预期的结果</strong>，没有完美的合并提交记录。多次操作之后，将一些零散的东西合并到了同一个仓库。但是原来的仓库还是存在的。如果将原来零散的仓库删除。可以看到结果中，<code>a year ago</code>，历史提交记录确实存在，但是其他<code>flex_Ex</code>显示的却是在进行这个合并操作时提交的时间。</li></ul><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://segmentfault.com/a/1190000000678808" target="_blank" rel="noopener">如何用 Git 合并两个库（合并历史记录，解决冲突／改写路径）</a><br><a href="https://mlichtenberg.wordpress.com/2015/08/28/merging-git-repositories-and-preserving-history/" target="_blank" rel="noopener">Merging Git Repositories and Preserving History</a><br><a href="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8" target="_blank" rel="noopener"> Git 基础 - 远程仓库的使用</a><br><a href="https://git-scm.com/docs/merge-strategies#merge-strategies-ours" target="_blank" rel="noopener">MERGE STRATEGIES​ - ours</a><br><a href="https://git-scm.com/docs/git-read-tree" target="_blank" rel="noopener">git read-tree</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近想着整理一下 github 上一些零散的代码到同一个库中，问题是如何合并两个仓库并且保留每个文件的提交记录？如果只是两个目录并为一个，不需保留每个库的提交的记录，你只要在本地 A 仓库中 clone B 再提交就行，而本文所做的就是实践这个过程，参考的博客在文末。&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://blog.booml.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="git" scheme="http://blog.booml.cn/tags/git/"/>
    
      <category term="工具" scheme="http://blog.booml.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>undefined behavior in c</title>
    <link href="http://blog.booml.cn/2018/01/06/undefined%20behavior%20in%20c/"/>
    <id>http://blog.booml.cn/2018/01/06/undefined behavior in c/</id>
    <published>2018-01-06T13:41:18.000Z</published>
    <updated>2018-12-30T11:20:04.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="undefined-behavior（未定义行为）"><a href="#undefined-behavior（未定义行为）" class="headerlink" title="undefined behavior（未定义行为）"></a>undefined behavior（未定义行为）</h2><ul><li>思考一下下面这段代码的输出会是什么（答案在后面）？</li><li>这段代码运行过程是怎样？</li></ul><a id="more"></a><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQ(y) (y*y)  <span class="comment">//define 1</span></span></span><br><span class="line"><span class="comment">//#define SQ(y) ((y)*(y))   //define 2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span>(i &lt;= <span class="number">5</span>)&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%-2d"</span>,SQ(i++));</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*-只试了两种编译器</span></span><br><span class="line"><span class="comment"> *所用编译器：gcc</span></span><br><span class="line"><span class="comment"> *       用define  1 : 结果1  9  15</span></span><br><span class="line"><span class="comment"> *       用define 2 ：结果1  9  15</span></span><br><span class="line"><span class="comment"> *其他编辑器：</span></span><br><span class="line"><span class="comment"> *      用define  1 : 结果2  12  30</span></span><br><span class="line"><span class="comment"> *      用define  2: 结果1  9  15</span></span><br><span class="line"><span class="comment"> *      。。。。。</span></span><br></pre></td></tr></table></figure><h3 id="问题：为什么得到的结果不一样？"><a href="#问题：为什么得到的结果不一样？" class="headerlink" title="问题：为什么得到的结果不一样？"></a>问题：为什么得到的结果不一样？</h3><ul><li>看上面的对比，是因为编辑器的原因导致的??</li><li>一开始某本书上的答案是 2 12 30 ，我很纳闷，开头第一个数居然是 2，于是一番折腾查阅了一下别人的看法。</li></ul><h3 id="我认为的原因是：undefined-behavior"><a href="#我认为的原因是：undefined-behavior" class="headerlink" title="我认为的原因是：undefined behavior"></a>我认为的原因是：undefined behavior</h3><ul><li>什么是：undefined behavior（未定义行为）呢？如下。<blockquote><p>在计算机程序设计中，未定义行为（英语：undefined behavior) 是指行为不可预测的计算机代码。这是一些编程语言的一个特点，最有名的是在 C 语言中。在这些语言中，为了简化标准，并给予实现一定的灵活性，标准特别地规定某些操作的结果是未定义的，这意味着程序员不能预测会发生什么事。……. 因此，这种未定义行为一般应被视为 bug。<br>—来源：<a href="https://zh.wikipedia.org/wiki/%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA" target="_blank" rel="noopener">中文维基百科</a></p></blockquote></li></ul><h3 id="还有哪些-undefined-behavior（未定义行为）"><a href="#还有哪些-undefined-behavior（未定义行为）" class="headerlink" title="还有哪些 undefined behavior（未定义行为）"></a>还有哪些 undefined behavior（未定义行为）</h3><blockquote><p>偷懒：)。此处省略一些例子，因为 wiki 上都有一些典型例子。中文访问不了的话，英文在这，<a href="https://en.wikipedia.org/wiki/Undefined_behavior" target="_blank" rel="noopener">点我</a>。</p></blockquote><h2 id="如何解释这段代码"><a href="#如何解释这段代码" class="headerlink" title="如何解释这段代码"></a>如何解释这段代码</h2><ul><li>输出 1 9 15<br>++ 其计算过程可能为：<br><strong>第一次循环时</strong>，i=1，i++=2，1 _ 2 = 2， 再 i++=3<br><strong>第二次循环时</strong>，i=3，i++=4，3 _ 4 = 12，再 i++=5<br><strong>第三次循环时</strong>，i=5，i++=5, 5 * 6 = 30，再 i++=6<br>//进入 i&lt;=5 判断,值为假，退出循环</li></ul><hr><ul><li>输出 2 12 30<br>++ 其计算过程可能为：<br><strong>第一次循环时</strong>，首先 i=1, 1 _ 1 = 1，i++=2，再 i++=3<br><strong>第二次循环时</strong>，首先 i=3, 3 _ 3 = 9，i++=4，再 i++=5<br><strong>第三次循环时</strong>，首先 i=5, 5 * 5 = 25, i++=6，再 i++=7<br>// i=7，所以退出循环。<blockquote><p>首先 i++是先运算，后加。对于 SQ(i++)来说，其实质是((i++)*(i++))。在后加运算符是在整个运算完成之后，才进行加 1 操作的。</p></blockquote></li></ul><p><em>多问和讨论总是有好处的，继续保持：）</em><br>参考：<br>[1]<a href="https://zhidao.baidu.com/question/561702258825816084.html" target="_blank" rel="noopener">c语言的代参宏定义，#define sq(y) ((y)*(y))….输出应该是2 12 30才对啊？？</a>[2]<a href="https://www.zhihu.com/question/36940781/answer/69683475" target="_blank" rel="noopener">int i=5 ；printf(“%d”,i++,++i)；为什么输出 6?</a></p><p>[3]<a href="http://www.cnblogs.com/yezhenhan/archive/2011/11/05/2236973.html" target="_blank" rel="noopener">c语言中define的用法</a><br>进阶（可不看）：<br><a href="https://wenku.baidu.com/view/2bd97e6bdd36a32d737581b4.html" target="_blank" rel="noopener">关于宏定义的 ppt</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;undefined-behavior（未定义行为）&quot;&gt;&lt;a href=&quot;#undefined-behavior（未定义行为）&quot; class=&quot;headerlink&quot; title=&quot;undefined behavior（未定义行为）&quot;&gt;&lt;/a&gt;undefined behavior（未定义行为）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;思考一下下面这段代码的输出会是什么（答案在后面）？&lt;/li&gt;
&lt;li&gt;这段代码运行过程是怎样？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习" scheme="http://blog.booml.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="编程" scheme="http://blog.booml.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="c" scheme="http://blog.booml.cn/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>shell的正则表达式</title>
    <link href="http://blog.booml.cn/2017/07/20/shell%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://blog.booml.cn/2017/07/20/shell正则表达式/</id>
    <published>2017-07-19T16:00:00.000Z</published>
    <updated>2018-12-30T11:20:04.535Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><ol><li>正则表达式用于描述字符排列和匹配模式的一种语法规则。—-用来筛选数据</li><li>正则表达式与通配符的区别 1.正则表达式–匹配“文件”符合条件的字符串–&gt;&gt;包含匹配 2.通配符—–匹配符合条件的“文件”名——–&gt;&gt;完全匹配 3.为什么存在，通配符、正则表达式？<a id="more"></a><ul><li>ls、find、cp（操作文件的一些命令）不支持正则表达式，只能用通配符。</li><li>grep、awk、sed（操作字符串的一些命令）支持正则表达式。</li><li>为什么所有的不都支持正则表达式？</li></ul></li><li>正则表达式<ol><li>基础正则</li></ol></li></ol><table><thead><tr><th>元<strong>字</strong>符</th><th>作用</th></tr></thead><tbody><tr><td>*</td><td>前一个字符匹配<strong>0 次</strong>或任意多次</td></tr><tr><td><strong>.</strong></td><td>前一个字符匹配<strong>0 次</strong>或任意多次</td></tr><tr><td><strong>^</strong></td><td>匹配行首，例：^he 匹配以 he 开头的行</td></tr><tr><td><strong>$</strong></td><td>匹配行尾，例：he$匹配以 he 为结尾的字符串</td></tr><tr><td><strong>[ ]</strong></td><td>匹配括号中指定的任意一个字符，<strong>只匹配一个</strong> 例：[a-z]匹配 a-z 中的任意一个字符，[0-9][a-z]表示“连续匹配”</td></tr><tr><td><strong>[^]</strong></td><td>匹配除中括号字符外任意一个字符，例：^[0-9]匹配任意一位非数字的字符</td></tr><tr><td>\</td><td>转义符，取消特殊字符的含义</td></tr><tr><td>\ { n\ }</td><td>表示前面字符<strong>恰好</strong>出现 n 次</td></tr><tr><td>\ { n,\ }</td><td>表示前面字符出现<strong>不小于</strong>n 次</td></tr><tr><td>\ {n,m\ }</td><td>表示其前面字符<strong>至少</strong>出现 n 次</td></tr></tbody></table><ol><li>扩展正则</li></ol><hr><h2 id="正则表达式（基础正则）"><a href="#正则表达式（基础正则）" class="headerlink" title="正则表达式（基础正则）"></a><strong>正则表达式（基础正则）</strong></h2><h3 id="“-“"><a href="#“-“" class="headerlink" title="“ * “"></a>“ * “</h3><ol><li>“<code>*</code>“星号——–不同于通配符中的匹配所有内容。<ul><li>前一个字符匹配<strong>0 次</strong>，或者任意多次。<ul><li><code>a*</code> - - 匹配<strong>所有内容</strong>，包括<strong>空白行</strong>。</li><li><code>aa*</code> - - 匹配至少包含有一个 a 的行。</li><li><code>aaa*</code> - -匹配至少包含两个连续的 a 的字符串。</li></ul></li></ul></li></ol><h3 id="“-“-1"><a href="#“-“-1" class="headerlink" title="“ . “"></a>“ . “</h3><ol><li>“<code>.</code>“——–和通配符中”?”类似。<ul><li>匹配<strong>除了换行符</strong>外任意字符<ul><li><code>s..d</code> - - 匹配之间两个字符的单词。</li><li><code>s.*d</code> - - 匹配之间的任意字符。</li><li><code>.*</code> - - 匹配所有内容。</li></ul></li></ul></li></ol><h3 id="“-“、”-“、”-“、”-“"><a href="#“-“、”-“、”-“、”-“" class="headerlink" title="“ ^ “、” $ “、” [] “、” [ ^ ] “"></a>“ ^ “、” $ “、” [] “、” [ ^ ] “</h3><ol><li>“<code>^</code>“、”<code>$</code>“、”<code>[]</code>“、”<code>[^]</code>“<ul><li><code>^</code> - - 匹配行首。</li><li><code>$</code> - - 匹配行尾。</li><li><code>[]</code> - - 匹配括号中指定字符串中的任意字符，<strong>只匹配一个</strong>。</li><li><code>[^]</code> - - 匹配除中括号的字符以外的任意一个字符。</li></ul></li></ol><h3 id="n-、-n-、-n-m"><a href="#n-、-n-、-n-m" class="headerlink" title="{n\ }、{n,\ }、{n,m\ }"></a>{n\ }、{n,\ }、{n,m\ }</h3><ol><li>“<code>\{n\}</code>”、”<code>\{n,\}</code>“、”<code>\{n,m\}</code>“<ul><li><code>\{n\}</code> - - 例：<code>a\{3\}</code> 匹配 a 字母连续出现三次的字符串（连续四次以上也会被匹配到，所以在该匹配首尾加定界符能精确匹配到）</li><li><code>\{n,\}</code> - - 例：<code>\{n,\}</code> 前面字符出现不少于 n 次</li><li><code>\{n,m\}</code> - - 例：<code>sa\{1,3}i</code> 匹配在字母 s 和字母 i 之间最少一个 a，最多三个 a</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;正则表达式用于描述字符排列和匹配模式的一种语法规则。—-用来筛选数据&lt;/li&gt;
&lt;li&gt;正则表达式与通配符的区别 1.正则表达式–匹配“文件”符合条件的字符串–&amp;gt;&amp;gt;包含匹配 2.通配符—–匹配符合条件的“文件”名——–&amp;gt;&amp;gt;完全匹配 3.为什么存在，通配符、正则表达式？
    
    </summary>
    
      <category term="学习" scheme="http://blog.booml.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="编程" scheme="http://blog.booml.cn/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="shell" scheme="http://blog.booml.cn/tags/shell/"/>
    
  </entry>
  
</feed>
