<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LMISLMのBlog</title>
  
  <subtitle>不积小流，无以成江海。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lmislm.com/"/>
  <updated>2019-07-22T15:40:40.206Z</updated>
  <id>http://lmislm.com/</id>
  
  <author>
    <name>lmislm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>day190-MyVue-完善Complier、Watcher</title>
    <link href="http://lmislm.com/2019/07/22/2019-07-22/"/>
    <id>http://lmislm.com/2019/07/22/2019-07-22/</id>
    <published>2019-07-21T16:00:00.000Z</published>
    <updated>2019-07-22T15:40:40.206Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>提取模板中的变量</li><li>完善<code>Watcher</code>和<code>Observer</code>之间的桥梁，Dep中添加target</li></ol><a id="more"></a><h2 id="Complier"><a href="#Complier" class="headerlink" title="Complier"></a>Complier</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Watcher <span class="keyword">from</span> <span class="string">"./Watcher"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> REG = <span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span> <span class="comment">// 取胡须括号中的内容</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complier</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(el, vm) &#123;</span><br><span class="line">    <span class="keyword">this</span>.el = <span class="built_in">document</span>.querySelector(el) <span class="comment">// 高效的原生DOM选择器，用着方便（比getElementsBy系列）</span></span><br><span class="line">    <span class="keyword">this</span>.vm = vm</span><br><span class="line">    <span class="keyword">this</span>.frag = <span class="keyword">this</span>._createFragment()</span><br><span class="line">    <span class="keyword">this</span>.el.appendChild(<span class="keyword">this</span>.frag) <span class="comment">// 整个element添加到这里，最后会清空</span></span><br><span class="line">  &#125;</span><br><span class="line">  _createFragment () &#123;</span><br><span class="line">    <span class="keyword">var</span> frag = <span class="built_in">document</span>.createDocumentFragment() <span class="comment">// 文档碎片节点，比createElement多次添加到document.body效率高</span></span><br><span class="line">    <span class="keyword">var</span> child</span><br><span class="line">    <span class="keyword">while</span>(child = <span class="keyword">this</span>.el.firstChild) &#123;</span><br><span class="line">     <span class="keyword">this</span>._compile(child) <span class="comment">// 接收每个node的子节点</span></span><br><span class="line">     frag.appendChild(child) <span class="comment">// 编译完之后，添加到碎片;appendChild做移动步骤；</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> frag</span><br><span class="line">  &#125;</span><br><span class="line">  _compile(node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.nodeType === <span class="number">1</span>) &#123; <span class="comment">// 元素</span></span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.nodeType === <span class="number">3</span>) &#123; <span class="comment">// 文本节点</span></span><br><span class="line">      <span class="keyword">if</span> (REG.test(node.nodeValue)) &#123;</span><br><span class="line">        <span class="keyword">var</span> name = <span class="built_in">RegExp</span>.$<span class="number">1</span> <span class="comment">// 拿到第一个大括号里的</span></span><br><span class="line">        name = name.trim() <span class="comment">// 得到属性名字</span></span><br><span class="line">        <span class="keyword">new</span> Watcher(node, name, <span class="keyword">this</span>.vm) <span class="comment">// 观察得到的值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Complier</span><br></pre></td></tr></table></figure><h2 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Dep <span class="keyword">from</span> <span class="string">"./Dep"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订阅的人附到Dep</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (node, name, vm) &#123;</span><br><span class="line">    <span class="keyword">this</span>.node = node</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.vm = vm</span><br><span class="line">    Dep.target = <span class="keyword">this</span> <span class="comment">// 注入，给Observer提供this，否则Observer不会主动注入listen(Dep.target)</span></span><br><span class="line">    <span class="keyword">this</span>._update()</span><br><span class="line">    Dep.target = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  _update () &#123;</span><br><span class="line">    <span class="keyword">this</span>.node.nodeValue = <span class="keyword">this</span>.vm[name]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Watcher</span><br></pre></td></tr></table></figure><h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><p>添加<code>target</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发布订阅事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="comment">// static target = null // 可能不被识别</span></span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.listenerList = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * subs 传入Watcher,知道谁在监听</span></span><br><span class="line"><span class="comment">   * @param &#123;*&#125; subs </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  sub (subs) &#123;</span><br><span class="line">    <span class="keyword">this</span>.listenerList.push(subs)</span><br><span class="line">  &#125;</span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.listenerList.length; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>.listenerList[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Dep.prototype.target = <span class="literal">null</span> <span class="comment">// 兼容性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Dep</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;提取模板中的变量&lt;/li&gt;
&lt;li&gt;完善&lt;code&gt;Watcher&lt;/code&gt;和&lt;code&gt;Observer&lt;/code&gt;之间的桥梁，Dep中添加target&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day189-MyVue-完善Observer</title>
    <link href="http://lmislm.com/2019/07/21/2019-07-21/"/>
    <id>http://lmislm.com/2019/07/21/2019-07-21/</id>
    <published>2019-07-20T16:00:00.000Z</published>
    <updated>2019-07-22T15:35:24.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>从Vue.js中入手，先完善<code>new Obersver(this._data)</code></li></ol><a id="more"></a><h2 id="Obersver"><a href="#Obersver" class="headerlink" title="Obersver"></a>Obersver</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者，需要观察到的实例属性,通过set、get把数据发布者订阅者绑定在一起</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> Dep <span class="keyword">from</span> <span class="string">'./Dep'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (data) &#123;</span><br><span class="line">    <span class="keyword">this</span>.data = data</span><br><span class="line">    <span class="built_in">Object</span>.keys(<span class="keyword">this</span>.data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>._bind(data, key, data[key])</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  _bind(data, key, val) &#123;</span><br><span class="line">    <span class="keyword">var</span> myDep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="comment">// 逐个改掉</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">      <span class="keyword">get</span> () &#123;</span><br><span class="line">        <span class="keyword">if</span> (Dep.target) myDep.listen(Dep.target)</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span> (newVal) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val === newVal) <span class="keyword">return</span></span><br><span class="line">        val = newVal</span><br><span class="line">        myDep.notify()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Observer</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;从Vue.js中入手，先完善&lt;code&gt;new Obersver(this._data)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day188-MyVue-搭建基本架构</title>
    <link href="http://lmislm.com/2019/07/20/2019-07-20/"/>
    <id>http://lmislm.com/2019/07/20/2019-07-20/</id>
    <published>2019-07-19T16:00:00.000Z</published>
    <updated>2019-07-21T13:47:15.401Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>发布订阅模式</li><li>Vue基本架构，文件目录</li><li>架构细化，Dep.js、index.html、main.js、Watcher.js、Observer.js</li><li>vue.js-获取data等，构建入口文件</li></ol><h2 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleEvent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.listenerList = []</span><br><span class="line">  &#125;</span><br><span class="line">  listen (listener) &#123; <span class="comment">// 订阅 </span></span><br><span class="line">    <span class="keyword">this</span>.listenerList.push(listener)</span><br><span class="line">  &#125;</span><br><span class="line">  trigger () &#123; <span class="comment">// 发布</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.listenerList.length; i++) &#123;</span><br><span class="line">      <span class="comment">// this.listenerList[i].call(this)</span></span><br><span class="line">      <span class="keyword">this</span>.listenerList[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myEvent = <span class="keyword">new</span> SimpleEvent()</span><br><span class="line"></span><br><span class="line"><span class="comment">// myEvent.listen(function () &#123;</span></span><br><span class="line"><span class="comment">//   console.log('谁订阅了我')</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// myEvent.trigger()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> eventObj = &#123;</span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'订阅之后更新了'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myEvent.listen(eventObj)</span><br><span class="line">myEvent.trigger()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅之后更新了</span></span><br></pre></td></tr></table></figure><h2 id="Vue基本架构"><a href="#Vue基本架构" class="headerlink" title="Vue基本架构"></a>Vue基本架构</h2><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">MyVue</span><br><span class="line">|</span><br><span class="line">├─index.html # 页面</span><br><span class="line">├─main.js # new Vue 实例化vue</span><br><span class="line">├─vue.js # vue 入口文件</span><br><span class="line">├─Dep.js # 发布订阅</span><br><span class="line">├─Watcher.js # 订阅的事件，即Dep中listen(subs)的subs</span><br><span class="line">├─Comlier.js # 模板编译，处理html文件相关数据</span><br><span class="line">└─Observer.js # 观察者，set、get方法，绑定数据</span><br></pre></td></tr></table></figure><h2 id="架构细化"><a href="#架构细化" class="headerlink" title="架构细化"></a>架构细化</h2><p><strong>Dep.js</strong></p><details><br><summary>展开代码</summary><br><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.listenerList = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * subs 传入Watcher,知道谁在监听</span></span><br><span class="line"><span class="comment">   * @param &#123;*&#125; subs </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  sub (subs) &#123;</span><br><span class="line">    <span class="keyword">this</span>.listenerList.push(subs)</span><br><span class="line">  &#125;</span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.listenerList.length; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>.listenerList[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Dep</span><br></pre></td></tr></table></figure><br><br></details><p><strong>index.html</strong></p><details><br><summary>展开代码</summary><br><br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"message"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  &#123;&#123;message&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./bundle.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br><br></details><p><strong>main.js</strong></p><details><br><summary>展开代码</summary><br><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> MyVue <span class="keyword">from</span> <span class="string">"./Vue"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> MyVue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'my binding vue'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br><br></details><p><strong>Watcher.js</strong></p><details><br><summary>展开代码</summary><br><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订阅的人附到Dep</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Watchers</span><br></pre></td></tr></table></figure><br><br></details><p><strong>Observer.js</strong></p><details><br><summary>展开代码</summary><br><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者，需要观察到的实例属性,通过set、get把数据发布者订阅者绑定在一起</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Observer</span><br></pre></td></tr></table></figure><br><br></details><h2 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h2><p>获取data等<br><strong>Vue.js</strong></p><details><br><summary>展开代码</summary><br><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Observer <span class="keyword">from</span> <span class="string">'./Observer'</span></span><br><span class="line"><span class="keyword">import</span> Complier <span class="keyword">from</span> <span class="string">'./Complier'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (options) &#123;</span><br><span class="line">    <span class="comment">// 拿到内部</span></span><br><span class="line">    <span class="keyword">this</span>.$options = options</span><br><span class="line">    <span class="keyword">this</span>.$el = <span class="keyword">this</span>.$options.el</span><br><span class="line">    <span class="keyword">this</span>._data = <span class="keyword">this</span>.$options.data</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绑定数据</span></span><br><span class="line">    <span class="keyword">new</span> Observer(<span class="keyword">this</span>._data)</span><br><span class="line">    <span class="comment">// 编译，挂载</span></span><br><span class="line">    <span class="keyword">new</span> Complier(<span class="keyword">this</span>.$el, <span class="keyword">this</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// data上每个属性都做转换</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(<span class="keyword">this</span>._data.forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>._proxy(key)</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 函数解决调繁琐调用Vue.$options.data.message</span></span><br><span class="line">  _proxy (key) &#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">      <span class="keyword">get</span> () &#123;</span><br><span class="line">        <span class="keyword">return</span> self.data[key]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span> (value) &#123;</span><br><span class="line">        self.data[key] = value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></table></figure><br><br></details>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;发布订阅模式&lt;/li&gt;
&lt;li&gt;Vue基本架构，文件目录&lt;/li&gt;
&lt;li&gt;架构细化，Dep.js、index.html、mai
      
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day187-diff-updateChildren示例</title>
    <link href="http://lmislm.com/2019/07/19/2019-07-19/"/>
    <id>http://lmislm.com/2019/07/19/2019-07-19/</id>
    <published>2019-07-18T16:00:00.000Z</published>
    <updated>2019-07-20T14:03:01.288Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li><code>updateChildren()</code>如何进行比较最终全部替换掉的。</li></ol><ul><li>例子：</li></ul><p>原有的oldCh的顺序是  <code>A、B、C、D、E、F、G</code></p><p>更新后成ch的顺序是   <code>F、D、A、H、E、C、B、G</code></p><a id="more"></a><h2 id="diff流程示例"><a href="#diff流程示例" class="headerlink" title="diff流程示例"></a>diff流程示例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">开始：patchVnode (oldVnode, newVnode))</span><br><span class="line"></span><br><span class="line">round1:(找到相同的)</span><br><span class="line">对比顺序：A-F -&gt; G-G，匹配成功，然后：</span><br><span class="line"><span class="comment">/** A-F（头头比较：不等） -&gt;  G-G（尾尾比较：相等尾部指针往前移动，不满足while条件，开始第二次循环比较） */</span></span><br><span class="line"></span><br><span class="line">对G进行patchVnode的操作，更新oldEndVnodeG和newEndVnodeG的elm</span><br><span class="line">指针移动，两个尾部指针向左移动，即oldEndIdx-- newEndIdx--</span><br><span class="line"></span><br><span class="line">round2:</span><br><span class="line">对比顺序：A-F -&gt; F-B -&gt; A-B -&gt; F-F，匹配成功，然后：</span><br><span class="line"><span class="comment">/** （头头比较：不等） -&gt; （尾尾比较：不等）-&gt;（头尾比较：不等）-&gt;（尾头比较：相等） */</span></span><br><span class="line"></span><br><span class="line">对F进行patchVnode的操作，更新oldEndVnodeF和newEndVnodeF的elm</span><br><span class="line">指针移动，移动指针，即oldEndIdx-- newStartIdx++</span><br><span class="line">找到oldStartVnode在dom中所在的位置A，然后在其前面插入更新过的F的elm</span><br><span class="line"></span><br><span class="line">round3:</span><br><span class="line">对比顺序：A-D -&gt; E-B -&gt; A-B -&gt; E-D，仍未成功，取D的key，在oldKeyToIdx中查找，找到对应的D，查找成功，然后：</span><br><span class="line"></span><br><span class="line">将D取出赋值到 vnodeToMove</span><br><span class="line">对D进行patchVnode的操作，更新vnodeToMoveD和newStartVnodeD的elm</span><br><span class="line">指针移动，移动指针，即newStartIdx++</span><br><span class="line">将oldCh中对应D的vnode置<span class="literal">undefined</span></span><br><span class="line">在dom中找到oldStartVnodeA的elm对应的节点，然后在其前面插入更新过的D的elm</span><br><span class="line"></span><br><span class="line">round4:</span><br><span class="line">对比顺序：A-A，对比成功，然后：</span><br><span class="line"></span><br><span class="line">对A进行patchVnode的操作，更新oldStartVnodeA和newStartVnodeA的elm</span><br><span class="line">指针移动，两个尾部指针向左移动，即oldStartIdx++ newStartIdx++</span><br><span class="line"></span><br><span class="line">round5:</span><br><span class="line">对比顺序：B-H -&gt; E-B -&gt; B-B ,对比成功，然后：</span><br><span class="line"></span><br><span class="line">对B进行patchVnode的操作，更新oldStartVnodeB和newStartVnodeB的elm</span><br><span class="line">指针移动，即oldStartIdx++ newEndIdx--</span><br><span class="line">在dom中找到oldEndVnodeE的elm的nextSibling节点（即G的elm），然后在其前面插入更新过的B的elm</span><br><span class="line"></span><br><span class="line">round6:</span><br><span class="line">对比顺序：C-H -&gt; E-C -&gt; C-C ,对比成功，然后(同round5)：</span><br><span class="line"></span><br><span class="line">对C进行patchVnode的操作，更新oldStartVnodeC和newStartVnodeC的elm</span><br><span class="line">指针移动，即oldStartIdx++ newEndIdx--</span><br><span class="line">在dom中找到oldEndVnodeE的elm的nextSibling节点（即刚刚插入的B的elm），然后在其前面插入更新过的C的elm</span><br><span class="line"></span><br><span class="line">round7:</span><br><span class="line">获取oldStartVnode失败（因为round3的步骤<span class="number">4</span>）,然后：</span><br><span class="line"></span><br><span class="line">指针移动，即oldStartIdx++</span><br><span class="line"></span><br><span class="line">round8:</span><br><span class="line">对比顺序：E-H、E-E,匹配成功，然后（同round1）：</span><br><span class="line"></span><br><span class="line">对E进行patchVnode的操作，更新oldEndVnodeE和newEndVnodeE的elm</span><br><span class="line">指针移动，两个尾部指针向左移动，即oldEndIdx-- newEndIdx--</span><br><span class="line"></span><br><span class="line">last</span><br><span class="line">round8之后oldCh提前发生了‘交叉’，退出循环。</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://lequ7.com/2019/06/16/richang/vue-yuan-ma-jie-xi-diff-guo-cheng-yi-tan-jiu-jing/" target="_blank" rel="noopener">VUE源码解析DIFF过程一探究竟</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;updateChildren()&lt;/code&gt;如何进行比较最终全部替换掉的。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;例子：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原有的oldCh的顺序是  &lt;code&gt;A、B、C、D、E、F、G&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;更新后成ch的顺序是   &lt;code&gt;F、D、A、H、E、C、B、G&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day186-具体的diff分析过程（vuejs）-笔记</title>
    <link href="http://lmislm.com/2019/07/18/2019-07-18/"/>
    <id>http://lmislm.com/2019/07/18/2019-07-18/</id>
    <published>2019-07-17T16:00:00.000Z</published>
    <updated>2019-07-19T15:33:17.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li><code>updateChildren()</code>代码</li></ol><p>代码相对较多，较繁琐，这里了解代码和key起的作用就可。<br><a id="more"></a></p><h2 id="代码-内部注释"><a href="#代码-内部注释" class="headerlink" title="代码 + 内部注释"></a>代码 + 内部注释</h2><p>patch过程中父节点相同，父节点文本内容相同，子节点不同updateChildren()的比较。</p><p>基本思路就是两个树进行新旧节点的比较。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">updateChildren (parentElm, oldCh, newCh) &#123;</span><br><span class="line">  <span class="keyword">let</span> oldStartIdx = <span class="number">0</span>, newStartIdx = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> newEndVnode = newCh[newEndIdx] </span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> oldKeyToIdx</span><br><span class="line">  <span class="keyword">let</span> idxInOld</span><br><span class="line">  <span class="keyword">let</span> elmToMove</span><br><span class="line">  <span class="keyword">let</span> before</span><br><span class="line">  <span class="comment">// 判断遍历是否结束</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="comment">// 1，不设置key</span></span><br><span class="line">    <span class="keyword">if</span> (oldStartVnode === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 2,都是两头指针相互向中间靠</span></span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndVnode === <span class="literal">null</span>) &#123;</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartVnode === <span class="literal">null</span>) &#123;</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newEndVnode === <span class="literal">null</span>) &#123;</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">      <span class="comment">// 3,递归调用，需要看清楚具体比较的东西是什么</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">      patchVnode(oldStartVnode, newEndVnode)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果碰到一样的节点，就深度遍历比较，走递归</span></span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">      patchVnode(oldEndVnode, newEndVnode)</span><br><span class="line"></span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123;</span><br><span class="line">      <span class="comment">// ？？？？</span></span><br><span class="line">      patchVnode(oldEndVnode, newEndVnode)</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 需要对dom进行移动</span></span><br><span class="line">      api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el))</span><br><span class="line">      </span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">      newEndVnode = newCh[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123;</span><br><span class="line">      patchVnode(oldEndVnode, newStartVnode)</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 需要对dom进行移动</span></span><br><span class="line">      api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el)</span><br><span class="line"></span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">      newStartVnode = newCh[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 设置key，除头尾两端比较外，加了一个oldKeyToIdx对象表，从中查找匹配的节点</span></span><br><span class="line">      <span class="keyword">if</span> (oldKeyToIdx === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="comment">// 有key时生成index表</span></span><br><span class="line">        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">      &#125;</span><br><span class="line">      idxInOld = oldKeyToIdx[newStartVnode.key]</span><br><span class="line">      <span class="keyword">if</span> (!idxInOld) &#123;</span><br><span class="line">        api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        elmToMove = oldCh[idxInOld]</span><br><span class="line">        <span class="keyword">if</span> (elmToMove.sel !== newStartVnode.sel) &#123;</span><br><span class="line">          api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          patchVnode(elmToMove, newStartVnode)</span><br><span class="line"></span><br><span class="line">          oldCh[idxInOld] = <span class="literal">null</span></span><br><span class="line">          api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el)</span><br><span class="line">        &#125;</span><br><span class="line">        newStartVnode = newCh[++newStartIdx]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">    before = newCh[newEndIdx + <span class="number">1</span>] === <span class="literal">null</span> ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].el</span><br><span class="line">    addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">    removeVnodess(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/aooy/blog/issues/2" target="_blank" rel="noopener">原文点此</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;updateChildren()&lt;/code&gt;代码&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;代码相对较多，较繁琐，这里了解代码和key起的作用就可。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day185-Diff过程（vuejs）-笔记</title>
    <link href="http://lmislm.com/2019/07/17/2019-07-17/"/>
    <id>http://lmislm.com/2019/07/17/2019-07-17/</id>
    <published>2019-07-16T16:00:00.000Z</published>
    <updated>2019-07-17T15:26:31.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>patch 函数概览。()</li><li>patchVnode 函数概览。<br>主要分为两个部分。每个函数中都会有代码并附上代码的行行解释。<a id="more"></a><h2 id="patch-函数概览"><a href="#patch-函数概览" class="headerlink" title="patch() 函数概览"></a><strong>patch()</strong> 函数概览</h2></li></ol><p>代码 + 解析</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * vuejs diff过程</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; oldVnode </span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; newVnode </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">oldVnode, newVnode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">if</span> (sameVnode(oldVnode, newVnode)) &#123;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    patchVnode(oldVnode, newVnode)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">const</span> oEl = oldVnode.el</span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">let</span> parentEle = api.parentNode(oEl)</span><br><span class="line">    <span class="comment">// 5</span></span><br><span class="line">    createEle(newVnode)</span><br><span class="line">    <span class="keyword">if</span> (parentEle !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 6</span></span><br><span class="line">      api.insertBefore(parentEle, newVnode.el, api.nextSibling(oEl))</span><br><span class="line">      api.removeChild(parentEle, oldVnode.el)</span><br><span class="line">      oldVnode = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 7</span></span><br><span class="line">  <span class="keyword">return</span> newVnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><ol><li>看这两个节点是否值得比较（比比是不是子节点有不一样的地方），比较两者<code>key</code>和<code>sel</code>是否完全相等。（<code>sel</code>：节点的选择器）<br>vuejs中virtual dom用的是snabbdom，snabbom定义的(Virtual Node属性)[<a href="https://github.com/snabbdom/snabbdom#sel--string]有sel、data、children、text、elm、key。这点和React用的库不一样。" target="_blank" rel="noopener">https://github.com/snabbdom/snabbdom#sel--string]有sel、data、children、text、elm、key。这点和React用的库不一样。</a></li><li>两个节点相互比较<br>比较的过程要分好几种情况，后面再记笔记啊。</li><li>进入了不需要比较两个节点的处理流程<br><code>oEl</code>表示节点的父节点。（取父节点做？？）</li><li><code>parentEle</code>是父节点的真是dom</li><li>给newVnode创建真实的节点。</li><li>插入新的节点，移除旧节点。（为啥还要特地移除Child，直接把二叉树的顶部根节点移除不就行了？）</li><li>返回newVnode对应的真实dom</li></ol><h2 id="patchVnode-函数概览"><a href="#patchVnode-函数概览" class="headerlink" title="patchVnode() 函数概览"></a><strong>patchVnode()</strong> 函数概览</h2><p>代码 + 解析</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 比较不同的节点patchVnode()</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; oldVnode </span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; newVnode </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span> (<span class="params">oldVnode, newVnode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> el = newVnode.el = oldVnode.el</span><br><span class="line">  <span class="keyword">let</span> i, oldCh = oldVnode.children, newCh = newVnode.children</span><br><span class="line">  <span class="comment">// 这里这个相等应该是深比较吧，完全相等就返回`false`？</span></span><br><span class="line">  <span class="comment">// 2.1</span></span><br><span class="line">  <span class="keyword">if</span> (oldVnode === newVnode) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 比较Virtual node中text是否相等？</span></span><br><span class="line">  <span class="comment">// 2.2</span></span><br><span class="line">  <span class="keyword">if</span> (oldVnode.text !== <span class="literal">null</span> &amp;&amp; newVnode.text !== <span class="literal">null</span> &amp;&amp; oldVnode.text !== newVnode.text) &#123;</span><br><span class="line">    <span class="comment">// 如果只是文本内容相等直接替换旧文本内容就行？</span></span><br><span class="line">    api.setTextContent(el, newVnode.text)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 2.3</span></span><br><span class="line">    updateEle(el, newVnode, oldVnode)</span><br><span class="line">    <span class="keyword">if</span> (oldCh &amp;&amp; newCh &amp;&amp; oldCh !== newCh) &#123;</span><br><span class="line">      <span class="comment">// 2.4</span></span><br><span class="line">      updateChildren(el, oldCh, newCh)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newCh) &#123;</span><br><span class="line">      <span class="comment">// 2.5</span></span><br><span class="line">      createEle(newVnode)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldCh) &#123;</span><br><span class="line">      <span class="comment">// 2.6</span></span><br><span class="line">      api.removeChildren(el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h3><blockquote><p>序号<strong>2</strong>中，什么是值得比较的节点（我理解的是，子节点是不是完全一样？）<br>比较相同节点<code>sameVnode(oldVnode, newVnode)</code></p></blockquote><p>2.1 比较引用是否一致，一致则认为没有变化。（引用？）</p><p>2.2 文本节点的比较，需要修改则调用<code>Node.textContent = newVnode.text</code>。</p><p>2.3 判断新旧节点是否存在子节点，新旧节点子节点是不是相等。</p><p>2.4 <code>updateChildren</code>函数，是diff核心。</p><p>2.5 只有新节点有子节点就调用<code>createEle(newVnode)</code>。在老dom节点上添加子节点。</p><p>2.6 只有旧节点有子节点，新节点为空。可以直接遵循新节点。直接删除老节点。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/aooy/blog/issues/2" target="_blank" rel="noopener">原文点此</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;patch 函数概览。()&lt;/li&gt;
&lt;li&gt;patchVnode 函数概览。&lt;br&gt;主要分为两个部分。每个函数中都会有代码并附上代码的行行解释。
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day184-Diff Algorithm（译）</title>
    <link href="http://lmislm.com/2019/07/16/2019-07-16/"/>
    <id>http://lmislm.com/2019/07/16/2019-07-16/</id>
    <published>2019-07-15T16:00:00.000Z</published>
    <updated>2019-07-17T15:17:50.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>本文为一篇经典的Diff算法文章的译文，原文写的是React的Diff算法。<br>这里只是摘取了后半部分的内容，并没有翻译开篇部分。</p><p><a href="https://calendar.perfplanet.com/2013/diff/" target="_blank" rel="noopener">原文点此</a></p><a id="more"></a><h2 id="level-by-level"><a href="#level-by-level" class="headerlink" title="level by level"></a>level by level</h2><p>找出两个任意二叉树的最小变化是一个O(n^3)问题。但是React用简单且强大的启发式来找一个O(n)的最优解。</p><p>React尝试逐层地去求解二叉树。这种方式大幅地减少了树的复杂度且在web应用中组件移动到不同层级时产生极少的（性能）损耗。通常这种移动都是横向的子节点间移动。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>假设有在一个组件中某次迭代渲染5个组件之后要在List的中间位置插入一个新的组件。这里很难去根据这个信息去知道如何映射在两个list组件之间。（This would be really hard with just this information to know how to do the mapping between the two lists of components.）</p><p>默认情况下，React会将前一个list中的第一个组件和下一个list中的第一个组件相关联,等等。你可以加一个<code>key</code>属性来帮助React找出映射。在实践中，这样做通常能很容易找到唯一的key就存在子节点之间。</p><h2 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h2><p>一个React应用通常是由很多用户定义的组件组成并最终转换成一棵主要由<code>div</code>组成的树。其他的信息会被diff算法考虑在内，因为React只匹配具有相同类的组件。<br>例如，如果一个<code>&lt;Header&gt;</code>被一个<code>&lt;ExampleBlock&gt;</code>替代，React会移除header创建一个example block。不需要我们花宝贵的时间去尝试匹配两个组件而且是不太可能有任何的相似之处。</p><h2 id="Event-Delegation（事件委托）"><a href="#Event-Delegation（事件委托）" class="headerlink" title="Event Delegation（事件委托）"></a>Event Delegation（事件委托）</h2><p>添加事件监听到DOM节点上非常的慢而且还费内存。相反的是，React采用一种非常流行的技术叫“event delegation”。React则更进一步重新实现符合W3C标准的事件系统。这个意味着Internet Explorer 8事件处理的问题已经成为过去，事件名称在所有的浏览器中都是一致的。</p><p>让我解释下它是怎么实现的。一个单独的事件监听被添加到document的root中。当该事件被触发时，浏览器给我们提供目标DOM节点。为了通过DOM层级分发事件（propagate the even），React不会再virtual DOM层级上进行迭代。</p><p>相反，我们用的每个React组件实际上都有唯一的id来编码层级（encodes the hierarchy）。我们可以用简单的字符操作来获取所有父组件（原文为：parents）的id。通过将事件监听存储在hash map中，<br>我们发现性能要优于添加到virtual DOM。这里有个例子来解释当一个事件通过virtual DOM被调度（dispatched）会发生什么。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dispatchEven('click', 'a.b.c', event)</span></span><br><span class="line">clickCaptureListeners[<span class="string">'a'</span>](event);</span><br><span class="line">clickCaptureListeners[<span class="string">'a.b'</span>](event);</span><br><span class="line">clickCaptureListeners[<span class="string">'a.b.c'</span>](event);</span><br><span class="line">clickBubbleListeners[<span class="string">'a.b.c'</span>](event);</span><br><span class="line">clickBubbleListeners[<span class="string">'a.b'</span>](event);</span><br><span class="line">clickBubbleListeners[<span class="string">'a'</span>](event);</span><br></pre></td></tr></table></figure></p><p>浏览器创建一个新的事件对象给每个事件和每个监听者（listener）。这个性质的好处在于你可以保留事件对象的引用甚至可以修改它。然而，这意味着要进行大量的内存分配。React在启动时会分配这些对象一个池。<br>需要事件对象时，它会从池子里去取。这极大地减少了垃圾收集。</p><h2 id="Rendering"><a href="#Rendering" class="headerlink" title="Rendering"></a>Rendering</h2><h3 id="Batching（批量）"><a href="#Batching（批量）" class="headerlink" title="Batching（批量）"></a>Batching（批量）</h3><p>当你调用在组件内的<code>setState</code>时，React会标记它为脏值。在事件循环的末尾，React会查看组件所有的脏值并重新渲染它们。<br>批量表示在一次事件循环期间，DOM只有一次的更新。这个性质是建立高性能应用的关键，但用常规的JavaScript非常难写这个。在React应用中，默认有这个性质。</p><h3 id="Sub-tree-Rendering"><a href="#Sub-tree-Rendering" class="headerlink" title="Sub-tree Rendering"></a>Sub-tree Rendering</h3><p>当<code>setState</code>被调用时，组件给其子节点重新建立virtual DOM。如果你在根元素调用<code>setState</code>，整个React应用就会重新渲染。<br>所有的组件，即使它们没有改变，都会被他们的<code>render</code>方法调用。这可能听起来很可怕且在实际情况中低效，这很好用，因为我们没有接触到真实DOM。</p><p>首先，我们谈谈关于用户界面的展示。因为屏幕空间的限制，你可能通常一次性地展示成百上千的节点。JavaScript在整个可管理的界面上的业务逻辑已经够快了（JavaScript has gotten fast enough business logic for the whole interface is manageable.）另一个重要的点是写React代码时，你通常不会在根节点每次变化时都调用setState。你会在收到变动的事件或上层几个组件时在组件上调用。很少会直接到顶部。这表明改动会落实到用户的交互。</p><h3 id="Selective-Sub-tree-Rendering"><a href="#Selective-Sub-tree-Rendering" class="headerlink" title="Selective Sub-tree Rendering"></a>Selective Sub-tree Rendering</h3><p>最后你有可能阻止一些子树重新渲染。如果你在组件上用下列方法：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">boolean shouldComponentUpdate(object nextProps object nextState)</span><br></pre></td></tr></table></figure></p><p>建立在前后（previous and next）的props/state组件上，你可以告诉React这个组件不要改动且没必要再重新渲染它。用的得当时，这个可以让性能极大地提升。<br>为了能够用它，必须能够比较JavaScript对象。如果比较的浅或深会有很多的问题产生；如果深的话我们是否要用不可变数据结构或者做深拷贝。<br>而你想要记住，这个功能会一直被调用，因此你想确认它计算所需的时间是否少于启发式少于渲染组件的花费，及时不是严格需要重新渲染。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>这技术让React变得更快这并不新鲜。我们很早就知道，接触DOM的开销很大，应该批量的读写操作，事件委托更快…</p><p>人们依旧在讨论这些东西，因为在实践中，它们很难用于常规的JavaScript代码。让React脱颖而出的是所有这些优化都是默认。这让你很难搬起石头砸自己的脚，让你的应用变慢。<br>这些React的性能开销模型也非常容易理解：每个setState重新渲染整个子树。如果你想挤出性能，尽可能的少调用setState同时用shouldComponentUpdate来阻止一颗大子树的重新渲染。<br>(全文完)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;p&gt;本文为一篇经典的Diff算法文章的译文，原文写的是React的Diff算法。&lt;br&gt;这里只是摘取了后半部分的内容，并没有翻译开篇部分。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://calendar.perfplanet.com/2013/diff/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文点此&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day183-Tree Shaking in Webpack-了解</title>
    <link href="http://lmislm.com/2019/07/15/2019-07-15/"/>
    <id>http://lmislm.com/2019/07/15/2019-07-15/</id>
    <published>2019-07-14T16:00:00.000Z</published>
    <updated>2019-07-17T15:11:30.546Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>概念</li><li>机制</li><li>使用方法<a id="more"></a></li></ol><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol><li><code>DCE Dead Code Elimination</code></li></ol><ul><li>去除无用的没有执行的代码（如：不可能进入的分支）。</li><li>导致<code>dead variable</code>的代码（写入变量之后不再读取的代码）。</li></ul><p>tree shaking是<code>DCE</code>的一种方式，可以在webpack打包时，忽略没有用的代码。</p><h2 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h2><ul><li><strong>找出使用的代码</strong><br>基于 ES6 的静态引用，tree shaking 扫描所有<code>export</code>，找出有用的和无用的内容添加到代码中，最后压缩时分类处理。</li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>源码必须遵循 ES6 的模块规范 <code>(import &amp; export)</code>，CommonJs规范（require）没法用。</p><p><code>webpack2</code>需要修改配置文件，<code>webpack3+</code>可以正常tree shaking</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;概念&lt;/li&gt;
&lt;li&gt;机制&lt;/li&gt;
&lt;li&gt;使用方法
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day182-对象-键值对</title>
    <link href="http://lmislm.com/2019/07/14/2019-07-14/"/>
    <id>http://lmislm.com/2019/07/14/2019-07-14/</id>
    <published>2019-07-13T16:00:00.000Z</published>
    <updated>2019-07-15T14:57:43.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>对象的指定位置插入键值对<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123; <span class="attr">key1</span>: <span class="string">'value1'</span>, <span class="attr">key3</span>: <span class="string">'value3'</span> &#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertKey</span>(<span class="params">key, value, obj, pos</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.keys(obj).reduce(<span class="function">(<span class="params">ac, a, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i === pos) ac[key] = value</span><br><span class="line">    ac[a] = obj[a]</span><br><span class="line">    <span class="keyword">return</span> ac</span><br><span class="line">  &#125;, &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行</span></span><br><span class="line"><span class="built_in">console</span>.log(insertKey(<span class="string">'key2'</span>, <span class="string">'value2'</span>, data, <span class="number">1</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;p&gt;对象的指定位置插入键值对&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; data = &amp;#123; &lt;span class=&quot;attr&quot;&gt;key1&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;value1&#39;&lt;/span&gt;, &lt;span class=&quot;attr&quot;&gt;key3&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;value3&#39;&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day181-Reduce求对象中多个属性的和</title>
    <link href="http://lmislm.com/2019/07/13/2019-07-13/"/>
    <id>http://lmislm.com/2019/07/13/2019-07-13/</id>
    <published>2019-07-12T16:00:00.000Z</published>
    <updated>2019-07-13T13:26:08.482Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>求对象中多个属性的和<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">  &#123;</span><br><span class="line">    tqaModifyCount: <span class="number">9</span>,</span><br><span class="line">    tqaMarkCount: <span class="number">19</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    tqaModifyCount: <span class="number">3</span>,</span><br><span class="line">    tqaMarkCount: <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> tgt = &#123;</span><br><span class="line">  tqaModifyCounts: <span class="number">12</span></span><br><span class="line">  tqaMarkCounts: <span class="number">22</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">dataArr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> dataArr.reduce(<span class="function">(<span class="params">acc, obj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      tqaModifyCounts: acc.tqaModifyCount + obj.tqaModifyCount,</span><br><span class="line">      tqaMarkCounts: acc.tqaMarkCount + obj.tqaMarkCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;p&gt;求对象中多个属性的和&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; data = [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    tqaModifyCount: &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    tqaMarkCount: &lt;span class=&quot;number&quot;&gt;19&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    tqaModifyCount: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    tqaMarkCount: &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; tgt = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  tqaModifyCounts: &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  tqaMarkCounts: &lt;span class=&quot;number&quot;&gt;22&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day180-Virtual DOM-再探</title>
    <link href="http://lmislm.com/2019/07/12/2019-07-12/"/>
    <id>http://lmislm.com/2019/07/12/2019-07-12/</id>
    <published>2019-07-11T16:00:00.000Z</published>
    <updated>2019-07-12T14:06:34.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>Virtual DOM的是三个重要步骤；</li><li>Virtual DOM的具体步骤；<a id="more"></a></li></ol><h2 id="Virtual-DOM的是三个重要步骤"><a href="#Virtual-DOM的是三个重要步骤" class="headerlink" title="Virtual DOM的是三个重要步骤"></a>Virtual DOM的是三个重要步骤</h2><ul><li>生成Virtual DOM树</li><li>对比两棵树的差异（diff）</li><li>更新试图（patch）</li></ul><h2 id="Virtual-DOM的具体步骤"><a href="#Virtual-DOM的具体步骤" class="headerlink" title="Virtual DOM的具体步骤"></a>Virtual DOM的具体步骤</h2><h3 id="生成Virtual-DOM树"><a href="#生成Virtual-DOM树" class="headerlink" title="生成Virtual DOM树"></a><strong>生成Virtual DOM树</strong></h3><p>例子：</p><h4 id="真实DOM"><a href="#真实DOM" class="headerlink" title="真实DOM"></a>真实DOM</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="DOM树"><a href="#DOM树" class="headerlink" title="DOM树"></a>DOM树</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> element = &#123;</span><br><span class="line"> tagName: <span class="string">'ul'</span>,</span><br><span class="line"> props: &#123; <span class="attr">id</span>: <span class="string">'list'</span> &#125;,</span><br><span class="line"> children: [</span><br><span class="line">   &#123; <span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">props</span>: &#123; <span class="attr">class</span>: <span class="string">'item'</span> &#125;, <span class="attr">children</span>: [<span class="string">'Item 1'</span>] &#125;,</span><br><span class="line">   &#123; <span class="attr">tagName</span>: <span class="string">'li'</span>, <span class="attr">props</span>: &#123; <span class="attr">class</span>: <span class="string">'item'</span> &#125;, <span class="attr">children</span>: [<span class="string">'Item 2'</span>] &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对比两棵树的差异"><a href="#对比两棵树的差异" class="headerlink" title="对比两棵树的差异"></a><strong>对比两棵树的差异</strong></h3><p>对树进行遍历：深度优先遍历、广度优先遍历</p><p>diff算法中采用深度优先遍历。对新旧两棵树进行一次深度优先的遍历，这样每个节点都会有一个唯一的标记。</p><p>遍历时，每遍历到一个节点就把该节点和新的树的同一个位置的节点进行对比，如果有差异的话就记录到一个对象（差异对象）里面。</p><h4 id="差异对象（常见的差异）"><a href="#差异对象（常见的差异）" class="headerlink" title="差异对象（常见的差异）"></a>差异对象（常见的差异）</h4><p>替换节点<br>增加/删除子节点<br>修改节点属性<br>改变文本内容</p><h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a><strong>更新视图</strong></h3><p>根据差异的不同类型，对DOM进行针对性的更新。<br>更新视图（针对相应差异的更新方法）<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">replaceChild()</span><br><span class="line">appendChild() / removeChild()</span><br><span class="line">setAttribute() / removeAttribute()</span><br><span class="line">textContent</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Virtual DOM的是三个重要步骤；&lt;/li&gt;
&lt;li&gt;Virtual DOM的具体步骤；
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day179-HTTPS协议-SSL和TLS的区别</title>
    <link href="http://lmislm.com/2019/07/11/2019-07-11/"/>
    <id>http://lmislm.com/2019/07/11/2019-07-11/</id>
    <published>2019-07-10T16:00:00.000Z</published>
    <updated>2019-07-12T13:53:56.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>关系（并列关系）；</li><li>SSL(Secure Socket Layer，安全套接字层)；</li><li><code>HTTP/2</code>的<code>多路复用</code>解决要点2的问题；</li><li>不适用于<code>HTTP/2</code>的优化；</li><li>SSL和TLS之间的详细关系；<a id="more"></a></li></ol><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>SSL是专门保护Web通讯的。TLS是制定的一种新协议，建立在<code>SSL3.0</code>协议规范上，<code>TLS1.0</code>和<code>SSL3.0</code>两者差别极小。</p><h2 id="SSL-Secure-Socket-Layer，安全套接字层"><a href="#SSL-Secure-Socket-Layer，安全套接字层" class="headerlink" title="SSL(Secure Socket Layer，安全套接字层)"></a>SSL(Secure Socket Layer，安全套接字层)</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>作用：SSL利用数据加密技术，确保web浏览器与服务器之间的<code>身份认证</code>和<code>数据加密</code>传输安全。通用的规格为40bit安全标准。</p><p>层级：<code>SSL协议</code>位于<code>TCP/IP协议</code>与各种应用层之间，为数据通讯提供安全支持。</p><p>分类：SSL协议主要分两层，SSL记录协议（SSL Record Protocol）和SSL握手协议（SSL Handshake Protocol）。</p><p><strong>SSL记录协议</strong>：它建立在可靠的传输协议（如TCP）上，为高层协议提供<code>数据封装</code>、<code>压缩</code>、<code>加密</code>等基本功能的支持。<br><strong>SSL握手协议</strong>：它建立在<code>SSL记录协议</code>之上，用于数据传输开始前，<code>通讯双方进行身份认证</code>、<code>协商加密算法</code>、<code>交换加密密钥</code>等。</p><h3 id="SSL协议提供的服务"><a href="#SSL协议提供的服务" class="headerlink" title="SSL协议提供的服务"></a>SSL协议<strong>提供的服务</strong></h3><p>1) 认证用户和服务端（服务器），确保数据发送到正确的客户端和服务端。<br>2) 维护数据的完整性，确保数据在传输过程中不被改变。<br>3) 加密数据以防数据中途被窃取。</p><h3 id="SSL协议的工作流程"><a href="#SSL协议的工作流程" class="headerlink" title="SSL协议的工作流程"></a>SSL协议的<strong>工作流程</strong></h3><ul><li><p>服务端认证阶段：<br>1) 客户端向服务端发送一个开始信息’Hello’以便开始一个新的会话连接；<br>2) 服务端根据客户的信息确定是否需要生成新的主密钥（什么信息申请新的主密钥？），<br>如果需要则服务端在响应客户的’Hello’信息时将包含生成主密钥所需的信息。<br>3) 客户端根据收到的服务端响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务端。<br>4) 服务端恢复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务端。</p></li><li><p>用户端认证阶段：<br>在此之前，服务端已通过客户端认证，这一阶段主要是完成对客户端的认证。<br>经认证的服务端发送一个提问给客户端，客户端则返回（数字）签名后的提问和其公开的密钥，从而向服务端提供认证。</p></li></ul><h3 id="SSL协议的总结"><a href="#SSL协议的总结" class="headerlink" title="SSL协议的总结"></a>SSL协议的总结</h3><p>SSL协议的运行基础是商家（即：服务端）对消费者（即：客户端）信息保密的承诺，有利于商家而不利于消费者。</p><p>在电子商务初级阶段，由于运作电子商务的企业大多是信誉较高的大公司，因此这问题还没有充分暴露出来。</p><p>随着电子商务的发展，各中小型公司也参与进来，这样在电子支付过程中的<code>单一认证问题</code>就越来越突出。</p><p>虽然在SSL3.0中通过数字签名和数字证书可实现浏览器和Web服务端双方的身份验证，但SSL协议仍存在一些问题，<br>比如，只能提供交易中客户端与服务端间的双方认证，在设计<code>多方的电子交易</code>中，SSL协议并不能协调各方间的安全传输和信任关系。</p><p>在这种情况下，Visa和MasterCard两大信用卡组织制定了<code>SET协议</code>，为网上信用卡支付提供了全球性的标准。</p><h2 id="TLS-Transport-Layer-Security-Protocol-安全传输层协议"><a href="#TLS-Transport-Layer-Security-Protocol-安全传输层协议" class="headerlink" title="TLS(Transport Layer Security Protocol, 安全传输层协议)"></a>TLS(Transport Layer Security Protocol, 安全传输层协议)</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>作用：TLS（安全传输层协议）用于在两个通信应用程序之间提供<code>保密性</code>和<code>数据完整性</code>。<br>分类：TLS协议主要分两层，TLS记录协议（TLS Record）和TLS握手协议（TLS Handshake）。</p><blockquote><p>较低的层为<code>TLS记录协议</code>（注：同SSL记录协议），位于某个可靠的传输协议（如TCP）上面。</p></blockquote><p><strong>TLS记录协议</strong>：它提供的<code>连接安全性</code>具有两个基本特性，<code>私有</code>、<code>可靠</code>。</p><ul><li><p>私有——<code>对称加密</code>用数据加密（DES、RC4等）。对称加密产生的密钥对每个连接都是唯一的，且此密钥基于另一个协议（如握手协议）协商。</p><blockquote><p>记录协议也可以不加密使用。</p></blockquote></li><li><p>可靠——信息传输包括使用密钥的MAC进行信息<code>完整性检查</code>。安全哈希功能（SHA、MD5等）用于MAC计算。</p><blockquote><p>记录协议在没有MAC的情况下也能操作，但一般只能用于这种模式，即有另一个协议正在使用记录协议传输协商安全参数。</p></blockquote></li></ul><p><strong>TLS握手协议</strong>：</p><ul><li>简介</li></ul><p>TLS记录协议用于封装各种高层协议。</p><p>作为这种封装协议之一的<code>握手协议</code>允许服务器于客户端在应用程序协议传输和接收其第一个数据字节前彼此之间相互认证，协商加密算法和加密密钥。</p><p>TLS握手协议提供的<code>连接安全</code>具有三个基本属性：</p><p> 1）可以使用非对称的，或公共密钥的密码来认证对方的身份。该认证是可选的，但至少需要一个结点方。</p><p> 2）共享加密密钥的协商是安全的。对偷窃者来说<code>协商加密</code>是难以获得的。以此经过认证的连接不能获得加密，及时是进入连接中间的攻击者也不能。</p><p> 3）协商是可靠的。没有经过通信方成员的检测，任何攻击者都不能修改通信协商。</p><blockquote><p>TLS的最大优势就在于：TLS是<code>独立于应用协议</code>。高层协议可以透明地分布在TLS协议上面。</p></blockquote><p>然而，TLS标准并没有规定应用程序如何在TLS上增加安全性， 它把如何启动TLS握手协议以及如何解释交换的认证证书的决定权留给协议的设计者和实施者来判断。</p><ol><li>TLS协议的<strong>协议结构</strong><br>TLS协议包括<code>两个协议组</code>（即：TLS记录协议和TLS握手协议），每组具有很多不同格式的信息。<blockquote><p>在此文件中我们只列出协议摘要并不做具体解析。具体内容可参照相关文档。</p></blockquote></li></ol><ul><li><p>TLS记录协议是一种<code>分层协议</code>。每一层中的信息可能包含长度、描述和内容等字段。记录协议支持<code>信息传输</code>、将<code>数据分段</code>到可处理块、<code>压缩数据</code>、<code>应用MAC</code>、<code>加密</code>以及<code>传输结果</code>等。<br>对接收到的数据进行解密、校验、解压缩、重组等，然后将他们传送到高层客户机。</p></li><li><p>TLS连接状态指的是TLS记录协议的操作环境。它规定了压缩算法、加密算法和MAC算法。</p></li><li><p>TLS记录层从高层接收任意大小无空块的连续数据。密钥计算：记录协议通过算法从握手协议提供的安全参数中产生密钥、IV和MAC密钥。</p></li><li><p>TLS握手协议由三个子协议组构成，允许对等双方在记录层的安全参数上达成一致、自我认证、例示协商安全参数、互相报告出错条件。</p></li></ul><h2 id="SSL和TLS之间的详细关系"><a href="#SSL和TLS之间的详细关系" class="headerlink" title="SSL和TLS之间的详细关系"></a>SSL和TLS之间的详细关系</h2><p>TLS（Transport Layer Security，传输层安全协议）是IETF制定的一种新的协议，它建立在SSL3.0协议规范之上，是SSL3.0的后续版本。<br>在TLS与SSL3.0之间存在着显著的差别，主要是所支持的<code>加密算法</code>不同,所以TLS与SSL3.0不能互操作。</p><h3 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h3><p> 版本号：TLS记录格式与SSL记录格式相同，但<code>版本号的值不同</code>，TLS的版本1.0使用的版本号为SSLv3.1。</p><p> 报文鉴别码：SSLv3.0和TLS的<code>MAC算法及MAC计算的范围不同</code>。TLS使用了RFC-2104定义的HMAC算法（消息认证代码的密钥散列法）。</p><p>SSLv3.0使用了相似的算法，两者差别在于SSLv3.0中，填充的字节与密钥之间采用的是连接运算，而HMAC算法采用的是异或运算。但是两者的安全程度是相同的。</p><p> 伪随机函数：TLS使用了称为<code>PRF的伪随机函数</code>将密钥扩展成数据块，是更安全的方式。</p><p> 报警代码：TLS支持几乎所有的SSLv3.0报警代码，而且TLS还补充定义了很多的报警代码，<br>如：解密失败（decryption_failed）、记录溢出（record_overflow）、未知CA（unknown_ca）、拒绝访问（access_denied）等。</p><p> 密文族和客户证书：SSLv3.0和TLS存在少量差别，即TLS不支持Fortezza密钥交换、加密算法和客户证书。</p><p> certificate_verify和finished消息：SSLv3.0和TLS在用certificate_verify和finished消息计算MD5和SHA-1散列码时，计算的输入有少许差别，但安全性相当。</p><p> 加密计算：TLS和SSLv3.0在计算主密值（master sercret）时采用的方式不同。</p><p> 填充：用户数据加密之前需要增加的填充字节。在SSL中，填充后的数据长度要达到密文块长度的最小整数倍。</p><p>而在TLS中，<code>填充后的数据长度可以是密文块长度的任意整数倍</code>（但填充的最大长度为255字节），这种方式可以防止基于对报文长度进行分析的攻击。</p><h3 id="TLS的主要增强内容（对比SSL"><a href="#TLS的主要增强内容（对比SSL" class="headerlink" title="TLS的主要增强内容（对比SSL)"></a><strong>TLS的主要增强内容</strong>（对比SSL)</h3><p>TLS的主要目标是使SSL更安全，并使协议的规范更精确和完善。TLS在SSLv3.0的基础上，提供了一下增强内容：<br> 1) 更安全的MAC算法。<br> 2) 更严密的警报。<br> 3) ‘灰色区域’规范的更明确定义。</p><h3 id="TLS对于安全性的改进"><a href="#TLS对于安全性的改进" class="headerlink" title="TLS对于安全性的改进"></a>TLS对于安全性的改进</h3><p> 1) 对于消息认证使用密钥散列法：TLS使用“消息认证代码的密钥散列法”（HMAC），当记录在开放网络（如：英特网）上传送时，该代码确保记录不会被变更。<br>SSLv3.0还提供键控消息认证，但HMAC比SSLv3.0使用的（消息认证代码）MAC功能更安全。<br> 2) 增强的伪随机功能（PRF）：PRF生成密钥数据。在TLS中，HMAC定义PRF。PRF使用两种散列算法保证其安全性。如果任一算法暴露了，只要第二种算法未暴露，则数据仍然是安全的。<br> 3) 改进的已完成消息验证：TLS和SSLv3.0都对两个端点提供已完成的消息，该消息认证交换的消息没有被变更。然而，TLS将此已完成消息基于PRF和HMAC值之上，这也比SSLv3.0更安全。<br> 4) 一致证书处理：与SSLv3.0不同，TLS试图制定必须在TLS之间实现交换的证书类型。<br> 5) 特定警报消息：TLS提供更多的特定和附加警报，以指示任一会话端点检测到的问题。TLS还对合适应该发送某些警报进行记录。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;关系（并列关系）；&lt;/li&gt;
&lt;li&gt;SSL(Secure Socket Layer，安全套接字层)；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HTTP/2&lt;/code&gt;的&lt;code&gt;多路复用&lt;/code&gt;解决要点2的问题；&lt;/li&gt;
&lt;li&gt;不适用于&lt;code&gt;HTTP/2&lt;/code&gt;的优化；&lt;/li&gt;
&lt;li&gt;SSL和TLS之间的详细关系；
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day178-HTTP协议-多路复用</title>
    <link href="http://lmislm.com/2019/07/10/2019-07-10/"/>
    <id>http://lmislm.com/2019/07/10/2019-07-10/</id>
    <published>2019-07-09T16:00:00.000Z</published>
    <updated>2019-07-11T14:36:21.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li><code>Keep-Alive</code>。</li><li><code>HTTP1.1</code>存在的问题。</li><li><code>HTTP/2</code>的<code>多路复用</code>解决要点2的问题。</li><li>不适用于<code>HTTP/2</code>的优化。<a id="more"></a></li></ol><h2 id="Keep-Alive"><a href="#Keep-Alive" class="headerlink" title="Keep-Alive"></a>Keep-Alive</h2><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>每次请求都会建立一次HTTP连接,即<code>3次握手</code>和<code>四次挥手</code>。一个长连接时就会有多次不间断请求数据和建立连接的过程。</p><p>如果第一次建立连接，就一直占用通道，就省去多次请求过程，<br>即：<code>Keep-Alive</code>。</p><h3 id="详细（Keep-Alive解决的核心问题）"><a href="#详细（Keep-Alive解决的核心问题）" class="headerlink" title="详细（Keep-Alive解决的核心问题）"></a>详细（Keep-Alive解决的核心问题）</h3><p>规定的时间内，同一个域名多次请求数据，只建立一次HTTP请求，其他请求可复用每次建立的连接通道，以达到提高请求效率的问题。</p><h2 id="HTTP1-1的其他问题"><a href="#HTTP1-1的其他问题" class="headerlink" title="HTTP1.1的其他问题"></a>HTTP1.1的其他问题</h2><ul><li><code>Keep-Alive</code>解决多次连接问题</li></ul><ol><li>文件传输是<code>串行</code>进行。<br>在<code>HTTP1.1</code>协议中，传输的<code>request</code>和<code>response</code>都是基于文本的，所有的数据必须按顺序串行传输，这样接收端才能知道原本的顺序。</li><li>连接数过多。最大并发数有限为<code>50</code>(Apache)。</li></ol><h2 id="HTTP-2的多路复用"><a href="#HTTP-2的多路复用" class="headerlink" title="HTTP/2的多路复用"></a>HTTP/2的多路复用</h2><ul><li>解决以上的<code>HTTP1.1</code>中两个问题</li></ul><ol><li>解决文件串行传输。<br><code>HTTP/2</code>引入<code>二进制数据帧</code>和<code>流</code>的概念。<code>帧</code>对数据进行顺序标识,这样才能并行传输，接收端才能按照序列（即：顺序标识）对数据进行合并。<br><code>流</code>（服务器并行传输数据）。</li><li>解决连接数过多。<br>HTTP/2对同一域名下所有请求都是基于<code>流</code>,不管访问多少个文件，都只建立<strong>一路连接</strong>。<br>最大并发提升到了300(Apache)。</li></ol><h2 id="不适用于HTTP-2的优化"><a href="#不适用于HTTP-2的优化" class="headerlink" title="不适用于HTTP/2的优化"></a>不适用于HTTP/2的优化</h2><ol><li><p>JS文件合并。<br>上线时把所有多个模块代码压缩合并成一个文件，减少HTTP的请求数。但是其中某个模块改了之后，所有的文件都需要重新下载，不能被缓存。<br><code>HTTP/2</code>里，模块可以单独压缩上线不影响其他没有修改的模块。</p></li><li><p>多域名的下载速度<br>当css文件和js文件放到两个域名下面时，可以避免浏览器的<strong>6个通道限制</strong>(对于同一个协议、域名、端口，浏览器允许同时打开个 TCP 连接，一般上限为 6 个)。</p></li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>HTTP/2解决了这些缺点</li></ul><ol><li>DNS解析时间变长。</li><li>增加服务器压力。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Keep-Alive&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HTTP1.1&lt;/code&gt;存在的问题。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HTTP/2&lt;/code&gt;的&lt;code&gt;多路复用&lt;/code&gt;解决要点2的问题。&lt;/li&gt;
&lt;li&gt;不适用于&lt;code&gt;HTTP/2&lt;/code&gt;的优化。
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day177-TypeScript基础小记-构造函数</title>
    <link href="http://lmislm.com/2019/07/09/2019-07-09/"/>
    <id>http://lmislm.com/2019/07/09/2019-07-09/</id>
    <published>2019-07-08T16:00:00.000Z</published>
    <updated>2019-07-11T14:36:17.746Z</updated>
    
    <content type="html"><![CDATA[<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ol><li>构造函数。</li><li>编译成JavaScript后。</li><li>把类当做接口使用。<a id="more"></a></li></ol><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><blockquote><p>简单的构造函数</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">  greeting: string</span><br><span class="line">  <span class="keyword">constructor</span>(message: string) &#123;</span><br><span class="line">    <span class="keyword">this</span>.greeting = message</span><br><span class="line">  &#125;</span><br><span class="line">  greet() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello,'</span> + <span class="keyword">this</span>.greeting</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> greeter: Greeter <span class="comment">// Greeter类的实例的类型是Greeter</span></span><br><span class="line">greeter = <span class="keyword">new</span> Greeter(<span class="string">'TypeScript'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(greeter.greet())</span><br></pre></td></tr></table></figure><h3 id="编译成JavaScript"><a href="#编译成JavaScript" class="headerlink" title="编译成JavaScript"></a>编译成JavaScript</h3><blockquote><p><code>let Greeter</code>被赋值为<code>构造函数</code>。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Greeter = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Greeter</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.greeting = message</span><br><span class="line">  &#125;</span><br><span class="line">  Greeter.prototype.greet = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello,'</span> + <span class="keyword">this</span>.greeting</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Greeter</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="keyword">let</span> greeter</span><br><span class="line">greeter = <span class="keyword">new</span> Greeter(<span class="string">'world'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(greeter.greet())</span><br></pre></td></tr></table></figure><blockquote><p>例子改写</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> standardGreeting = <span class="string">'hello, there'</span></span><br><span class="line">  greeting: string</span><br><span class="line">  greet () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.greeting) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'hello,'</span> + <span class="keyword">this</span>.greeting</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Greeter.standardGreeting</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> greeter1: Greeter</span><br><span class="line">greeter1 = <span class="keyword">new</span> Greeter()</span><br><span class="line"><span class="built_in">console</span>.log(greeter1)</span><br><span class="line"><span class="comment">// typeof Greeter意思取Greeter类的类型，而不是实例类型。</span></span><br><span class="line"><span class="keyword">let</span> greeterMaker: <span class="keyword">typeof</span> Greeter = Greeter</span><br><span class="line">greeterMaker.standardGreeting = <span class="string">'Hey there!'</span></span><br><span class="line"><span class="keyword">let</span> greeter2: Greeter = <span class="keyword">new</span> greeterMaker()</span><br><span class="line"><span class="built_in">console</span>.log(greeter2.greet())</span><br></pre></td></tr></table></figure><h3 id="类当做接口使用"><a href="#类当做接口使用" class="headerlink" title="类当做接口使用"></a>类当做接口使用</h3><blockquote><p>类定义会创建两个东西：<br>类的实例累心和一个构造函数（因为类可以创建出类型，所以你能够在允许使用接口的地方使用类）<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  x: number</span><br><span class="line">  y: number</span><br><span class="line">&#125;</span><br><span class="line">interface Point3d extends Point &#123;</span><br><span class="line">  z: number</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> point3d: Point3d = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;构造函数。&lt;/li&gt;
&lt;li&gt;编译成JavaScript后。&lt;/li&gt;
&lt;li&gt;把类当做接口使用。
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day176-数组-嵌套数组-nested Array</title>
    <link href="http://lmislm.com/2019/07/08/2019-07-08/"/>
    <id>http://lmislm.com/2019/07/08/2019-07-08/</id>
    <published>2019-07-07T16:00:00.000Z</published>
    <updated>2019-07-11T14:36:14.116Z</updated>
    
    <content type="html"><![CDATA[<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><p>给出特定结构的数据，转换成特定的数据结构。</p><ol><li><code>deepMerge</code>, <code>groupBy</code></li><li><code>flattenDeep</code>, nested Array(嵌套数组)<a id="more"></a></li></ol><h2 id="源数组-gt-目标数组"><a href="#源数组-gt-目标数组" class="headerlink" title="源数组-&gt;目标数组"></a>源数组-&gt;目标数组</h2><blockquote><p>源数据<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">'文风'</span>: &#123;</span><br><span class="line">      <span class="string">'过译'</span>: [</span><br><span class="line">        &#123; <span class="string">'errorLevel'</span>: <span class="string">'一般般'</span>, <span class="string">'count'</span>: <span class="number">5</span> &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="string">'漏译'</span>: [</span><br><span class="line">        &#123; <span class="string">'errorLevel'</span>: <span class="string">'非常严重'</span>, <span class="string">'count'</span>: <span class="number">2</span> &#125;,</span><br><span class="line">        &#123; <span class="string">'errorLevel'</span>: <span class="string">'一般般'</span>, <span class="string">'count'</span>: <span class="number">10</span> &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">'增译'</span>: [</span><br><span class="line">        &#123; <span class="string">'errorLevel'</span>: <span class="string">'非常严重'</span>, <span class="string">'count'</span>: <span class="number">22</span> &#125;,</span><br><span class="line">        &#123; <span class="string">'errorLevel'</span>: <span class="string">'一般般'</span>, <span class="string">'count'</span>: <span class="number">10</span> &#125;</span><br><span class="line">      ]</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>目标数组<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> res = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'一般般'</span>, <span class="attr">count</span>: <span class="number">27</span>, <span class="string">'过译'</span>: <span class="number">10</span>, <span class="string">'漏译'</span>: <span class="number">20</span>, <span class="string">'增译'</span>: <span class="number">22</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'非常严重'</span>, <span class="attr">count</span>: <span class="number">24</span>, <span class="string">'漏译'</span>: <span class="number">4</span>, <span class="string">'增译'</span>: <span class="number">44</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'重大错误'</span>, <span class="attr">count</span>: <span class="number">10</span>, <span class="string">'过译'</span>: <span class="number">10</span> &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="两步"><a href="#两步" class="headerlink" title="两步"></a>两步</h2><ol><li>先降维处理成一维数组</li><li>根据一维数组相关属性<code>groupBy</code></li></ol><h3 id="降维处理"><a href="#降维处理" class="headerlink" title="降维处理"></a>降维处理</h3><ul><li>注意不需要第一层的<code>keys</code>。</li><li><code>_.</code>是loadshjs的方法。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatData</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 去掉了术语、文风等</span></span><br><span class="line">  <span class="keyword">let</span> res = (data || []).map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> mergedData = _.mergeWith(&#123;&#125;, ...Object.values(item), (obj, src) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> (obj || []).concat(src)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.entries(mergedData).map(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 转为多层嵌套数组</span></span><br><span class="line">      <span class="keyword">return</span> [...value.map(<span class="function"><span class="params">item</span> =&gt;</span> (&#123;...item, <span class="attr">type</span>: key&#125;))]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> _.flattenDeep(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组分类"><a href="#数组分类" class="headerlink" title="数组分类"></a>数组分类</h3><p>由<code>嵌套数组</code>得出的结果进行数组归类。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nest</span> (<span class="params">seq, keys</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!keys.length) <span class="keyword">return</span> seq</span><br><span class="line">  <span class="keyword">let</span> first = keys[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> rest = keys.slice(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> mapValues(groupBy(seq, first), (value) =&gt; &#123;</span><br><span class="line">    <span class="comment">// return &#123; ...nest(value, rest) &#125;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(nest(value, rest))) &#123;</span><br><span class="line">      <span class="comment">// reduce by prop count</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function">(<span class="params">nest(value, rest</span>) || []).<span class="params">reduce</span>(<span class="params">(acc, obj</span>) =&gt;</span> (acc + obj[<span class="string">'count'</span>]), <span class="number">0</span>)</span><br><span class="line">      <span class="comment">// return &#123; ...item, item: '122'&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> nest(value, rest)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h2&gt;&lt;p&gt;给出特定结构的数据，转换成特定的数据结构。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;deepMerge&lt;/code&gt;, &lt;code&gt;groupBy&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flattenDeep&lt;/code&gt;, nested Array(嵌套数组)
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day175-contenteditable（2）</title>
    <link href="http://lmislm.com/2019/07/07/2019-07-07/"/>
    <id>http://lmislm.com/2019/07/07/2019-07-07/</id>
    <published>2019-07-06T16:00:00.000Z</published>
    <updated>2019-07-11T14:36:09.442Z</updated>
    
    <content type="html"><![CDATA[<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><p><strong>contenteditable</strong><br>这里是<code>contentedtable</code>的第二种写法。<br><a id="more"></a></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>VEdit组件</p><blockquote><p>VEdit vue2 实现 div contenteditable=”true” 类似于 v-model 的效果</p><ul><li>参考<br><a href="https://segmentfault.com/a/1190000008261449#articleHeader1" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008261449#articleHeader1</a><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div</span><br><span class="line">    ref=<span class="string">"diveditable"</span></span><br><span class="line">    v-html=<span class="string">"innerText"</span></span><br><span class="line">    :contenteditable=<span class="string">"canEdit"</span></span><br><span class="line">    @input=<span class="string">"changeText"</span></span><br><span class="line">    @focus=<span class="string">"isLocked = true"</span></span><br><span class="line">    @blur=<span class="string">"isLocked = false"</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span></span>=<span class="string">"v-edit"</span></span><br><span class="line">  &gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'VEdit'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">''</span></span><br><span class="line">    &#125;,</span><br><span class="line">    canEdit: &#123;</span><br><span class="line">      type: <span class="built_in">Boolean</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      innerText: <span class="keyword">this</span>.value,</span><br><span class="line">      isLocked: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    <span class="string">'value'</span> () &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.isLocked || !<span class="keyword">this</span>.innerText) &#123;</span><br><span class="line">        <span class="keyword">this</span>.innerText = <span class="keyword">this</span>.value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeText () &#123;</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, <span class="keyword">this</span>.$el.innerHTML)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;style lang='less' scoped&gt;</span></span><br><span class="line"><span class="regexp">.v-edit &#123;</span></span><br><span class="line"><span class="regexp">  width: 100%;</span></span><br><span class="line"><span class="regexp">  height: 100%;</span></span><br><span class="line"><span class="regexp">  overflow: auto;</span></span><br><span class="line"><span class="regexp">  word-break: break-all;</span></span><br><span class="line"><span class="regexp">  outline: none;</span></span><br><span class="line"><span class="regexp">  user-select: text;</span></span><br><span class="line"><span class="regexp">  white-space: pre-wrap;</span></span><br><span class="line"><span class="regexp">  text-align: left;</span></span><br><span class="line"><span class="regexp">  &amp;[contenteditable=true]&#123;</span></span><br><span class="line"><span class="regexp">    user-modify: read-write-plaintext-only;</span></span><br><span class="line"><span class="regexp">    &amp;:empty:before &#123;</span></span><br><span class="line"><span class="regexp">      content: attr(placeholder);</span></span><br><span class="line"><span class="regexp">      display: block;</span></span><br><span class="line"><span class="regexp">      color: #ccc;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;contenteditable&lt;/strong&gt;&lt;br&gt;这里是&lt;code&gt;contentedtable&lt;/code&gt;的第二种写法。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day174-contenteditable</title>
    <link href="http://lmislm.com/2019/07/06/2019-07-06/"/>
    <id>http://lmislm.com/2019/07/06/2019-07-06/</id>
    <published>2019-07-05T16:00:00.000Z</published>
    <updated>2019-07-11T14:24:18.474Z</updated>
    
    <content type="html"><![CDATA[<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><p><strong>contenteditable</strong><br>利用<code>contenteditable</code>来做行内编辑。与利用<code>input</code>的区别是，能够保留内容的样式，而<code>input</code>内输入的是纯文本。<br>这里依靠<code>Vue2</code>做了一个小组件。<br><a id="more"></a></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>EditDiv组件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- EditDiv Vue <span class="number">2</span> contentEditable <span class="keyword">with</span> v-model --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div</span><br><span class="line">    ref=<span class="string">"diveditable"</span></span><br><span class="line">    contenteditable</span><br><span class="line">    v-on=<span class="string">"listeners"</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span></span>=<span class="string">"edit-div"</span></span><br><span class="line">  &gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'EditDiv'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    value: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    listeners () &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...this.$listeners, <span class="attr">input</span>: <span class="keyword">this</span>.onInput &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="keyword">this</span>.$refs.diveditable.innerText = <span class="keyword">this</span>.value</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onInput (e) &#123;</span><br><span class="line">      <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, e.target.innerText)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;style lang='less' scoped&gt;</span></span><br><span class="line"><span class="regexp">.edit-div &#123;</span></span><br><span class="line"><span class="regexp">    width: 100%;</span></span><br><span class="line"><span class="regexp">    height: 100%;</span></span><br><span class="line"><span class="regexp">    overflow: auto;</span></span><br><span class="line"><span class="regexp">    word-break: break-all;</span></span><br><span class="line"><span class="regexp">    outline: none;</span></span><br><span class="line"><span class="regexp">    user-select: text;</span></span><br><span class="line"><span class="regexp">    white-space: pre-wrap;</span></span><br><span class="line"><span class="regexp">    text-align: left;</span></span><br><span class="line"><span class="regexp">    &amp;[contenteditable=true]&#123;</span></span><br><span class="line"><span class="regexp">      user-modify: read-write-plaintext-only;</span></span><br><span class="line"><span class="regexp">      &amp;:empty:before &#123;</span></span><br><span class="line"><span class="regexp">        content: attr(placeholder);</span></span><br><span class="line"><span class="regexp">        display: block;</span></span><br><span class="line"><span class="regexp">        color: #ccc;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;contenteditable&lt;/strong&gt;&lt;br&gt;利用&lt;code&gt;contenteditable&lt;/code&gt;来做行内编辑。与利用&lt;code&gt;input&lt;/code&gt;的区别是，能够保留内容的样式，而&lt;code&gt;input&lt;/code&gt;内输入的是纯文本。&lt;br&gt;这里依靠&lt;code&gt;Vue2&lt;/code&gt;做了一个小组件。&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day173-数组-结构转换</title>
    <link href="http://lmislm.com/2019/07/05/2019-07-05/"/>
    <id>http://lmislm.com/2019/07/05/2019-07-05/</id>
    <published>2019-07-04T16:00:00.000Z</published>
    <updated>2019-07-11T14:24:18.473Z</updated>
    
    <content type="html"><![CDATA[<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><p>给出特定结构的数据，转换成特定的数据结构。</p><ol><li>循环</li><li>递归<a id="more"></a></li></ol><h3 id="源数组-gt-目标数组"><a href="#源数组-gt-目标数组" class="headerlink" title="源数组-&gt;目标数组"></a>源数组-&gt;目标数组</h3><blockquote><p>源数组<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">'文风'</span>: &#123;</span><br><span class="line">      <span class="string">'过译'</span>: [</span><br><span class="line">        &#123; <span class="string">'errorLevel'</span>: <span class="string">'一般般'</span>, <span class="string">'count'</span>: <span class="number">5</span> &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="string">'漏译'</span>: [</span><br><span class="line">        &#123; <span class="string">'errorLevel'</span>: <span class="string">'非常严重'</span>, <span class="string">'count'</span>: <span class="number">2</span> &#125;,</span><br><span class="line">        &#123; <span class="string">'errorLevel'</span>: <span class="string">'一般般'</span>, <span class="string">'count'</span>: <span class="number">10</span> &#125;</span><br><span class="line">      ]</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>目标数组<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> res = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'文风'</span>, <span class="string">'过译'</span>: <span class="number">5</span>, <span class="string">'漏译'</span>: <span class="number">12</span>, <span class="string">'增译'</span>: <span class="number">3</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'准确性'</span>, <span class="string">'过译'</span>: <span class="number">21</span>, <span class="string">'漏译'</span>: <span class="number">20</span>, <span class="string">'增译'</span>: <span class="number">10</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'流畅性'</span>, <span class="string">'过译'</span>: <span class="number">9</span>, <span class="string">'漏译'</span>: <span class="number">12</span>, <span class="string">'增译'</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'术语'</span>,  <span class="string">'过译'</span>: <span class="number">34</span>, <span class="string">'漏译'</span>: <span class="number">24</span>, <span class="string">'增译'</span>: <span class="number">34</span> &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.entries(...data).map(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> newVal = <span class="built_in">Object</span>.entries(value).map(<span class="function">(<span class="params">[objkey, objVal]</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> objVals = [...objVal].reduce(<span class="function">(<span class="params">acc, obj</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(k)) &#123;</span><br><span class="line">          acc[k] = (acc[k] || <span class="number">0</span>) + obj[k]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> acc</span><br><span class="line">    &#125;, &#123;&#125;)[<span class="string">'count'</span>]</span><br><span class="line">    <span class="keyword">return</span> &#123;[objkey]: objVals&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">name</span>: key, ...Object.assign(...newVal), <span class="attr">total</span>: sum &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// return [].concat(obj)</span></span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatData</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> object) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> object[i] == <span class="keyword">typeof</span> &#123;&#125;)&#123;</span><br><span class="line">      flatData(object[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(object[i])</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(object[i])) &#123;</span><br><span class="line">      <span class="keyword">let</span> tmp = object[i]</span><br><span class="line">      object[i] = tmp.reduce(<span class="function">(<span class="params">acc, obj</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">          <span class="keyword">if</span> (obj.hasOwnProperty(k)) &#123;</span><br><span class="line">            acc[k] = (acc[k] || <span class="number">0</span>) + obj[k]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> acc</span><br><span class="line">      &#125;, &#123;&#125;)[<span class="string">'count'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// return object</span></span><br><span class="line">&#125;</span><br><span class="line">flatData(data)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h3&gt;&lt;p&gt;给出特定结构的数据，转换成特定的数据结构。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;循环&lt;/li&gt;
&lt;li&gt;递归
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day172-TypeScript基础小记-抽象类</title>
    <link href="http://lmislm.com/2019/07/04/2019-07-04/"/>
    <id>http://lmislm.com/2019/07/04/2019-07-04/</id>
    <published>2019-07-03T16:00:00.000Z</published>
    <updated>2019-07-11T14:24:18.473Z</updated>
    
    <content type="html"><![CDATA[<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ol><li><code>abstract</code>关键字。</li><li>抽象方法。<a id="more"></a></li></ol><h3 id="abstract关键字"><a href="#abstract关键字" class="headerlink" title="abstract关键字"></a><code>abstract</code>关键字</h3><blockquote><p>抽象类做其他<code>派生类</code>的<code>基类</code>使用。抽象类一般不会直接被<code>实例化</code>。</p></blockquote><blockquote><p>抽象类可以包含成员的实现细节。<br><code>abstract</code>关键字是用于定义<code>抽象类</code>和在抽象类内部定义抽象方法。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  abstract makeSound(): <span class="keyword">void</span></span><br><span class="line">  move(): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'到处走'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><blockquote><p><code>抽象类</code>中的<code>抽象方法</code>不包含具体实现并且必须在<code>派生类</code>中实现。<code>抽象方法</code>的语法与<code>接口方法</code>相似。</p></blockquote><blockquote><p>两者都是定义<code>方法签名</code>但不包含<code>方法体</code>。然而，<code>抽象方法</code>必须包含<code>abstract</code>关键字并且可以包含<code>访问修饰符</code>。 </p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(public name: string) &#123;&#125;</span><br><span class="line">  printName(): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Department name:'</span> + <span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">  abstract printMeeting(): <span class="keyword">void</span> <span class="comment">// 必须在派生类中实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountingDepartment</span> <span class="keyword">extends</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="string">'银行'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  printMeeting(): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'银行每周一早上10点开门'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  generateReports(): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'生成银行报告'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> department: Department <span class="comment">// 允许创建一个对抽象类型的引用</span></span><br><span class="line"><span class="comment">// department = new Department() // 无法创建抽象类的实例。ts(2511)</span></span><br><span class="line">department = <span class="keyword">new</span> AccountingDepartment() <span class="comment">// 允许对一个抽象子类进行实例化和赋值</span></span><br><span class="line">department.printMeeting()</span><br><span class="line">department.printName()</span><br><span class="line">department.generateReports() <span class="comment">// 类型“Department”上不存在属性“generateReports”。ts(2339)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;abstract&lt;/code&gt;关键字。&lt;/li&gt;
&lt;li&gt;抽象方法。
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>day171-获取图片原始长宽</title>
    <link href="http://lmislm.com/2019/07/03/2019-07-03/"/>
    <id>http://lmislm.com/2019/07/03/2019-07-03/</id>
    <published>2019-07-02T16:00:00.000Z</published>
    <updated>2019-07-11T14:24:18.472Z</updated>
    
    <content type="html"><![CDATA[<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ol><li>base64图片的长宽。</li><li>图片长宽。</li><li>“src图片”的长宽。<a id="more"></a></li></ol><h3 id="base64图片"><a href="#base64图片" class="headerlink" title="base64图片"></a>base64图片</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPngDimensions</span> (<span class="params">base64</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> header = atob(base64.slice(<span class="number">0</span>, <span class="number">50</span>)).slice(<span class="number">16</span>, <span class="number">24</span>)</span><br><span class="line">  <span class="keyword">const</span> uint8 = <span class="built_in">Uint8Array</span>.from(header, c =&gt; c.charCodeAt(<span class="number">0</span>))</span><br><span class="line">  <span class="keyword">const</span> dataView = <span class="keyword">new</span> <span class="built_in">DataView</span>(uint8.buffer)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    width: dataView.getInt32(<span class="number">0</span>),</span><br><span class="line">    height: dataView.getInt32(<span class="number">4</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图片长宽"><a href="#图片长宽" class="headerlink" title="图片长宽"></a>图片长宽</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">imageElement.naturalHeight</span><br><span class="line">imageElement.naturalWidth</span><br></pre></td></tr></table></figure><h3 id="“src图片”"><a href="#“src图片”" class="headerlink" title="“src图片”"></a>“src图片”</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">img.src = <span class="string">'http://www.google.com/intl/en_ALL/images/logo.gif'</span></span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.width + <span class="string">'x'</span> + <span class="keyword">this</span>.height)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://stackoverflow.com/questions/623172/how-to-get-image-size-height-width-using-javascript" target="_blank" rel="noopener">https://stackoverflow.com/questions/623172/how-to-get-image-size-height-width-using-javascript</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;要点&quot;&gt;&lt;a href=&quot;#要点&quot; class=&quot;headerlink&quot; title=&quot;要点&quot;&gt;&lt;/a&gt;要点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;base64图片的长宽。&lt;/li&gt;
&lt;li&gt;图片长宽。&lt;/li&gt;
&lt;li&gt;“src图片”的长宽。
    
    </summary>
    
      <category term="技术" scheme="http://lmislm.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="前端" scheme="http://lmislm.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
